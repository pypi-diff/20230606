# Comparing `tmp/chronogram-0.1.7.tar.gz` & `tmp/chronogram-0.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist\chronogram-0.1.7.tar", last modified: Mon Sep 23 14:56:30 2019, max compression
+gzip compressed data, was "chronogram-0.2.0.tar", last modified: Tue Jun  6 06:03:00 2023, max compression
```

## Comparing `chronogram-0.1.7.tar` & `chronogram-0.2.0.tar`

### file list

```diff
@@ -1,379 +1,452 @@
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/
--rw-rw-rw-   0        0        0       73 2019-07-28 08:43:47.000000 chronogram-0.1.7/MANIFEST.in
--rw-rw-rw-   0        0        0     2524 2019-09-23 14:56:30.000000 chronogram-0.1.7/PKG-INFO
--rw-rw-rw-   0        0        0      925 2019-09-03 12:19:04.000000 chronogram-0.1.7/README.rst
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/chronogram/
--rw-rw-rw-   0        0        0     1267 2019-08-01 17:37:22.000000 chronogram-0.1.7/chronogram/__init__.py
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/chronogram.egg-info/
--rw-rw-rw-   0        0        0     2524 2019-09-23 14:56:29.000000 chronogram-0.1.7/chronogram.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    13424 2019-09-23 14:56:29.000000 chronogram-0.1.7/chronogram.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2019-09-23 14:56:29.000000 chronogram-0.1.7/chronogram.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       11 2019-09-23 14:56:29.000000 chronogram-0.1.7/chronogram.egg-info/requires.txt
--rw-rw-rw-   0        0        0       56 2019-09-23 14:56:29.000000 chronogram-0.1.7/chronogram.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/
--rw-rw-rw-   0        0        0      694 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/CMakeLists.txt
--rw-rw-rw-   0        0        0     1206 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Cholesky
--rw-rw-rw-   0        0        0     1900 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/CholmodSupport
--rw-rw-rw-   0        0        0    17961 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Core
--rw-rw-rw-   0        0        0      122 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Dense
--rw-rw-rw-   0        0        0       35 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Eigen
--rw-rw-rw-   0        0        0     1822 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Eigenvalues
--rw-rw-rw-   0        0        0     2050 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Geometry
--rw-rw-rw-   0        0        0      874 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Householder
--rw-rw-rw-   0        0        0     2083 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/IterativeLinearSolvers
--rw-rw-rw-   0        0        0      939 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Jacobi
--rw-rw-rw-   0        0        0     1433 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/LU
--rw-rw-rw-   0        0        0      991 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/MetisSupport
--rw-rw-rw-   0        0        0     2483 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/OrderingMethods
--rw-rw-rw-   0        0        0     1676 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/PaStiXSupport
--rw-rw-rw-   0        0        0     1116 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/PardisoSupport
--rw-rw-rw-   0        0        0     1317 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/QR
--rw-rw-rw-   0        0        0      945 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/QtAlignedMalloc
--rw-rw-rw-   0        0        0     1162 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/SPQRSupport
--rw-rw-rw-   0        0        0     1629 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/SVD
--rw-rw-rw-   0        0        0      919 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/Sparse
--rw-rw-rw-   0        0        0     1371 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/SparseCholesky
--rw-rw-rw-   0        0        0     2240 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/SparseCore
--rw-rw-rw-   0        0        0     1713 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/SparseLU
--rw-rw-rw-   0        0        0     1222 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/SparseQR
--rw-rw-rw-   0        0        0      797 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/StdDeque
--rw-rw-rw-   0        0        0      726 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/StdList
--rw-rw-rw-   0        0        0      803 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/StdVector
--rw-rw-rw-   0        0        0     2243 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/SuperLUSupport
--rw-rw-rw-   0        0        0     1382 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/UmfPackSupport
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Cholesky/
--rw-rw-rw-   0        0        0    24480 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Cholesky/LDLT.h
--rw-rw-rw-   0        0        0    18395 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Cholesky/LLT.h
--rw-rw-rw-   0        0        0     3974 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Cholesky/LLT_LAPACKE.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/CholmodSupport/
--rw-rw-rw-   0        0        0    22307 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/CholmodSupport/CholmodSupport.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/
--rw-rw-rw-   0        0        0    12115 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Array.h
--rw-rw-rw-   0        0        0     8179 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/ArrayBase.h
--rw-rw-rw-   0        0        0     6775 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/ArrayWrapper.h
--rw-rw-rw-   0        0        0     2720 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Assign.h
--rw-rw-rw-   0        0        0    38153 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/AssignEvaluator.h
--rw-rw-rw-   0        0        0    12479 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Assign_MKL.h
--rw-rw-rw-   0        0        0    13910 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/BandMatrix.h
--rw-rw-rw-   0        0        0    18064 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Block.h
--rw-rw-rw-   0        0        0     4249 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/BooleanRedux.h
--rw-rw-rw-   0        0        0     5689 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/CommaInitializer.h
--rw-rw-rw-   0        0        0     6990 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/ConditionEstimator.h
--rw-rw-rw-   0        0        0    62197 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/CoreEvaluators.h
--rw-rw-rw-   0        0        0     4525 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/CoreIterators.h
--rw-rw-rw-   0        0        0     7593 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/CwiseBinaryOp.h
--rw-rw-rw-   0        0        0    31424 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/CwiseNullaryOp.h
--rw-rw-rw-   0        0        0     8256 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/CwiseTernaryOp.h
--rw-rw-rw-   0        0        0     3877 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/CwiseUnaryOp.h
--rw-rw-rw-   0        0        0     5282 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/CwiseUnaryView.h
--rw-rw-rw-   0        0        0    27420 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/DenseBase.h
--rw-rw-rw-   0        0        0    24212 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/DenseCoeffsBase.h
--rw-rw-rw-   0        0        0    21959 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/DenseStorage.h
--rw-rw-rw-   0        0        0     9597 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Diagonal.h
--rw-rw-rw-   0        0        0    12666 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/DiagonalMatrix.h
--rw-rw-rw-   0        0        0      970 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/DiagonalProduct.h
--rw-rw-rw-   0        0        0    11507 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Dot.h
--rw-rw-rw-   0        0        0     5619 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/EigenBase.h
--rw-rw-rw-   0        0        0     4769 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/ForceAlignedAccess.h
--rw-rw-rw-   0        0        0     5705 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Fuzzy.h
--rw-rw-rw-   0        0        0    21123 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/GeneralProduct.h
--rw-rw-rw-   0        0        0    22185 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/GenericPacketMath.h
--rw-rw-rw-   0        0        0    10222 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/GlobalFunctions.h
--rw-rw-rw-   0        0        0     7076 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/IO.h
--rw-rw-rw-   0        0        0     3519 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Inverse.h
--rw-rw-rw-   0        0        0     7239 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Map.h
--rw-rw-rw-   0        0        0    10991 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/MapBase.h
--rw-rw-rw-   0        0        0    40865 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/MathFunctions.h
--rw-rw-rw-   0        0        0     3369 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/MathFunctionsImpl.h
--rw-rw-rw-   0        0        0    19067 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Matrix.h
--rw-rw-rw-   0        0        0    23213 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/MatrixBase.h
--rw-rw-rw-   0        0        0     3400 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/NestByValue.h
--rw-rw-rw-   0        0        0     3582 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/NoAlias.h
--rw-rw-rw-   0        0        0     9234 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/NumTraits.h
--rw-rw-rw-   0        0        0    21646 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/PermutationMatrix.h
--rw-rw-rw-   0        0        0    45180 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/PlainObjectBase.h
--rw-rw-rw-   0        0        0     7235 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Product.h
--rw-rw-rw-   0        0        0    49497 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/ProductEvaluators.h
--rw-rw-rw-   0        0        0     6379 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Random.h
--rw-rw-rw-   0        0        0    17852 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Redux.h
--rw-rw-rw-   0        0        0    12800 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Ref.h
--rw-rw-rw-   0        0        0     5595 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Replicate.h
--rw-rw-rw-   0        0        0     4200 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/ReturnByValue.h
--rw-rw-rw-   0        0        0     7073 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Reverse.h
--rw-rw-rw-   0        0        0     6020 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Select.h
--rw-rw-rw-   0        0        0    14245 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/SelfAdjointView.h
--rw-rw-rw-   0        0        0     1697 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/SelfCwiseBinaryOp.h
--rw-rw-rw-   0        0        0     6795 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Solve.h
--rw-rw-rw-   0        0        0     9136 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/SolveTriangular.h
--rw-rw-rw-   0        0        0     4365 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/SolverBase.h
--rw-rw-rw-   0        0        0     7692 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/StableNorm.h
--rw-rw-rw-   0        0        0     3865 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Stride.h
--rw-rw-rw-   0        0        0     2683 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Swap.h
--rw-rw-rw-   0        0        0    14777 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Transpose.h
--rw-rw-rw-   0        0        0    14386 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Transpositions.h
--rw-rw-rw-   0        0        0    37234 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/TriangularMatrix.h
--rw-rw-rw-   0        0        0     3462 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/VectorBlock.h
--rw-rw-rw-   0        0        0    29441 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/VectorwiseOp.h
--rw-rw-rw-   0        0        0     8074 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/Visitor.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AVX/
--rw-rw-rw-   0        0        0    18037 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AVX/Complex.h
--rw-rw-rw-   0        0        0    17776 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AVX/MathFunctions.h
--rw-rw-rw-   0        0        0    27841 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AVX/PacketMath.h
--rw-rw-rw-   0        0        0     1194 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AVX/TypeCasting.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AVX512/
--rw-rw-rw-   0        0        0    15733 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AVX512/MathFunctions.h
--rw-rw-rw-   0        0        0    50985 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AVX512/PacketMath.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AltiVec/
--rw-rw-rw-   0        0        0    16443 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AltiVec/Complex.h
--rw-rw-rw-   0        0        0    10797 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AltiVec/MathFunctions.h
--rw-rw-rw-   0        0        0    37671 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/AltiVec/PacketMath.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/
--rw-rw-rw-   0        0        0     4240 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/Complex.h
--rw-rw-rw-   0        0        0    23528 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/Half.h
--rw-rw-rw-   0        0        0     2387 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/MathFunctions.h
--rw-rw-rw-   0        0        0    10744 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/PacketMath.h
--rw-rw-rw-   0        0        0    35538 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/PacketMathHalf.h
--rw-rw-rw-   0        0        0     5509 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/TypeCasting.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/Default/
--rw-rw-rw-   0        0        0     1989 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/Default/ConjHelper.h
--rw-rw-rw-   0        0        0     1746 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/Default/Settings.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/NEON/
--rw-rw-rw-   0        0        0    17706 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/NEON/Complex.h
--rw-rw-rw-   0        0        0     2846 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/NEON/MathFunctions.h
--rw-rw-rw-   0        0        0    28726 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/NEON/PacketMath.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/SSE/
--rw-rw-rw-   0        0        0    19426 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/SSE/Complex.h
--rw-rw-rw-   0        0        0    18888 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/SSE/MathFunctions.h
--rw-rw-rw-   0        0        0    35843 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/SSE/PacketMath.h
--rw-rw-rw-   0        0        0     1759 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/SSE/TypeCasting.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/ZVector/
--rw-rw-rw-   0        0        0    15366 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/ZVector/Complex.h
--rw-rw-rw-   0        0        0     4418 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/ZVector/MathFunctions.h
--rw-rw-rw-   0        0        0    32283 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/arch/ZVector/PacketMath.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/functors/
--rw-rw-rw-   0        0        0     6284 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/functors/AssignmentFunctors.h
--rw-rw-rw-   0        0        0    18263 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/functors/BinaryFunctors.h
--rw-rw-rw-   0        0        0     8229 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/functors/NullaryFunctors.h
--rw-rw-rw-   0        0        0     4400 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/functors/StlFunctors.h
--rw-rw-rw-   0        0        0      607 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/functors/TernaryFunctors.h
--rw-rw-rw-   0        0        0    27944 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/functors/UnaryFunctors.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/products/
--rw-rw-rw-   0        0        0    81534 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/GeneralBlockPanelKernel.h
--rw-rw-rw-   0        0        0    18478 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixMatrix.h
--rw-rw-rw-   0        0        0    15188 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h
--rw-rw-rw-   0        0        0     6907 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h
--rw-rw-rw-   0        0        0     5017 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h
--rw-rw-rw-   0        0        0    26808 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixVector.h
--rw-rw-rw-   0        0        0     6368 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h
--rw-rw-rw-   0        0        0     4905 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/Parallelizer.h
--rw-rw-rw-   0        0        0    19632 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h
--rw-rw-rw-   0        0        0    11198 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h
--rw-rw-rw-   0        0        0     9901 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointMatrixVector.h
--rw-rw-rw-   0        0        0     5209 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h
--rw-rw-rw-   0        0        0     6105 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointProduct.h
--rw-rw-rw-   0        0        0     4066 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointRank2Update.h
--rw-rw-rw-   0        0        0    20403 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/TriangularMatrixMatrix.h
--rw-rw-rw-   0        0        0    13743 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h
--rw-rw-rw-   0        0        0    14722 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/TriangularMatrixVector.h
--rw-rw-rw-   0        0        0    10571 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h
--rw-rw-rw-   0        0        0    13979 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/TriangularSolverMatrix.h
--rw-rw-rw-   0        0        0     6513 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h
--rw-rw-rw-   0        0        0     5741 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/products/TriangularSolverVector.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Core/util/
--rw-rw-rw-   0        0        0    15722 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/BlasUtil.h
--rw-rw-rw-   0        0        0    21579 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/Constants.h
--rw-rw-rw-   0        0        0     3981 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/DisableStupidWarnings.h
--rw-rw-rw-   0        0        0    14150 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/ForwardDeclarations.h
--rw-rw-rw-   0        0        0     4026 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/MKL_support.h
--rw-rw-rw-   0        0        0    36570 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/Macros.h
--rw-rw-rw-   0        0        0    40579 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/Memory.h
--rw-rw-rw-   0        0        0    20586 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/Meta.h
--rw-rw-rw-   0        0        0       85 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/NonMPL2.h
--rw-rw-rw-   0        0        0      856 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/ReenableStupidWarnings.h
--rw-rw-rw-   0        0        0    10518 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/StaticAssert.h
--rw-rw-rw-   0        0        0    34198 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Core/util/XprHelper.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/
--rw-rw-rw-   0        0        0    12558 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/ComplexEigenSolver.h
--rw-rw-rw-   0        0        0    17021 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/ComplexSchur.h
--rw-rw-rw-   0        0        0     4178 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h
--rw-rw-rw-   0        0        0    22944 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/EigenSolver.h
--rw-rw-rw-   0        0        0    17176 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h
--rw-rw-rw-   0        0        0     9715 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h
--rw-rw-rw-   0        0        0    14351 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/HessenbergDecomposition.h
--rw-rw-rw-   0        0        0     5539 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h
--rw-rw-rw-   0        0        0    23586 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/RealQZ.h
--rw-rw-rw-   0        0        0    20288 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/RealSchur.h
--rw-rw-rw-   0        0        0     3650 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/RealSchur_LAPACKE.h
--rw-rw-rw-   0        0        0    33674 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h
--rw-rw-rw-   0        0        0     4104 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h
--rw-rw-rw-   0        0        0    22444 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Eigenvalues/Tridiagonalization.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Geometry/
--rw-rw-rw-   0        0        0    14815 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/AlignedBox.h
--rw-rw-rw-   0        0        0     8423 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/AngleAxis.h
--rw-rw-rw-   0        0        0     3639 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/EulerAngles.h
--rw-rw-rw-   0        0        0    20539 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/Homogeneous.h
--rw-rw-rw-   0        0        0    11961 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/Hyperplane.h
--rw-rw-rw-   0        0        0     8949 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/OrthoMethods.h
--rw-rw-rw-   0        0        0     8308 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/ParametrizedLine.h
--rw-rw-rw-   0        0        0    32152 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/Quaternion.h
--rw-rw-rw-   0        0        0     6877 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/Rotation2D.h
--rw-rw-rw-   0        0        0     8063 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/RotationBase.h
--rw-rw-rw-   0        0        0     6324 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/Scaling.h
--rw-rw-rw-   0        0        0    60514 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/Transform.h
--rw-rw-rw-   0        0        0     7773 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/Translation.h
--rw-rw-rw-   0        0        0     6191 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/Umeyama.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Geometry/arch/
--rw-rw-rw-   0        0        0     5387 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Geometry/arch/Geometry_SSE.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Householder/
--rw-rw-rw-   0        0        0     4481 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Householder/BlockHouseholder.h
--rw-rw-rw-   0        0        0     5345 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Householder/Householder.h
--rw-rw-rw-   0        0        0    20603 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Householder/HouseholderSequence.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/
--rw-rw-rw-   0        0        0     6755 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h
--rw-rw-rw-   0        0        0     7253 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h
--rw-rw-rw-   0        0        0     9289 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h
--rw-rw-rw-   0        0        0    15062 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h
--rw-rw-rw-   0        0        0    15234 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h
--rw-rw-rw-   0        0        0    11527 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h
--rw-rw-rw-   0        0        0     7762 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h
--rw-rw-rw-   0        0        0     4158 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/Jacobi/
--rw-rw-rw-   0        0        0    15902 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/Jacobi/Jacobi.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/LU/
--rw-rw-rw-   0        0        0     3057 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/LU/Determinant.h
--rw-rw-rw-   0        0        0    32803 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/LU/FullPivLU.h
--rw-rw-rw-   0        0        0    15064 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/LU/InverseImpl.h
--rw-rw-rw-   0        0        0    21478 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/LU/PartialPivLU.h
--rw-rw-rw-   0        0        0     3555 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/LU/PartialPivLU_LAPACKE.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/LU/arch/
--rw-rw-rw-   0        0        0    13669 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/LU/arch/Inverse_SSE.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/MetisSupport/
--rw-rw-rw-   0        0        0     4588 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/MetisSupport/MetisSupport.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/OrderingMethods/
--rw-rw-rw-   0        0        0    16396 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/OrderingMethods/Amd.h
--rw-rw-rw-   0        0        0    62266 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/OrderingMethods/Eigen_Colamd.h
--rw-rw-rw-   0        0        0     5229 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/OrderingMethods/Ordering.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/PaStiXSupport/
--rw-rw-rw-   0        0        0    22248 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/PaStiXSupport/PaStiXSupport.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:29.000000 chronogram-0.1.7/include/Eigen/src/PardisoSupport/
--rw-rw-rw-   0        0        0    20032 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/PardisoSupport/PardisoSupport.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/QR/
--rw-rw-rw-   0        0        0    24881 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/QR/ColPivHouseholderQR.h
--rw-rw-rw-   0        0        0     4662 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h
--rw-rw-rw-   0        0        0    20805 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/QR/CompleteOrthogonalDecomposition.h
--rw-rw-rw-   0        0        0    25478 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/QR/FullPivHouseholderQR.h
--rw-rw-rw-   0        0        0    14022 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/QR/HouseholderQR.h
--rw-rw-rw-   0        0        0     2993 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/QR/HouseholderQR_LAPACKE.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/SPQRSupport/
--rw-rw-rw-   0        0        0    11405 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/SVD/
--rw-rw-rw-   0        0        0    48778 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SVD/BDCSVD.h
--rw-rw-rw-   0        0        0    32949 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SVD/JacobiSVD.h
--rw-rw-rw-   0        0        0     5099 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SVD/JacobiSVD_LAPACKE.h
--rw-rw-rw-   0        0        0    12740 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SVD/SVDBase.h
--rw-rw-rw-   0        0        0    15957 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SVD/UpperBidiagonalization.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/SparseCholesky/
--rw-rw-rw-   0        0        0    24010 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCholesky/SimplicialCholesky.h
--rw-rw-rw-   0        0        0     6898 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCholesky/SimplicialCholesky_impl.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/
--rw-rw-rw-   0        0        0    10537 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/AmbiVector.h
--rw-rw-rw-   0        0        0     8164 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/CompressedStorage.h
--rw-rw-rw-   0        0        0    13178 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h
--rw-rw-rw-   0        0        0     2191 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/MappedSparseMatrix.h
--rw-rw-rw-   0        0        0     8080 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseAssign.h
--rw-rw-rw-   0        0        0    25592 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseBlock.h
--rw-rw-rw-   0        0        0     6485 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseColEtree.h
--rw-rw-rw-   0        0        0    12720 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseCompressedBase.h
--rw-rw-rw-   0        0        0    25840 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h
--rw-rw-rw-   0        0        0     4711 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h
--rw-rw-rw-   0        0        0    12487 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseDenseProduct.h
--rw-rw-rw-   0        0        0     5808 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseDiagonalProduct.h
--rw-rw-rw-   0        0        0     3080 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseDot.h
--rw-rw-rw-   0        0        0     1107 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseFuzzy.h
--rw-rw-rw-   0        0        0    12589 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseMap.h
--rw-rw-rw-   0        0        0    52373 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseMatrix.h
--rw-rw-rw-   0        0        0    17923 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseMatrixBase.h
--rw-rw-rw-   0        0        0     7329 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparsePermutation.h
--rw-rw-rw-   0        0        0     7049 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseProduct.h
--rw-rw-rw-   0        0        0     1699 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseRedux.h
--rw-rw-rw-   0        0        0    15492 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseRef.h
--rw-rw-rw-   0        0        0    25715 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseSelfAdjointView.h
--rw-rw-rw-   0        0        0     4424 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseSolverBase.h
--rw-rw-rw-   0        0        0     8704 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h
--rw-rw-rw-   0        0        0     3175 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseTranspose.h
--rw-rw-rw-   0        0        0     6437 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseTriangularView.h
--rw-rw-rw-   0        0        0     6602 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseUtil.h
--rw-rw-rw-   0        0        0    14831 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseVector.h
--rw-rw-rw-   0        0        0     8110 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/SparseView.h
--rw-rw-rw-   0        0        0     9657 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseCore/TriangularSolver.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/
--rw-rw-rw-   0        0        0    27866 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU.h
--rw-rw-rw-   0        0        0     4303 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLUImpl.h
--rw-rw-rw-   0        0        0     7601 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_Memory.h
--rw-rw-rw-   0        0        0     4974 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_Structs.h
--rw-rw-rw-   0        0        0    10022 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h
--rw-rw-rw-   0        0        0     2049 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_Utils.h
--rw-rw-rw-   0        0        0     6712 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_column_bmod.h
--rw-rw-rw-   0        0        0     6582 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_column_dfs.h
--rw-rw-rw-   0        0        0     3681 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h
--rw-rw-rw-   0        0        0    10216 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_gemm_kernel.h
--rw-rw-rw-   0        0        0     4181 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_heap_relax_snode.h
--rw-rw-rw-   0        0        0     5723 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_kernel_bmod.h
--rw-rw-rw-   0        0        0     8486 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_panel_bmod.h
--rw-rw-rw-   0        0        0     9028 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_panel_dfs.h
--rw-rw-rw-   0        0        0     4979 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_pivotL.h
--rw-rw-rw-   0        0        0     4545 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_pruneL.h
--rw-rw-rw-   0        0        0     2889 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_relax_snode.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/SparseQR/
--rw-rw-rw-   0        0        0    28373 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SparseQR/SparseQR.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/StlSupport/
--rw-rw-rw-   0        0        0     5117 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/StlSupport/StdDeque.h
--rw-rw-rw-   0        0        0     4147 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/StlSupport/StdList.h
--rw-rw-rw-   0        0        0     5330 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/StlSupport/StdVector.h
--rw-rw-rw-   0        0        0     2809 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/StlSupport/details.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/SuperLUSupport/
--rw-rw-rw-   0        0        0    34345 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/SuperLUSupport/SuperLUSupport.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/UmfPackSupport/
--rw-rw-rw-   0        0        0    17202 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/UmfPackSupport/UmfPackSupport.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/misc/
--rw-rw-rw-   0        0        0     2913 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/misc/Image.h
--rw-rw-rw-   0        0        0     2742 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/misc/Kernel.h
--rw-rw-rw-   0        0        0     1748 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/misc/RealSvd2x2.h
--rw-rw-rw-   0        0        0    30560 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/misc/blas.h
--rw-rw-rw-   0        0        0     7834 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/misc/lapack.h
--rw-rw-rw-   0        0        0  1058368 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/misc/lapacke.h
--rw-rw-rw-   0        0        0      474 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/misc/lapacke_mangling.h
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/include/Eigen/src/plugins/
--rw-rw-rw-   0        0        0    13132 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/plugins/ArrayCwiseBinaryOps.h
--rw-rw-rw-   0        0        0    16929 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/plugins/ArrayCwiseUnaryOps.h
--rw-rw-rw-   0        0        0    37403 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/plugins/BlockMethods.h
--rw-rw-rw-   0        0        0     4828 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/plugins/CommonCwiseBinaryOps.h
--rw-rw-rw-   0        0        0     5621 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/plugins/CommonCwiseUnaryOps.h
--rw-rw-rw-   0        0        0     6375 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/plugins/MatrixCwiseBinaryOps.h
--rw-rw-rw-   0        0        0     2937 2018-12-11 17:57:55.000000 chronogram-0.1.7/include/Eigen/src/plugins/MatrixCwiseUnaryOps.h
--rw-rw-rw-   0        0        0       42 2019-09-23 14:56:30.000000 chronogram-0.1.7/setup.cfg
--rw-rw-rw-   0        0        0     3064 2019-09-23 14:56:19.000000 chronogram-0.1.7/setup.py
-drwxrwxrwx   0        0        0        0 2019-09-23 14:56:30.000000 chronogram-0.1.7/src/
--rw-rw-rw-   0        0        0    48323 2019-09-23 14:23:26.000000 chronogram-0.1.7/src/ChronoGramModel.cpp
--rw-rw-rw-   0        0        0    12204 2019-09-23 14:19:08.000000 chronogram-0.1.7/src/ChronoGramModel.h
--rw-rw-rw-   0        0        0     2057 2019-09-04 11:03:32.000000 chronogram-0.1.7/src/DataReader.cpp
--rw-rw-rw-   0        0        0      797 2019-09-04 11:03:32.000000 chronogram-0.1.7/src/DataReader.h
--rw-rw-rw-   0        0        0     1534 2019-09-23 14:05:27.000000 chronogram-0.1.7/src/IOUtils.cpp
--rw-rw-rw-   0        0        0     5922 2019-09-23 14:05:22.000000 chronogram-0.1.7/src/IOUtils.h
--rw-rw-rw-   0        0        0     1450 2018-09-20 15:25:31.000000 chronogram-0.1.7/src/LUT.hpp
--rw-rw-rw-   0        0        0     1312 2019-09-23 13:48:35.000000 chronogram-0.1.7/src/MMap.cpp
--rw-rw-rw-   0        0        0     1892 2019-09-22 14:41:02.000000 chronogram-0.1.7/src/MMap.h
--rw-rw-rw-   0        0        0     4166 2019-07-28 08:43:47.000000 chronogram-0.1.7/src/PyUtils.h
--rw-rw-rw-   0        0        0     2896 2019-02-02 07:57:54.000000 chronogram-0.1.7/src/ThreadPool.h
--rw-rw-rw-   0        0        0      367 2018-10-02 16:23:19.000000 chronogram-0.1.7/src/Timer.h
--rw-rw-rw-   0        0        0    40901 2019-01-05 14:48:44.000000 chronogram-0.1.7/src/cxxopts.hpp
--rw-rw-rw-   0        0        0     1942 2019-09-23 13:53:27.000000 chronogram-0.1.7/src/dictionary.h
--rw-rw-rw-   0        0        0     1664 2018-09-20 15:25:31.000000 chronogram-0.1.7/src/gamma.h
--rw-rw-rw-   0        0        0    28441 2019-09-23 14:20:55.000000 chronogram-0.1.7/src/main.cpp
--rw-rw-rw-   0        0        0     2941 2019-09-04 11:03:32.000000 chronogram-0.1.7/src/mathUtils.h
--rw-rw-rw-   0        0        0     6321 2019-01-16 17:39:26.000000 chronogram-0.1.7/src/polynomials.hpp
--rw-rw-rw-   0        0        0     2947 2019-09-03 12:01:55.000000 chronogram-0.1.7/src/pyDocs.h
--rw-rw-rw-   0        0        0    36070 2019-09-23 14:53:34.000000 chronogram-0.1.7/src/pyModule.cpp
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.273605 chronogram-0.2.0/
+-rw-r--r--   0 root         (0) root         (0)      122 2023-06-06 06:02:21.000000 chronogram-0.2.0/MANIFEST.in
+-rw-r--r--   0 root         (0) root         (0)     1163 2023-06-06 06:03:00.273605 chronogram-0.2.0/PKG-INFO
+-rw-r--r--   0 root         (0) root         (0)      883 2023-06-06 06:02:21.000000 chronogram-0.2.0/README.rst
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.153605 chronogram-0.2.0/chronogram/
+-rw-r--r--   0 root         (0) root         (0)     1236 2023-06-06 06:02:21.000000 chronogram-0.2.0/chronogram/__init__.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.157605 chronogram-0.2.0/chronogram.egg-info/
+-rw-r--r--   0 root         (0) root         (0)     1163 2023-06-06 06:03:00.000000 chronogram-0.2.0/chronogram.egg-info/PKG-INFO
+-rw-r--r--   0 root         (0) root         (0)    15984 2023-06-06 06:03:00.000000 chronogram-0.2.0/chronogram.egg-info/SOURCES.txt
+-rw-r--r--   0 root         (0) root         (0)        1 2023-06-06 06:03:00.000000 chronogram-0.2.0/chronogram.egg-info/dependency_links.txt
+-rw-r--r--   0 root         (0) root         (0)       11 2023-06-06 06:03:00.000000 chronogram-0.2.0/chronogram.egg-info/requires.txt
+-rw-r--r--   0 root         (0) root         (0)       56 2023-06-06 06:03:00.000000 chronogram-0.2.0/chronogram.egg-info/top_level.txt
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.153605 chronogram-0.2.0/include/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.165605 chronogram-0.2.0/include/Eigen/
+-rw-r--r--   0 root         (0) root         (0)     1161 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Cholesky
+-rw-r--r--   0 root         (0) root         (0)     1900 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/CholmodSupport
+-rw-r--r--   0 root         (0) root         (0)    12799 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Core
+-rw-r--r--   0 root         (0) root         (0)      122 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Dense
+-rw-r--r--   0 root         (0) root         (0)       35 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Eigen
+-rw-r--r--   0 root         (0) root         (0)     1777 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Eigenvalues
+-rw-r--r--   0 root         (0) root         (0)     1940 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Geometry
+-rw-r--r--   0 root         (0) root         (0)      829 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Householder
+-rw-r--r--   0 root         (0) root         (0)     2083 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/IterativeLinearSolvers
+-rw-r--r--   0 root         (0) root         (0)      894 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Jacobi
+-rw-r--r--   0 root         (0) root         (0)     1389 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/KLUSupport
+-rw-r--r--   0 root         (0) root         (0)     1268 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/LU
+-rw-r--r--   0 root         (0) root         (0)      991 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/MetisSupport
+-rw-r--r--   0 root         (0) root         (0)     2451 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/OrderingMethods
+-rw-r--r--   0 root         (0) root         (0)     1751 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/PaStiXSupport
+-rw-r--r--   0 root         (0) root         (0)     1116 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/PardisoSupport
+-rw-r--r--   0 root         (0) root         (0)     1272 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/QR
+-rw-r--r--   0 root         (0) root         (0)      900 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/QtAlignedMalloc
+-rw-r--r--   0 root         (0) root         (0)     1162 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/SPQRSupport
+-rw-r--r--   0 root         (0) root         (0)     1584 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/SVD
+-rw-r--r--   0 root         (0) root         (0)      888 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/Sparse
+-rw-r--r--   0 root         (0) root         (0)     1235 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/SparseCholesky
+-rw-r--r--   0 root         (0) root         (0)     2240 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/SparseCore
+-rw-r--r--   0 root         (0) root         (0)     1814 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/SparseLU
+-rw-r--r--   0 root         (0) root         (0)     1195 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/SparseQR
+-rw-r--r--   0 root         (0) root         (0)      797 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/StdDeque
+-rw-r--r--   0 root         (0) root         (0)      726 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/StdList
+-rw-r--r--   0 root         (0) root         (0)      803 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/StdVector
+-rw-r--r--   0 root         (0) root         (0)     2243 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/SuperLUSupport
+-rw-r--r--   0 root         (0) root         (0)     1382 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/UmfPackSupport
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.153605 chronogram-0.2.0/include/Eigen/src/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.165605 chronogram-0.2.0/include/Eigen/src/Cholesky/
+-rw-r--r--   0 root         (0) root         (0)    24934 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Cholesky/LDLT.h
+-rw-r--r--   0 root         (0) root         (0)    18760 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Cholesky/LLT.h
+-rw-r--r--   0 root         (0) root         (0)     3974 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Cholesky/LLT_LAPACKE.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.165605 chronogram-0.2.0/include/Eigen/src/CholmodSupport/
+-rw-r--r--   0 root         (0) root         (0)    25441 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/CholmodSupport/CholmodSupport.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.185605 chronogram-0.2.0/include/Eigen/src/Core/
+-rw-r--r--   0 root         (0) root         (0)    19214 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/ArithmeticSequence.h
+-rw-r--r--   0 root         (0) root         (0)    16782 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Array.h
+-rw-r--r--   0 root         (0) root         (0)     8217 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/ArrayBase.h
+-rw-r--r--   0 root         (0) root         (0)     7018 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/ArrayWrapper.h
+-rw-r--r--   0 root         (0) root         (0)     2738 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Assign.h
+-rw-r--r--   0 root         (0) root         (0)    41673 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/AssignEvaluator.h
+-rwxr-xr-x   0 root         (0) root         (0)    12488 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Assign_MKL.h
+-rw-r--r--   0 root         (0) root         (0)    14075 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/BandMatrix.h
+-rw-r--r--   0 root         (0) root         (0)    18648 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Block.h
+-rw-r--r--   0 root         (0) root         (0)     4429 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/BooleanRedux.h
+-rw-r--r--   0 root         (0) root         (0)     5981 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/CommaInitializer.h
+-rw-r--r--   0 root         (0) root         (0)     6990 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/ConditionEstimator.h
+-rw-r--r--   0 root         (0) root         (0)    63841 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/CoreEvaluators.h
+-rw-r--r--   0 root         (0) root         (0)     4745 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/CoreIterators.h
+-rw-r--r--   0 root         (0) root         (0)     7909 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/CwiseBinaryOp.h
+-rw-r--r--   0 root         (0) root         (0)    36282 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/CwiseNullaryOp.h
+-rw-r--r--   0 root         (0) root         (0)     8256 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/CwiseTernaryOp.h
+-rw-r--r--   0 root         (0) root         (0)     3937 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/CwiseUnaryOp.h
+-rw-r--r--   0 root         (0) root         (0)     5551 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/CwiseUnaryView.h
+-rw-r--r--   0 root         (0) root         (0)    31529 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/DenseBase.h
+-rw-r--r--   0 root         (0) root         (0)    24484 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/DenseCoeffsBase.h
+-rw-r--r--   0 root         (0) root         (0)    25360 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/DenseStorage.h
+-rw-r--r--   0 root         (0) root         (0)     9870 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Diagonal.h
+-rw-r--r--   0 root         (0) root         (0)    14670 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/DiagonalMatrix.h
+-rw-r--r--   0 root         (0) root         (0)      988 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/DiagonalProduct.h
+-rw-r--r--   0 root         (0) root         (0)    11654 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Dot.h
+-rw-r--r--   0 root         (0) root         (0)     5841 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/EigenBase.h
+-rw-r--r--   0 root         (0) root         (0)     4909 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/ForceAlignedAccess.h
+-rw-r--r--   0 root         (0) root         (0)     5759 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Fuzzy.h
+-rw-r--r--   0 root         (0) root         (0)    21679 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/GeneralProduct.h
+-rw-r--r--   0 root         (0) root         (0)    38812 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/GenericPacketMath.h
+-rw-r--r--   0 root         (0) root         (0)    11543 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/GlobalFunctions.h
+-rw-r--r--   0 root         (0) root         (0)     8238 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/IO.h
+-rw-r--r--   0 root         (0) root         (0)     9620 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/IndexedView.h
+-rw-r--r--   0 root         (0) root         (0)     3503 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Inverse.h
+-rw-r--r--   0 root         (0) root         (0)     7256 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Map.h
+-rw-r--r--   0 root         (0) root         (0)    11281 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/MapBase.h
+-rw-r--r--   0 root         (0) root         (0)    60784 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)     7156 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/MathFunctionsImpl.h
+-rw-r--r--   0 root         (0) root         (0)    24343 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Matrix.h
+-rw-r--r--   0 root         (0) root         (0)    23856 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/MatrixBase.h
+-rw-r--r--   0 root         (0) root         (0)     2520 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/NestByValue.h
+-rw-r--r--   0 root         (0) root         (0)     3620 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/NoAlias.h
+-rw-r--r--   0 root         (0) root         (0)    12884 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/NumTraits.h
+-rw-r--r--   0 root         (0) root         (0)     9207 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/PartialReduxEvaluator.h
+-rw-r--r--   0 root         (0) root         (0)    20748 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/PermutationMatrix.h
+-rw-r--r--   0 root         (0) root         (0)    49193 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/PlainObjectBase.h
+-rw-r--r--   0 root         (0) root         (0)     7336 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Product.h
+-rw-r--r--   0 root         (0) root         (0)    53832 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/ProductEvaluators.h
+-rw-r--r--   0 root         (0) root         (0)     7756 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Random.h
+-rw-r--r--   0 root         (0) root         (0)    19195 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Redux.h
+-rw-r--r--   0 root         (0) root         (0)    17821 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Ref.h
+-rw-r--r--   0 root         (0) root         (0)     5656 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Replicate.h
+-rw-r--r--   0 root         (0) root         (0)    17033 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Reshaped.h
+-rw-r--r--   0 root         (0) root         (0)     4284 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/ReturnByValue.h
+-rw-r--r--   0 root         (0) root         (0)     7522 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Reverse.h
+-rw-r--r--   0 root         (0) root         (0)     6143 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Select.h
+-rw-r--r--   0 root         (0) root         (0)    14999 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/SelfAdjointView.h
+-rw-r--r--   0 root         (0) root         (0)     1697 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/SelfCwiseBinaryOp.h
+-rw-r--r--   0 root         (0) root         (0)     6837 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Solve.h
+-rw-r--r--   0 root         (0) root         (0)     9368 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/SolveTriangular.h
+-rw-r--r--   0 root         (0) root         (0)     6170 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/SolverBase.h
+-rw-r--r--   0 root         (0) root         (0)     8700 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/StableNorm.h
+-rw-r--r--   0 root         (0) root         (0)    21641 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/StlIterators.h
+-rw-r--r--   0 root         (0) root         (0)     4212 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Stride.h
+-rw-r--r--   0 root         (0) root         (0)     2765 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Swap.h
+-rw-r--r--   0 root         (0) root         (0)    17606 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Transpose.h
+-rw-r--r--   0 root         (0) root         (0)    13567 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Transpositions.h
+-rw-r--r--   0 root         (0) root         (0)    38277 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/TriangularMatrix.h
+-rw-r--r--   0 root         (0) root         (0)     3488 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/VectorBlock.h
+-rw-r--r--   0 root         (0) root         (0)    35168 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/VectorwiseOp.h
+-rw-r--r--   0 root         (0) root         (0)    11997 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/Visitor.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.145605 chronogram-0.2.0/include/Eigen/src/Core/arch/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.189605 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX/
+-rw-r--r--   0 root         (0) root         (0)    15223 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX/Complex.h
+-rw-r--r--   0 root         (0) root         (0)     8102 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)    64608 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX/PacketMath.h
+-rw-r--r--   0 root         (0) root         (0)     2564 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX/TypeCasting.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.189605 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX512/
+-rw-r--r--   0 root         (0) root         (0)    17160 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX512/Complex.h
+-rw-r--r--   0 root         (0) root         (0)    13344 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX512/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)    87891 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX512/PacketMath.h
+-rw-r--r--   0 root         (0) root         (0)     2134 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AVX512/TypeCasting.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.193605 chronogram-0.2.0/include/Eigen/src/Core/arch/AltiVec/
+-rw-r--r--   0 root         (0) root         (0)    16540 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AltiVec/Complex.h
+-rw-r--r--   0 root         (0) root         (0)     2323 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AltiVec/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)   119355 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AltiVec/MatrixProduct.h
+-rw-r--r--   0 root         (0) root         (0)     9490 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AltiVec/MatrixProductCommon.h
+-rw-r--r--   0 root         (0) root         (0)    24820 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AltiVec/MatrixProductMMA.h
+-rwxr-xr-x   0 root         (0) root         (0)   102394 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/AltiVec/PacketMath.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.193605 chronogram-0.2.0/include/Eigen/src/Core/arch/CUDA/
+-rw-r--r--   0 root         (0) root         (0)    17317 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/CUDA/Complex.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.193605 chronogram-0.2.0/include/Eigen/src/Core/arch/Default/
+-rw-r--r--   0 root         (0) root         (0)    26903 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/Default/BFloat16.h
+-rw-r--r--   0 root         (0) root         (0)     5251 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/Default/ConjHelper.h
+-rw-r--r--   0 root         (0) root         (0)    67696 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/Default/GenericPacketMathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)     3770 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/Default/GenericPacketMathFunctionsFwd.h
+-rw-r--r--   0 root         (0) root         (0)    35534 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/Default/Half.h
+-rw-r--r--   0 root         (0) root         (0)     1746 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/Default/Settings.h
+-rw-r--r--   0 root         (0) root         (0)     3746 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/Default/TypeCasting.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.193605 chronogram-0.2.0/include/Eigen/src/Core/arch/GPU/
+-rw-r--r--   0 root         (0) root         (0)     2695 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/GPU/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)    57047 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/GPU/PacketMath.h
+-rw-r--r--   0 root         (0) root         (0)     2256 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/GPU/TypeCasting.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.145605 chronogram-0.2.0/include/Eigen/src/Core/arch/HIP/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.193605 chronogram-0.2.0/include/Eigen/src/Core/arch/HIP/hcc/
+-rw-r--r--   0 root         (0) root         (0)      691 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/HIP/hcc/math_constants.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.197605 chronogram-0.2.0/include/Eigen/src/Core/arch/MSA/
+-rw-r--r--   0 root         (0) root         (0)    17541 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/MSA/Complex.h
+-rw-r--r--   0 root         (0) root         (0)    16159 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/MSA/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)    33615 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/MSA/PacketMath.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.197605 chronogram-0.2.0/include/Eigen/src/Core/arch/NEON/
+-rw-r--r--   0 root         (0) root         (0)    22503 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/NEON/Complex.h
+-rw-r--r--   0 root         (0) root         (0)     6815 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/NEON/GeneralBlockPanelKernel.h
+-rw-r--r--   0 root         (0) root         (0)     3083 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/NEON/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)   189525 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/NEON/PacketMath.h
+-rw-r--r--   0 root         (0) root         (0)    51286 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/NEON/TypeCasting.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.201605 chronogram-0.2.0/include/Eigen/src/Core/arch/SSE/
+-rw-r--r--   0 root         (0) root         (0)    14251 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SSE/Complex.h
+-rw-r--r--   0 root         (0) root         (0)     6765 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SSE/MathFunctions.h
+-rwxr-xr-x   0 root         (0) root         (0)    64465 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SSE/PacketMath.h
+-rw-r--r--   0 root         (0) root         (0)     3650 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SSE/TypeCasting.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.201605 chronogram-0.2.0/include/Eigen/src/Core/arch/SVE/
+-rw-r--r--   0 root         (0) root         (0)     1194 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SVE/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)    21200 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SVE/PacketMath.h
+-rw-r--r--   0 root         (0) root         (0)     1351 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SVE/TypeCasting.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.201605 chronogram-0.2.0/include/Eigen/src/Core/arch/SYCL/
+-rw-r--r--   0 root         (0) root         (0)     7428 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SYCL/InteropHeaders.h
+-rw-r--r--   0 root         (0) root         (0)    12539 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SYCL/MathFunctions.h
+-rw-r--r--   0 root         (0) root         (0)    27786 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SYCL/PacketMath.h
+-rw-r--r--   0 root         (0) root         (0)    21856 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SYCL/SyclMemoryModel.h
+-rw-r--r--   0 root         (0) root         (0)     2626 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/SYCL/TypeCasting.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.201605 chronogram-0.2.0/include/Eigen/src/Core/arch/ZVector/
+-rw-r--r--   0 root         (0) root         (0)    16728 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/ZVector/Complex.h
+-rw-r--r--   0 root         (0) root         (0)     8024 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/ZVector/MathFunctions.h
+-rwxr-xr-x   0 root         (0) root         (0)    36894 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/arch/ZVector/PacketMath.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.205605 chronogram-0.2.0/include/Eigen/src/Core/functors/
+-rw-r--r--   0 root         (0) root         (0)     6686 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/functors/AssignmentFunctors.h
+-rw-r--r--   0 root         (0) root         (0)    20921 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/functors/BinaryFunctors.h
+-rw-r--r--   0 root         (0) root         (0)     8334 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/functors/NullaryFunctors.h
+-rw-r--r--   0 root         (0) root         (0)     4998 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/functors/StlFunctors.h
+-rw-r--r--   0 root         (0) root         (0)      607 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/functors/TernaryFunctors.h
+-rw-r--r--   0 root         (0) root         (0)    40146 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/functors/UnaryFunctors.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.209605 chronogram-0.2.0/include/Eigen/src/Core/products/
+-rw-r--r--   0 root         (0) root         (0)   108448 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/GeneralBlockPanelKernel.h
+-rw-r--r--   0 root         (0) root         (0)    20104 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixMatrix.h
+-rw-r--r--   0 root         (0) root         (0)    15948 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h
+-rw-r--r--   0 root         (0) root         (0)     6936 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h
+-rw-r--r--   0 root         (0) root         (0)     5106 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h
+-rw-r--r--   0 root         (0) root         (0)    21724 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixVector.h
+-rw-r--r--   0 root         (0) root         (0)     6368 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h
+-rw-r--r--   0 root         (0) root         (0)     5582 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/Parallelizer.h
+-rw-r--r--   0 root         (0) root         (0)    21354 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h
+-rw-r--r--   0 root         (0) root         (0)    11570 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h
+-rw-r--r--   0 root         (0) root         (0)     9958 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointMatrixVector.h
+-rw-r--r--   0 root         (0) root         (0)     5209 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h
+-rw-r--r--   0 root         (0) root         (0)     6164 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointProduct.h
+-rw-r--r--   0 root         (0) root         (0)     4126 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointRank2Update.h
+-rw-r--r--   0 root         (0) root         (0)    20987 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/TriangularMatrixMatrix.h
+-rw-r--r--   0 root         (0) root         (0)    13867 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h
+-rw-r--r--   0 root         (0) root         (0)    14722 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/TriangularMatrixVector.h
+-rw-r--r--   0 root         (0) root         (0)    10571 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h
+-rw-r--r--   0 root         (0) root         (0)    14678 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/TriangularSolverMatrix.h
+-rw-r--r--   0 root         (0) root         (0)     6707 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h
+-rw-r--r--   0 root         (0) root         (0)     5882 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/products/TriangularSolverVector.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.217605 chronogram-0.2.0/include/Eigen/src/Core/util/
+-rwxr-xr-x   0 root         (0) root         (0)    23156 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/BlasUtil.h
+-rw-r--r--   0 root         (0) root         (0)    19876 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/ConfigureVectorization.h
+-rw-r--r--   0 root         (0) root         (0)    21931 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/Constants.h
+-rwxr-xr-x   0 root         (0) root         (0)     4892 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/DisableStupidWarnings.h
+-rw-r--r--   0 root         (0) root         (0)    15555 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/ForwardDeclarations.h
+-rw-r--r--   0 root         (0) root         (0)     6696 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/IndexedViewHelper.h
+-rw-r--r--   0 root         (0) root         (0)    10949 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/IntegralConstant.h
+-rwxr-xr-x   0 root         (0) root         (0)     4268 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/MKL_support.h
+-rw-r--r--   0 root         (0) root         (0)    52909 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/Macros.h
+-rw-r--r--   0 root         (0) root         (0)    46661 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/Memory.h
+-rwxr-xr-x   0 root         (0) root         (0)    29336 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/Meta.h
+-rw-r--r--   0 root         (0) root         (0)       85 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/NonMPL2.h
+-rw-r--r--   0 root         (0) root         (0)     1024 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/ReenableStupidWarnings.h
+-rw-r--r--   0 root         (0) root         (0)     1432 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/ReshapedHelper.h
+-rw-r--r--   0 root         (0) root         (0)    10676 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/StaticAssert.h
+-rw-r--r--   0 root         (0) root         (0)    12003 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/SymbolicIndex.h
+-rw-r--r--   0 root         (0) root         (0)    35762 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Core/util/XprHelper.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.221605 chronogram-0.2.0/include/Eigen/src/Eigenvalues/
+-rw-r--r--   0 root         (0) root         (0)    12559 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/ComplexEigenSolver.h
+-rw-r--r--   0 root         (0) root         (0)    17274 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/ComplexSchur.h
+-rw-r--r--   0 root         (0) root         (0)     4178 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h
+-rw-r--r--   0 root         (0) root         (0)    22970 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/EigenSolver.h
+-rw-r--r--   0 root         (0) root         (0)    17176 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h
+-rw-r--r--   0 root         (0) root         (0)     9716 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h
+-rw-r--r--   0 root         (0) root         (0)    14349 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/HessenbergDecomposition.h
+-rw-r--r--   0 root         (0) root         (0)     5575 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h
+-rw-r--r--   0 root         (0) root         (0)    23640 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/RealQZ.h
+-rw-r--r--   0 root         (0) root         (0)    21078 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/RealSchur.h
+-rw-r--r--   0 root         (0) root         (0)     3650 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/RealSchur_LAPACKE.h
+-rw-r--r--   0 root         (0) root         (0)    35182 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h
+-rw-r--r--   0 root         (0) root         (0)     4104 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h
+-rw-r--r--   0 root         (0) root         (0)    22764 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Eigenvalues/Tridiagonalization.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.225605 chronogram-0.2.0/include/Eigen/src/Geometry/
+-rw-r--r--   0 root         (0) root         (0)    18939 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/AlignedBox.h
+-rw-r--r--   0 root         (0) root         (0)     8403 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/AngleAxis.h
+-rw-r--r--   0 root         (0) root         (0)     3624 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/EulerAngles.h
+-rw-r--r--   0 root         (0) root         (0)    20726 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/Homogeneous.h
+-rw-r--r--   0 root         (0) root         (0)    11962 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/Hyperplane.h
+-rw-r--r--   0 root         (0) root         (0)     8955 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/OrthoMethods.h
+-rw-r--r--   0 root         (0) root         (0)     9812 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/ParametrizedLine.h
+-rw-r--r--   0 root         (0) root         (0)    34367 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/Quaternion.h
+-rw-r--r--   0 root         (0) root         (0)     6862 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/Rotation2D.h
+-rw-r--r--   0 root         (0) root         (0)     8063 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/RotationBase.h
+-rw-r--r--   0 root         (0) root         (0)     6724 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/Scaling.h
+-rw-r--r--   0 root         (0) root         (0)    61930 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/Transform.h
+-rw-r--r--   0 root         (0) root         (0)     7664 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/Translation.h
+-rw-r--r--   0 root         (0) root         (0)     6190 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/Umeyama.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.225605 chronogram-0.2.0/include/Eigen/src/Geometry/arch/
+-rw-r--r--   0 root         (0) root         (0)     5945 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Geometry/arch/Geometry_SIMD.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.225605 chronogram-0.2.0/include/Eigen/src/Householder/
+-rw-r--r--   0 root         (0) root         (0)     4784 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Householder/BlockHouseholder.h
+-rw-r--r--   0 root         (0) root         (0)     5365 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Householder/Householder.h
+-rw-r--r--   0 root         (0) root         (0)    23611 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Householder/HouseholderSequence.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.229605 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/
+-rw-r--r--   0 root         (0) root         (0)     6771 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h
+-rw-r--r--   0 root         (0) root         (0)     6850 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h
+-rw-r--r--   0 root         (0) root         (0)     8887 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h
+-rw-r--r--   0 root         (0) root         (0)    15036 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h
+-rw-r--r--   0 root         (0) root         (0)    14940 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h
+-rw-r--r--   0 root         (0) root         (0)    13379 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h
+-rw-r--r--   0 root         (0) root         (0)     7349 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h
+-rw-r--r--   0 root         (0) root         (0)     4212 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.229605 chronogram-0.2.0/include/Eigen/src/Jacobi/
+-rw-r--r--   0 root         (0) root         (0)    16383 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/Jacobi/Jacobi.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.229605 chronogram-0.2.0/include/Eigen/src/KLUSupport/
+-rw-r--r--   0 root         (0) root         (0)    11555 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/KLUSupport/KLUSupport.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.229605 chronogram-0.2.0/include/Eigen/src/LU/
+-rw-r--r--   0 root         (0) root         (0)     3439 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/LU/Determinant.h
+-rw-r--r--   0 root         (0) root         (0)    32383 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/LU/FullPivLU.h
+-rw-r--r--   0 root         (0) root         (0)    15727 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/LU/InverseImpl.h
+-rw-r--r--   0 root         (0) root         (0)    22069 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/LU/PartialPivLU.h
+-rw-r--r--   0 root         (0) root         (0)     3555 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/LU/PartialPivLU_LAPACKE.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.229605 chronogram-0.2.0/include/Eigen/src/LU/arch/
+-rw-r--r--   0 root         (0) root         (0)    13693 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/LU/arch/InverseSize4.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.229605 chronogram-0.2.0/include/Eigen/src/MetisSupport/
+-rw-r--r--   0 root         (0) root         (0)     4588 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/MetisSupport/MetisSupport.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.233605 chronogram-0.2.0/include/Eigen/src/OrderingMethods/
+-rw-r--r--   0 root         (0) root         (0)    16105 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/OrderingMethods/Amd.h
+-rw-r--r--   0 root         (0) root         (0)    61681 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/OrderingMethods/Eigen_Colamd.h
+-rw-r--r--   0 root         (0) root         (0)     5248 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/OrderingMethods/Ordering.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.233605 chronogram-0.2.0/include/Eigen/src/PaStiXSupport/
+-rw-r--r--   0 root         (0) root         (0)    22249 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/PaStiXSupport/PaStiXSupport.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.233605 chronogram-0.2.0/include/Eigen/src/PardisoSupport/
+-rw-r--r--   0 root         (0) root         (0)    20092 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/PardisoSupport/PardisoSupport.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.233605 chronogram-0.2.0/include/Eigen/src/QR/
+-rw-r--r--   0 root         (0) root         (0)    25498 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/QR/ColPivHouseholderQR.h
+-rw-r--r--   0 root         (0) root         (0)     4662 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h
+-rw-r--r--   0 root         (0) root         (0)    23429 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/QR/CompleteOrthogonalDecomposition.h
+-rw-r--r--   0 root         (0) root         (0)    26768 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/QR/FullPivHouseholderQR.h
+-rw-r--r--   0 root         (0) root         (0)    14641 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/QR/HouseholderQR.h
+-rw-r--r--   0 root         (0) root         (0)     2993 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/QR/HouseholderQR_LAPACKE.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.233605 chronogram-0.2.0/include/Eigen/src/SPQRSupport/
+-rw-r--r--   0 root         (0) root         (0)    11826 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.237605 chronogram-0.2.0/include/Eigen/src/SVD/
+-rw-r--r--   0 root         (0) root         (0)    54214 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SVD/BDCSVD.h
+-rw-r--r--   0 root         (0) root         (0)    32988 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SVD/JacobiSVD.h
+-rw-r--r--   0 root         (0) root         (0)     5099 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SVD/JacobiSVD_LAPACKE.h
+-rw-r--r--   0 root         (0) root         (0)    14743 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SVD/SVDBase.h
+-rw-r--r--   0 root         (0) root         (0)    15957 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SVD/UpperBidiagonalization.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.237605 chronogram-0.2.0/include/Eigen/src/SparseCholesky/
+-rw-r--r--   0 root         (0) root         (0)    24216 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCholesky/SimplicialCholesky.h
+-rw-r--r--   0 root         (0) root         (0)     5830 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCholesky/SimplicialCholesky_impl.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.245605 chronogram-0.2.0/include/Eigen/src/SparseCore/
+-rw-r--r--   0 root         (0) root         (0)    10670 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/AmbiVector.h
+-rw-r--r--   0 root         (0) root         (0)     8743 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/CompressedStorage.h
+-rw-r--r--   0 root         (0) root         (0)    13166 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h
+-rw-r--r--   0 root         (0) root         (0)     2191 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/MappedSparseMatrix.h
+-rw-r--r--   0 root         (0) root         (0)    11368 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseAssign.h
+-rw-r--r--   0 root         (0) root         (0)    24360 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseBlock.h
+-rw-r--r--   0 root         (0) root         (0)     6485 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseColEtree.h
+-rw-r--r--   0 root         (0) root         (0)    13606 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseCompressedBase.h
+-rw-r--r--   0 root         (0) root         (0)    25524 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h
+-rw-r--r--   0 root         (0) root         (0)     4757 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h
+-rw-r--r--   0 root         (0) root         (0)    13256 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseDenseProduct.h
+-rw-r--r--   0 root         (0) root         (0)     5808 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseDiagonalProduct.h
+-rw-r--r--   0 root         (0) root         (0)     3080 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseDot.h
+-rw-r--r--   0 root         (0) root         (0)     1107 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseFuzzy.h
+-rw-r--r--   0 root         (0) root         (0)    12589 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseMap.h
+-rw-r--r--   0 root         (0) root         (0)    57475 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseMatrix.h
+-rw-r--r--   0 root         (0) root         (0)    17451 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseMatrixBase.h
+-rw-r--r--   0 root         (0) root         (0)     7329 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparsePermutation.h
+-rw-r--r--   0 root         (0) root         (0)     7593 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseProduct.h
+-rw-r--r--   0 root         (0) root         (0)     1699 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseRedux.h
+-rw-r--r--   0 root         (0) root         (0)    15600 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseRef.h
+-rw-r--r--   0 root         (0) root         (0)    25889 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseSelfAdjointView.h
+-rw-r--r--   0 root         (0) root         (0)     4424 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseSolverBase.h
+-rw-r--r--   0 root         (0) root         (0)     8704 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h
+-rw-r--r--   0 root         (0) root         (0)     3175 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseTranspose.h
+-rw-r--r--   0 root         (0) root         (0)     6437 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseTriangularView.h
+-rw-r--r--   0 root         (0) root         (0)     6827 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseUtil.h
+-rw-r--r--   0 root         (0) root         (0)    14832 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseVector.h
+-rw-r--r--   0 root         (0) root         (0)     8127 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/SparseView.h
+-rw-r--r--   0 root         (0) root         (0)     9657 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseCore/TriangularSolver.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.249605 chronogram-0.2.0/include/Eigen/src/SparseLU/
+-rw-r--r--   0 root         (0) root         (0)    33316 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU.h
+-rw-r--r--   0 root         (0) root         (0)     4303 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLUImpl.h
+-rw-r--r--   0 root         (0) root         (0)     7602 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_Memory.h
+-rw-r--r--   0 root         (0) root         (0)     4974 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_Structs.h
+-rw-r--r--   0 root         (0) root         (0)    12837 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h
+-rw-r--r--   0 root         (0) root         (0)     2049 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_Utils.h
+-rw-r--r--   0 root         (0) root         (0)     6712 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_column_bmod.h
+-rw-r--r--   0 root         (0) root         (0)     6584 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_column_dfs.h
+-rw-r--r--   0 root         (0) root         (0)     3681 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h
+-rw-r--r--   0 root         (0) root         (0)    10217 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_gemm_kernel.h
+-rw-r--r--   0 root         (0) root         (0)     4181 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_heap_relax_snode.h
+-rw-r--r--   0 root         (0) root         (0)     5723 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_kernel_bmod.h
+-rw-r--r--   0 root         (0) root         (0)     8485 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_panel_bmod.h
+-rw-r--r--   0 root         (0) root         (0)     9028 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_panel_dfs.h
+-rw-r--r--   0 root         (0) root         (0)     4979 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_pivotL.h
+-rw-r--r--   0 root         (0) root         (0)     4545 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_pruneL.h
+-rw-r--r--   0 root         (0) root         (0)     2889 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_relax_snode.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.249605 chronogram-0.2.0/include/Eigen/src/SparseQR/
+-rw-r--r--   0 root         (0) root         (0)    29167 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SparseQR/SparseQR.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.253605 chronogram-0.2.0/include/Eigen/src/StlSupport/
+-rw-r--r--   0 root         (0) root         (0)     4730 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/StlSupport/StdDeque.h
+-rw-r--r--   0 root         (0) root         (0)     4155 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/StlSupport/StdList.h
+-rw-r--r--   0 root         (0) root         (0)     5338 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/StlSupport/StdVector.h
+-rw-r--r--   0 root         (0) root         (0)     2809 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/StlSupport/details.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.253605 chronogram-0.2.0/include/Eigen/src/SuperLUSupport/
+-rw-r--r--   0 root         (0) root         (0)    34324 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/SuperLUSupport/SuperLUSupport.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.253605 chronogram-0.2.0/include/Eigen/src/UmfPackSupport/
+-rw-r--r--   0 root         (0) root         (0)    24456 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/UmfPackSupport/UmfPackSupport.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.257605 chronogram-0.2.0/include/Eigen/src/misc/
+-rw-r--r--   0 root         (0) root         (0)     2913 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/misc/Image.h
+-rw-r--r--   0 root         (0) root         (0)     2742 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/misc/Kernel.h
+-rw-r--r--   0 root         (0) root         (0)     1748 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/misc/RealSvd2x2.h
+-rw-r--r--   0 root         (0) root         (0)    30560 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/misc/blas.h
+-rw-r--r--   0 root         (0) root         (0)     7834 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/misc/lapack.h
+-rwxr-xr-x   0 root         (0) root         (0)  1058369 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/misc/lapacke.h
+-rw-r--r--   0 root         (0) root         (0)      474 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/misc/lapacke_mangling.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.257605 chronogram-0.2.0/include/Eigen/src/plugins/
+-rw-r--r--   0 root         (0) root         (0)    14060 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/ArrayCwiseBinaryOps.h
+-rw-r--r--   0 root         (0) root         (0)    21431 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/ArrayCwiseUnaryOps.h
+-rw-r--r--   0 root         (0) root         (0)    59020 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/BlockMethods.h
+-rw-r--r--   0 root         (0) root         (0)     4828 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/CommonCwiseBinaryOps.h
+-rw-r--r--   0 root         (0) root         (0)     6089 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/CommonCwiseUnaryOps.h
+-rw-r--r--   0 root         (0) root         (0)    12283 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/IndexedViewMethods.h
+-rw-r--r--   0 root         (0) root         (0)     6387 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/MatrixCwiseBinaryOps.h
+-rw-r--r--   0 root         (0) root         (0)     3350 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/MatrixCwiseUnaryOps.h
+-rw-r--r--   0 root         (0) root         (0)     6915 2023-06-06 06:02:30.000000 chronogram-0.2.0/include/Eigen/src/plugins/ReshapedMethods.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.261605 chronogram-0.2.0/include/EigenRand/
+-rw-r--r--   0 root         (0) root         (0)      548 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/Core.h
+-rw-r--r--   0 root         (0) root         (0)    12485 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/CwiseHeteroBinaryOp.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.261605 chronogram-0.2.0/include/EigenRand/Dists/
+-rw-r--r--   0 root         (0) root         (0)    35689 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/Dists/Basic.h
+-rw-r--r--   0 root         (0) root         (0)    60524 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/Dists/Discrete.h
+-rw-r--r--   0 root         (0) root         (0)     5091 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/Dists/GammaPoisson.h
+-rw-r--r--   0 root         (0) root         (0)    63601 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/Dists/NormalExp.h
+-rw-r--r--   0 root         (0) root         (0)      405 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/EigenRand
+-rw-r--r--   0 root         (0) root         (0)      587 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/Macro.h
+-rw-r--r--   0 root         (0) root         (0)    17346 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/MorePacketMath.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.261605 chronogram-0.2.0/include/EigenRand/MvDists/
+-rw-r--r--   0 root         (0) root         (0)     6965 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/MvDists/Multinomial.h
+-rw-r--r--   0 root         (0) root         (0)    16342 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/MvDists/MvNormal.h
+-rw-r--r--   0 root         (0) root         (0)      627 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/PacketFilter.h
+-rw-r--r--   0 root         (0) root         (0)    15575 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/PacketRandomEngine.h
+-rw-r--r--   0 root         (0) root         (0)     9534 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/RandUtils.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.153605 chronogram-0.2.0/include/EigenRand/arch/
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.265605 chronogram-0.2.0/include/EigenRand/arch/AVX/
+-rw-r--r--   0 root         (0) root         (0)    18299 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/AVX/MorePacketMath.h
+-rw-r--r--   0 root         (0) root         (0)     3819 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/AVX/PacketFilter.h
+-rw-r--r--   0 root         (0) root         (0)     5280 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/AVX/RandUtils.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.265605 chronogram-0.2.0/include/EigenRand/arch/NEON/
+-rw-r--r--   0 root         (0) root         (0)    17807 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/NEON/MorePacketMath.h
+-rw-r--r--   0 root         (0) root         (0)     3028 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/NEON/PacketFilter.h
+-rw-r--r--   0 root         (0) root         (0)     3031 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/NEON/RandUtils.h
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.265605 chronogram-0.2.0/include/EigenRand/arch/SSE/
+-rw-r--r--   0 root         (0) root         (0)    13700 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/SSE/MorePacketMath.h
+-rw-r--r--   0 root         (0) root         (0)     2846 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/SSE/PacketFilter.h
+-rw-r--r--   0 root         (0) root         (0)     2561 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/arch/SSE/RandUtils.h
+-rw-r--r--   0 root         (0) root         (0)    15662 2023-06-06 06:02:31.000000 chronogram-0.2.0/include/EigenRand/doc.h
+-rw-r--r--   0 root         (0) root         (0)       38 2023-06-06 06:03:00.273605 chronogram-0.2.0/setup.cfg
+-rw-r--r--   0 root         (0) root         (0)     3233 2023-06-06 06:02:21.000000 chronogram-0.2.0/setup.py
+drwxr-xr-x   0 root         (0) root         (0)        0 2023-06-06 06:03:00.273605 chronogram-0.2.0/src/
+-rw-r--r--   0 root         (0) root         (0)    73462 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/ChronoGramModel.cpp
+-rw-r--r--   0 root         (0) root         (0)    14974 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/ChronoGramModel.h
+-rw-r--r--   0 root         (0) root         (0)     1960 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/DataReader.cpp
+-rw-r--r--   0 root         (0) root         (0)      767 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/DataReader.h
+-rw-r--r--   0 root         (0) root         (0)     1461 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/IOUtils.cpp
+-rw-r--r--   0 root         (0) root         (0)     5265 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/IOUtils.h
+-rw-r--r--   0 root         (0) root         (0)     1373 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/LUT.hpp
+-rw-r--r--   0 root         (0) root         (0)     1268 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/MMap.cpp
+-rw-r--r--   0 root         (0) root         (0)     1772 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/MMap.h
+-rw-r--r--   0 root         (0) root         (0)    16010 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/PyUtils.h
+-rw-r--r--   0 root         (0) root         (0)     2794 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/ThreadPool.h
+-rw-r--r--   0 root         (0) root         (0)      345 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/Timer.h
+-rw-r--r--   0 root         (0) root         (0)    38825 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/cxxopts.hpp
+-rw-r--r--   0 root         (0) root         (0)     1746 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/dictionary.h
+-rw-r--r--   0 root         (0) root         (0)     1597 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/gamma.h
+-rw-r--r--   0 root         (0) root         (0)    29508 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/main.cpp
+-rw-r--r--   0 root         (0) root         (0)     2845 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/mathUtils.h
+-rw-r--r--   0 root         (0) root         (0)     6052 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/polynomials.hpp
+-rw-r--r--   0 root         (0) root         (0)     2854 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/pyDocs.h
+-rw-r--r--   0 root         (0) root         (0)    41720 2023-06-06 06:02:21.000000 chronogram-0.2.0/src/pyModule.cpp
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `chronogram-0.1.7/README.rst` & `chronogram-0.2.0/README.rst`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-Chrono-gram
-===========
-
-.. image:: https://badge.fury.io/py/chronogram.svg
-    :target: https://pypi.python.org/pypi/chronogram
-
-Chrono-gram is a diachronic word embedding model based on
-SGNS(word2vec Skip-gram with Negative Sampling) with Chebyshev approximation.
-
-Getting Started
----------------
-
-1. Install using pip
-
-.. code::
-
-    $ pip install chronogram
-
-C++11 or later requires a compilable compiler for installation on Linux or macOS.
-
-
-2. Compile from sources
-
-Download this repository and run commands following:
-
-.. code::
-
-    $ python setup.py build
-
-Eigen 3.0 or later(http://eigen.tuxfamily.org/index.php?title=Main_Page) is needed to compile.
-
-Python API
-----------
-
-Here is a brief sample code. https://github.com/bab2min/chronogram/blob/master/example.py
-
-
-Demo
---------
-Text Dating & Finding similar words using Chrono-gram
-
-https://lab.bab2min.pe.kr/chronogram
+Chrono-gram
+===========
+
+.. image:: https://badge.fury.io/py/chronogram.svg
+    :target: https://pypi.python.org/pypi/chronogram
+
+Chrono-gram is a diachronic word embedding model based on
+SGNS(word2vec Skip-gram with Negative Sampling) with Chebyshev approximation.
+
+Getting Started
+---------------
+
+1. Install using pip
+
+.. code::
+
+    $ pip install chronogram
+
+C++11 or later requires a compilable compiler for installation on Linux or macOS.
+
+
+2. Compile from sources
+
+Download this repository and run commands following:
+
+.. code::
+
+    $ python setup.py build
+
+Eigen 3.0 or later(http://eigen.tuxfamily.org/index.php?title=Main_Page) is needed to compile.
+
+Python API
+----------
+
+Here is a brief sample code. https://github.com/bab2min/chronogram/blob/master/example.py
+
+
+Demo
+--------
+Text Dating & Finding similar words using Chrono-gram
+
+https://lab.bab2min.pe.kr/chronogram
```

### Comparing `chronogram-0.1.7/chronogram/__init__.py` & `chronogram-0.2.0/chronogram/__init__.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-"""Python package `chronogram` provides types and functions for Chrono-gram Word Embedding Model.
-It is written in C++ for speed and provides Python extension."""
-
-isa = ''
-"""
-Indicate which SIMD instruction set is used for acceleration.
-It can be one of `'avx2'`, `'avx'`, `'sse2'` and `'none'`.
-"""
-
-# This code is an autocomplete-hint for IDE.
-# The object imported here will be overwritten by _load() function.
-from _chronogram import *
-
-def _load():
-    import importlib, os
-    from cpuinfo import get_cpu_info
-    flags = get_cpu_info()['flags']
-    env_setting = os.environ.get('CHRONOGRAM_ISA', '').split(',')
-    if not env_setting[0]: env_setting = []
-    isas = ['avx2', 'avx', 'sse2', 'none']
-    isas = [isa for isa in isas if (env_setting and isa in env_setting) or (not env_setting and (isa in flags or isa == 'none'))]
-    if not isas: raise RuntimeError("No isa option for " + str(env_setting))
-    for isa in isas:
-        try:
-            mod_name = '_chronogram' + ('_' + isa if isa != 'none' else '')
-            globals().update({k:v for k, v in vars(importlib.import_module(mod_name)).items() if not k.startswith('_')})
-            return
-        except:
-            if isa == isas[-1]: raise
-_load()
-del _load
+"""Python package `chronogram` provides types and functions for Chrono-gram Word Embedding Model.
+It is written in C++ for speed and provides Python extension."""
+
+isa = ''
+"""
+Indicate which SIMD instruction set is used for acceleration.
+It can be one of `'avx2'`, `'avx'`, `'sse2'` and `'none'`.
+"""
+
+# This code is an autocomplete-hint for IDE.
+# The object imported here will be overwritten by _load() function.
+from _chronogram import *
+
+def _load():
+    import importlib, os
+    from cpuinfo import get_cpu_info
+    flags = get_cpu_info()['flags']
+    env_setting = os.environ.get('CHRONOGRAM_ISA', '').split(',')
+    if not env_setting[0]: env_setting = []
+    isas = ['avx2', 'avx', 'sse2', 'none']
+    isas = [isa for isa in isas if (env_setting and isa in env_setting) or (not env_setting and (isa in flags or isa == 'none'))]
+    if not isas: raise RuntimeError("No isa option for " + str(env_setting))
+    for isa in isas:
+        try:
+            mod_name = '_chronogram' + ('_' + isa if isa != 'none' else '')
+            globals().update({k:v for k, v in vars(importlib.import_module(mod_name)).items() if not k.startswith('_')})
+            return
+        except:
+            if isa == isas[-1]: raise
+_load()
+del _load
```

### Comparing `chronogram-0.1.7/chronogram.egg-info/SOURCES.txt` & `chronogram-0.2.0/chronogram.egg-info/SOURCES.txt`

 * *Files 12% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 setup.py
 chronogram/__init__.py
 chronogram.egg-info/PKG-INFO
 chronogram.egg-info/SOURCES.txt
 chronogram.egg-info/dependency_links.txt
 chronogram.egg-info/requires.txt
 chronogram.egg-info/top_level.txt
-include/Eigen/CMakeLists.txt
 include/Eigen/Cholesky
 include/Eigen/CholmodSupport
 include/Eigen/Core
 include/Eigen/Dense
 include/Eigen/Eigen
 include/Eigen/Eigenvalues
 include/Eigen/Geometry
 include/Eigen/Householder
 include/Eigen/IterativeLinearSolvers
 include/Eigen/Jacobi
+include/Eigen/KLUSupport
 include/Eigen/LU
 include/Eigen/MetisSupport
 include/Eigen/OrderingMethods
 include/Eigen/PaStiXSupport
 include/Eigen/PardisoSupport
 include/Eigen/QR
 include/Eigen/QtAlignedMalloc
@@ -37,14 +37,15 @@
 include/Eigen/StdVector
 include/Eigen/SuperLUSupport
 include/Eigen/UmfPackSupport
 include/Eigen/src/Cholesky/LDLT.h
 include/Eigen/src/Cholesky/LLT.h
 include/Eigen/src/Cholesky/LLT_LAPACKE.h
 include/Eigen/src/CholmodSupport/CholmodSupport.h
+include/Eigen/src/Core/ArithmeticSequence.h
 include/Eigen/src/Core/Array.h
 include/Eigen/src/Core/ArrayBase.h
 include/Eigen/src/Core/ArrayWrapper.h
 include/Eigen/src/Core/Assign.h
 include/Eigen/src/Core/AssignEvaluator.h
 include/Eigen/src/Core/Assign_MKL.h
 include/Eigen/src/Core/BandMatrix.h
@@ -69,73 +70,99 @@
 include/Eigen/src/Core/EigenBase.h
 include/Eigen/src/Core/ForceAlignedAccess.h
 include/Eigen/src/Core/Fuzzy.h
 include/Eigen/src/Core/GeneralProduct.h
 include/Eigen/src/Core/GenericPacketMath.h
 include/Eigen/src/Core/GlobalFunctions.h
 include/Eigen/src/Core/IO.h
+include/Eigen/src/Core/IndexedView.h
 include/Eigen/src/Core/Inverse.h
 include/Eigen/src/Core/Map.h
 include/Eigen/src/Core/MapBase.h
 include/Eigen/src/Core/MathFunctions.h
 include/Eigen/src/Core/MathFunctionsImpl.h
 include/Eigen/src/Core/Matrix.h
 include/Eigen/src/Core/MatrixBase.h
 include/Eigen/src/Core/NestByValue.h
 include/Eigen/src/Core/NoAlias.h
 include/Eigen/src/Core/NumTraits.h
+include/Eigen/src/Core/PartialReduxEvaluator.h
 include/Eigen/src/Core/PermutationMatrix.h
 include/Eigen/src/Core/PlainObjectBase.h
 include/Eigen/src/Core/Product.h
 include/Eigen/src/Core/ProductEvaluators.h
 include/Eigen/src/Core/Random.h
 include/Eigen/src/Core/Redux.h
 include/Eigen/src/Core/Ref.h
 include/Eigen/src/Core/Replicate.h
+include/Eigen/src/Core/Reshaped.h
 include/Eigen/src/Core/ReturnByValue.h
 include/Eigen/src/Core/Reverse.h
 include/Eigen/src/Core/Select.h
 include/Eigen/src/Core/SelfAdjointView.h
 include/Eigen/src/Core/SelfCwiseBinaryOp.h
 include/Eigen/src/Core/Solve.h
 include/Eigen/src/Core/SolveTriangular.h
 include/Eigen/src/Core/SolverBase.h
 include/Eigen/src/Core/StableNorm.h
+include/Eigen/src/Core/StlIterators.h
 include/Eigen/src/Core/Stride.h
 include/Eigen/src/Core/Swap.h
 include/Eigen/src/Core/Transpose.h
 include/Eigen/src/Core/Transpositions.h
 include/Eigen/src/Core/TriangularMatrix.h
 include/Eigen/src/Core/VectorBlock.h
 include/Eigen/src/Core/VectorwiseOp.h
 include/Eigen/src/Core/Visitor.h
 include/Eigen/src/Core/arch/AVX/Complex.h
 include/Eigen/src/Core/arch/AVX/MathFunctions.h
 include/Eigen/src/Core/arch/AVX/PacketMath.h
 include/Eigen/src/Core/arch/AVX/TypeCasting.h
+include/Eigen/src/Core/arch/AVX512/Complex.h
 include/Eigen/src/Core/arch/AVX512/MathFunctions.h
 include/Eigen/src/Core/arch/AVX512/PacketMath.h
+include/Eigen/src/Core/arch/AVX512/TypeCasting.h
 include/Eigen/src/Core/arch/AltiVec/Complex.h
 include/Eigen/src/Core/arch/AltiVec/MathFunctions.h
+include/Eigen/src/Core/arch/AltiVec/MatrixProduct.h
+include/Eigen/src/Core/arch/AltiVec/MatrixProductCommon.h
+include/Eigen/src/Core/arch/AltiVec/MatrixProductMMA.h
 include/Eigen/src/Core/arch/AltiVec/PacketMath.h
 include/Eigen/src/Core/arch/CUDA/Complex.h
-include/Eigen/src/Core/arch/CUDA/Half.h
-include/Eigen/src/Core/arch/CUDA/MathFunctions.h
-include/Eigen/src/Core/arch/CUDA/PacketMath.h
-include/Eigen/src/Core/arch/CUDA/PacketMathHalf.h
-include/Eigen/src/Core/arch/CUDA/TypeCasting.h
+include/Eigen/src/Core/arch/Default/BFloat16.h
 include/Eigen/src/Core/arch/Default/ConjHelper.h
+include/Eigen/src/Core/arch/Default/GenericPacketMathFunctions.h
+include/Eigen/src/Core/arch/Default/GenericPacketMathFunctionsFwd.h
+include/Eigen/src/Core/arch/Default/Half.h
 include/Eigen/src/Core/arch/Default/Settings.h
+include/Eigen/src/Core/arch/Default/TypeCasting.h
+include/Eigen/src/Core/arch/GPU/MathFunctions.h
+include/Eigen/src/Core/arch/GPU/PacketMath.h
+include/Eigen/src/Core/arch/GPU/TypeCasting.h
+include/Eigen/src/Core/arch/HIP/hcc/math_constants.h
+include/Eigen/src/Core/arch/MSA/Complex.h
+include/Eigen/src/Core/arch/MSA/MathFunctions.h
+include/Eigen/src/Core/arch/MSA/PacketMath.h
 include/Eigen/src/Core/arch/NEON/Complex.h
+include/Eigen/src/Core/arch/NEON/GeneralBlockPanelKernel.h
 include/Eigen/src/Core/arch/NEON/MathFunctions.h
 include/Eigen/src/Core/arch/NEON/PacketMath.h
+include/Eigen/src/Core/arch/NEON/TypeCasting.h
 include/Eigen/src/Core/arch/SSE/Complex.h
 include/Eigen/src/Core/arch/SSE/MathFunctions.h
 include/Eigen/src/Core/arch/SSE/PacketMath.h
 include/Eigen/src/Core/arch/SSE/TypeCasting.h
+include/Eigen/src/Core/arch/SVE/MathFunctions.h
+include/Eigen/src/Core/arch/SVE/PacketMath.h
+include/Eigen/src/Core/arch/SVE/TypeCasting.h
+include/Eigen/src/Core/arch/SYCL/InteropHeaders.h
+include/Eigen/src/Core/arch/SYCL/MathFunctions.h
+include/Eigen/src/Core/arch/SYCL/PacketMath.h
+include/Eigen/src/Core/arch/SYCL/SyclMemoryModel.h
+include/Eigen/src/Core/arch/SYCL/TypeCasting.h
 include/Eigen/src/Core/arch/ZVector/Complex.h
 include/Eigen/src/Core/arch/ZVector/MathFunctions.h
 include/Eigen/src/Core/arch/ZVector/PacketMath.h
 include/Eigen/src/Core/functors/AssignmentFunctors.h
 include/Eigen/src/Core/functors/BinaryFunctors.h
 include/Eigen/src/Core/functors/NullaryFunctors.h
 include/Eigen/src/Core/functors/StlFunctors.h
@@ -159,24 +186,29 @@
 include/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h
 include/Eigen/src/Core/products/TriangularMatrixVector.h
 include/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h
 include/Eigen/src/Core/products/TriangularSolverMatrix.h
 include/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h
 include/Eigen/src/Core/products/TriangularSolverVector.h
 include/Eigen/src/Core/util/BlasUtil.h
+include/Eigen/src/Core/util/ConfigureVectorization.h
 include/Eigen/src/Core/util/Constants.h
 include/Eigen/src/Core/util/DisableStupidWarnings.h
 include/Eigen/src/Core/util/ForwardDeclarations.h
+include/Eigen/src/Core/util/IndexedViewHelper.h
+include/Eigen/src/Core/util/IntegralConstant.h
 include/Eigen/src/Core/util/MKL_support.h
 include/Eigen/src/Core/util/Macros.h
 include/Eigen/src/Core/util/Memory.h
 include/Eigen/src/Core/util/Meta.h
 include/Eigen/src/Core/util/NonMPL2.h
 include/Eigen/src/Core/util/ReenableStupidWarnings.h
+include/Eigen/src/Core/util/ReshapedHelper.h
 include/Eigen/src/Core/util/StaticAssert.h
+include/Eigen/src/Core/util/SymbolicIndex.h
 include/Eigen/src/Core/util/XprHelper.h
 include/Eigen/src/Eigenvalues/ComplexEigenSolver.h
 include/Eigen/src/Eigenvalues/ComplexSchur.h
 include/Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h
 include/Eigen/src/Eigenvalues/EigenSolver.h
 include/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h
 include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h
@@ -198,33 +230,34 @@
 include/Eigen/src/Geometry/Quaternion.h
 include/Eigen/src/Geometry/Rotation2D.h
 include/Eigen/src/Geometry/RotationBase.h
 include/Eigen/src/Geometry/Scaling.h
 include/Eigen/src/Geometry/Transform.h
 include/Eigen/src/Geometry/Translation.h
 include/Eigen/src/Geometry/Umeyama.h
-include/Eigen/src/Geometry/arch/Geometry_SSE.h
+include/Eigen/src/Geometry/arch/Geometry_SIMD.h
 include/Eigen/src/Householder/BlockHouseholder.h
 include/Eigen/src/Householder/Householder.h
 include/Eigen/src/Householder/HouseholderSequence.h
 include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h
 include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h
 include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h
 include/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h
 include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h
 include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h
 include/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h
 include/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h
 include/Eigen/src/Jacobi/Jacobi.h
+include/Eigen/src/KLUSupport/KLUSupport.h
 include/Eigen/src/LU/Determinant.h
 include/Eigen/src/LU/FullPivLU.h
 include/Eigen/src/LU/InverseImpl.h
 include/Eigen/src/LU/PartialPivLU.h
 include/Eigen/src/LU/PartialPivLU_LAPACKE.h
-include/Eigen/src/LU/arch/Inverse_SSE.h
+include/Eigen/src/LU/arch/InverseSize4.h
 include/Eigen/src/MetisSupport/MetisSupport.h
 include/Eigen/src/OrderingMethods/Amd.h
 include/Eigen/src/OrderingMethods/Eigen_Colamd.h
 include/Eigen/src/OrderingMethods/Ordering.h
 include/Eigen/src/PaStiXSupport/PaStiXSupport.h
 include/Eigen/src/PardisoSupport/PardisoSupport.h
 include/Eigen/src/QR/ColPivHouseholderQR.h
@@ -303,16 +336,42 @@
 include/Eigen/src/misc/lapacke.h
 include/Eigen/src/misc/lapacke_mangling.h
 include/Eigen/src/plugins/ArrayCwiseBinaryOps.h
 include/Eigen/src/plugins/ArrayCwiseUnaryOps.h
 include/Eigen/src/plugins/BlockMethods.h
 include/Eigen/src/plugins/CommonCwiseBinaryOps.h
 include/Eigen/src/plugins/CommonCwiseUnaryOps.h
+include/Eigen/src/plugins/IndexedViewMethods.h
 include/Eigen/src/plugins/MatrixCwiseBinaryOps.h
 include/Eigen/src/plugins/MatrixCwiseUnaryOps.h
+include/Eigen/src/plugins/ReshapedMethods.h
+include/EigenRand/Core.h
+include/EigenRand/CwiseHeteroBinaryOp.h
+include/EigenRand/EigenRand
+include/EigenRand/Macro.h
+include/EigenRand/MorePacketMath.h
+include/EigenRand/PacketFilter.h
+include/EigenRand/PacketRandomEngine.h
+include/EigenRand/RandUtils.h
+include/EigenRand/doc.h
+include/EigenRand/Dists/Basic.h
+include/EigenRand/Dists/Discrete.h
+include/EigenRand/Dists/GammaPoisson.h
+include/EigenRand/Dists/NormalExp.h
+include/EigenRand/MvDists/Multinomial.h
+include/EigenRand/MvDists/MvNormal.h
+include/EigenRand/arch/AVX/MorePacketMath.h
+include/EigenRand/arch/AVX/PacketFilter.h
+include/EigenRand/arch/AVX/RandUtils.h
+include/EigenRand/arch/NEON/MorePacketMath.h
+include/EigenRand/arch/NEON/PacketFilter.h
+include/EigenRand/arch/NEON/RandUtils.h
+include/EigenRand/arch/SSE/MorePacketMath.h
+include/EigenRand/arch/SSE/PacketFilter.h
+include/EigenRand/arch/SSE/RandUtils.h
 src/ChronoGramModel.cpp
 src/ChronoGramModel.h
 src/DataReader.cpp
 src/DataReader.h
 src/IOUtils.cpp
 src/IOUtils.h
 src/LUT.hpp
```

### Comparing `chronogram-0.1.7/include/Eigen/Cholesky` & `chronogram-0.2.0/include/Eigen/Cholesky`

 * *Files 20% similar despite different names*

```diff
@@ -39,8 +39,7 @@
 #endif
 #include "src/Cholesky/LLT_LAPACKE.h"
 #endif
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_CHOLESKY_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
```

### Comparing `chronogram-0.1.7/include/Eigen/CholmodSupport` & `chronogram-0.2.0/include/Eigen/CholmodSupport`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/Eigenvalues` & `chronogram-0.2.0/include/Eigen/Eigenvalues`

 * *Files 2% similar despite different names*

```diff
@@ -6,22 +6,22 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_EIGENVALUES_MODULE_H
 #define EIGEN_EIGENVALUES_MODULE_H
 
 #include "Core"
 
-#include "src/Core/util/DisableStupidWarnings.h"
-
 #include "Cholesky"
 #include "Jacobi"
 #include "Householder"
 #include "LU"
 #include "Geometry"
 
+#include "src/Core/util/DisableStupidWarnings.h"
+
 /** \defgroup Eigenvalues_Module Eigenvalues module
   *
   *
   *
   * This module mainly provides various eigenvalue solvers.
   * This module also provides some MatrixBase methods, including:
   *  - MatrixBase::eigenvalues(),
@@ -54,8 +54,7 @@
 #include "src/Eigenvalues/ComplexSchur_LAPACKE.h"
 #include "src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h"
 #endif
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_EIGENVALUES_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
```

### Comparing `chronogram-0.1.7/include/Eigen/Geometry` & `chronogram-0.2.0/include/Eigen/Geometry`

 * *Files 9% similar despite different names*

```diff
@@ -6,20 +6,20 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_GEOMETRY_MODULE_H
 #define EIGEN_GEOMETRY_MODULE_H
 
 #include "Core"
 
-#include "src/Core/util/DisableStupidWarnings.h"
-
 #include "SVD"
 #include "LU"
 #include <limits>
 
+#include "src/Core/util/DisableStupidWarnings.h"
+
 /** \defgroup Geometry_Module Geometry module
   *
   * This module provides support for:
   *  - fixed-size homogeneous transformations
   *  - translation, scaling, 2D and 3D rotations
   *  - \link Quaternion quaternions \endlink
   *  - cross products (\ref MatrixBase::cross, \ref MatrixBase::cross3)
@@ -45,18 +45,15 @@
 #include "src/Geometry/Translation.h"
 #include "src/Geometry/Scaling.h"
 #include "src/Geometry/Hyperplane.h"
 #include "src/Geometry/ParametrizedLine.h"
 #include "src/Geometry/AlignedBox.h"
 #include "src/Geometry/Umeyama.h"
 
-// Use the SSE optimized version whenever possible. At the moment the
-// SSE version doesn't compile when AVX is enabled
-#if defined EIGEN_VECTORIZE_SSE && !defined EIGEN_VECTORIZE_AVX
-#include "src/Geometry/arch/Geometry_SSE.h"
+// Use the SSE optimized version whenever possible.
+#if (defined EIGEN_VECTORIZE_SSE) || (defined EIGEN_VECTORIZE_NEON)
+#include "src/Geometry/arch/Geometry_SIMD.h"
 #endif
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_GEOMETRY_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
-
```

### Comparing `chronogram-0.1.7/include/Eigen/Householder` & `chronogram-0.2.0/include/Eigen/Householder`

 * *Files 13% similar despite different names*

```diff
@@ -23,8 +23,7 @@
 #include "src/Householder/Householder.h"
 #include "src/Householder/HouseholderSequence.h"
 #include "src/Householder/BlockHouseholder.h"
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_HOUSEHOLDER_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
```

### Comparing `chronogram-0.1.7/include/Eigen/IterativeLinearSolvers` & `chronogram-0.2.0/include/Eigen/IterativeLinearSolvers`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/Jacobi` & `chronogram-0.2.0/include/Eigen/Jacobi`

 * *Files 5% similar despite different names*

```diff
@@ -25,9 +25,8 @@
   */
 
 #include "src/Jacobi/Jacobi.h"
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_JACOBI_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
```

### Comparing `chronogram-0.1.7/include/Eigen/LU` & `chronogram-0.2.0/include/Eigen/LU`

 * *Files 11% similar despite different names*

```diff
@@ -34,17 +34,14 @@
 #include "src/misc/lapacke.h"
 #endif
 #include "src/LU/PartialPivLU_LAPACKE.h"
 #endif
 #include "src/LU/Determinant.h"
 #include "src/LU/InverseImpl.h"
 
-// Use the SSE optimized version whenever possible. At the moment the
-// SSE version doesn't compile when AVX is enabled
-#if defined EIGEN_VECTORIZE_SSE && !defined EIGEN_VECTORIZE_AVX
-  #include "src/LU/arch/Inverse_SSE.h"
+#if defined EIGEN_VECTORIZE_SSE || defined EIGEN_VECTORIZE_NEON
+  #include "src/LU/arch/InverseSize4.h"
 #endif
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_LU_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
```

### Comparing `chronogram-0.1.7/include/Eigen/MetisSupport` & `chronogram-0.2.0/include/Eigen/MetisSupport`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/OrderingMethods` & `chronogram-0.2.0/include/Eigen/OrderingMethods`

 * *Files 3% similar despite different names*

```diff
@@ -59,15 +59,12 @@
   * 
   * \code
   *  // Call the ordering on the pattern of the lower triangular matrix A
   * ordering(A.selfadjointView<Lower>(), perm);
   * \endcode
   */
 
-#ifndef EIGEN_MPL2_ONLY
 #include "src/OrderingMethods/Amd.h"
-#endif
-
 #include "src/OrderingMethods/Ordering.h"
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_ORDERINGMETHODS_MODULE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/PaStiXSupport` & `chronogram-0.2.0/include/Eigen/PaStiXSupport`

 * *Files 8% similar despite different names*

```diff
@@ -32,14 +32,15 @@
   * - class PastixLU : a supernodal, parallel LU factorization (optimized for a symmetric pattern).
   * 
   * \code
   * #include <Eigen/PaStiXSupport>
   * \endcode
   *
   * In order to use this module, the PaSTiX headers must be accessible from the include paths, and your binary must be linked to the PaSTiX library and its dependencies.
+  * This wrapper resuires PaStiX version 5.x compiled without MPI support.
   * The dependencies depend on how PaSTiX has been compiled.
   * For a cmake based project, you can use our FindPaSTiX.cmake module to help you in this task.
   *
   */
 
 #include "src/PaStiXSupport/PaStiXSupport.h"
```

#### html2text {}

```diff
@@ -12,12 +12,13 @@
 parallel and \b opensource sparse solver. * It provides the two following main
 factorization classes: * - class PastixLLT : a supernodal, parallel LLt
 Cholesky factorization. * - class PastixLDLT: a supernodal, parallel LDLt
 Cholesky factorization. * - class PastixLU : a supernodal, parallel LU
 factorization (optimized for a symmetric pattern). * * \code * #include
 aStiXSupport> * \endcode * * In order to use this module, the PaSTiX headers
 must be accessible from the include paths, and your binary must be linked to
-the PaSTiX library and its dependencies. * The dependencies depend on how
-PaSTiX has been compiled. * For a cmake based project, you can use our
-FindPaSTiX.cmake module to help you in this task. * */ #include "src/
-PaStiXSupport/PaStiXSupport.h" #include "src/Core/util/
-ReenableStupidWarnings.h" #endif // EIGEN_PASTIXSUPPORT_MODULE_H
+the PaSTiX library and its dependencies. * This wrapper resuires PaStiX version
+5.x compiled without MPI support. * The dependencies depend on how PaSTiX has
+been compiled. * For a cmake based project, you can use our FindPaSTiX.cmake
+module to help you in this task. * */ #include "src/PaStiXSupport/
+PaStiXSupport.h" #include "src/Core/util/ReenableStupidWarnings.h" #endif /
+/ EIGEN_PASTIXSUPPORT_MODULE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/PardisoSupport` & `chronogram-0.2.0/include/Eigen/PardisoSupport`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/QR` & `chronogram-0.2.0/include/Eigen/QR`

 * *Files 10% similar despite different names*

```diff
@@ -6,20 +6,20 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_QR_MODULE_H
 #define EIGEN_QR_MODULE_H
 
 #include "Core"
 
-#include "src/Core/util/DisableStupidWarnings.h"
-
 #include "Cholesky"
 #include "Jacobi"
 #include "Householder"
 
+#include "src/Core/util/DisableStupidWarnings.h"
+
 /** \defgroup QR_Module QR module
   *
   *
   *
   * This module provides various QR decompositions
   * This module also provides some MatrixBase methods, including:
   *  - MatrixBase::householderQr()
@@ -44,8 +44,7 @@
 #include "src/QR/HouseholderQR_LAPACKE.h"
 #include "src/QR/ColPivHouseholderQR_LAPACKE.h"
 #endif
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_QR_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
```

### Comparing `chronogram-0.1.7/include/Eigen/QtAlignedMalloc` & `chronogram-0.2.0/include/Eigen/QtAlignedMalloc`

 * *Files 5% similar despite different names*

```diff
@@ -33,8 +33,7 @@
 }
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif
 
 #endif // EIGEN_QTMALLOC_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
```

### Comparing `chronogram-0.1.7/include/Eigen/SPQRSupport` & `chronogram-0.2.0/include/Eigen/SPQRSupport`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/SVD` & `chronogram-0.2.0/include/Eigen/SVD`

 * *Files 2% similar despite different names*

```diff
@@ -44,8 +44,7 @@
 #endif
 #include "src/SVD/JacobiSVD_LAPACKE.h"
 #endif
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_SVD_MODULE_H
-/* vim: set filetype=cpp et sw=2 ts=2 ai: */
```

### Comparing `chronogram-0.1.7/include/Eigen/Sparse` & `chronogram-0.2.0/include/Eigen/Sparse`

 * *Files 7% similar despite different names*

```diff
@@ -21,16 +21,14 @@
     \code
     #include <Eigen/Sparse>
     \endcode
   */
 
 #include "SparseCore"
 #include "OrderingMethods"
-#ifndef EIGEN_MPL2_ONLY
 #include "SparseCholesky"
-#endif
 #include "SparseLU"
 #include "SparseQR"
 #include "IterativeLinearSolvers"
 
 #endif // EIGEN_SPARSE_MODULE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/SparseCholesky` & `chronogram-0.2.0/include/Eigen/SparseCholesky`

 * *Files 7% similar despite different names*

```diff
@@ -26,20 +26,12 @@
   * Such problems can also be solved using the ConjugateGradient solver from the IterativeLinearSolvers module.
   *
   * \code
   * #include <Eigen/SparseCholesky>
   * \endcode
   */
 
-#ifdef EIGEN_MPL2_ONLY
-#error The SparseCholesky module has nothing to offer in MPL2 only mode
-#endif
-
 #include "src/SparseCholesky/SimplicialCholesky.h"
-
-#ifndef EIGEN_MPL2_ONLY
 #include "src/SparseCholesky/SimplicialCholesky_impl.h"
-#endif
-
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif // EIGEN_SPARSECHOLESKY_MODULE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/SparseCore` & `chronogram-0.2.0/include/Eigen/SparseCore`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/SparseLU` & `chronogram-0.2.0/include/Eigen/SparseLU`

 * *Files 7% similar despite different names*

```diff
@@ -19,14 +19,16 @@
   * The code is fully optimized for supernode-panel updates with specialized kernels.
   * Please, see the documentation of the SparseLU class for more details.
   */
 
 // Ordering interface
 #include "OrderingMethods"
 
+#include "src/Core/util/DisableStupidWarnings.h"
+
 #include "src/SparseLU/SparseLU_gemm_kernel.h"
 
 #include "src/SparseLU/SparseLU_Structs.h"
 #include "src/SparseLU/SparseLU_SupernodalMatrix.h"
 #include "src/SparseLU/SparseLUImpl.h"
 #include "src/SparseCore/SparseColEtree.h"
 #include "src/SparseLU/SparseLU_Memory.h"
@@ -39,8 +41,10 @@
 #include "src/SparseLU/SparseLU_column_dfs.h"
 #include "src/SparseLU/SparseLU_column_bmod.h"
 #include "src/SparseLU/SparseLU_copy_to_ucol.h"
 #include "src/SparseLU/SparseLU_pruneL.h"
 #include "src/SparseLU/SparseLU_Utils.h"
 #include "src/SparseLU/SparseLU.h"
 
+#include "src/Core/util/ReenableStupidWarnings.h"
+
 #endif // EIGEN_SPARSELU_MODULE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/SparseQR` & `chronogram-0.2.0/include/Eigen/SparseQR`

 * *Files 3% similar despite different names*

```diff
@@ -24,14 +24,13 @@
   * \code
   * #include <Eigen/SparseQR>
   * \endcode
   * 
   * 
   */
 
-#include "OrderingMethods"
 #include "src/SparseCore/SparseColEtree.h"
 #include "src/SparseQR/SparseQR.h"
 
 #include "src/Core/util/ReenableStupidWarnings.h"
 
 #endif
```

### Comparing `chronogram-0.1.7/include/Eigen/StdDeque` & `chronogram-0.2.0/include/Eigen/StdDeque`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/StdList` & `chronogram-0.2.0/include/Eigen/StdList`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/StdVector` & `chronogram-0.2.0/include/Eigen/StdVector`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/SuperLUSupport` & `chronogram-0.2.0/include/Eigen/SuperLUSupport`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/UmfPackSupport` & `chronogram-0.2.0/include/Eigen/UmfPackSupport`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Cholesky/LDLT.h` & `chronogram-0.2.0/include/Eigen/src/Cholesky/LDLT.h`

 * *Files 6% similar despite different names*

```diff
@@ -12,14 +12,23 @@
 
 #ifndef EIGEN_LDLT_H
 #define EIGEN_LDLT_H
 
 namespace Eigen {
 
 namespace internal {
+  template<typename _MatrixType, int _UpLo> struct traits<LDLT<_MatrixType, _UpLo> >
+   : traits<_MatrixType>
+  {
+    typedef MatrixXpr XprKind;
+    typedef SolverStorage StorageKind;
+    typedef int StorageIndex;
+    enum { Flags = 0 };
+  };
+
   template<typename MatrixType, int UpLo> struct LDLT_Traits;
 
   // PositiveSemiDef means positive semi-definite and non-zero; same for NegativeSemiDef
   enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };
 }
 
 /** \ingroup Cholesky_Module
@@ -32,40 +41,39 @@
   * \tparam _UpLo the triangular part that will be used for the decompositon: Lower (default) or Upper.
   *             The other triangular part won't be read.
   *
   * Perform a robust Cholesky decomposition of a positive semidefinite or negative semidefinite
   * matrix \f$ A \f$ such that \f$ A =  P^TLDL^*P \f$, where P is a permutation matrix, L
   * is lower triangular with a unit diagonal and D is a diagonal matrix.
   *
-  * The decomposition uses pivoting to ensure stability, so that L will have
+  * The decomposition uses pivoting to ensure stability, so that D will have
   * zeros in the bottom right rank(A) - n submatrix. Avoiding the square root
   * on D also stabilizes the computation.
   *
   * Remember that Cholesky decompositions are not rank-revealing. Also, do not use a Cholesky
   * decomposition to determine whether a system of equations has a solution.
   *
   * This class supports the \link InplaceDecomposition inplace decomposition \endlink mechanism.
-  * 
+  *
   * \sa MatrixBase::ldlt(), SelfAdjointView::ldlt(), class LLT
   */
 template<typename _MatrixType, int _UpLo> class LDLT
+        : public SolverBase<LDLT<_MatrixType, _UpLo> >
 {
   public:
     typedef _MatrixType MatrixType;
+    typedef SolverBase<LDLT> Base;
+    friend class SolverBase<LDLT>;
+
+    EIGEN_GENERIC_PUBLIC_INTERFACE(LDLT)
     enum {
-      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
-      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
       UpLo = _UpLo
     };
-    typedef typename MatrixType::Scalar Scalar;
-    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;
-    typedef Eigen::Index Index; ///< \deprecated since Eigen 3.3
-    typedef typename MatrixType::StorageIndex StorageIndex;
     typedef Matrix<Scalar, RowsAtCompileTime, 1, 0, MaxRowsAtCompileTime, 1> TmpMatrixType;
 
     typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;
     typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;
 
     typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;
 
@@ -176,38 +184,34 @@
     /** \returns true if the matrix is negative (semidefinite) */
     inline bool isNegative(void) const
     {
       eigen_assert(m_isInitialized && "LDLT is not initialized.");
       return m_sign == internal::NegativeSemiDef || m_sign == internal::ZeroSign;
     }
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
     /** \returns a solution x of \f$ A x = b \f$ using the current decomposition of A.
       *
       * This function also supports in-place solves using the syntax <tt>x = decompositionObject.solve(x)</tt> .
       *
       * \note_about_checking_solutions
       *
       * More precisely, this method solves \f$ A x = b \f$ using the decomposition \f$ A = P^T L D L^* P \f$
       * by solving the systems \f$ P^T y_1 = b \f$, \f$ L y_2 = y_1 \f$, \f$ D y_3 = y_2 \f$,
       * \f$ L^* y_4 = y_3 \f$ and \f$ P x = y_4 \f$ in succession. If the matrix \f$ A \f$ is singular, then
       * \f$ D \f$ will also be singular (all the other matrices are invertible). In that case, the
       * least-square solution of \f$ D y_3 = y_2 \f$ is computed. This does not mean that this function
-      * computes the least-square solution of \f$ A x = b \f$ is \f$ A \f$ is singular.
+      * computes the least-square solution of \f$ A x = b \f$ if \f$ A \f$ is singular.
       *
       * \sa MatrixBase::ldlt(), SelfAdjointView::ldlt()
       */
     template<typename Rhs>
     inline const Solve<LDLT, Rhs>
-    solve(const MatrixBase<Rhs>& b) const
-    {
-      eigen_assert(m_isInitialized && "LDLT is not initialized.");
-      eigen_assert(m_matrix.rows()==b.rows()
-                && "LDLT::solve(): invalid number of rows of the right hand side matrix b");
-      return Solve<LDLT, Rhs>(*this, b.derived());
-    }
+    solve(const MatrixBase<Rhs>& b) const;
+    #endif
 
     template<typename Derived>
     bool solveInPlace(MatrixBase<Derived> &bAndX) const;
 
     template<typename InputType>
     LDLT& compute(const EigenBase<InputType>& matrix);
 
@@ -238,32 +242,34 @@
     /** \returns the adjoint of \c *this, that is, a const reference to the decomposition itself as the underlying matrix is self-adjoint.
       *
       * This method is provided for compatibility with other matrix decompositions, thus enabling generic code such as:
       * \code x = decomposition.adjoint().solve(b) \endcode
       */
     const LDLT& adjoint() const { return *this; };
 
-    inline Index rows() const { return m_matrix.rows(); }
-    inline Index cols() const { return m_matrix.cols(); }
+    EIGEN_DEVICE_FUNC inline EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }
+    EIGEN_DEVICE_FUNC inline EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
 
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the factorization failed because of a zero pivot.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "LDLT is not initialized.");
       return m_info;
     }
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename RhsType, typename DstType>
-    EIGEN_DEVICE_FUNC
     void _solve_impl(const RhsType &rhs, DstType &dst) const;
+
+    template<bool Conjugate, typename RhsType, typename DstType>
+    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;
     #endif
 
   protected:
 
     static void check_template_parameters()
     {
       EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar);
@@ -556,46 +562,55 @@
 }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template<typename _MatrixType, int _UpLo>
 template<typename RhsType, typename DstType>
 void LDLT<_MatrixType,_UpLo>::_solve_impl(const RhsType &rhs, DstType &dst) const
 {
-  eigen_assert(rhs.rows() == rows());
+  _solve_impl_transposed<true>(rhs, dst);
+}
+
+template<typename _MatrixType,int _UpLo>
+template<bool Conjugate, typename RhsType, typename DstType>
+void LDLT<_MatrixType,_UpLo>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const
+{
   // dst = P b
   dst = m_transpositions * rhs;
 
   // dst = L^-1 (P b)
-  matrixL().solveInPlace(dst);
+  // dst = L^-*T (P b)
+  matrixL().template conjugateIf<!Conjugate>().solveInPlace(dst);
 
-  // dst = D^-1 (L^-1 P b)
+  // dst = D^-* (L^-1 P b)
+  // dst = D^-1 (L^-*T P b)
   // more precisely, use pseudo-inverse of D (see bug 241)
   using std::abs;
   const typename Diagonal<const MatrixType>::RealReturnType vecD(vectorD());
   // In some previous versions, tolerance was set to the max of 1/highest (or rather numeric_limits::min())
   // and the maximal diagonal entry * epsilon as motivated by LAPACK's xGELSS:
   // RealScalar tolerance = numext::maxi(vecD.array().abs().maxCoeff() * NumTraits<RealScalar>::epsilon(),RealScalar(1) / NumTraits<RealScalar>::highest());
   // However, LDLT is not rank revealing, and so adjusting the tolerance wrt to the highest
   // diagonal element is not well justified and leads to numerical issues in some cases.
   // Moreover, Lapack's xSYTRS routines use 0 for the tolerance.
   // Using numeric_limits::min() gives us more robustness to denormals.
   RealScalar tolerance = (std::numeric_limits<RealScalar>::min)();
-
   for (Index i = 0; i < vecD.size(); ++i)
   {
     if(abs(vecD(i)) > tolerance)
       dst.row(i) /= vecD(i);
     else
       dst.row(i).setZero();
   }
 
-  // dst = L^-T (D^-1 L^-1 P b)
-  matrixU().solveInPlace(dst);
+  // dst = L^-* (D^-* L^-1 P b)
+  // dst = L^-T (D^-1 L^-*T P b)
+  matrixL().transpose().template conjugateIf<Conjugate>().solveInPlace(dst);
 
-  // dst = P^-1 (L^-T D^-1 L^-1 P b) = A^-1 b
+  // dst = P^T (L^-* D^-* L^-1 P b) = A^-1 b
+  // dst = P^-T (L^-T D^-1 L^-*T P b) = A^-1 b
   dst = m_transpositions.transpose() * dst;
 }
 #endif
 
 /** \internal use x = ldlt_object.solve(x);
   *
   * This is the \em in-place version of solve().
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Cholesky/LLT.h` & `chronogram-0.2.0/include/Eigen/src/Cholesky/LLT.h`

 * *Files 2% similar despite different names*

```diff
@@ -9,14 +9,24 @@
 
 #ifndef EIGEN_LLT_H
 #define EIGEN_LLT_H
 
 namespace Eigen {
 
 namespace internal{
+
+template<typename _MatrixType, int _UpLo> struct traits<LLT<_MatrixType, _UpLo> >
+ : traits<_MatrixType>
+{
+  typedef MatrixXpr XprKind;
+  typedef SolverStorage StorageKind;
+  typedef int StorageIndex;
+  enum { Flags = 0 };
+};
+
 template<typename MatrixType, int UpLo> struct LLT_Traits;
 }
 
 /** \ingroup Cholesky_Module
   *
   * \class LLT
   *
@@ -50,26 +60,25 @@
   *
   * Note that during the decomposition, only the lower (or upper, as defined by _UpLo) triangular part of A is considered.
   * Therefore, the strict lower part does not have to store correct values.
   *
   * \sa MatrixBase::llt(), SelfAdjointView::llt(), class LDLT
   */
 template<typename _MatrixType, int _UpLo> class LLT
+        : public SolverBase<LLT<_MatrixType, _UpLo> >
 {
   public:
     typedef _MatrixType MatrixType;
+    typedef SolverBase<LLT> Base;
+    friend class SolverBase<LLT>;
+
+    EIGEN_GENERIC_PUBLIC_INTERFACE(LLT)
     enum {
-      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
-      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
     };
-    typedef typename MatrixType::Scalar Scalar;
-    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;
-    typedef Eigen::Index Index; ///< \deprecated since Eigen 3.3
-    typedef typename MatrixType::StorageIndex StorageIndex;
 
     enum {
       PacketSize = internal::packet_traits<Scalar>::size,
       AlignmentMask = int(PacketSize)-1,
       UpLo = _UpLo
     };
 
@@ -96,15 +105,15 @@
     explicit LLT(const EigenBase<InputType>& matrix)
       : m_matrix(matrix.rows(), matrix.cols()),
         m_isInitialized(false)
     {
       compute(matrix.derived());
     }
 
-    /** \brief Constructs a LDLT factorization from a given matrix
+    /** \brief Constructs a LLT factorization from a given matrix
       *
       * This overloaded constructor is provided for \link InplaceDecomposition inplace decomposition \endlink when
       * \c MatrixType is a Eigen::Ref.
       *
       * \sa LLT(const EigenBase&)
       */
     template<typename InputType>
@@ -125,33 +134,29 @@
     /** \returns a view of the lower triangular matrix L */
     inline typename Traits::MatrixL matrixL() const
     {
       eigen_assert(m_isInitialized && "LLT is not initialized.");
       return Traits::getL(m_matrix);
     }
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
     /** \returns the solution x of \f$ A x = b \f$ using the current decomposition of A.
       *
       * Since this LLT class assumes anyway that the matrix A is invertible, the solution
       * theoretically exists and is unique regardless of b.
       *
       * Example: \include LLT_solve.cpp
       * Output: \verbinclude LLT_solve.out
       *
       * \sa solveInPlace(), MatrixBase::llt(), SelfAdjointView::llt()
       */
     template<typename Rhs>
     inline const Solve<LLT, Rhs>
-    solve(const MatrixBase<Rhs>& b) const
-    {
-      eigen_assert(m_isInitialized && "LLT is not initialized.");
-      eigen_assert(m_matrix.rows()==b.rows()
-                && "LLT::solve(): invalid number of rows of the right hand side matrix b");
-      return Solve<LLT, Rhs>(*this, b.derived());
-    }
+    solve(const MatrixBase<Rhs>& b) const;
+    #endif
 
     template<typename Derived>
     void solveInPlace(const MatrixBase<Derived> &bAndX) const;
 
     template<typename InputType>
     LLT& compute(const EigenBase<InputType>& matrix);
 
@@ -176,40 +181,42 @@
     }
 
     MatrixType reconstructedMatrix() const;
 
 
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the matrix.appears not to be positive definite.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "LLT is not initialized.");
       return m_info;
     }
 
     /** \returns the adjoint of \c *this, that is, a const reference to the decomposition itself as the underlying matrix is self-adjoint.
       *
       * This method is provided for compatibility with other matrix decompositions, thus enabling generic code such as:
       * \code x = decomposition.adjoint().solve(b) \endcode
       */
-    const LLT& adjoint() const { return *this; };
+    const LLT& adjoint() const EIGEN_NOEXCEPT { return *this; };
 
-    inline Index rows() const { return m_matrix.rows(); }
-    inline Index cols() const { return m_matrix.cols(); }
+    inline EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }
+    inline EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
 
     template<typename VectorType>
-    LLT rankUpdate(const VectorType& vec, const RealScalar& sigma = 1);
+    LLT & rankUpdate(const VectorType& vec, const RealScalar& sigma = 1);
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename RhsType, typename DstType>
-    EIGEN_DEVICE_FUNC
     void _solve_impl(const RhsType &rhs, DstType &dst) const;
+
+    template<bool Conjugate, typename RhsType, typename DstType>
+    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;
     #endif
 
   protected:
 
     static void check_template_parameters()
     {
       EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar);
@@ -455,15 +462,15 @@
 /** Performs a rank one update (or dowdate) of the current decomposition.
   * If A = LL^* before the rank one update,
   * then after it we have LL^* = A + sigma * v v^* where \a v must be a vector
   * of same dimension.
   */
 template<typename _MatrixType, int _UpLo>
 template<typename VectorType>
-LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)
+LLT<_MatrixType,_UpLo> & LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)
 {
   EIGEN_STATIC_ASSERT_VECTOR_ONLY(VectorType);
   eigen_assert(v.size()==m_matrix.cols());
   eigen_assert(m_isInitialized);
   if(internal::llt_inplace<typename MatrixType::Scalar, UpLo>::rankUpdate(m_matrix,v,sigma)>=0)
     m_info = NumericalIssue;
   else
@@ -473,16 +480,25 @@
 }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template<typename _MatrixType,int _UpLo>
 template<typename RhsType, typename DstType>
 void LLT<_MatrixType,_UpLo>::_solve_impl(const RhsType &rhs, DstType &dst) const
 {
-  dst = rhs;
-  solveInPlace(dst);
+  _solve_impl_transposed<true>(rhs, dst);
+}
+
+template<typename _MatrixType,int _UpLo>
+template<bool Conjugate, typename RhsType, typename DstType>
+void LLT<_MatrixType,_UpLo>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const
+{
+    dst = rhs;
+
+    matrixL().template conjugateIf<!Conjugate>().solveInPlace(dst);
+    matrixU().template conjugateIf<!Conjugate>().solveInPlace(dst);
 }
 #endif
 
 /** \internal use x = llt_object.solve(x);
   *
   * This is the \em in-place version of solve().
   *
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Cholesky/LLT_LAPACKE.h` & `chronogram-0.2.0/include/Eigen/src/Cholesky/LLT_LAPACKE.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/CholmodSupport/CholmodSupport.h` & `chronogram-0.2.0/include/Eigen/src/CholmodSupport/CholmodSupport.h`

 * *Files 6% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_CHOLMODSUPPORT_H
 #define EIGEN_CHOLMODSUPPORT_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 
 template<typename Scalar> struct cholmod_configure_matrix;
 
 template<> struct cholmod_configure_matrix<double> {
   template<typename CholmodType>
@@ -28,15 +28,15 @@
   template<typename CholmodType>
   static void run(CholmodType& mat) {
     mat.xtype = CHOLMOD_COMPLEX;
     mat.dtype = CHOLMOD_DOUBLE;
   }
 };
 
-// Other scalar types are not yet suppotred by Cholmod
+// Other scalar types are not yet supported by Cholmod
 // template<> struct cholmod_configure_matrix<float> {
 //   template<typename CholmodType>
 //   static void run(CholmodType& mat) {
 //     mat.xtype = CHOLMOD_REAL;
 //     mat.dtype = CHOLMOD_SINGLE;
 //   }
 // };
@@ -75,33 +75,33 @@
   {
     res.packed  = 0;
     res.nz = mat.innerNonZeroPtr();
   }
 
   res.dtype   = 0;
   res.stype   = -1;
-  
+
   if (internal::is_same<_StorageIndex,int>::value)
   {
     res.itype = CHOLMOD_INT;
   }
-  else if (internal::is_same<_StorageIndex,long>::value)
+  else if (internal::is_same<_StorageIndex,SuiteSparse_long>::value)
   {
     res.itype = CHOLMOD_LONG;
   }
   else
   {
     eigen_assert(false && "Index type not supported yet");
   }
 
   // setup res.xtype
   internal::cholmod_configure_matrix<_Scalar>::run(res);
-  
+
   res.stype = 0;
-  
+
   return res;
 }
 
 template<typename _Scalar, int _Options, typename _Index>
 const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)
 {
   cholmod_sparse res = viewAsCholmod(Ref<SparseMatrix<_Scalar,_Options,_Index> >(mat.const_cast_derived()));
@@ -117,17 +117,20 @@
 
 /** Returns a view of the Eigen sparse matrix \a mat as Cholmod sparse matrix.
   * The data are not copied but shared. */
 template<typename _Scalar, int _Options, typename _Index, unsigned int UpLo>
 cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<const SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)
 {
   cholmod_sparse res = viewAsCholmod(Ref<SparseMatrix<_Scalar,_Options,_Index> >(mat.matrix().const_cast_derived()));
-  
+
   if(UpLo==Upper) res.stype =  1;
   if(UpLo==Lower) res.stype = -1;
+  // swap stype for rowmajor matrices (only works for real matrices)
+  EIGEN_STATIC_ASSERT((_Options & RowMajorBit) == 0 || NumTraits<_Scalar>::IsComplex == 0, THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES);
+  if(_Options & RowMajorBit) res.stype *=-1;
 
   return res;
 }
 
 /** Returns a view of the Eigen \b dense matrix \a mat as Cholmod dense matrix.
   * The data are not copied but shared. */
 template<typename Derived>
@@ -155,14 +158,52 @@
 MappedSparseMatrix<Scalar,Flags,StorageIndex> viewAsEigen(cholmod_sparse& cm)
 {
   return MappedSparseMatrix<Scalar,Flags,StorageIndex>
          (cm.nrow, cm.ncol, static_cast<StorageIndex*>(cm.p)[cm.ncol],
           static_cast<StorageIndex*>(cm.p), static_cast<StorageIndex*>(cm.i),static_cast<Scalar*>(cm.x) );
 }
 
+namespace internal {
+
+// template specializations for int and long that call the correct cholmod method
+
+#define EIGEN_CHOLMOD_SPECIALIZE0(ret, name) \
+    template<typename _StorageIndex> inline ret cm_ ## name       (cholmod_common &Common) { return cholmod_ ## name   (&Common); } \
+    template<>                       inline ret cm_ ## name<SuiteSparse_long> (cholmod_common &Common) { return cholmod_l_ ## name (&Common); }
+
+#define EIGEN_CHOLMOD_SPECIALIZE1(ret, name, t1, a1) \
+    template<typename _StorageIndex> inline ret cm_ ## name       (t1& a1, cholmod_common &Common) { return cholmod_ ## name   (&a1, &Common); } \
+    template<>                       inline ret cm_ ## name<SuiteSparse_long> (t1& a1, cholmod_common &Common) { return cholmod_l_ ## name (&a1, &Common); }
+
+EIGEN_CHOLMOD_SPECIALIZE0(int, start)
+EIGEN_CHOLMOD_SPECIALIZE0(int, finish)
+
+EIGEN_CHOLMOD_SPECIALIZE1(int, free_factor, cholmod_factor*, L)
+EIGEN_CHOLMOD_SPECIALIZE1(int, free_dense,  cholmod_dense*,  X)
+EIGEN_CHOLMOD_SPECIALIZE1(int, free_sparse, cholmod_sparse*, A)
+
+EIGEN_CHOLMOD_SPECIALIZE1(cholmod_factor*, analyze, cholmod_sparse, A)
+
+template<typename _StorageIndex> inline cholmod_dense*  cm_solve         (int sys, cholmod_factor& L, cholmod_dense&  B, cholmod_common &Common) { return cholmod_solve     (sys, &L, &B, &Common); }
+template<>                       inline cholmod_dense*  cm_solve<SuiteSparse_long>   (int sys, cholmod_factor& L, cholmod_dense&  B, cholmod_common &Common) { return cholmod_l_solve   (sys, &L, &B, &Common); }
+
+template<typename _StorageIndex> inline cholmod_sparse* cm_spsolve       (int sys, cholmod_factor& L, cholmod_sparse& B, cholmod_common &Common) { return cholmod_spsolve   (sys, &L, &B, &Common); }
+template<>                       inline cholmod_sparse* cm_spsolve<SuiteSparse_long> (int sys, cholmod_factor& L, cholmod_sparse& B, cholmod_common &Common) { return cholmod_l_spsolve (sys, &L, &B, &Common); }
+
+template<typename _StorageIndex>
+inline int  cm_factorize_p       (cholmod_sparse*  A, double beta[2], _StorageIndex* fset, std::size_t fsize, cholmod_factor* L, cholmod_common &Common) { return cholmod_factorize_p   (A, beta, fset, fsize, L, &Common); }
+template<>
+inline int  cm_factorize_p<SuiteSparse_long> (cholmod_sparse*  A, double beta[2], SuiteSparse_long* fset,          std::size_t fsize, cholmod_factor* L, cholmod_common &Common) { return cholmod_l_factorize_p (A, beta, fset, fsize, L, &Common); }
+
+#undef EIGEN_CHOLMOD_SPECIALIZE0
+#undef EIGEN_CHOLMOD_SPECIALIZE1
+
+}  // namespace internal
+
+
 enum CholmodMode {
   CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt
 };
 
 
 /** \ingroup CholmodSupport_Module
   * \class CholmodBase
@@ -191,39 +232,39 @@
   public:
 
     CholmodBase()
       : m_cholmodFactor(0), m_info(Success), m_factorizationIsOk(false), m_analysisIsOk(false)
     {
       EIGEN_STATIC_ASSERT((internal::is_same<double,RealScalar>::value), CHOLMOD_SUPPORTS_DOUBLE_PRECISION_ONLY);
       m_shiftOffset[0] = m_shiftOffset[1] = 0.0;
-      cholmod_start(&m_cholmod);
+      internal::cm_start<StorageIndex>(m_cholmod);
     }
 
     explicit CholmodBase(const MatrixType& matrix)
       : m_cholmodFactor(0), m_info(Success), m_factorizationIsOk(false), m_analysisIsOk(false)
     {
       EIGEN_STATIC_ASSERT((internal::is_same<double,RealScalar>::value), CHOLMOD_SUPPORTS_DOUBLE_PRECISION_ONLY);
       m_shiftOffset[0] = m_shiftOffset[1] = 0.0;
-      cholmod_start(&m_cholmod);
+      internal::cm_start<StorageIndex>(m_cholmod);
       compute(matrix);
     }
 
     ~CholmodBase()
     {
       if(m_cholmodFactor)
-        cholmod_free_factor(&m_cholmodFactor, &m_cholmod);
-      cholmod_finish(&m_cholmod);
+        internal::cm_free_factor<StorageIndex>(m_cholmodFactor, m_cholmod);
+      internal::cm_finish<StorageIndex>(m_cholmod);
     }
-    
+
     inline StorageIndex cols() const { return internal::convert_index<StorageIndex, Index>(m_cholmodFactor->n); }
     inline StorageIndex rows() const { return internal::convert_index<StorageIndex, Index>(m_cholmodFactor->n); }
-    
+
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the matrix.appears to be negative.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "Decomposition is not initialized.");
       return m_info;
     }
@@ -231,123 +272,125 @@
     /** Computes the sparse Cholesky decomposition of \a matrix */
     Derived& compute(const MatrixType& matrix)
     {
       analyzePattern(matrix);
       factorize(matrix);
       return derived();
     }
-    
+
     /** Performs a symbolic decomposition on the sparsity pattern of \a matrix.
       *
       * This function is particularly useful when solving for several problems having the same structure.
-      * 
+      *
       * \sa factorize()
       */
     void analyzePattern(const MatrixType& matrix)
     {
       if(m_cholmodFactor)
       {
-        cholmod_free_factor(&m_cholmodFactor, &m_cholmod);
+        internal::cm_free_factor<StorageIndex>(m_cholmodFactor, m_cholmod);
         m_cholmodFactor = 0;
       }
       cholmod_sparse A = viewAsCholmod(matrix.template selfadjointView<UpLo>());
-      m_cholmodFactor = cholmod_analyze(&A, &m_cholmod);
-      
+      m_cholmodFactor = internal::cm_analyze<StorageIndex>(A, m_cholmod);
+
       this->m_isInitialized = true;
       this->m_info = Success;
       m_analysisIsOk = true;
       m_factorizationIsOk = false;
     }
-    
+
     /** Performs a numeric decomposition of \a matrix
       *
       * The given matrix must have the same sparsity pattern as the matrix on which the symbolic decomposition has been performed.
       *
       * \sa analyzePattern()
       */
     void factorize(const MatrixType& matrix)
     {
       eigen_assert(m_analysisIsOk && "You must first call analyzePattern()");
       cholmod_sparse A = viewAsCholmod(matrix.template selfadjointView<UpLo>());
-      cholmod_factorize_p(&A, m_shiftOffset, 0, 0, m_cholmodFactor, &m_cholmod);
+      internal::cm_factorize_p<StorageIndex>(&A, m_shiftOffset, 0, 0, m_cholmodFactor, m_cholmod);
 
       // If the factorization failed, minor is the column at which it did. On success minor == n.
       this->m_info = (m_cholmodFactor->minor == m_cholmodFactor->n ? Success : NumericalIssue);
       m_factorizationIsOk = true;
     }
-    
+
     /** Returns a reference to the Cholmod's configuration structure to get a full control over the performed operations.
      *  See the Cholmod user guide for details. */
     cholmod_common& cholmod() { return m_cholmod; }
-    
+
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     /** \internal */
     template<typename Rhs,typename Dest>
     void _solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const
     {
       eigen_assert(m_factorizationIsOk && "The decomposition is not in a valid state for solving, you must first call either compute() or symbolic()/numeric()");
       const Index size = m_cholmodFactor->n;
       EIGEN_UNUSED_VARIABLE(size);
       eigen_assert(size==b.rows());
-      
-      // Cholmod needs column-major stoarge without inner-stride, which corresponds to the default behavior of Ref.
+
+      // Cholmod needs column-major storage without inner-stride, which corresponds to the default behavior of Ref.
       Ref<const Matrix<typename Rhs::Scalar,Dynamic,Dynamic,ColMajor> > b_ref(b.derived());
 
       cholmod_dense b_cd = viewAsCholmod(b_ref);
-      cholmod_dense* x_cd = cholmod_solve(CHOLMOD_A, m_cholmodFactor, &b_cd, &m_cholmod);
+      cholmod_dense* x_cd = internal::cm_solve<StorageIndex>(CHOLMOD_A, *m_cholmodFactor, b_cd, m_cholmod);
       if(!x_cd)
       {
         this->m_info = NumericalIssue;
         return;
       }
       // TODO optimize this copy by swapping when possible (be careful with alignment, etc.)
+      // NOTE Actually, the copy can be avoided by calling cholmod_solve2 instead of cholmod_solve
       dest = Matrix<Scalar,Dest::RowsAtCompileTime,Dest::ColsAtCompileTime>::Map(reinterpret_cast<Scalar*>(x_cd->x),b.rows(),b.cols());
-      cholmod_free_dense(&x_cd, &m_cholmod);
+      internal::cm_free_dense<StorageIndex>(x_cd, m_cholmod);
     }
-    
+
     /** \internal */
     template<typename RhsDerived, typename DestDerived>
     void _solve_impl(const SparseMatrixBase<RhsDerived> &b, SparseMatrixBase<DestDerived> &dest) const
     {
       eigen_assert(m_factorizationIsOk && "The decomposition is not in a valid state for solving, you must first call either compute() or symbolic()/numeric()");
       const Index size = m_cholmodFactor->n;
       EIGEN_UNUSED_VARIABLE(size);
       eigen_assert(size==b.rows());
 
       // note: cs stands for Cholmod Sparse
       Ref<SparseMatrix<typename RhsDerived::Scalar,ColMajor,typename RhsDerived::StorageIndex> > b_ref(b.const_cast_derived());
       cholmod_sparse b_cs = viewAsCholmod(b_ref);
-      cholmod_sparse* x_cs = cholmod_spsolve(CHOLMOD_A, m_cholmodFactor, &b_cs, &m_cholmod);
+      cholmod_sparse* x_cs = internal::cm_spsolve<StorageIndex>(CHOLMOD_A, *m_cholmodFactor, b_cs, m_cholmod);
       if(!x_cs)
       {
         this->m_info = NumericalIssue;
         return;
       }
       // TODO optimize this copy by swapping when possible (be careful with alignment, etc.)
+      // NOTE cholmod_spsolve in fact just calls the dense solver for blocks of 4 columns at a time (similar to Eigen's sparse solver)
       dest.derived() = viewAsEigen<typename DestDerived::Scalar,ColMajor,typename DestDerived::StorageIndex>(*x_cs);
-      cholmod_free_sparse(&x_cs, &m_cholmod);
+      internal::cm_free_sparse<StorageIndex>(x_cs, m_cholmod);
     }
     #endif // EIGEN_PARSED_BY_DOXYGEN
-    
-    
+
+
     /** Sets the shift parameter that will be used to adjust the diagonal coefficients during the numerical factorization.
       *
       * During the numerical factorization, an offset term is added to the diagonal coefficients:\n
       * \c d_ii = \a offset + \c d_ii
       *
       * The default is \a offset=0.
       *
       * \returns a reference to \c *this.
       */
     Derived& setShift(const RealScalar& offset)
     {
       m_shiftOffset[0] = double(offset);
       return derived();
     }
-    
+
     /** \returns the determinant of the underlying matrix from the current factorization */
     Scalar determinant() const
     {
       using std::exp;
       return exp(logDeterminant());
     }
 
@@ -394,15 +437,15 @@
         logDet *= 2.0;
       return logDet;
     };
 
     template<typename Stream>
     void dumpMemory(Stream& /*s*/)
     {}
-    
+
   protected:
     mutable cholmod_common m_cholmod;
     cholmod_factor* m_cholmodFactor;
     double m_shiftOffset[2];
     mutable ComputationInfo m_info;
     int m_factorizationIsOk;
     int m_analysisIsOk;
@@ -431,19 +474,19 @@
   * \sa \ref TutorialSparseSolverConcept, class CholmodSupernodalLLT, class SimplicialLLT
   */
 template<typename _MatrixType, int _UpLo = Lower>
 class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >
 {
     typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;
     using Base::m_cholmod;
-    
+
   public:
-    
+
     typedef _MatrixType MatrixType;
-    
+
     CholmodSimplicialLLT() : Base() { init(); }
 
     CholmodSimplicialLLT(const MatrixType& matrix) : Base()
     {
       init();
       this->compute(matrix);
     }
@@ -482,19 +525,19 @@
   * \sa \ref TutorialSparseSolverConcept, class CholmodSupernodalLLT, class SimplicialLDLT
   */
 template<typename _MatrixType, int _UpLo = Lower>
 class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >
 {
     typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;
     using Base::m_cholmod;
-    
+
   public:
-    
+
     typedef _MatrixType MatrixType;
-    
+
     CholmodSimplicialLDLT() : Base() { init(); }
 
     CholmodSimplicialLDLT(const MatrixType& matrix) : Base()
     {
       init();
       this->compute(matrix);
     }
@@ -531,19 +574,19 @@
   * \sa \ref TutorialSparseSolverConcept
   */
 template<typename _MatrixType, int _UpLo = Lower>
 class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >
 {
     typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;
     using Base::m_cholmod;
-    
+
   public:
-    
+
     typedef _MatrixType MatrixType;
-    
+
     CholmodSupernodalLLT() : Base() { init(); }
 
     CholmodSupernodalLLT(const MatrixType& matrix) : Base()
     {
       init();
       this->compute(matrix);
     }
@@ -582,29 +625,29 @@
   * \sa \ref TutorialSparseSolverConcept
   */
 template<typename _MatrixType, int _UpLo = Lower>
 class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >
 {
     typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;
     using Base::m_cholmod;
-    
+
   public:
-    
+
     typedef _MatrixType MatrixType;
-    
+
     CholmodDecomposition() : Base() { init(); }
 
     CholmodDecomposition(const MatrixType& matrix) : Base()
     {
       init();
       this->compute(matrix);
     }
 
     ~CholmodDecomposition() {}
-    
+
     void setMode(CholmodMode mode)
     {
       switch(mode)
       {
         case CholmodAuto:
           m_cholmod.final_asis = 1;
           m_cholmod.supernodal = CHOLMOD_AUTO;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Array.h` & `chronogram-0.2.0/include/Eigen/src/Core/Array.h`

 * *Files 15% similar despite different names*

```diff
@@ -113,15 +113,15 @@
       * prevent a default operator= from hiding the templated operator=.
       */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Array& operator=(const Array& other)
     {
       return Base::_set(other);
     }
-    
+
     /** Default constructor.
       *
       * For fixed-size matrices, does nothing.
       *
       * For dynamic-size matrices, creates an empty matrix of size 0. Does not allocate any array. Such a matrix
       * is called a null matrix. This constructor is the unique way to create null matrices: resizing
       * a matrix to 0 is not supported.
@@ -153,19 +153,58 @@
       : Base(std::move(other))
     {
       Base::_check_template_params();
     }
     EIGEN_DEVICE_FUNC
     Array& operator=(Array&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)
     {
-      other.swap(*this);
+      Base::operator=(std::move(other));
       return *this;
     }
 #endif
 
+    #if EIGEN_HAS_CXX11
+    /** \copydoc PlainObjectBase(const Scalar& a0, const Scalar& a1, const Scalar& a2, const Scalar& a3, const ArgTypes&... args)
+     *
+     * Example: \include Array_variadic_ctor_cxx11.cpp
+     * Output: \verbinclude Array_variadic_ctor_cxx11.out
+     *
+     * \sa Array(const std::initializer_list<std::initializer_list<Scalar>>&)
+     * \sa Array(const Scalar&), Array(const Scalar&,const Scalar&)
+     */
+    template <typename... ArgTypes>
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Array(const Scalar& a0, const Scalar& a1, const Scalar& a2, const Scalar& a3, const ArgTypes&... args)
+      : Base(a0, a1, a2, a3, args...) {}
+
+    /** \brief Constructs an array and initializes it from the coefficients given as initializer-lists grouped by row. \cpp11
+      *
+      * In the general case, the constructor takes a list of rows, each row being represented as a list of coefficients:
+      *
+      * Example: \include Array_initializer_list_23_cxx11.cpp
+      * Output: \verbinclude Array_initializer_list_23_cxx11.out
+      *
+      * Each of the inner initializer lists must contain the exact same number of elements, otherwise an assertion is triggered.
+      *
+      * In the case of a compile-time column 1D array, implicit transposition from a single row is allowed.
+      * Therefore <code> Array<int,Dynamic,1>{{1,2,3,4,5}}</code> is legal and the more verbose syntax
+      * <code>Array<int,Dynamic,1>{{1},{2},{3},{4},{5}}</code> can be avoided:
+      *
+      * Example: \include Array_initializer_list_vector_cxx11.cpp
+      * Output: \verbinclude Array_initializer_list_vector_cxx11.out
+      *
+      * In the case of fixed-sized arrays, the initializer list sizes must exactly match the array sizes,
+      * and implicit transposition is allowed for compile-time 1D arrays only.
+      *
+      * \sa  Array(const Scalar& a0, const Scalar& a1, const Scalar& a2, const Scalar& a3, const ArgTypes&... args)
+      */
+    EIGEN_DEVICE_FUNC
+    EIGEN_STRONG_INLINE Array(const std::initializer_list<std::initializer_list<Scalar>>& list) : Base(list) {}
+    #endif // end EIGEN_HAS_CXX11
+
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename T>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE explicit Array(const T& x)
     {
       Base::_check_template_params();
       Base::template _init1<T>(x);
@@ -174,48 +213,55 @@
     template<typename T0, typename T1>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Array(const T0& val0, const T1& val1)
     {
       Base::_check_template_params();
       this->template _init2<T0,T1>(val0, val1);
     }
+
     #else
     /** \brief Constructs a fixed-sized array initialized with coefficients starting at \a data */
     EIGEN_DEVICE_FUNC explicit Array(const Scalar *data);
     /** Constructs a vector or row-vector with given dimension. \only_for_vectors
       *
       * Note that this is only useful for dynamic-size vectors. For fixed-size vectors,
       * it is redundant to pass the dimension here, so it makes more sense to use the default
       * constructor Array() instead.
       */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE explicit Array(Index dim);
-    /** constructs an initialized 1x1 Array with the given coefficient */
+    /** constructs an initialized 1x1 Array with the given coefficient
+      * \sa const Scalar& a0, const Scalar& a1, const Scalar& a2, const Scalar& a3, const ArgTypes&... args */
     Array(const Scalar& value);
     /** constructs an uninitialized array with \a rows rows and \a cols columns.
       *
       * This is useful for dynamic-size arrays. For fixed-size arrays,
       * it is redundant to pass these parameters, so one should use the default constructor
       * Array() instead. */
     Array(Index rows, Index cols);
-    /** constructs an initialized 2D vector with given coefficients */
+    /** constructs an initialized 2D vector with given coefficients
+      * \sa Array(const Scalar& a0, const Scalar& a1, const Scalar& a2, const Scalar& a3, const ArgTypes&... args) */
     Array(const Scalar& val0, const Scalar& val1);
-    #endif
+    #endif  // end EIGEN_PARSED_BY_DOXYGEN
 
-    /** constructs an initialized 3D vector with given coefficients */
+    /** constructs an initialized 3D vector with given coefficients
+      * \sa Array(const Scalar& a0, const Scalar& a1, const Scalar& a2, const Scalar& a3, const ArgTypes&... args)
+      */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2)
     {
       Base::_check_template_params();
       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Array, 3)
       m_storage.data()[0] = val0;
       m_storage.data()[1] = val1;
       m_storage.data()[2] = val2;
     }
-    /** constructs an initialized 4D vector with given coefficients */
+    /** constructs an initialized 4D vector with given coefficients
+      * \sa Array(const Scalar& a0, const Scalar& a1, const Scalar& a2, const Scalar& a3, const ArgTypes&... args)
+      */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2, const Scalar& val3)
     {
       Base::_check_template_params();
       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Array, 4)
       m_storage.data()[0] = val0;
       m_storage.data()[1] = val1;
@@ -238,43 +284,51 @@
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other,
                               typename internal::enable_if<internal::is_convertible<typename OtherDerived::Scalar,Scalar>::value,
                                                            PrivateType>::type = PrivateType())
       : Base(other.derived())
     { }
 
-    EIGEN_DEVICE_FUNC inline Index innerStride() const { return 1; }
-    EIGEN_DEVICE_FUNC inline Index outerStride() const { return this->innerSize(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT{ return 1; }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT { return this->innerSize(); }
 
     #ifdef EIGEN_ARRAY_PLUGIN
     #include EIGEN_ARRAY_PLUGIN
     #endif
 
   private:
 
     template<typename MatrixType, typename OtherDerived, bool SwapPointers>
     friend struct internal::matrix_swap_impl;
 };
 
 /** \defgroup arraytypedefs Global array typedefs
   * \ingroup Core_Module
   *
-  * Eigen defines several typedef shortcuts for most common 1D and 2D array types.
+  * %Eigen defines several typedef shortcuts for most common 1D and 2D array types.
   *
   * The general patterns are the following:
   *
   * \c ArrayRowsColsType where \c Rows and \c Cols can be \c 2,\c 3,\c 4 for fixed size square matrices or \c X for dynamic size,
   * and where \c Type can be \c i for integer, \c f for float, \c d for double, \c cf for complex float, \c cd
   * for complex double.
   *
   * For example, \c Array33d is a fixed-size 3x3 array type of doubles, and \c ArrayXXf is a dynamic-size matrix of floats.
   *
   * There are also \c ArraySizeType which are self-explanatory. For example, \c Array4cf is
   * a fixed-size 1D array of 4 complex floats.
   *
+  * With \cpp11, template alias are also defined for common sizes.
+  * They follow the same pattern as above except that the scalar type suffix is replaced by a
+  * template parameter, i.e.:
+  *   - `ArrayRowsCols<Type>` where `Rows` and `Cols` can be \c 2,\c 3,\c 4, or \c X for fixed or dynamic size.
+  *   - `ArraySize<Type>` where `Size` can be \c 2,\c 3,\c 4 or \c X for fixed or dynamic size 1D arrays.
+  *
   * \sa class Array
   */
 
 #define EIGEN_MAKE_ARRAY_TYPEDEFS(Type, TypeSuffix, Size, SizeSuffix)   \
 /** \ingroup arraytypedefs */                                    \
 typedef Array<Type, Size, Size> Array##SizeSuffix##SizeSuffix##TypeSuffix;  \
 /** \ingroup arraytypedefs */                                    \
@@ -299,16 +353,50 @@
 EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES(float,                f)
 EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES(double,               d)
 EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES(std::complex<float>,  cf)
 EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES(std::complex<double>, cd)
 
 #undef EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES
 #undef EIGEN_MAKE_ARRAY_TYPEDEFS
+#undef EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS
+
+#if EIGEN_HAS_CXX11
+
+#define EIGEN_MAKE_ARRAY_TYPEDEFS(Size, SizeSuffix)               \
+/** \ingroup arraytypedefs */                                     \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using Array##SizeSuffix##SizeSuffix = Array<Type, Size, Size>;    \
+/** \ingroup arraytypedefs */                                     \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using Array##SizeSuffix = Array<Type, Size, 1>;
+
+#define EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS(Size)                     \
+/** \ingroup arraytypedefs */                                     \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using Array##Size##X = Array<Type, Size, Dynamic>;                \
+/** \ingroup arraytypedefs */                                     \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using Array##X##Size = Array<Type, Dynamic, Size>;
+
+EIGEN_MAKE_ARRAY_TYPEDEFS(2, 2)
+EIGEN_MAKE_ARRAY_TYPEDEFS(3, 3)
+EIGEN_MAKE_ARRAY_TYPEDEFS(4, 4)
+EIGEN_MAKE_ARRAY_TYPEDEFS(Dynamic, X)
+EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS(2)
+EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS(3)
+EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS(4)
+
+#undef EIGEN_MAKE_ARRAY_TYPEDEFS
+#undef EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS
 
-#undef EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE
+#endif // EIGEN_HAS_CXX11
 
 #define EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE(TypeSuffix, SizeSuffix) \
 using Eigen::Matrix##SizeSuffix##TypeSuffix; \
 using Eigen::Vector##SizeSuffix##TypeSuffix; \
 using Eigen::RowVector##SizeSuffix##TypeSuffix;
 
 #define EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE(TypeSuffix) \
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/ArrayBase.h` & `chronogram-0.2.0/include/Eigen/src/Core/ArrayBase.h`

 * *Files 1% similar despite different names*

```diff
@@ -65,14 +65,15 @@
     using Base::const_cast_derived;
     using Base::rows;
     using Base::cols;
     using Base::size;
     using Base::coeff;
     using Base::coeffRef;
     using Base::lazyAssign;
+    using Base::operator-;
     using Base::operator=;
     using Base::operator+=;
     using Base::operator-=;
     using Base::operator*=;
     using Base::operator/=;
 
     typedef typename Base::CoeffReturnType CoeffReturnType;
@@ -84,15 +85,14 @@
 
     /** \internal Represents a matrix with all coefficients equal to one another*/
     typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;
 #endif // not EIGEN_PARSED_BY_DOXYGEN
 
 #define EIGEN_CURRENT_STORAGE_BASE_CLASS Eigen::ArrayBase
 #define EIGEN_DOC_UNARY_ADDONS(X,Y)
-#   include "../plugins/CommonCwiseUnaryOps.h"
 #   include "../plugins/MatrixCwiseUnaryOps.h"
 #   include "../plugins/ArrayCwiseUnaryOps.h"
 #   include "../plugins/CommonCwiseBinaryOps.h"
 #   include "../plugins/MatrixCwiseBinaryOps.h"
 #   include "../plugins/ArrayCwiseBinaryOps.h"
 #   ifdef EIGEN_ARRAYBASE_PLUGIN
 #     include EIGEN_ARRAYBASE_PLUGIN
@@ -149,16 +149,16 @@
     EIGEN_DEVICE_FUNC
     const MatrixWrapper<const Derived> matrix() const { return MatrixWrapper<const Derived>(derived()); }
 
 //     template<typename Dest>
 //     inline void evalTo(Dest& dst) const { dst = matrix(); }
 
   protected:
-    EIGEN_DEVICE_FUNC
-    ArrayBase() : Base() {}
+    EIGEN_DEFAULT_COPY_CONSTRUCTOR(ArrayBase)
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(ArrayBase)
 
   private:
     explicit ArrayBase(Index);
     ArrayBase(Index,Index);
     template<typename OtherDerived> explicit ArrayBase(const ArrayBase<OtherDerived>&);
   protected:
     // mixing arrays and matrices is not legal
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/ArrayWrapper.h` & `chronogram-0.2.0/include/Eigen/src/Core/ArrayWrapper.h`

 * *Files 20% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_ARRAYWRAPPER_H
 #define EIGEN_ARRAYWRAPPER_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \class ArrayWrapper
   * \ingroup Core_Module
   *
   * \brief Expression of a mathematical vector or matrix as an array object
   *
   * This class is the return type of MatrixBase::array(), and most of the time
@@ -56,22 +56,22 @@
     typedef typename internal::ref_selector<ExpressionType>::non_const_type NestedExpressionType;
 
     using Base::coeffRef;
 
     EIGEN_DEVICE_FUNC
     explicit EIGEN_STRONG_INLINE ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}
 
-    EIGEN_DEVICE_FUNC
-    inline Index rows() const { return m_expression.rows(); }
-    EIGEN_DEVICE_FUNC
-    inline Index cols() const { return m_expression.cols(); }
-    EIGEN_DEVICE_FUNC
-    inline Index outerStride() const { return m_expression.outerStride(); }
-    EIGEN_DEVICE_FUNC
-    inline Index innerStride() const { return m_expression.innerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_expression.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_expression.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT { return m_expression.outerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT { return m_expression.innerStride(); }
 
     EIGEN_DEVICE_FUNC
     inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }
     EIGEN_DEVICE_FUNC
     inline const Scalar* data() const { return m_expression.data(); }
 
     EIGEN_DEVICE_FUNC
@@ -86,17 +86,17 @@
       return m_expression.coeffRef(index);
     }
 
     template<typename Dest>
     EIGEN_DEVICE_FUNC
     inline void evalTo(Dest& dst) const { dst = m_expression; }
 
-    const typename internal::remove_all<NestedExpressionType>::type& 
     EIGEN_DEVICE_FUNC
-    nestedExpression() const 
+    const typename internal::remove_all<NestedExpressionType>::type&
+    nestedExpression() const
     {
       return m_expression;
     }
 
     /** Forwards the resizing request to the nested expression
       * \sa DenseBase::resize(Index)  */
     EIGEN_DEVICE_FUNC
@@ -154,22 +154,22 @@
     typedef typename internal::ref_selector<ExpressionType>::non_const_type NestedExpressionType;
 
     using Base::coeffRef;
 
     EIGEN_DEVICE_FUNC
     explicit inline MatrixWrapper(ExpressionType& matrix) : m_expression(matrix) {}
 
-    EIGEN_DEVICE_FUNC
-    inline Index rows() const { return m_expression.rows(); }
-    EIGEN_DEVICE_FUNC
-    inline Index cols() const { return m_expression.cols(); }
-    EIGEN_DEVICE_FUNC
-    inline Index outerStride() const { return m_expression.outerStride(); }
-    EIGEN_DEVICE_FUNC
-    inline Index innerStride() const { return m_expression.innerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_expression.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_expression.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT { return m_expression.outerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT { return m_expression.innerStride(); }
 
     EIGEN_DEVICE_FUNC
     inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }
     EIGEN_DEVICE_FUNC
     inline const Scalar* data() const { return m_expression.data(); }
 
     EIGEN_DEVICE_FUNC
@@ -181,16 +181,16 @@
     EIGEN_DEVICE_FUNC
     inline const Scalar& coeffRef(Index index) const
     {
       return m_expression.coeffRef(index);
     }
 
     EIGEN_DEVICE_FUNC
-    const typename internal::remove_all<NestedExpressionType>::type& 
-    nestedExpression() const 
+    const typename internal::remove_all<NestedExpressionType>::type&
+    nestedExpression() const
     {
       return m_expression;
     }
 
     /** Forwards the resizing request to the nested expression
       * \sa DenseBase::resize(Index)  */
     EIGEN_DEVICE_FUNC
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Assign.h` & `chronogram-0.2.0/include/Eigen/src/Core/Assign.h`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 #ifndef EIGEN_ASSIGN_H
 #define EIGEN_ASSIGN_H
 
 namespace Eigen {
 
 template<typename Derived>
 template<typename OtherDerived>
-EIGEN_STRONG_INLINE Derived& DenseBase<Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>
   ::lazyAssign(const DenseBase<OtherDerived>& other)
 {
   enum{
     SameType = internal::is_same<typename Derived::Scalar,typename OtherDerived::Scalar>::value
   };
 
   EIGEN_STATIC_ASSERT_LVALUE(Derived)
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/AssignEvaluator.h` & `chronogram-0.2.0/include/Eigen/src/Core/AssignEvaluator.h`

 * *Files 4% similar despite different names*

```diff
@@ -13,32 +13,32 @@
 #define EIGEN_ASSIGN_EVALUATOR_H
 
 namespace Eigen {
 
 // This implementation is based on Assign.h
 
 namespace internal {
-  
+
 /***************************************************************************
 * Part 1 : the logic deciding a strategy for traversal and unrolling       *
 ***************************************************************************/
 
 // copy_using_evaluator_traits is based on assign_traits
 
-template <typename DstEvaluator, typename SrcEvaluator, typename AssignFunc>
+template <typename DstEvaluator, typename SrcEvaluator, typename AssignFunc, int MaxPacketSize = -1>
 struct copy_using_evaluator_traits
 {
   typedef typename DstEvaluator::XprType Dst;
   typedef typename Dst::Scalar DstScalar;
-  
+
   enum {
     DstFlags = DstEvaluator::Flags,
     SrcFlags = SrcEvaluator::Flags
   };
-  
+
 public:
   enum {
     DstAlignment = DstEvaluator::Alignment,
     SrcAlignment = SrcEvaluator::Alignment,
     DstHasDirectAccess = (DstFlags & DirectAccessBit) == DirectAccessBit,
     JointAlignment = EIGEN_PLAIN_ENUM_MIN(DstAlignment,SrcAlignment)
   };
@@ -47,21 +47,23 @@
   enum {
     InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)
               : int(DstFlags)&RowMajorBit ? int(Dst::ColsAtCompileTime)
               : int(Dst::RowsAtCompileTime),
     InnerMaxSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)
               : int(DstFlags)&RowMajorBit ? int(Dst::MaxColsAtCompileTime)
               : int(Dst::MaxRowsAtCompileTime),
+    RestrictedInnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(InnerSize,MaxPacketSize),
+    RestrictedLinearSize = EIGEN_SIZE_MIN_PREFER_FIXED(Dst::SizeAtCompileTime,MaxPacketSize),
     OuterStride = int(outer_stride_at_compile_time<Dst>::ret),
     MaxSizeAtCompileTime = Dst::SizeAtCompileTime
   };
 
   // TODO distinguish between linear traversal and inner-traversals
-  typedef typename find_best_packet<DstScalar,Dst::SizeAtCompileTime>::type LinearPacketType;
-  typedef typename find_best_packet<DstScalar,InnerSize>::type InnerPacketType;
+  typedef typename find_best_packet<DstScalar,RestrictedLinearSize>::type LinearPacketType;
+  typedef typename find_best_packet<DstScalar,RestrictedInnerSize>::type InnerPacketType;
 
   enum {
     LinearPacketSize = unpacket_traits<LinearPacketType>::size,
     InnerPacketSize = unpacket_traits<InnerPacketType>::size
   };
 
 public:
@@ -93,15 +95,16 @@
          indicated by InnerMaxSize rather than InnerSize, think of the case of a dynamic block
          in a fixed-size matrix
          However, with EIGEN_UNALIGNED_VECTORIZE and unrolling, slice vectorization is still worth it */
   };
 
 public:
   enum {
-    Traversal = int(MayLinearVectorize) && (LinearPacketSize>InnerPacketSize) ? int(LinearVectorizedTraversal)
+    Traversal =  int(Dst::SizeAtCompileTime) == 0 ? int(AllAtOnceTraversal) // If compile-size is zero, traversing will fail at compile-time.
+              : (int(MayLinearVectorize) && (LinearPacketSize>InnerPacketSize)) ? int(LinearVectorizedTraversal)
               : int(MayInnerVectorize)   ? int(InnerVectorizedTraversal)
               : int(MayLinearVectorize)  ? int(LinearVectorizedTraversal)
               : int(MaySliceVectorize)   ? int(SliceVectorizedTraversal)
               : int(MayLinearize)        ? int(LinearTraversal)
                                          : int(DefaultTraversal),
     Vectorized = int(Traversal) == InnerVectorizedTraversal
               || int(Traversal) == LinearVectorizedTraversal
@@ -131,15 +134,15 @@
                                              : int(NoUnrolling)
                   )
               : int(Traversal) == int(LinearVectorizedTraversal)
                 ? ( bool(MayUnrollCompletely) && ( EIGEN_UNALIGNED_VECTORIZE || (int(DstAlignment)>=int(LinearRequiredAlignment)))
                           ? int(CompleteUnrolling)
                           : int(NoUnrolling) )
               : int(Traversal) == int(LinearTraversal)
-                ? ( bool(MayUnrollCompletely) ? int(CompleteUnrolling) 
+                ? ( bool(MayUnrollCompletely) ? int(CompleteUnrolling)
                                               : int(NoUnrolling) )
 #if EIGEN_UNALIGNED_VECTORIZE
               : int(Traversal) == int(SliceVectorizedTraversal)
                 ? ( bool(MayUnrollInner) ? int(InnerUnrolling)
                                          : int(NoUnrolling) )
 #endif
               : int(NoUnrolling)
@@ -168,14 +171,16 @@
     EIGEN_DEBUG_VAR(MightVectorize)
     EIGEN_DEBUG_VAR(MayLinearize)
     EIGEN_DEBUG_VAR(MayInnerVectorize)
     EIGEN_DEBUG_VAR(MayLinearVectorize)
     EIGEN_DEBUG_VAR(MaySliceVectorize)
     std::cerr << "Traversal" << " = " << Traversal << " (" << demangle_traversal(Traversal) << ")" << std::endl;
     EIGEN_DEBUG_VAR(SrcEvaluator::CoeffReadCost)
+    EIGEN_DEBUG_VAR(DstEvaluator::CoeffReadCost)
+    EIGEN_DEBUG_VAR(Dst::SizeAtCompileTime)
     EIGEN_DEBUG_VAR(UnrollingLimit)
     EIGEN_DEBUG_VAR(MayUnrollCompletely)
     EIGEN_DEBUG_VAR(MayUnrollInner)
     std::cerr << "Unrolling" << " = " << Unrolling << " (" << demangle_unrolling(Unrolling) << ")" << std::endl;
     std::cerr << std::endl;
   }
 #endif
@@ -191,15 +196,15 @@
 
 template<typename Kernel, int Index, int Stop>
 struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling
 {
   // FIXME: this is not very clean, perhaps this information should be provided by the kernel?
   typedef typename Kernel::DstEvaluatorType DstEvaluatorType;
   typedef typename DstEvaluatorType::XprType DstXprType;
-  
+
   enum {
     outer = Index / DstXprType::InnerSizeAtCompileTime,
     inner = Index % DstXprType::InnerSizeAtCompileTime
   };
 
   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
   {
@@ -257,15 +262,15 @@
 template<typename Kernel, int Index, int Stop>
 struct copy_using_evaluator_innervec_CompleteUnrolling
 {
   // FIXME: this is not very clean, perhaps this information should be provided by the kernel?
   typedef typename Kernel::DstEvaluatorType DstEvaluatorType;
   typedef typename DstEvaluatorType::XprType DstXprType;
   typedef typename Kernel::PacketType PacketType;
-  
+
   enum {
     outer = Index / DstXprType::InnerSizeAtCompileTime,
     inner = Index % DstXprType::InnerSizeAtCompileTime,
     SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,
     DstAlignment = Kernel::AssignmentTraits::DstAlignment
   };
 
@@ -309,14 +314,30 @@
 
 template<typename Kernel,
          int Traversal = Kernel::AssignmentTraits::Traversal,
          int Unrolling = Kernel::AssignmentTraits::Unrolling>
 struct dense_assignment_loop;
 
 /************************
+***** Special Cases *****
+************************/
+
+// Zero-sized assignment is a no-op.
+template<typename Kernel, int Unrolling>
+struct dense_assignment_loop<Kernel, AllAtOnceTraversal, Unrolling>
+{
+  EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel& /*kernel*/)
+  {
+    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
+    EIGEN_STATIC_ASSERT(int(DstXprType::SizeAtCompileTime) == 0,
+      EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT)
+  }
+};
+
+/************************
 *** Default traversal ***
 ************************/
 
 template<typename Kernel>
 struct dense_assignment_loop<Kernel, DefaultTraversal, NoUnrolling>
 {
   EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel &kernel)
@@ -422,18 +443,18 @@
 template<typename Kernel>
 struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, CompleteUnrolling>
 {
   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
   {
     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
     typedef typename Kernel::PacketType PacketType;
-    
+
     enum { size = DstXprType::SizeAtCompileTime,
            packetSize =unpacket_traits<PacketType>::size,
-           alignedSize = (size/packetSize)*packetSize };
+           alignedSize = (int(size)/packetSize)*packetSize };
 
     copy_using_evaluator_innervec_CompleteUnrolling<Kernel, 0, alignedSize>::run(kernel);
     copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, alignedSize, size>::run(kernel);
   }
 };
 
 /**************************
@@ -526,15 +547,15 @@
       dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),
       dstAlignment = alignable ? int(requestedAlignment)
                                : int(Kernel::AssignmentTraits::DstAlignment)
     };
     const Scalar *dst_ptr = kernel.dstDataPtr();
     if((!bool(dstIsAligned)) && (UIntPtr(dst_ptr) % sizeof(Scalar))>0)
     {
-      // the pointer is not aligend-on scalar, so alignment is not possible
+      // the pointer is not aligned-on scalar, so alignment is not possible
       return dense_assignment_loop<Kernel,DefaultTraversal,NoUnrolling>::run(kernel);
     }
     const Index packetAlignedMask = packetSize - 1;
     const Index innerSize = kernel.innerSize();
     const Index outerSize = kernel.outerSize();
     const Index alignedStep = alignable ? (packetSize - kernel.outerStride() % packetSize) & packetAlignedMask : 0;
     Index alignedStart = ((!alignable) || bool(dstIsAligned)) ? 0 : internal::first_aligned<requestedAlignment>(dst_ptr, innerSize);
@@ -564,22 +585,23 @@
 struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, InnerUnrolling>
 {
   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)
   {
     typedef typename Kernel::DstEvaluatorType::XprType DstXprType;
     typedef typename Kernel::PacketType PacketType;
 
-    enum { size = DstXprType::InnerSizeAtCompileTime,
+    enum { innerSize = DstXprType::InnerSizeAtCompileTime,
            packetSize =unpacket_traits<PacketType>::size,
-           vectorizableSize = (size/packetSize)*packetSize };
+           vectorizableSize = (int(innerSize) / int(packetSize)) * int(packetSize),
+           size = DstXprType::SizeAtCompileTime };
 
     for(Index outer = 0; outer < kernel.outerSize(); ++outer)
     {
       copy_using_evaluator_innervec_InnerUnrolling<Kernel, 0, vectorizableSize, 0, 0>::run(kernel, outer);
-      copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, vectorizableSize, size>::run(kernel, outer);
+      copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, vectorizableSize, innerSize>::run(kernel, outer);
     }
   }
 };
 #endif
 
 
 /***************************************************************************
@@ -595,81 +617,82 @@
 template<typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT, typename Functor, int Version = Specialized>
 class generic_dense_assignment_kernel
 {
 protected:
   typedef typename DstEvaluatorTypeT::XprType DstXprType;
   typedef typename SrcEvaluatorTypeT::XprType SrcXprType;
 public:
-  
+
   typedef DstEvaluatorTypeT DstEvaluatorType;
   typedef SrcEvaluatorTypeT SrcEvaluatorType;
   typedef typename DstEvaluatorType::Scalar Scalar;
   typedef copy_using_evaluator_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor> AssignmentTraits;
   typedef typename AssignmentTraits::PacketType PacketType;
-  
-  
-  EIGEN_DEVICE_FUNC generic_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)
+
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  generic_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)
     : m_dst(dst), m_src(src), m_functor(func), m_dstExpr(dstExpr)
   {
     #ifdef EIGEN_DEBUG_ASSIGN
     AssignmentTraits::debug();
     #endif
   }
-  
-  EIGEN_DEVICE_FUNC Index size() const        { return m_dstExpr.size(); }
-  EIGEN_DEVICE_FUNC Index innerSize() const   { return m_dstExpr.innerSize(); }
-  EIGEN_DEVICE_FUNC Index outerSize() const   { return m_dstExpr.outerSize(); }
-  EIGEN_DEVICE_FUNC Index rows() const        { return m_dstExpr.rows(); }
-  EIGEN_DEVICE_FUNC Index cols() const        { return m_dstExpr.cols(); }
-  EIGEN_DEVICE_FUNC Index outerStride() const { return m_dstExpr.outerStride(); }
-  
-  EIGEN_DEVICE_FUNC DstEvaluatorType& dstEvaluator() { return m_dst; }
-  EIGEN_DEVICE_FUNC const SrcEvaluatorType& srcEvaluator() const { return m_src; }
-  
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index size() const EIGEN_NOEXCEPT { return m_dstExpr.size(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index innerSize() const EIGEN_NOEXCEPT { return m_dstExpr.innerSize(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index outerSize() const EIGEN_NOEXCEPT { return m_dstExpr.outerSize(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_dstExpr.rows(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_dstExpr.cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index outerStride() const EIGEN_NOEXCEPT { return m_dstExpr.outerStride(); }
+
+  EIGEN_DEVICE_FUNC DstEvaluatorType& dstEvaluator() EIGEN_NOEXCEPT { return m_dst; }
+  EIGEN_DEVICE_FUNC const SrcEvaluatorType& srcEvaluator() const EIGEN_NOEXCEPT { return m_src; }
+
   /// Assign src(row,col) to dst(row,col) through the assignment functor.
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index row, Index col)
   {
     m_functor.assignCoeff(m_dst.coeffRef(row,col), m_src.coeff(row,col));
   }
-  
+
   /// \sa assignCoeff(Index,Index)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index index)
   {
     m_functor.assignCoeff(m_dst.coeffRef(index), m_src.coeff(index));
   }
-  
+
   /// \sa assignCoeff(Index,Index)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeffByOuterInner(Index outer, Index inner)
   {
-    Index row = rowIndexByOuterInner(outer, inner); 
-    Index col = colIndexByOuterInner(outer, inner); 
+    Index row = rowIndexByOuterInner(outer, inner);
+    Index col = colIndexByOuterInner(outer, inner);
     assignCoeff(row, col);
   }
-  
-  
+
+
   template<int StoreMode, int LoadMode, typename PacketType>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index row, Index col)
   {
     m_functor.template assignPacket<StoreMode>(&m_dst.coeffRef(row,col), m_src.template packet<LoadMode,PacketType>(row,col));
   }
-  
+
   template<int StoreMode, int LoadMode, typename PacketType>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index index)
   {
     m_functor.template assignPacket<StoreMode>(&m_dst.coeffRef(index), m_src.template packet<LoadMode,PacketType>(index));
   }
-  
+
   template<int StoreMode, int LoadMode, typename PacketType>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacketByOuterInner(Index outer, Index inner)
   {
-    Index row = rowIndexByOuterInner(outer, inner); 
+    Index row = rowIndexByOuterInner(outer, inner);
     Index col = colIndexByOuterInner(outer, inner);
     assignPacket<StoreMode,LoadMode,PacketType>(row, col);
   }
-  
+
   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner)
   {
     typedef typename DstEvaluatorType::ExpressionTraits Traits;
     return int(Traits::RowsAtCompileTime) == 1 ? 0
       : int(Traits::ColsAtCompileTime) == 1 ? inner
       : int(DstEvaluatorType::Flags)&RowMajorBit ? outer
       : inner;
@@ -684,23 +707,44 @@
       : outer;
   }
 
   EIGEN_DEVICE_FUNC const Scalar* dstDataPtr() const
   {
     return m_dstExpr.data();
   }
-  
+
 protected:
   DstEvaluatorType& m_dst;
   const SrcEvaluatorType& m_src;
   const Functor &m_functor;
   // TODO find a way to avoid the needs of the original expression
   DstXprType& m_dstExpr;
 };
 
+// Special kernel used when computing small products whose operands have dynamic dimensions.  It ensures that the
+// PacketSize used is no larger than 4, thereby increasing the chance that vectorized instructions will be used
+// when computing the product.
+
+template<typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT, typename Functor>
+class restricted_packet_dense_assignment_kernel : public generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, BuiltIn>
+{
+protected:
+  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, BuiltIn> Base;
+ public:
+    typedef typename Base::Scalar Scalar;
+    typedef typename Base::DstXprType DstXprType;
+    typedef copy_using_evaluator_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, 4> AssignmentTraits;
+    typedef typename AssignmentTraits::PacketType PacketType;
+
+    EIGEN_DEVICE_FUNC restricted_packet_dense_assignment_kernel(DstEvaluatorTypeT &dst, const SrcEvaluatorTypeT &src, const Functor &func, DstXprType& dstExpr)
+    : Base(dst, src, func, dstExpr)
+  {
+  }
+ };
+
 /***************************************************************************
 * Part 5 : Entry point for dense rectangular assignment
 ***************************************************************************/
 
 template<typename DstXprType,typename SrcXprType, typename Functor>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const Functor &/*func*/)
@@ -730,21 +774,31 @@
   SrcEvaluatorType srcEvaluator(src);
 
   // NOTE To properly handle A = (A*A.transpose())/s with A rectangular,
   // we need to resize the destination after the source evaluator has been created.
   resize_if_allowed(dst, src, func);
 
   DstEvaluatorType dstEvaluator(dst);
-    
+
   typedef generic_dense_assignment_kernel<DstEvaluatorType,SrcEvaluatorType,Functor> Kernel;
   Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());
 
   dense_assignment_loop<Kernel>::run(kernel);
 }
 
+// Specialization for filling the destination with a constant value.
+#ifndef EIGEN_GPU_COMPILE_PHASE
+template<typename DstXprType>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<typename DstXprType::Scalar>, DstXprType>& src, const internal::assign_op<typename DstXprType::Scalar,typename DstXprType::Scalar>& func)
+{
+  resize_if_allowed(dst, src, func);
+  std::fill_n(dst.data(), dst.size(), src.functor()());
+}
+#endif
+
 template<typename DstXprType, typename SrcXprType>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src)
 {
   call_dense_assignment_loop(dst, src, internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>());
 }
 
 /***************************************************************************
@@ -752,21 +806,21 @@
 ***************************************************************************/
 
 // Based on the respective shapes of the destination and source,
 // the class AssignmentKind determine the kind of assignment mechanism.
 // AssignmentKind must define a Kind typedef.
 template<typename DstShape, typename SrcShape> struct AssignmentKind;
 
-// Assignement kind defined in this file:
+// Assignment kind defined in this file:
 struct Dense2Dense {};
 struct EigenBase2EigenBase {};
 
 template<typename,typename> struct AssignmentKind { typedef EigenBase2EigenBase Kind; };
 template<> struct AssignmentKind<DenseShape,DenseShape> { typedef Dense2Dense Kind; };
-    
+
 // This is the main assignment class
 template< typename DstXprType, typename SrcXprType, typename Functor,
           typename Kind = typename AssignmentKind< typename evaluator_traits<DstXprType>::Shape , typename evaluator_traits<SrcXprType>::Shape >::Kind,
           typename EnableIf = void>
 struct Assignment;
 
 
@@ -783,15 +837,15 @@
 }
 template<typename Dst, typename Src>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 void call_assignment(const Dst& dst, const Src& src)
 {
   call_assignment(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());
 }
-                     
+
 // Deal with "assume-aliasing"
 template<typename Dst, typename Src, typename Func>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if< evaluator_assume_aliasing<Src>::value, void*>::type = 0)
 {
   typename plain_matrix_type<Src>::type tmp(src);
   call_assignment_no_alias(dst, tmp, func);
@@ -823,22 +877,43 @@
                         || (int(Dst::ColsAtCompileTime) == 1 && int(Src::RowsAtCompileTime) == 1)
                       ) && int(Dst::SizeAtCompileTime) != 1
   };
 
   typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst>::type ActualDstTypeCleaned;
   typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst&>::type ActualDstType;
   ActualDstType actualDst(dst);
-  
+
   // TODO check whether this is the right place to perform these checks:
   EIGEN_STATIC_ASSERT_LVALUE(Dst)
   EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(ActualDstTypeCleaned,Src)
   EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename ActualDstTypeCleaned::Scalar,typename Src::Scalar);
-  
+
   Assignment<ActualDstTypeCleaned,Src,Func>::run(actualDst, src, func);
 }
+
+template<typename Dst, typename Src, typename Func>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+void call_restricted_packet_assignment_no_alias(Dst& dst, const Src& src, const Func& func)
+{
+    typedef evaluator<Dst> DstEvaluatorType;
+    typedef evaluator<Src> SrcEvaluatorType;
+    typedef restricted_packet_dense_assignment_kernel<DstEvaluatorType,SrcEvaluatorType,Func> Kernel;
+
+    EIGEN_STATIC_ASSERT_LVALUE(Dst)
+    EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename Dst::Scalar,typename Src::Scalar);
+
+    SrcEvaluatorType srcEvaluator(src);
+    resize_if_allowed(dst, src, func);
+
+    DstEvaluatorType dstEvaluator(dst);
+    Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());
+
+    dense_assignment_loop<Kernel>::run(kernel);
+}
+
 template<typename Dst, typename Src>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 void call_assignment_no_alias(Dst& dst, const Src& src)
 {
   call_assignment_no_alias(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());
 }
 
@@ -871,15 +946,15 @@
 {
   EIGEN_DEVICE_FUNC
   static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const Functor &func)
   {
 #ifndef EIGEN_NO_DEBUG
     internal::check_for_aliasing(dst, src);
 #endif
-    
+
     call_dense_assignment_loop(dst, src, func);
   }
 };
 
 // Generic assignment through evalTo.
 // TODO: not sure we have to keep that one, but it helps porting current code to new evaluator mechanism.
 // Note that the last template argument "Weak" is needed to make it possible to perform
@@ -895,15 +970,15 @@
     if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
       dst.resize(dstRows, dstCols);
 
     eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
     src.evalTo(dst);
   }
 
-  // NOTE The following two functions are templated to avoid their instanciation if not needed
+  // NOTE The following two functions are templated to avoid their instantiation if not needed
   //      This is needed because some expressions supports evalTo only and/or have 'void' as scalar type.
   template<typename SrcScalarType>
   EIGEN_DEVICE_FUNC
   static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,SrcScalarType> &/*func*/)
   {
     Index dstRows = src.rows();
     Index dstCols = src.cols();
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Assign_MKL.h` & `chronogram-0.2.0/include/Eigen/src/Core/Assign_MKL.h`

 * *Files 1% similar despite different names*

```diff
@@ -64,44 +64,44 @@
       EnableVml = MightEnableVml && LargeEnough,
       Traversal = MightLinearize ? LinearTraversal : DefaultTraversal
     };
 };
 
 #define EIGEN_PP_EXPAND(ARG) ARG
 #if !defined (EIGEN_FAST_MATH) || (EIGEN_FAST_MATH != 1)
-#define EIGEN_VMLMODE_EXPAND_LA , VML_HA
+#define EIGEN_VMLMODE_EXPAND_xLA , VML_HA
 #else
-#define EIGEN_VMLMODE_EXPAND_LA , VML_LA
+#define EIGEN_VMLMODE_EXPAND_xLA , VML_LA
 #endif
 
-#define EIGEN_VMLMODE_EXPAND__ 
+#define EIGEN_VMLMODE_EXPAND_x_
 
-#define EIGEN_VMLMODE_PREFIX_LA vm
-#define EIGEN_VMLMODE_PREFIX__  v
-#define EIGEN_VMLMODE_PREFIX(VMLMODE) EIGEN_CAT(EIGEN_VMLMODE_PREFIX_,VMLMODE)
+#define EIGEN_VMLMODE_PREFIX_xLA vm
+#define EIGEN_VMLMODE_PREFIX_x_  v
+#define EIGEN_VMLMODE_PREFIX(VMLMODE) EIGEN_CAT(EIGEN_VMLMODE_PREFIX_x,VMLMODE)
 
 #define EIGEN_MKL_VML_DECLARE_UNARY_CALL(EIGENOP, VMLOP, EIGENTYPE, VMLTYPE, VMLMODE)                                           \
   template< typename DstXprType, typename SrcXprNested>                                                                         \
   struct Assignment<DstXprType, CwiseUnaryOp<scalar_##EIGENOP##_op<EIGENTYPE>, SrcXprNested>, assign_op<EIGENTYPE,EIGENTYPE>,   \
                    Dense2Dense, typename enable_if<vml_assign_traits<DstXprType,SrcXprNested>::EnableVml>::type> {              \
     typedef CwiseUnaryOp<scalar_##EIGENOP##_op<EIGENTYPE>, SrcXprNested> SrcXprType;                                            \
     static void run(DstXprType &dst, const SrcXprType &src, const assign_op<EIGENTYPE,EIGENTYPE> &func) {                       \
       resize_if_allowed(dst, src, func);                                                                                        \
       eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());                                                       \
       if(vml_assign_traits<DstXprType,SrcXprNested>::Traversal==LinearTraversal) {                                              \
         VMLOP(dst.size(), (const VMLTYPE*)src.nestedExpression().data(),                                                        \
-              (VMLTYPE*)dst.data() EIGEN_PP_EXPAND(EIGEN_VMLMODE_EXPAND_##VMLMODE) );                                           \
+              (VMLTYPE*)dst.data() EIGEN_PP_EXPAND(EIGEN_VMLMODE_EXPAND_x##VMLMODE) );                                           \
       } else {                                                                                                                  \
         const Index outerSize = dst.outerSize();                                                                                \
         for(Index outer = 0; outer < outerSize; ++outer) {                                                                      \
           const EIGENTYPE *src_ptr = src.IsRowMajor ? &(src.nestedExpression().coeffRef(outer,0)) :                             \
                                                       &(src.nestedExpression().coeffRef(0, outer));                             \
           EIGENTYPE *dst_ptr = dst.IsRowMajor ? &(dst.coeffRef(outer,0)) : &(dst.coeffRef(0, outer));                           \
           VMLOP( dst.innerSize(), (const VMLTYPE*)src_ptr,                                                                      \
-                (VMLTYPE*)dst_ptr EIGEN_PP_EXPAND(EIGEN_VMLMODE_EXPAND_##VMLMODE));                                             \
+                (VMLTYPE*)dst_ptr EIGEN_PP_EXPAND(EIGEN_VMLMODE_EXPAND_x##VMLMODE));                                             \
         }                                                                                                                       \
       }                                                                                                                         \
     }                                                                                                                           \
   };                                                                                                                            \
 
 
 #define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL(EIGENOP, VMLOP, VMLMODE)                                                         \
@@ -148,23 +148,23 @@
     static void run(DstXprType &dst, const SrcXprType &src, const assign_op<EIGENTYPE,EIGENTYPE> &func) {                     \
       resize_if_allowed(dst, src, func);                                                                                      \
       eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());                                                     \
       VMLTYPE exponent = reinterpret_cast<const VMLTYPE&>(src.rhs().functor().m_other);                                       \
       if(vml_assign_traits<DstXprType,SrcXprNested>::Traversal==LinearTraversal)                                              \
       {                                                                                                                       \
         VMLOP( dst.size(), (const VMLTYPE*)src.lhs().data(), exponent,                                                        \
-              (VMLTYPE*)dst.data() EIGEN_PP_EXPAND(EIGEN_VMLMODE_EXPAND_##VMLMODE) );                                         \
+              (VMLTYPE*)dst.data() EIGEN_PP_EXPAND(EIGEN_VMLMODE_EXPAND_x##VMLMODE) );                                         \
       } else {                                                                                                                \
         const Index outerSize = dst.outerSize();                                                                              \
         for(Index outer = 0; outer < outerSize; ++outer) {                                                                    \
           const EIGENTYPE *src_ptr = src.IsRowMajor ? &(src.lhs().coeffRef(outer,0)) :                                        \
                                                       &(src.lhs().coeffRef(0, outer));                                        \
           EIGENTYPE *dst_ptr = dst.IsRowMajor ? &(dst.coeffRef(outer,0)) : &(dst.coeffRef(0, outer));                         \
           VMLOP( dst.innerSize(), (const VMLTYPE*)src_ptr, exponent,                                                          \
-                 (VMLTYPE*)dst_ptr EIGEN_PP_EXPAND(EIGEN_VMLMODE_EXPAND_##VMLMODE));                                          \
+                 (VMLTYPE*)dst_ptr EIGEN_PP_EXPAND(EIGEN_VMLMODE_EXPAND_x##VMLMODE));                                          \
         }                                                                                                                     \
       }                                                                                                                       \
     }                                                                                                                         \
   };
   
 EIGEN_MKL_VML_DECLARE_POW_CALL(pow, vmsPowx, float,    float,         LA)
 EIGEN_MKL_VML_DECLARE_POW_CALL(pow, vmdPowx, double,   double,        LA)
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/BandMatrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/BandMatrix.h`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_BANDMATRIX_H
 #define EIGEN_BANDMATRIX_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 
 template<typename Derived>
 class BandMatrixBase : public EigenBase<Derived>
 {
   public:
@@ -41,37 +41,37 @@
       DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))
                             ? 1 + Supers + Subs
                             : Dynamic,
       SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)
     };
 
   public:
-    
+
     using Base::derived;
     using Base::rows;
     using Base::cols;
 
     /** \returns the number of super diagonals */
     inline Index supers() const { return derived().supers(); }
 
     /** \returns the number of sub diagonals */
     inline Index subs() const { return derived().subs(); }
-    
+
     /** \returns an expression of the underlying coefficient matrix */
     inline const CoefficientsType& coeffs() const { return derived().coeffs(); }
-    
+
     /** \returns an expression of the underlying coefficient matrix */
     inline CoefficientsType& coeffs() { return derived().coeffs(); }
 
     /** \returns a vector expression of the \a i -th column,
       * only the meaningful part is returned.
       * \warning the internal storage must be column major. */
     inline Block<CoefficientsType,Dynamic,1> col(Index i)
     {
-      EIGEN_STATIC_ASSERT((Options&RowMajor)==0,THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES);
+      EIGEN_STATIC_ASSERT((int(Options) & int(RowMajor)) == 0, THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES);
       Index start = 0;
       Index len = coeffs().rows();
       if (i<=supers())
       {
         start = supers()-i;
         len = (std::min)(rows(),std::max<Index>(0,coeffs().rows() - (supers()-i)));
       }
@@ -86,15 +86,15 @@
 
     /** \returns a vector expression of the main diagonal (const version) */
     inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const
     { return Block<const CoefficientsType,1,SizeAtCompileTime>(coeffs(),supers(),0,1,(std::min)(rows(),cols())); }
 
     template<int Index> struct DiagonalIntReturnType {
       enum {
-        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),
+        ReturnOpposite = (int(Options) & int(SelfAdjoint)) && (((Index) > 0 && Supers == 0) || ((Index) < 0 && Subs == 0)),
         Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,
         ActualIndex = ReturnOpposite ? -Index : Index,
         DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)
                      ? Dynamic
                      : (ActualIndex<0
                      ? EIGEN_SIZE_MIN_PREFER_DYNAMIC(ColsAtCompileTime, RowsAtCompileTime + ActualIndex)
                      : EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime, ColsAtCompileTime - ActualIndex))
@@ -126,15 +126,15 @@
 
     /** \returns a vector expression of the \a i -th sub or super diagonal */
     inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const
     {
       eigen_assert((i<0 && -i<=subs()) || (i>=0 && i<=supers()));
       return Block<const CoefficientsType,1,Dynamic>(coeffs(), supers()-i, std::max<Index>(0,i), 1, diagonalLength(i));
     }
-    
+
     template<typename Dest> inline void evalTo(Dest& dst) const
     {
       dst.resize(rows(),cols());
       dst.setZero();
       dst.diagonal() = diagonal();
       for (Index i=1; i<=supers();++i)
         dst.diagonal(i) = diagonal(i);
@@ -188,15 +188,15 @@
     MaxColsAtCompileTime = _Cols,
     Flags = LvalueBit,
     Supers = _Supers,
     Subs = _Subs,
     Options = _Options,
     DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic
   };
-  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;
+  typedef Matrix<Scalar, DataRowsAtCompileTime, ColsAtCompileTime, int(Options) & int(RowMajor) ? RowMajor : ColMajor> CoefficientsType;
 };
 
 template<typename _Scalar, int Rows, int Cols, int Supers, int Subs, int Options>
 class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >
 {
   public:
 
@@ -207,24 +207,24 @@
     explicit inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)
       : m_coeffs(1+supers+subs,cols),
         m_rows(rows), m_supers(supers), m_subs(subs)
     {
     }
 
     /** \returns the number of columns */
-    inline Index rows() const { return m_rows.value(); }
+    inline EIGEN_CONSTEXPR Index rows() const { return m_rows.value(); }
 
     /** \returns the number of rows */
-    inline Index cols() const { return m_coeffs.cols(); }
+    inline EIGEN_CONSTEXPR Index cols() const { return m_coeffs.cols(); }
 
     /** \returns the number of super diagonals */
-    inline Index supers() const { return m_supers.value(); }
+    inline EIGEN_CONSTEXPR Index supers() const { return m_supers.value(); }
 
     /** \returns the number of sub diagonals */
-    inline Index subs() const { return m_subs.value(); }
+    inline EIGEN_CONSTEXPR Index subs() const { return m_subs.value(); }
 
     inline const CoefficientsType& coeffs() const { return m_coeffs; }
     inline CoefficientsType& coeffs() { return m_coeffs; }
 
   protected:
 
     CoefficientsType m_coeffs;
@@ -271,24 +271,24 @@
         m_rows(rows), m_supers(supers), m_subs(subs)
     {
       EIGEN_UNUSED_VARIABLE(cols);
       //internal::assert(coeffs.cols()==cols() && (supers()+subs()+1)==coeffs.rows());
     }
 
     /** \returns the number of columns */
-    inline Index rows() const { return m_rows.value(); }
+    inline EIGEN_CONSTEXPR Index rows() const { return m_rows.value(); }
 
     /** \returns the number of rows */
-    inline Index cols() const { return m_coeffs.cols(); }
+    inline EIGEN_CONSTEXPR Index cols() const { return m_coeffs.cols(); }
 
     /** \returns the number of super diagonals */
-    inline Index supers() const { return m_supers.value(); }
+    inline EIGEN_CONSTEXPR Index supers() const { return m_supers.value(); }
 
     /** \returns the number of sub diagonals */
-    inline Index subs() const { return m_subs.value(); }
+    inline EIGEN_CONSTEXPR Index subs() const { return m_subs.value(); }
 
     inline const CoefficientsType& coeffs() const { return m_coeffs; }
 
   protected:
 
     const CoefficientsType& m_coeffs;
     internal::variable_if_dynamic<Index, _Rows>   m_rows;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Block.h` & `chronogram-0.2.0/include/Eigen/src/Core/Block.h`

 * *Files 10% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_BLOCK_H
 #define EIGEN_BLOCK_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>
 struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel> > : traits<XprType>
 {
   typedef typename traits<XprType>::Scalar Scalar;
   typedef typename traits<XprType>::StorageKind StorageKind;
@@ -48,24 +48,24 @@
                              : int(inner_stride_at_compile_time<XprType>::ret),
 
     // FIXME, this traits is rather specialized for dense object and it needs to be cleaned further
     FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,
     FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,
     Flags = (traits<XprType>::Flags & (DirectAccessBit | (InnerPanel?CompressedAccessBit:0))) | FlagsLvalueBit | FlagsRowMajorBit,
     // FIXME DirectAccessBit should not be handled by expressions
-    // 
+    //
     // Alignment is needed by MapBase's assertions
     // We can sefely set it to false here. Internal alignment errors will be detected by an eigen_internal_assert in the respective evaluator
     Alignment = 0
   };
 };
 
 template<typename XprType, int BlockRows=Dynamic, int BlockCols=Dynamic, bool InnerPanel = false,
          bool HasDirectAccess = internal::has_direct_access<XprType>::ret> class BlockImpl_dense;
-         
+
 } // end namespace internal
 
 template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, typename StorageKind> class BlockImpl;
 
 /** \class Block
   * \ingroup Core_Module
   *
@@ -105,68 +105,68 @@
 {
     typedef BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, typename internal::traits<XprType>::StorageKind> Impl;
   public:
     //typedef typename Impl::Base Base;
     typedef Impl Base;
     EIGEN_GENERIC_PUBLIC_INTERFACE(Block)
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Block)
-    
+
     typedef typename internal::remove_all<XprType>::type NestedExpression;
-  
+
     /** Column or Row constructor
       */
-    EIGEN_DEVICE_FUNC
-    inline Block(XprType& xpr, Index i) : Impl(xpr,i)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Block(XprType& xpr, Index i) : Impl(xpr,i)
     {
       eigen_assert( (i>=0) && (
           ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows())
         ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols())));
     }
 
     /** Fixed-size constructor
       */
-    EIGEN_DEVICE_FUNC
-    inline Block(XprType& xpr, Index startRow, Index startCol)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Block(XprType& xpr, Index startRow, Index startCol)
       : Impl(xpr, startRow, startCol)
     {
       EIGEN_STATIC_ASSERT(RowsAtCompileTime!=Dynamic && ColsAtCompileTime!=Dynamic,THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE)
       eigen_assert(startRow >= 0 && BlockRows >= 0 && startRow + BlockRows <= xpr.rows()
              && startCol >= 0 && BlockCols >= 0 && startCol + BlockCols <= xpr.cols());
     }
 
     /** Dynamic-size constructor
       */
-    EIGEN_DEVICE_FUNC
-    inline Block(XprType& xpr,
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Block(XprType& xpr,
           Index startRow, Index startCol,
           Index blockRows, Index blockCols)
       : Impl(xpr, startRow, startCol, blockRows, blockCols)
     {
       eigen_assert((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows)
           && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols));
       eigen_assert(startRow >= 0 && blockRows >= 0 && startRow  <= xpr.rows() - blockRows
           && startCol >= 0 && blockCols >= 0 && startCol <= xpr.cols() - blockCols);
     }
 };
-         
+
 // The generic default implementation for dense block simplu forward to the internal::BlockImpl_dense
 // that must be specialized for direct and non-direct access...
 template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>
 class BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Dense>
   : public internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel>
 {
     typedef internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel> Impl;
     typedef typename XprType::StorageIndex StorageIndex;
   public:
     typedef Impl Base;
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(BlockImpl)
-    EIGEN_DEVICE_FUNC inline BlockImpl(XprType& xpr, Index i) : Impl(xpr,i) {}
-    EIGEN_DEVICE_FUNC inline BlockImpl(XprType& xpr, Index startRow, Index startCol) : Impl(xpr, startRow, startCol) {}
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE BlockImpl(XprType& xpr, Index i) : Impl(xpr,i) {}
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE BlockImpl(XprType& xpr, Index startRow, Index startCol) : Impl(xpr, startRow, startCol) {}
     EIGEN_DEVICE_FUNC
-    inline BlockImpl(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)
+    EIGEN_STRONG_INLINE BlockImpl(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)
       : Impl(xpr, startRow, startCol, blockRows, blockCols) {}
 };
 
 namespace internal {
 
 /** \internal Internal implementation of dense Blocks in the general case. */
 template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class BlockImpl_dense
@@ -290,33 +290,33 @@
     #ifdef EIGEN_PARSED_BY_DOXYGEN
     /** \sa MapBase::data() */
     EIGEN_DEVICE_FUNC inline const Scalar* data() const;
     EIGEN_DEVICE_FUNC inline Index innerStride() const;
     EIGEN_DEVICE_FUNC inline Index outerStride() const;
     #endif
 
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     const typename internal::remove_all<XprTypeNested>::type& nestedExpression() const
-    { 
-      return m_xpr; 
+    {
+      return m_xpr;
     }
 
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     XprType& nestedExpression() { return m_xpr; }
-      
-    EIGEN_DEVICE_FUNC
-    StorageIndex startRow() const
-    { 
-      return m_startRow.value(); 
+
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    StorageIndex startRow() const EIGEN_NOEXCEPT
+    {
+      return m_startRow.value();
     }
-      
-    EIGEN_DEVICE_FUNC
-    StorageIndex startCol() const
-    { 
-      return m_startCol.value(); 
+
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    StorageIndex startCol() const EIGEN_NOEXCEPT
+    {
+      return m_startCol.value();
     }
 
   protected:
 
     XprTypeNested m_xpr;
     const internal::variable_if_dynamic<StorageIndex, (XprType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;
     const internal::variable_if_dynamic<StorageIndex, (XprType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;
@@ -338,104 +338,100 @@
 
     typedef MapBase<BlockType> Base;
     EIGEN_DENSE_PUBLIC_INTERFACE(BlockType)
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(BlockImpl_dense)
 
     /** Column or Row constructor
       */
-    EIGEN_DEVICE_FUNC
-    inline BlockImpl_dense(XprType& xpr, Index i)
-      : Base(xpr.data() + i * (    ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && (!XprTypeIsRowMajor)) 
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    BlockImpl_dense(XprType& xpr, Index i)
+      : Base(xpr.data() + i * (    ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && (!XprTypeIsRowMajor))
                                 || ((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && ( XprTypeIsRowMajor)) ? xpr.innerStride() : xpr.outerStride()),
              BlockRows==1 ? 1 : xpr.rows(),
              BlockCols==1 ? 1 : xpr.cols()),
         m_xpr(xpr),
         m_startRow( (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? i : 0),
         m_startCol( (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? i : 0)
     {
       init();
     }
 
     /** Fixed-size constructor
       */
-    EIGEN_DEVICE_FUNC
-    inline BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)
       : Base(xpr.data()+xpr.innerStride()*(XprTypeIsRowMajor?startCol:startRow) + xpr.outerStride()*(XprTypeIsRowMajor?startRow:startCol)),
         m_xpr(xpr), m_startRow(startRow), m_startCol(startCol)
     {
       init();
     }
 
     /** Dynamic-size constructor
       */
-    EIGEN_DEVICE_FUNC
-    inline BlockImpl_dense(XprType& xpr,
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    BlockImpl_dense(XprType& xpr,
           Index startRow, Index startCol,
           Index blockRows, Index blockCols)
       : Base(xpr.data()+xpr.innerStride()*(XprTypeIsRowMajor?startCol:startRow) + xpr.outerStride()*(XprTypeIsRowMajor?startRow:startCol), blockRows, blockCols),
         m_xpr(xpr), m_startRow(startRow), m_startCol(startCol)
     {
       init();
     }
 
-    EIGEN_DEVICE_FUNC
-    const typename internal::remove_all<XprTypeNested>::type& nestedExpression() const
-    { 
-      return m_xpr; 
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const typename internal::remove_all<XprTypeNested>::type& nestedExpression() const EIGEN_NOEXCEPT
+    {
+      return m_xpr;
     }
 
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     XprType& nestedExpression() { return m_xpr; }
-      
+
     /** \sa MapBase::innerStride() */
-    EIGEN_DEVICE_FUNC
-    inline Index innerStride() const
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index innerStride() const EIGEN_NOEXCEPT
     {
       return internal::traits<BlockType>::HasSameStorageOrderAsXprType
              ? m_xpr.innerStride()
              : m_xpr.outerStride();
     }
 
     /** \sa MapBase::outerStride() */
-    EIGEN_DEVICE_FUNC
-    inline Index outerStride() const
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index outerStride() const EIGEN_NOEXCEPT
     {
-      return m_outerStride;
+      return internal::traits<BlockType>::HasSameStorageOrderAsXprType
+                    ? m_xpr.outerStride()
+                    : m_xpr.innerStride();
     }
 
-    EIGEN_DEVICE_FUNC
-    StorageIndex startRow() const
-    {
-      return m_startRow.value();
-    }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    StorageIndex startRow() const EIGEN_NOEXCEPT { return m_startRow.value(); }
 
-    EIGEN_DEVICE_FUNC
-    StorageIndex startCol() const
-    {
-      return m_startCol.value();
-    }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    StorageIndex startCol() const EIGEN_NOEXCEPT { return m_startCol.value(); }
 
   #ifndef __SUNPRO_CC
   // FIXME sunstudio is not friendly with the above friend...
   // META-FIXME there is no 'friend' keyword around here. Is this obsolete?
   protected:
   #endif
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     /** \internal used by allowAligned() */
-    EIGEN_DEVICE_FUNC
-    inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)
       : Base(data, blockRows, blockCols), m_xpr(xpr)
     {
       init();
     }
     #endif
 
   protected:
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     void init()
     {
       m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType
                     ? m_xpr.outerStride()
                     : m_xpr.innerStride();
     }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/CommaInitializer.h` & `chronogram-0.2.0/include/Eigen/src/Core/CommaInitializer.h`

 * *Files 6% similar despite different names*

```diff
@@ -29,22 +29,26 @@
 {
   typedef typename XprType::Scalar Scalar;
 
   EIGEN_DEVICE_FUNC
   inline CommaInitializer(XprType& xpr, const Scalar& s)
     : m_xpr(xpr), m_row(0), m_col(1), m_currentBlockRows(1)
   {
+    eigen_assert(m_xpr.rows() > 0 && m_xpr.cols() > 0
+      && "Cannot comma-initialize a 0x0 matrix (operator<<)");
     m_xpr.coeffRef(0,0) = s;
   }
 
   template<typename OtherDerived>
   EIGEN_DEVICE_FUNC
   inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)
     : m_xpr(xpr), m_row(0), m_col(other.cols()), m_currentBlockRows(other.rows())
   {
+    eigen_assert(m_xpr.rows() >= other.rows() && m_xpr.cols() >= other.cols()
+      && "Cannot comma-initialize a 0x0 matrix (operator<<)");
     m_xpr.block(0, 0, other.rows(), other.cols()) = other;
   }
 
   /* Copy/Move constructor which transfers ownership. This is crucial in 
    * absence of return value optimization to avoid assertions during destruction. */
   // FIXME in C++11 mode this could be replaced by a proper RValue constructor
   EIGEN_DEVICE_FUNC
@@ -99,15 +103,15 @@
 
   EIGEN_DEVICE_FUNC
   inline ~CommaInitializer()
 #if defined VERIFY_RAISES_ASSERT && (!defined EIGEN_NO_ASSERTION_CHECKING) && defined EIGEN_EXCEPTIONS
   EIGEN_EXCEPTION_SPEC(Eigen::eigen_assert_exception)
 #endif
   {
-      finished();
+    finished();
   }
 
   /** \returns the built matrix once all its coefficients have been set.
     * Calling finished is 100% optional. Its purpose is to write expressions
     * like this:
     * \code
     * quaternion.fromRotationMatrix((Matrix3f() << axis0, axis1, axis2).finished());
@@ -137,23 +141,23 @@
   * Output: \verbinclude MatrixBase_set.out
   * 
   * \note According the c++ standard, the argument expressions of this comma initializer are evaluated in arbitrary order.
   *
   * \sa CommaInitializer::finished(), class CommaInitializer
   */
 template<typename Derived>
-inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)
+EIGEN_DEVICE_FUNC inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)
 {
   return CommaInitializer<Derived>(*static_cast<Derived*>(this), s);
 }
 
 /** \sa operator<<(const Scalar&) */
 template<typename Derived>
 template<typename OtherDerived>
-inline CommaInitializer<Derived>
+EIGEN_DEVICE_FUNC inline CommaInitializer<Derived>
 DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)
 {
   return CommaInitializer<Derived>(*static_cast<Derived *>(this), other);
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/ConditionEstimator.h` & `chronogram-0.2.0/include/Eigen/src/Core/ConditionEstimator.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/CoreEvaluators.h` & `chronogram-0.2.0/include/Eigen/src/Core/CoreEvaluators.h`

 * *Files 7% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 
 #ifndef EIGEN_COREEVALUATORS_H
 #define EIGEN_COREEVALUATORS_H
 
 namespace Eigen {
-  
+
 namespace internal {
 
 // This class returns the evaluator kind from the expression storage kind.
 // Default assumes index based accessors
 template<typename StorageKind>
 struct storage_kind_to_evaluator_kind {
   typedef IndexBased Kind;
@@ -59,16 +59,16 @@
           typename RhsKind   = typename evaluator_traits<typename T::Rhs>::Kind,
           typename LhsScalar = typename traits<typename T::Lhs>::Scalar,
           typename RhsScalar = typename traits<typename T::Rhs>::Scalar> struct binary_evaluator;
 
 template< typename T,
           typename Kind   = typename evaluator_traits<typename T::NestedExpression>::Kind,
           typename Scalar = typename T::Scalar> struct unary_evaluator;
-          
-// evaluator_traits<T> contains traits for evaluator<T> 
+
+// evaluator_traits<T> contains traits for evaluator<T>
 
 template<typename T>
 struct evaluator_traits_base
 {
   // by default, get evaluator kind and shape from storage
   typedef typename storage_kind_to_evaluator_kind<typename traits<T>::StorageKind>::Kind Kind;
   typedef typename storage_kind_to_shape<typename traits<T>::StorageKind>::Shape Shape;
@@ -86,197 +86,239 @@
 };
 
 // By default, we assume a unary expression:
 template<typename T>
 struct evaluator : public unary_evaluator<T>
 {
   typedef unary_evaluator<T> Base;
-  EIGEN_DEVICE_FUNC explicit evaluator(const T& xpr) : Base(xpr) {}
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const T& xpr) : Base(xpr) {}
 };
 
 
 // TODO: Think about const-correctness
 template<typename T>
 struct evaluator<const T>
   : evaluator<T>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   explicit evaluator(const T& xpr) : evaluator<T>(xpr) {}
 };
 
 // ---------- base class for all evaluators ----------
 
 template<typename ExpressionType>
-struct evaluator_base : public noncopyable
+struct evaluator_base
 {
   // TODO that's not very nice to have to propagate all these traits. They are currently only needed to handle outer,inner indices.
   typedef traits<ExpressionType> ExpressionTraits;
-  
+
   enum {
     Alignment = 0
   };
+  // noncopyable:
+  // Don't make this class inherit noncopyable as this kills EBO (Empty Base Optimization)
+  // and make complex evaluator much larger than then should do.
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE evaluator_base() {}
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ~evaluator_base() {}
+private:
+  EIGEN_DEVICE_FUNC evaluator_base(const evaluator_base&);
+  EIGEN_DEVICE_FUNC const evaluator_base& operator=(const evaluator_base&);
 };
 
 // -------------------- Matrix and Array --------------------
 //
 // evaluator<PlainObjectBase> is a common base class for the
 // Matrix and Array evaluators.
 // Here we directly specialize evaluator. This is not really a unary expression, and it is, by definition, dense,
 // so no need for more sophisticated dispatching.
 
+// this helper permits to completely eliminate m_outerStride if it is known at compiletime.
+template<typename Scalar,int OuterStride> class plainobjectbase_evaluator_data {
+public:
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  plainobjectbase_evaluator_data(const Scalar* ptr, Index outerStride) : data(ptr)
+  {
+#ifndef EIGEN_INTERNAL_DEBUGGING
+    EIGEN_UNUSED_VARIABLE(outerStride);
+#endif
+    eigen_internal_assert(outerStride==OuterStride);
+  }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+  Index outerStride() const EIGEN_NOEXCEPT { return OuterStride; }
+  const Scalar *data;
+};
+
+template<typename Scalar> class plainobjectbase_evaluator_data<Scalar,Dynamic> {
+public:
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  plainobjectbase_evaluator_data(const Scalar* ptr, Index outerStride) : data(ptr), m_outerStride(outerStride) {}
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  Index outerStride() const { return m_outerStride; }
+  const Scalar *data;
+protected:
+  Index m_outerStride;
+};
+
 template<typename Derived>
 struct evaluator<PlainObjectBase<Derived> >
   : evaluator_base<Derived>
 {
   typedef PlainObjectBase<Derived> PlainObjectType;
   typedef typename PlainObjectType::Scalar Scalar;
   typedef typename PlainObjectType::CoeffReturnType CoeffReturnType;
 
   enum {
     IsRowMajor = PlainObjectType::IsRowMajor,
     IsVectorAtCompileTime = PlainObjectType::IsVectorAtCompileTime,
     RowsAtCompileTime = PlainObjectType::RowsAtCompileTime,
     ColsAtCompileTime = PlainObjectType::ColsAtCompileTime,
-    
+
     CoeffReadCost = NumTraits<Scalar>::ReadCost,
     Flags = traits<Derived>::EvaluatorFlags,
     Alignment = traits<Derived>::Alignment
   };
-  
-  EIGEN_DEVICE_FUNC evaluator()
-    : m_data(0),
-      m_outerStride(IsVectorAtCompileTime  ? 0 
-                                           : int(IsRowMajor) ? ColsAtCompileTime 
-                                           : RowsAtCompileTime)
+  enum {
+    // We do not need to know the outer stride for vectors
+    OuterStrideAtCompileTime = IsVectorAtCompileTime  ? 0
+                                                      : int(IsRowMajor) ? ColsAtCompileTime
+                                                                        : RowsAtCompileTime
+  };
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  evaluator()
+    : m_d(0,OuterStrideAtCompileTime)
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
-  
-  EIGEN_DEVICE_FUNC explicit evaluator(const PlainObjectType& m)
-    : m_data(m.data()), m_outerStride(IsVectorAtCompileTime ? 0 : m.outerStride()) 
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const PlainObjectType& m)
+    : m_d(m.data(),IsVectorAtCompileTime ? 0 : m.outerStride())
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
     if (IsRowMajor)
-      return m_data[row * m_outerStride.value() + col];
+      return m_d.data[row * m_d.outerStride() + col];
     else
-      return m_data[row + col * m_outerStride.value()];
+      return m_d.data[row + col * m_d.outerStride()];
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index index) const
   {
-    return m_data[index];
+    return m_d.data[index];
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   Scalar& coeffRef(Index row, Index col)
   {
     if (IsRowMajor)
-      return const_cast<Scalar*>(m_data)[row * m_outerStride.value() + col];
+      return const_cast<Scalar*>(m_d.data)[row * m_d.outerStride() + col];
     else
-      return const_cast<Scalar*>(m_data)[row + col * m_outerStride.value()];
+      return const_cast<Scalar*>(m_d.data)[row + col * m_d.outerStride()];
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   Scalar& coeffRef(Index index)
   {
-    return const_cast<Scalar*>(m_data)[index];
+    return const_cast<Scalar*>(m_d.data)[index];
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index row, Index col) const
   {
     if (IsRowMajor)
-      return ploadt<PacketType, LoadMode>(m_data + row * m_outerStride.value() + col);
+      return ploadt<PacketType, LoadMode>(m_d.data + row * m_d.outerStride() + col);
     else
-      return ploadt<PacketType, LoadMode>(m_data + row + col * m_outerStride.value());
+      return ploadt<PacketType, LoadMode>(m_d.data + row + col * m_d.outerStride());
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index index) const
   {
-    return ploadt<PacketType, LoadMode>(m_data + index);
+    return ploadt<PacketType, LoadMode>(m_d.data + index);
   }
 
   template<int StoreMode,typename PacketType>
   EIGEN_STRONG_INLINE
   void writePacket(Index row, Index col, const PacketType& x)
   {
     if (IsRowMajor)
       return pstoret<Scalar, PacketType, StoreMode>
-	            (const_cast<Scalar*>(m_data) + row * m_outerStride.value() + col, x);
+	            (const_cast<Scalar*>(m_d.data) + row * m_d.outerStride() + col, x);
     else
       return pstoret<Scalar, PacketType, StoreMode>
-                    (const_cast<Scalar*>(m_data) + row + col * m_outerStride.value(), x);
+                    (const_cast<Scalar*>(m_d.data) + row + col * m_d.outerStride(), x);
   }
 
   template<int StoreMode, typename PacketType>
   EIGEN_STRONG_INLINE
   void writePacket(Index index, const PacketType& x)
   {
-    return pstoret<Scalar, PacketType, StoreMode>(const_cast<Scalar*>(m_data) + index, x);
+    return pstoret<Scalar, PacketType, StoreMode>(const_cast<Scalar*>(m_d.data) + index, x);
   }
 
 protected:
-  const Scalar *m_data;
 
-  // We do not need to know the outer stride for vectors
-  variable_if_dynamic<Index, IsVectorAtCompileTime  ? 0 
-                                                    : int(IsRowMajor) ? ColsAtCompileTime 
-                                                    : RowsAtCompileTime> m_outerStride;
+  plainobjectbase_evaluator_data<Scalar,OuterStrideAtCompileTime> m_d;
 };
 
 template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
 struct evaluator<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
   : evaluator<PlainObjectBase<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
 {
   typedef Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
-  
-  EIGEN_DEVICE_FUNC evaluator() {}
 
-  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& m)
-    : evaluator<PlainObjectBase<XprType> >(m) 
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  evaluator() {}
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const XprType& m)
+    : evaluator<PlainObjectBase<XprType> >(m)
   { }
 };
 
 template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
 struct evaluator<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
   : evaluator<PlainObjectBase<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> > >
 {
   typedef Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> XprType;
 
-  EIGEN_DEVICE_FUNC evaluator() {}
-  
-  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& m)
-    : evaluator<PlainObjectBase<XprType> >(m) 
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  evaluator() {}
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const XprType& m)
+    : evaluator<PlainObjectBase<XprType> >(m)
   { }
 };
 
 // -------------------- Transpose --------------------
 
 template<typename ArgType>
 struct unary_evaluator<Transpose<ArgType>, IndexBased>
   : evaluator_base<Transpose<ArgType> >
 {
   typedef Transpose<ArgType> XprType;
-  
+
   enum {
-    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,    
+    CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
     Flags = evaluator<ArgType>::Flags ^ RowMajorBit,
     Alignment = evaluator<ArgType>::Alignment
   };
 
-  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& t) : m_argImpl(t.nestedExpression()) {}
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit unary_evaluator(const XprType& t) : m_argImpl(t.nestedExpression()) {}
 
   typedef typename XprType::Scalar Scalar;
   typedef typename XprType::CoeffReturnType CoeffReturnType;
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
@@ -453,18 +495,18 @@
 
 template<typename NullaryOp, typename PlainObjectType>
 struct evaluator<CwiseNullaryOp<NullaryOp,PlainObjectType> >
   : evaluator_base<CwiseNullaryOp<NullaryOp,PlainObjectType> >
 {
   typedef CwiseNullaryOp<NullaryOp,PlainObjectType> XprType;
   typedef typename internal::remove_all<PlainObjectType>::type PlainObjectTypeCleaned;
-  
+
   enum {
     CoeffReadCost = internal::functor_traits<NullaryOp>::Cost,
-    
+
     Flags = (evaluator<PlainObjectTypeCleaned>::Flags
           &  (  HereditaryBits
               | (functor_has_linear_access<NullaryOp>::ret  ? LinearAccessBit : 0)
               | (functor_traits<NullaryOp>::PacketAccess    ? PacketAccessBit : 0)))
           | (functor_traits<NullaryOp>::IsRepeatable ? 0 : EvalBeforeNestingBit),
     Alignment = AlignedMax
   };
@@ -513,87 +555,96 @@
 // -------------------- CwiseUnaryOp --------------------
 
 template<typename UnaryOp, typename ArgType>
 struct unary_evaluator<CwiseUnaryOp<UnaryOp, ArgType>, IndexBased >
   : evaluator_base<CwiseUnaryOp<UnaryOp, ArgType> >
 {
   typedef CwiseUnaryOp<UnaryOp, ArgType> XprType;
-  
+
   enum {
-    CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,
-    
+    CoeffReadCost = int(evaluator<ArgType>::CoeffReadCost) + int(functor_traits<UnaryOp>::Cost),
+
     Flags = evaluator<ArgType>::Flags
           & (HereditaryBits | LinearAccessBit | (functor_traits<UnaryOp>::PacketAccess ? PacketAccessBit : 0)),
     Alignment = evaluator<ArgType>::Alignment
   };
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
-  explicit unary_evaluator(const XprType& op)
-    : m_functor(op.functor()), 
-      m_argImpl(op.nestedExpression()) 
+  explicit unary_evaluator(const XprType& op) : m_d(op)
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<UnaryOp>::Cost);
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
 
   typedef typename XprType::CoeffReturnType CoeffReturnType;
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
-    return m_functor(m_argImpl.coeff(row, col));
+    return m_d.func()(m_d.argImpl.coeff(row, col));
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index index) const
   {
-    return m_functor(m_argImpl.coeff(index));
+    return m_d.func()(m_d.argImpl.coeff(index));
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index row, Index col) const
   {
-    return m_functor.packetOp(m_argImpl.template packet<LoadMode, PacketType>(row, col));
+    return m_d.func().packetOp(m_d.argImpl.template packet<LoadMode, PacketType>(row, col));
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index index) const
   {
-    return m_functor.packetOp(m_argImpl.template packet<LoadMode, PacketType>(index));
+    return m_d.func().packetOp(m_d.argImpl.template packet<LoadMode, PacketType>(index));
   }
 
 protected:
-  const UnaryOp m_functor;
-  evaluator<ArgType> m_argImpl;
+
+  // this helper permits to completely eliminate the functor if it is empty
+  struct Data
+  {
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Data(const XprType& xpr) : op(xpr.functor()), argImpl(xpr.nestedExpression()) {}
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const UnaryOp& func() const { return op; }
+    UnaryOp op;
+    evaluator<ArgType> argImpl;
+  };
+
+  Data m_d;
 };
 
 // -------------------- CwiseTernaryOp --------------------
 
 // this is a ternary expression
 template<typename TernaryOp, typename Arg1, typename Arg2, typename Arg3>
 struct evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >
   : public ternary_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >
 {
   typedef CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> XprType;
   typedef ternary_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> > Base;
-  
+
   EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr) : Base(xpr) {}
 };
 
 template<typename TernaryOp, typename Arg1, typename Arg2, typename Arg3>
 struct ternary_evaluator<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3>, IndexBased, IndexBased>
   : evaluator_base<CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> >
 {
   typedef CwiseTernaryOp<TernaryOp, Arg1, Arg2, Arg3> XprType;
-  
+
   enum {
-    CoeffReadCost = evaluator<Arg1>::CoeffReadCost + evaluator<Arg2>::CoeffReadCost + evaluator<Arg3>::CoeffReadCost + functor_traits<TernaryOp>::Cost,
-    
+    CoeffReadCost = int(evaluator<Arg1>::CoeffReadCost) + int(evaluator<Arg2>::CoeffReadCost) + int(evaluator<Arg3>::CoeffReadCost) + int(functor_traits<TernaryOp>::Cost),
+
     Arg1Flags = evaluator<Arg1>::Flags,
     Arg2Flags = evaluator<Arg2>::Flags,
     Arg3Flags = evaluator<Arg3>::Flags,
     SameType = is_same<typename Arg1::Scalar,typename Arg2::Scalar>::value && is_same<typename Arg1::Scalar,typename Arg3::Scalar>::value,
     StorageOrdersAgree = (int(Arg1Flags)&RowMajorBit)==(int(Arg2Flags)&RowMajorBit) && (int(Arg1Flags)&RowMajorBit)==(int(Arg3Flags)&RowMajorBit),
     Flags0 = (int(Arg1Flags) | int(Arg2Flags) | int(Arg3Flags)) & (
         HereditaryBits
@@ -605,85 +656,92 @@
      ),
     Flags = (Flags0 & ~RowMajorBit) | (Arg1Flags & RowMajorBit),
     Alignment = EIGEN_PLAIN_ENUM_MIN(
         EIGEN_PLAIN_ENUM_MIN(evaluator<Arg1>::Alignment, evaluator<Arg2>::Alignment),
         evaluator<Arg3>::Alignment)
   };
 
-  EIGEN_DEVICE_FUNC explicit ternary_evaluator(const XprType& xpr)
-    : m_functor(xpr.functor()),
-      m_arg1Impl(xpr.arg1()), 
-      m_arg2Impl(xpr.arg2()), 
-      m_arg3Impl(xpr.arg3())  
+  EIGEN_DEVICE_FUNC explicit ternary_evaluator(const XprType& xpr) : m_d(xpr)
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<TernaryOp>::Cost);
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
 
   typedef typename XprType::CoeffReturnType CoeffReturnType;
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
-    return m_functor(m_arg1Impl.coeff(row, col), m_arg2Impl.coeff(row, col), m_arg3Impl.coeff(row, col));
+    return m_d.func()(m_d.arg1Impl.coeff(row, col), m_d.arg2Impl.coeff(row, col), m_d.arg3Impl.coeff(row, col));
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index index) const
   {
-    return m_functor(m_arg1Impl.coeff(index), m_arg2Impl.coeff(index), m_arg3Impl.coeff(index));
+    return m_d.func()(m_d.arg1Impl.coeff(index), m_d.arg2Impl.coeff(index), m_d.arg3Impl.coeff(index));
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index row, Index col) const
   {
-    return m_functor.packetOp(m_arg1Impl.template packet<LoadMode,PacketType>(row, col),
-                              m_arg2Impl.template packet<LoadMode,PacketType>(row, col),
-                              m_arg3Impl.template packet<LoadMode,PacketType>(row, col));
+    return m_d.func().packetOp(m_d.arg1Impl.template packet<LoadMode,PacketType>(row, col),
+                               m_d.arg2Impl.template packet<LoadMode,PacketType>(row, col),
+                               m_d.arg3Impl.template packet<LoadMode,PacketType>(row, col));
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index index) const
   {
-    return m_functor.packetOp(m_arg1Impl.template packet<LoadMode,PacketType>(index),
-                              m_arg2Impl.template packet<LoadMode,PacketType>(index),
-                              m_arg3Impl.template packet<LoadMode,PacketType>(index));
+    return m_d.func().packetOp(m_d.arg1Impl.template packet<LoadMode,PacketType>(index),
+                               m_d.arg2Impl.template packet<LoadMode,PacketType>(index),
+                               m_d.arg3Impl.template packet<LoadMode,PacketType>(index));
   }
 
 protected:
-  const TernaryOp m_functor;
-  evaluator<Arg1> m_arg1Impl;
-  evaluator<Arg2> m_arg2Impl;
-  evaluator<Arg3> m_arg3Impl;
+  // this helper permits to completely eliminate the functor if it is empty
+  struct Data
+  {
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Data(const XprType& xpr) : op(xpr.functor()), arg1Impl(xpr.arg1()), arg2Impl(xpr.arg2()), arg3Impl(xpr.arg3()) {}
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const TernaryOp& func() const { return op; }
+    TernaryOp op;
+    evaluator<Arg1> arg1Impl;
+    evaluator<Arg2> arg2Impl;
+    evaluator<Arg3> arg3Impl;
+  };
+
+  Data m_d;
 };
 
 // -------------------- CwiseBinaryOp --------------------
 
 // this is a binary expression
 template<typename BinaryOp, typename Lhs, typename Rhs>
 struct evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
   : public binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
 {
   typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
   typedef binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs> > Base;
-  
-  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr) : Base(xpr) {}
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const XprType& xpr) : Base(xpr) {}
 };
 
 template<typename BinaryOp, typename Lhs, typename Rhs>
 struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>, IndexBased, IndexBased>
   : evaluator_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >
 {
   typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;
-  
+
   enum {
-    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
-    
+    CoeffReadCost = int(evaluator<Lhs>::CoeffReadCost) + int(evaluator<Rhs>::CoeffReadCost) + int(functor_traits<BinaryOp>::Cost),
+
     LhsFlags = evaluator<Lhs>::Flags,
     RhsFlags = evaluator<Rhs>::Flags,
     SameType = is_same<typename Lhs::Scalar,typename Rhs::Scalar>::value,
     StorageOrdersAgree = (int(LhsFlags)&RowMajorBit)==(int(RhsFlags)&RowMajorBit),
     Flags0 = (int(LhsFlags) | int(RhsFlags)) & (
         HereditaryBits
       | (int(LhsFlags) & int(RhsFlags) &
@@ -692,113 +750,131 @@
            )
         )
      ),
     Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),
     Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<Lhs>::Alignment,evaluator<Rhs>::Alignment)
   };
 
-  EIGEN_DEVICE_FUNC explicit binary_evaluator(const XprType& xpr)
-    : m_functor(xpr.functor()),
-      m_lhsImpl(xpr.lhs()), 
-      m_rhsImpl(xpr.rhs())  
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit binary_evaluator(const XprType& xpr) : m_d(xpr)
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<BinaryOp>::Cost);
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
 
   typedef typename XprType::CoeffReturnType CoeffReturnType;
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
-    return m_functor(m_lhsImpl.coeff(row, col), m_rhsImpl.coeff(row, col));
+    return m_d.func()(m_d.lhsImpl.coeff(row, col), m_d.rhsImpl.coeff(row, col));
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index index) const
   {
-    return m_functor(m_lhsImpl.coeff(index), m_rhsImpl.coeff(index));
+    return m_d.func()(m_d.lhsImpl.coeff(index), m_d.rhsImpl.coeff(index));
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index row, Index col) const
   {
-    return m_functor.packetOp(m_lhsImpl.template packet<LoadMode,PacketType>(row, col),
-                              m_rhsImpl.template packet<LoadMode,PacketType>(row, col));
+    return m_d.func().packetOp(m_d.lhsImpl.template packet<LoadMode,PacketType>(row, col),
+                               m_d.rhsImpl.template packet<LoadMode,PacketType>(row, col));
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index index) const
   {
-    return m_functor.packetOp(m_lhsImpl.template packet<LoadMode,PacketType>(index),
-                              m_rhsImpl.template packet<LoadMode,PacketType>(index));
+    return m_d.func().packetOp(m_d.lhsImpl.template packet<LoadMode,PacketType>(index),
+                               m_d.rhsImpl.template packet<LoadMode,PacketType>(index));
   }
 
 protected:
-  const BinaryOp m_functor;
-  evaluator<Lhs> m_lhsImpl;
-  evaluator<Rhs> m_rhsImpl;
+
+  // this helper permits to completely eliminate the functor if it is empty
+  struct Data
+  {
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Data(const XprType& xpr) : op(xpr.functor()), lhsImpl(xpr.lhs()), rhsImpl(xpr.rhs()) {}
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const BinaryOp& func() const { return op; }
+    BinaryOp op;
+    evaluator<Lhs> lhsImpl;
+    evaluator<Rhs> rhsImpl;
+  };
+
+  Data m_d;
 };
 
 // -------------------- CwiseUnaryView --------------------
 
 template<typename UnaryOp, typename ArgType>
 struct unary_evaluator<CwiseUnaryView<UnaryOp, ArgType>, IndexBased>
   : evaluator_base<CwiseUnaryView<UnaryOp, ArgType> >
 {
   typedef CwiseUnaryView<UnaryOp, ArgType> XprType;
-  
+
   enum {
-    CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,
-    
+    CoeffReadCost = int(evaluator<ArgType>::CoeffReadCost) + int(functor_traits<UnaryOp>::Cost),
+
     Flags = (evaluator<ArgType>::Flags & (HereditaryBits | LinearAccessBit | DirectAccessBit)),
-    
+
     Alignment = 0 // FIXME it is not very clear why alignment is necessarily lost...
   };
 
-  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& op)
-    : m_unaryOp(op.functor()), 
-      m_argImpl(op.nestedExpression()) 
+  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& op) : m_d(op)
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<UnaryOp>::Cost);
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
 
   typedef typename XprType::Scalar Scalar;
   typedef typename XprType::CoeffReturnType CoeffReturnType;
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
-    return m_unaryOp(m_argImpl.coeff(row, col));
+    return m_d.func()(m_d.argImpl.coeff(row, col));
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index index) const
   {
-    return m_unaryOp(m_argImpl.coeff(index));
+    return m_d.func()(m_d.argImpl.coeff(index));
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   Scalar& coeffRef(Index row, Index col)
   {
-    return m_unaryOp(m_argImpl.coeffRef(row, col));
+    return m_d.func()(m_d.argImpl.coeffRef(row, col));
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   Scalar& coeffRef(Index index)
   {
-    return m_unaryOp(m_argImpl.coeffRef(index));
+    return m_d.func()(m_d.argImpl.coeffRef(index));
   }
 
 protected:
-  const UnaryOp m_unaryOp;
-  evaluator<ArgType> m_argImpl;
+
+  // this helper permits to completely eliminate the functor if it is empty
+  struct Data
+  {
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Data(const XprType& xpr) : op(xpr.functor()), argImpl(xpr.nestedExpression()) {}
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const UnaryOp& func() const { return op; }
+    UnaryOp op;
+    evaluator<ArgType> argImpl;
+  };
+
+  Data m_d;
 };
 
 // -------------------- Map --------------------
 
 // FIXME perhaps the PlainObjectType could be provided by Derived::PlainObject ?
 // but that might complicate template specialization
 template<typename Derived, typename PlainObjectType>
@@ -807,22 +883,23 @@
 template<typename Derived, typename PlainObjectType>
 struct mapbase_evaluator : evaluator_base<Derived>
 {
   typedef Derived  XprType;
   typedef typename XprType::PointerType PointerType;
   typedef typename XprType::Scalar Scalar;
   typedef typename XprType::CoeffReturnType CoeffReturnType;
-  
+
   enum {
     IsRowMajor = XprType::RowsAtCompileTime,
     ColsAtCompileTime = XprType::ColsAtCompileTime,
     CoeffReadCost = NumTraits<Scalar>::ReadCost
   };
 
-  EIGEN_DEVICE_FUNC explicit mapbase_evaluator(const XprType& map)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit mapbase_evaluator(const XprType& map)
     : m_data(const_cast<PointerType>(map.data())),
       m_innerStride(map.innerStride()),
       m_outerStride(map.outerStride())
   {
     EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(evaluator<Derived>::Flags&PacketAccessBit, internal::inner_stride_at_compile_time<Derived>::ret==1),
                         PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1);
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
@@ -878,251 +955,276 @@
   template<int StoreMode, typename PacketType>
   EIGEN_STRONG_INLINE
   void writePacket(Index index, const PacketType& x)
   {
     internal::pstoret<Scalar, PacketType, StoreMode>(m_data + index * m_innerStride.value(), x);
   }
 protected:
-  EIGEN_DEVICE_FUNC
-  inline Index rowStride() const { return XprType::IsRowMajor ? m_outerStride.value() : m_innerStride.value(); }
-  EIGEN_DEVICE_FUNC
-  inline Index colStride() const { return XprType::IsRowMajor ? m_innerStride.value() : m_outerStride.value(); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+  Index rowStride() const EIGEN_NOEXCEPT {
+    return XprType::IsRowMajor ? m_outerStride.value() : m_innerStride.value();
+  }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+  Index colStride() const EIGEN_NOEXCEPT {
+     return XprType::IsRowMajor ? m_innerStride.value() : m_outerStride.value();
+  }
 
   PointerType m_data;
   const internal::variable_if_dynamic<Index, XprType::InnerStrideAtCompileTime> m_innerStride;
   const internal::variable_if_dynamic<Index, XprType::OuterStrideAtCompileTime> m_outerStride;
 };
 
-template<typename PlainObjectType, int MapOptions, typename StrideType> 
+template<typename PlainObjectType, int MapOptions, typename StrideType>
 struct evaluator<Map<PlainObjectType, MapOptions, StrideType> >
   : public mapbase_evaluator<Map<PlainObjectType, MapOptions, StrideType>, PlainObjectType>
 {
   typedef Map<PlainObjectType, MapOptions, StrideType> XprType;
   typedef typename XprType::Scalar Scalar;
   // TODO: should check for smaller packet types once we can handle multi-sized packet types
   typedef typename packet_traits<Scalar>::type PacketScalar;
-  
+
   enum {
     InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0
                              ? int(PlainObjectType::InnerStrideAtCompileTime)
                              : int(StrideType::InnerStrideAtCompileTime),
     OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0
                              ? int(PlainObjectType::OuterStrideAtCompileTime)
                              : int(StrideType::OuterStrideAtCompileTime),
     HasNoInnerStride = InnerStrideAtCompileTime == 1,
     HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,
     HasNoStride = HasNoInnerStride && HasNoOuterStride,
     IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,
-    
+
     PacketAccessMask = bool(HasNoInnerStride) ? ~int(0) : ~int(PacketAccessBit),
     LinearAccessMask = bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime) ? ~int(0) : ~int(LinearAccessBit),
     Flags = int( evaluator<PlainObjectType>::Flags) & (LinearAccessMask&PacketAccessMask),
-    
+
     Alignment = int(MapOptions)&int(AlignedMask)
   };
 
   EIGEN_DEVICE_FUNC explicit evaluator(const XprType& map)
-    : mapbase_evaluator<XprType, PlainObjectType>(map) 
+    : mapbase_evaluator<XprType, PlainObjectType>(map)
   { }
 };
 
 // -------------------- Ref --------------------
 
-template<typename PlainObjectType, int RefOptions, typename StrideType> 
+template<typename PlainObjectType, int RefOptions, typename StrideType>
 struct evaluator<Ref<PlainObjectType, RefOptions, StrideType> >
   : public mapbase_evaluator<Ref<PlainObjectType, RefOptions, StrideType>, PlainObjectType>
 {
   typedef Ref<PlainObjectType, RefOptions, StrideType> XprType;
-  
+
   enum {
     Flags = evaluator<Map<PlainObjectType, RefOptions, StrideType> >::Flags,
     Alignment = evaluator<Map<PlainObjectType, RefOptions, StrideType> >::Alignment
   };
 
-  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& ref)
-    : mapbase_evaluator<XprType, PlainObjectType>(ref) 
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const XprType& ref)
+    : mapbase_evaluator<XprType, PlainObjectType>(ref)
   { }
 };
 
 // -------------------- Block --------------------
 
 template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel,
          bool HasDirectAccess = internal::has_direct_access<ArgType>::ret> struct block_evaluator;
-         
-template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel> 
+
+template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
 struct evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
   : block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel>
 {
   typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
   typedef typename XprType::Scalar Scalar;
   // TODO: should check for smaller packet types once we can handle multi-sized packet types
   typedef typename packet_traits<Scalar>::type PacketScalar;
-  
+
   enum {
     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
-    
+
     RowsAtCompileTime = traits<XprType>::RowsAtCompileTime,
     ColsAtCompileTime = traits<XprType>::ColsAtCompileTime,
     MaxRowsAtCompileTime = traits<XprType>::MaxRowsAtCompileTime,
     MaxColsAtCompileTime = traits<XprType>::MaxColsAtCompileTime,
-    
+
     ArgTypeIsRowMajor = (int(evaluator<ArgType>::Flags)&RowMajorBit) != 0,
     IsRowMajor = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? 1
                : (MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1) ? 0
                : ArgTypeIsRowMajor,
     HasSameStorageOrderAsArgType = (IsRowMajor == ArgTypeIsRowMajor),
     InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),
     InnerStrideAtCompileTime = HasSameStorageOrderAsArgType
                              ? int(inner_stride_at_compile_time<ArgType>::ret)
                              : int(outer_stride_at_compile_time<ArgType>::ret),
     OuterStrideAtCompileTime = HasSameStorageOrderAsArgType
                              ? int(outer_stride_at_compile_time<ArgType>::ret)
                              : int(inner_stride_at_compile_time<ArgType>::ret),
     MaskPacketAccessBit = (InnerStrideAtCompileTime == 1 || HasSameStorageOrderAsArgType) ? PacketAccessBit : 0,
-    
-    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (evaluator<ArgType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0,    
+
+    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (evaluator<ArgType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0,
     FlagsRowMajorBit = XprType::Flags&RowMajorBit,
     Flags0 = evaluator<ArgType>::Flags & ( (HereditaryBits & ~RowMajorBit) |
                                            DirectAccessBit |
                                            MaskPacketAccessBit),
     Flags = Flags0 | FlagsLinearAccessBit | FlagsRowMajorBit,
-    
+
     PacketAlignment = unpacket_traits<PacketScalar>::alignment,
     Alignment0 = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic)
                              && (OuterStrideAtCompileTime!=0)
                              && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % int(PacketAlignment)) == 0)) ? int(PacketAlignment) : 0,
     Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ArgType>::Alignment, Alignment0)
   };
   typedef block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel> block_evaluator_type;
-  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& block) : block_evaluator_type(block)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const XprType& block) : block_evaluator_type(block)
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
 };
 
 // no direct-access => dispatch to a unary evaluator
 template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
 struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, /*HasDirectAccess*/ false>
   : unary_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
 {
   typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
 
-  EIGEN_DEVICE_FUNC explicit block_evaluator(const XprType& block)
-    : unary_evaluator<XprType>(block) 
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit block_evaluator(const XprType& block)
+    : unary_evaluator<XprType>(block)
   {}
 };
 
 template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
 struct unary_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>, IndexBased>
   : evaluator_base<Block<ArgType, BlockRows, BlockCols, InnerPanel> >
 {
   typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
 
-  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& block)
-    : m_argImpl(block.nestedExpression()), 
-      m_startRow(block.startRow()), 
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit unary_evaluator(const XprType& block)
+    : m_argImpl(block.nestedExpression()),
+      m_startRow(block.startRow()),
       m_startCol(block.startCol()),
-      m_linear_offset(InnerPanel?(XprType::IsRowMajor ? block.startRow()*block.cols() : block.startCol()*block.rows()):0)
+      m_linear_offset(ForwardLinearAccess?(ArgType::IsRowMajor ? block.startRow()*block.nestedExpression().cols() + block.startCol() : block.startCol()*block.nestedExpression().rows() + block.startRow()):0)
   { }
- 
+
   typedef typename XprType::Scalar Scalar;
   typedef typename XprType::CoeffReturnType CoeffReturnType;
 
   enum {
     RowsAtCompileTime = XprType::RowsAtCompileTime,
-    ForwardLinearAccess = InnerPanel && bool(evaluator<ArgType>::Flags&LinearAccessBit)
+    ForwardLinearAccess = (InnerPanel || int(XprType::IsRowMajor)==int(ArgType::IsRowMajor)) && bool(evaluator<ArgType>::Flags&LinearAccessBit)
   };
- 
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
-  { 
-    return m_argImpl.coeff(m_startRow.value() + row, m_startCol.value() + col); 
+  {
+    return m_argImpl.coeff(m_startRow.value() + row, m_startCol.value() + col);
   }
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index index) const
-  { 
-    if (ForwardLinearAccess)
-      return m_argImpl.coeff(m_linear_offset.value() + index); 
-    else
-      return coeff(RowsAtCompileTime == 1 ? 0 : index, RowsAtCompileTime == 1 ? index : 0);
+  {
+    return linear_coeff_impl(index, bool_constant<ForwardLinearAccess>());
   }
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   Scalar& coeffRef(Index row, Index col)
-  { 
-    return m_argImpl.coeffRef(m_startRow.value() + row, m_startCol.value() + col); 
+  {
+    return m_argImpl.coeffRef(m_startRow.value() + row, m_startCol.value() + col);
   }
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   Scalar& coeffRef(Index index)
-  { 
-    if (ForwardLinearAccess)
-      return m_argImpl.coeffRef(m_linear_offset.value() + index); 
-    else
-      return coeffRef(RowsAtCompileTime == 1 ? 0 : index, RowsAtCompileTime == 1 ? index : 0);
+  {
+    return linear_coeffRef_impl(index, bool_constant<ForwardLinearAccess>());
   }
- 
+
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
-  PacketType packet(Index row, Index col) const 
-  { 
-    return m_argImpl.template packet<LoadMode,PacketType>(m_startRow.value() + row, m_startCol.value() + col); 
+  PacketType packet(Index row, Index col) const
+  {
+    return m_argImpl.template packet<LoadMode,PacketType>(m_startRow.value() + row, m_startCol.value() + col);
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
-  PacketType packet(Index index) const 
-  { 
+  PacketType packet(Index index) const
+  {
     if (ForwardLinearAccess)
       return m_argImpl.template packet<LoadMode,PacketType>(m_linear_offset.value() + index);
     else
       return packet<LoadMode,PacketType>(RowsAtCompileTime == 1 ? 0 : index,
                                          RowsAtCompileTime == 1 ? index : 0);
   }
-  
+
   template<int StoreMode, typename PacketType>
   EIGEN_STRONG_INLINE
-  void writePacket(Index row, Index col, const PacketType& x) 
+  void writePacket(Index row, Index col, const PacketType& x)
   {
-    return m_argImpl.template writePacket<StoreMode,PacketType>(m_startRow.value() + row, m_startCol.value() + col, x); 
+    return m_argImpl.template writePacket<StoreMode,PacketType>(m_startRow.value() + row, m_startCol.value() + col, x);
   }
-  
+
   template<int StoreMode, typename PacketType>
   EIGEN_STRONG_INLINE
-  void writePacket(Index index, const PacketType& x) 
+  void writePacket(Index index, const PacketType& x)
   {
     if (ForwardLinearAccess)
       return m_argImpl.template writePacket<StoreMode,PacketType>(m_linear_offset.value() + index, x);
     else
       return writePacket<StoreMode,PacketType>(RowsAtCompileTime == 1 ? 0 : index,
                                               RowsAtCompileTime == 1 ? index : 0,
                                               x);
   }
- 
+
 protected:
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  CoeffReturnType linear_coeff_impl(Index index, internal::true_type /* ForwardLinearAccess */) const
+  {
+    return m_argImpl.coeff(m_linear_offset.value() + index);
+  }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  CoeffReturnType linear_coeff_impl(Index index, internal::false_type /* not ForwardLinearAccess */) const
+  {
+    return coeff(RowsAtCompileTime == 1 ? 0 : index, RowsAtCompileTime == 1 ? index : 0);
+  }
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  Scalar& linear_coeffRef_impl(Index index, internal::true_type /* ForwardLinearAccess */)
+  {
+    return m_argImpl.coeffRef(m_linear_offset.value() + index);
+  }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  Scalar& linear_coeffRef_impl(Index index, internal::false_type /* not ForwardLinearAccess */)
+  {
+    return coeffRef(RowsAtCompileTime == 1 ? 0 : index, RowsAtCompileTime == 1 ? index : 0);
+  }
+
   evaluator<ArgType> m_argImpl;
   const variable_if_dynamic<Index, (ArgType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;
   const variable_if_dynamic<Index, (ArgType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;
-  const variable_if_dynamic<Index, InnerPanel ? Dynamic : 0> m_linear_offset;
+  const variable_if_dynamic<Index, ForwardLinearAccess ? Dynamic : 0> m_linear_offset;
 };
 
-// TODO: This evaluator does not actually use the child evaluator; 
+// TODO: This evaluator does not actually use the child evaluator;
 // all action is via the data() as returned by the Block expression.
 
-template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel> 
+template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
 struct block_evaluator<ArgType, BlockRows, BlockCols, InnerPanel, /* HasDirectAccess */ true>
   : mapbase_evaluator<Block<ArgType, BlockRows, BlockCols, InnerPanel>,
                       typename Block<ArgType, BlockRows, BlockCols, InnerPanel>::PlainObject>
 {
   typedef Block<ArgType, BlockRows, BlockCols, InnerPanel> XprType;
   typedef typename XprType::Scalar Scalar;
 
-  EIGEN_DEVICE_FUNC explicit block_evaluator(const XprType& block)
-    : mapbase_evaluator<XprType, typename XprType::PlainObject>(block) 
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit block_evaluator(const XprType& block)
+    : mapbase_evaluator<XprType, typename XprType::PlainObject>(block)
   {
     // TODO: for the 3.3 release, this should be turned to an internal assertion, but let's keep it as is for the beta lifetime
     eigen_assert(((internal::UIntPtr(block.data()) % EIGEN_PLAIN_ENUM_MAX(1,evaluator<XprType>::Alignment)) == 0) && "data is not aligned");
   }
 };
 
 
@@ -1137,26 +1239,27 @@
   typedef Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> XprType;
   enum {
     CoeffReadCost = evaluator<ConditionMatrixType>::CoeffReadCost
                   + EIGEN_PLAIN_ENUM_MAX(evaluator<ThenMatrixType>::CoeffReadCost,
                                          evaluator<ElseMatrixType>::CoeffReadCost),
 
     Flags = (unsigned int)evaluator<ThenMatrixType>::Flags & evaluator<ElseMatrixType>::Flags & HereditaryBits,
-    
+
     Alignment = EIGEN_PLAIN_ENUM_MIN(evaluator<ThenMatrixType>::Alignment, evaluator<ElseMatrixType>::Alignment)
   };
 
-  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& select)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const XprType& select)
     : m_conditionImpl(select.conditionMatrix()),
       m_thenImpl(select.thenMatrix()),
       m_elseImpl(select.elseMatrix())
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
- 
+
   typedef typename XprType::CoeffReturnType CoeffReturnType;
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
     if (m_conditionImpl.coeff(row, col))
       return m_thenImpl.coeff(row, col);
@@ -1168,73 +1271,74 @@
   CoeffReturnType coeff(Index index) const
   {
     if (m_conditionImpl.coeff(index))
       return m_thenImpl.coeff(index);
     else
       return m_elseImpl.coeff(index);
   }
- 
+
 protected:
   evaluator<ConditionMatrixType> m_conditionImpl;
   evaluator<ThenMatrixType> m_thenImpl;
   evaluator<ElseMatrixType> m_elseImpl;
 };
 
 
 // -------------------- Replicate --------------------
 
-template<typename ArgType, int RowFactor, int ColFactor> 
+template<typename ArgType, int RowFactor, int ColFactor>
 struct unary_evaluator<Replicate<ArgType, RowFactor, ColFactor> >
   : evaluator_base<Replicate<ArgType, RowFactor, ColFactor> >
 {
   typedef Replicate<ArgType, RowFactor, ColFactor> XprType;
   typedef typename XprType::CoeffReturnType CoeffReturnType;
   enum {
     Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor
   };
   typedef typename internal::nested_eval<ArgType,Factor>::type ArgTypeNested;
   typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;
-  
+
   enum {
     CoeffReadCost = evaluator<ArgTypeNestedCleaned>::CoeffReadCost,
     LinearAccessMask = XprType::IsVectorAtCompileTime ? LinearAccessBit : 0,
     Flags = (evaluator<ArgTypeNestedCleaned>::Flags & (HereditaryBits|LinearAccessMask) & ~RowMajorBit) | (traits<XprType>::Flags & RowMajorBit),
-    
+
     Alignment = evaluator<ArgTypeNestedCleaned>::Alignment
   };
 
-  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& replicate)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit unary_evaluator(const XprType& replicate)
     : m_arg(replicate.nestedExpression()),
       m_argImpl(m_arg),
       m_rows(replicate.nestedExpression().rows()),
       m_cols(replicate.nestedExpression().cols())
   {}
- 
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
     // try to avoid using modulo; this is a pure optimization strategy
     const Index actual_row = internal::traits<XprType>::RowsAtCompileTime==1 ? 0
                            : RowFactor==1 ? row
                            : row % m_rows.value();
     const Index actual_col = internal::traits<XprType>::ColsAtCompileTime==1 ? 0
                            : ColFactor==1 ? col
                            : col % m_cols.value();
-    
+
     return m_argImpl.coeff(actual_row, actual_col);
   }
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index index) const
   {
     // try to avoid using modulo; this is a pure optimization strategy
     const Index actual_index = internal::traits<XprType>::RowsAtCompileTime==1
                                   ? (ColFactor==1 ?  index : index%m_cols.value())
                                   : (RowFactor==1 ?  index : index%m_rows.value());
-    
+
     return m_argImpl.coeff(actual_index);
   }
 
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index row, Index col) const
   {
@@ -1243,91 +1347,33 @@
                            : row % m_rows.value();
     const Index actual_col = internal::traits<XprType>::ColsAtCompileTime==1 ? 0
                            : ColFactor==1 ? col
                            : col % m_cols.value();
 
     return m_argImpl.template packet<LoadMode,PacketType>(actual_row, actual_col);
   }
-  
+
   template<int LoadMode, typename PacketType>
   EIGEN_STRONG_INLINE
   PacketType packet(Index index) const
   {
     const Index actual_index = internal::traits<XprType>::RowsAtCompileTime==1
                                   ? (ColFactor==1 ?  index : index%m_cols.value())
                                   : (RowFactor==1 ?  index : index%m_rows.value());
 
     return m_argImpl.template packet<LoadMode,PacketType>(actual_index);
   }
- 
+
 protected:
   const ArgTypeNested m_arg;
   evaluator<ArgTypeNestedCleaned> m_argImpl;
   const variable_if_dynamic<Index, ArgType::RowsAtCompileTime> m_rows;
   const variable_if_dynamic<Index, ArgType::ColsAtCompileTime> m_cols;
 };
 
-
-// -------------------- PartialReduxExpr --------------------
-
-template< typename ArgType, typename MemberOp, int Direction>
-struct evaluator<PartialReduxExpr<ArgType, MemberOp, Direction> >
-  : evaluator_base<PartialReduxExpr<ArgType, MemberOp, Direction> >
-{
-  typedef PartialReduxExpr<ArgType, MemberOp, Direction> XprType;
-  typedef typename internal::nested_eval<ArgType,1>::type ArgTypeNested;
-  typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;
-  typedef typename ArgType::Scalar InputScalar;
-  typedef typename XprType::Scalar Scalar;
-  enum {
-    TraversalSize = Direction==int(Vertical) ? int(ArgType::RowsAtCompileTime) :  int(ArgType::ColsAtCompileTime)
-  };
-  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;
-  enum {
-    CoeffReadCost = TraversalSize==Dynamic ? HugeCost
-                  : TraversalSize * evaluator<ArgType>::CoeffReadCost + int(CostOpType::value),
-    
-    Flags = (traits<XprType>::Flags&RowMajorBit) | (evaluator<ArgType>::Flags&(HereditaryBits&(~RowMajorBit))) | LinearAccessBit,
-    
-    Alignment = 0 // FIXME this will need to be improved once PartialReduxExpr is vectorized
-  };
-
-  EIGEN_DEVICE_FUNC explicit evaluator(const XprType xpr)
-    : m_arg(xpr.nestedExpression()), m_functor(xpr.functor())
-  {
-    EIGEN_INTERNAL_CHECK_COST_VALUE(TraversalSize==Dynamic ? HugeCost : int(CostOpType::value));
-    EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
-  }
-
-  typedef typename XprType::CoeffReturnType CoeffReturnType;
-
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
-  const Scalar coeff(Index i, Index j) const
-  {
-    if (Direction==Vertical)
-      return m_functor(m_arg.col(j));
-    else
-      return m_functor(m_arg.row(i));
-  }
-
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
-  const Scalar coeff(Index index) const
-  {
-    if (Direction==Vertical)
-      return m_functor(m_arg.col(index));
-    else
-      return m_functor(m_arg.row(index));
-  }
-
-protected:
-  typename internal::add_const_on_value_type<ArgTypeNested>::type m_arg;
-  const MemberOp m_functor;
-};
-
-
 // -------------------- MatrixWrapper and ArrayWrapper --------------------
 //
 // evaluator_wrapper_base<T> is a common base class for the
 // MatrixWrapper and ArrayWrapper evaluators.
 
 template<typename XprType>
 struct evaluator_wrapper_base
@@ -1336,15 +1382,16 @@
   typedef typename remove_all<typename XprType::NestedExpressionType>::type ArgType;
   enum {
     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
     Flags = evaluator<ArgType>::Flags,
     Alignment = evaluator<ArgType>::Alignment
   };
 
-  EIGEN_DEVICE_FUNC explicit evaluator_wrapper_base(const ArgType& arg) : m_argImpl(arg) {}
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator_wrapper_base(const ArgType& arg) : m_argImpl(arg) {}
 
   typedef typename ArgType::Scalar Scalar;
   typedef typename ArgType::CoeffReturnType CoeffReturnType;
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
@@ -1403,26 +1450,28 @@
 
 template<typename TArgType>
 struct unary_evaluator<MatrixWrapper<TArgType> >
   : evaluator_wrapper_base<MatrixWrapper<TArgType> >
 {
   typedef MatrixWrapper<TArgType> XprType;
 
-  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& wrapper)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit unary_evaluator(const XprType& wrapper)
     : evaluator_wrapper_base<MatrixWrapper<TArgType> >(wrapper.nestedExpression())
   { }
 };
 
 template<typename TArgType>
 struct unary_evaluator<ArrayWrapper<TArgType> >
   : evaluator_wrapper_base<ArrayWrapper<TArgType> >
 {
   typedef ArrayWrapper<TArgType> XprType;
 
-  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& wrapper)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit unary_evaluator(const XprType& wrapper)
     : evaluator_wrapper_base<ArrayWrapper<TArgType> >(wrapper.nestedExpression())
   { }
 };
 
 
 // -------------------- Reverse --------------------
 
@@ -1441,35 +1490,36 @@
     IsRowMajor = XprType::IsRowMajor,
     IsColMajor = !IsRowMajor,
     ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),
     ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),
     ReversePacket = (Direction == BothDirections)
                     || ((Direction == Vertical)   && IsColMajor)
                     || ((Direction == Horizontal) && IsRowMajor),
-                    
+
     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
-    
+
     // let's enable LinearAccess only with vectorization because of the product overhead
     // FIXME enable DirectAccess with negative strides?
     Flags0 = evaluator<ArgType>::Flags,
     LinearAccess = ( (Direction==BothDirections) && (int(Flags0)&PacketAccessBit) )
                   || ((ReverseRow && XprType::ColsAtCompileTime==1) || (ReverseCol && XprType::RowsAtCompileTime==1))
                  ? LinearAccessBit : 0,
 
     Flags = int(Flags0) & (HereditaryBits | PacketAccessBit | LinearAccess),
-    
+
     Alignment = 0 // FIXME in some rare cases, Alignment could be preserved, like a Vector4f.
   };
 
-  EIGEN_DEVICE_FUNC explicit unary_evaluator(const XprType& reverse)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit unary_evaluator(const XprType& reverse)
     : m_argImpl(reverse.nestedExpression()),
       m_rows(ReverseRow ? reverse.nestedExpression().rows() : 1),
       m_cols(ReverseCol ? reverse.nestedExpression().cols() : 1)
   { }
- 
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index col) const
   {
     return m_argImpl.coeff(ReverseRow ? m_rows.value() - row - 1 : row,
                            ReverseCol ? m_cols.value() - col - 1 : col);
   }
 
@@ -1536,15 +1586,15 @@
   EIGEN_STRONG_INLINE
   void writePacket(Index index, const PacketType& x)
   {
     enum { PacketSize = unpacket_traits<PacketType>::size };
     m_argImpl.template writePacket<LoadMode>
       (m_rows.value() * m_cols.value() - index - PacketSize, preverse(x));
   }
- 
+
 protected:
   evaluator<ArgType> m_argImpl;
 
   // If we do not reverse rows, then we do not need to know the number of rows; same for columns
   // Nonetheless, in this case it is important to set to 1 such that the coeff(index) method works fine for vectors.
   const variable_if_dynamic<Index, ReverseRow ? ArgType::RowsAtCompileTime : 1> m_rows;
   const variable_if_dynamic<Index, ReverseCol ? ArgType::ColsAtCompileTime : 1> m_cols;
@@ -1554,28 +1604,29 @@
 // -------------------- Diagonal --------------------
 
 template<typename ArgType, int DiagIndex>
 struct evaluator<Diagonal<ArgType, DiagIndex> >
   : evaluator_base<Diagonal<ArgType, DiagIndex> >
 {
   typedef Diagonal<ArgType, DiagIndex> XprType;
-  
+
   enum {
     CoeffReadCost = evaluator<ArgType>::CoeffReadCost,
-    
+
     Flags = (unsigned int)(evaluator<ArgType>::Flags & (HereditaryBits | DirectAccessBit) & ~RowMajorBit) | LinearAccessBit,
-    
+
     Alignment = 0
   };
 
-  EIGEN_DEVICE_FUNC explicit evaluator(const XprType& diagonal)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit evaluator(const XprType& diagonal)
     : m_argImpl(diagonal.nestedExpression()),
       m_index(diagonal.index())
   { }
- 
+
   typedef typename XprType::Scalar Scalar;
   typedef typename XprType::CoeffReturnType CoeffReturnType;
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeff(Index row, Index) const
   {
     return m_argImpl.coeff(row + rowOffset(), row + colOffset());
@@ -1600,16 +1651,18 @@
   }
 
 protected:
   evaluator<ArgType> m_argImpl;
   const internal::variable_if_dynamicindex<Index, XprType::DiagIndex> m_index;
 
 private:
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value() > 0 ? 0 : -m_index.value(); }
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value() > 0 ? m_index.value() : 0; }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+  Index rowOffset() const { return m_index.value() > 0 ? 0 : -m_index.value(); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+  Index colOffset() const { return m_index.value() > 0 ? m_index.value() : 0; }
 };
 
 
 //----------------------------------------------------------------------
 // deprecated code
 //----------------------------------------------------------------------
 
@@ -1625,49 +1678,49 @@
 { };
 
 template<typename ArgType>
 class EvalToTemp
   : public dense_xpr_base<EvalToTemp<ArgType> >::type
 {
  public:
- 
+
   typedef typename dense_xpr_base<EvalToTemp>::type Base;
   EIGEN_GENERIC_PUBLIC_INTERFACE(EvalToTemp)
- 
+
   explicit EvalToTemp(const ArgType& arg)
     : m_arg(arg)
   { }
- 
+
   const ArgType& arg() const
   {
     return m_arg;
   }
 
-  Index rows() const 
+  EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT
   {
     return m_arg.rows();
   }
 
-  Index cols() const 
+  EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT
   {
     return m_arg.cols();
   }
 
  private:
   const ArgType& m_arg;
 };
- 
+
 template<typename ArgType>
 struct evaluator<EvalToTemp<ArgType> >
   : public evaluator<typename ArgType::PlainObject>
 {
   typedef EvalToTemp<ArgType>                   XprType;
   typedef typename ArgType::PlainObject         PlainObject;
   typedef evaluator<PlainObject> Base;
-  
+
   EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr)
     : m_result(xpr.arg())
   {
     ::new (static_cast<Base*>(this)) Base(m_result);
   }
 
   // This constructor is used when nesting an EvalTo evaluator in another evaluator
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/CoreIterators.h` & `chronogram-0.2.0/include/Eigen/src/Core/CoreIterators.h`

 * *Files 3% similar despite different names*

```diff
@@ -44,14 +44,19 @@
   
   /// \returns the value of the current coefficient.
   EIGEN_STRONG_INLINE Scalar value() const          { return m_iter.value(); }
   /** Increment the iterator \c *this to the next non-zero coefficient.
     * Explicit zeros are not skipped over. To skip explicit zeros, see class SparseView
     */
   EIGEN_STRONG_INLINE InnerIterator& operator++()   { m_iter.operator++(); return *this; }
+  EIGEN_STRONG_INLINE InnerIterator& operator+=(Index i) { m_iter.operator+=(i); return *this; }
+  EIGEN_STRONG_INLINE InnerIterator operator+(Index i) 
+  { InnerIterator result(*this); result+=i; return result; }
+    
+
   /// \returns the column or row index of the current coefficient.
   EIGEN_STRONG_INLINE Index index() const           { return m_iter.index(); }
   /// \returns the row index of the current coefficient.
   EIGEN_STRONG_INLINE Index row() const             { return m_iter.row(); }
   /// \returns the column index of the current coefficient.
   EIGEN_STRONG_INLINE Index col() const             { return m_iter.col(); }
   /// \returns \c true if the iterator \c *this still references a valid coefficient.
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/CwiseBinaryOp.h` & `chronogram-0.2.0/include/Eigen/src/Core/CwiseBinaryOp.h`

 * *Files 7% similar despite different names*

```diff
@@ -70,24 +70,24 @@
   *
   * Most of the time, this is the only way that it is used, so you typically don't have to name
   * CwiseBinaryOp types explicitly.
   *
   * \sa MatrixBase::binaryExpr(const MatrixBase<OtherDerived> &,const CustomBinaryOp &) const, class CwiseUnaryOp, class CwiseNullaryOp
   */
 template<typename BinaryOp, typename LhsType, typename RhsType>
-class CwiseBinaryOp : 
+class CwiseBinaryOp :
   public CwiseBinaryOpImpl<
           BinaryOp, LhsType, RhsType,
           typename internal::cwise_promote_storage_type<typename internal::traits<LhsType>::StorageKind,
                                                         typename internal::traits<RhsType>::StorageKind,
                                                         BinaryOp>::ret>,
   internal::no_assignment_operator
 {
   public:
-    
+
     typedef typename internal::remove_all<BinaryOp>::type Functor;
     typedef typename internal::remove_all<LhsType>::type Lhs;
     typedef typename internal::remove_all<RhsType>::type Rhs;
 
     typedef typename CwiseBinaryOpImpl<
         BinaryOp, LhsType, RhsType,
         typename internal::cwise_promote_storage_type<typename internal::traits<LhsType>::StorageKind,
@@ -96,49 +96,49 @@
     EIGEN_GENERIC_PUBLIC_INTERFACE(CwiseBinaryOp)
 
     typedef typename internal::ref_selector<LhsType>::type LhsNested;
     typedef typename internal::ref_selector<RhsType>::type RhsNested;
     typedef typename internal::remove_reference<LhsNested>::type _LhsNested;
     typedef typename internal::remove_reference<RhsNested>::type _RhsNested;
 
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())
+#if EIGEN_COMP_MSVC && EIGEN_HAS_CXX11
+    //Required for Visual Studio or the Copy constructor will probably not get inlined!
+    EIGEN_STRONG_INLINE
+    CwiseBinaryOp(const CwiseBinaryOp<BinaryOp,LhsType,RhsType>&) = default;
+#endif
+
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    CwiseBinaryOp(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())
       : m_lhs(aLhs), m_rhs(aRhs), m_functor(func)
     {
       EIGEN_CHECK_BINARY_COMPATIBILIY(BinaryOp,typename Lhs::Scalar,typename Rhs::Scalar);
       // require the sizes to match
       EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Lhs, Rhs)
       eigen_assert(aLhs.rows() == aRhs.rows() && aLhs.cols() == aRhs.cols());
     }
 
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index rows() const {
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT {
       // return the fixed size type if available to enable compile time optimizations
-      if (internal::traits<typename internal::remove_all<LhsNested>::type>::RowsAtCompileTime==Dynamic)
-        return m_rhs.rows();
-      else
-        return m_lhs.rows();
+      return internal::traits<typename internal::remove_all<LhsNested>::type>::RowsAtCompileTime==Dynamic ? m_rhs.rows() : m_lhs.rows();
     }
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index cols() const {
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT {
       // return the fixed size type if available to enable compile time optimizations
-      if (internal::traits<typename internal::remove_all<LhsNested>::type>::ColsAtCompileTime==Dynamic)
-        return m_rhs.cols();
-      else
-        return m_lhs.cols();
+      return internal::traits<typename internal::remove_all<LhsNested>::type>::ColsAtCompileTime==Dynamic ? m_rhs.cols() : m_lhs.cols();
     }
 
     /** \returns the left hand side nested expression */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     const _LhsNested& lhs() const { return m_lhs; }
     /** \returns the right hand side nested expression */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     const _RhsNested& rhs() const { return m_rhs; }
     /** \returns the functor representing the binary operation */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     const BinaryOp& functor() const { return m_functor; }
 
   protected:
     LhsNested m_lhs;
     RhsNested m_rhs;
     const BinaryOp m_functor;
 };
@@ -154,31 +154,30 @@
 
 /** replaces \c *this by \c *this - \a other.
   *
   * \returns a reference to \c *this
   */
 template<typename Derived>
 template<typename OtherDerived>
-EIGEN_STRONG_INLINE Derived &
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &
 MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)
 {
   call_assignment(derived(), other.derived(), internal::sub_assign_op<Scalar,typename OtherDerived::Scalar>());
   return derived();
 }
 
 /** replaces \c *this by \c *this + \a other.
   *
   * \returns a reference to \c *this
   */
 template<typename Derived>
 template<typename OtherDerived>
-EIGEN_STRONG_INLINE Derived &
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived &
 MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)
 {
   call_assignment(derived(), other.derived(), internal::add_assign_op<Scalar,typename OtherDerived::Scalar>());
   return derived();
 }
 
 } // end namespace Eigen
 
 #endif // EIGEN_CWISE_BINARY_OP_H
-
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/CwiseNullaryOp.h` & `chronogram-0.2.0/include/Eigen/src/Core/CwiseNullaryOp.h`

 * *Files 5% similar despite different names*

```diff
@@ -70,18 +70,18 @@
     {
       eigen_assert(rows >= 0
             && (RowsAtCompileTime == Dynamic || RowsAtCompileTime == rows)
             &&  cols >= 0
             && (ColsAtCompileTime == Dynamic || ColsAtCompileTime == cols));
     }
 
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index rows() const { return m_rows.value(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index cols() const { return m_cols.value(); }
 
     /** \returns the functor representing the nullary operation */
     EIGEN_DEVICE_FUNC
     const NullaryOp& functor() const { return m_functor; }
 
   protected:
     const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;
@@ -101,15 +101,20 @@
   *
   * The template parameter \a CustomNullaryOp is the type of the functor.
   *
   * \sa class CwiseNullaryOp
   */
 template<typename Derived>
 template<typename CustomNullaryOp>
-EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CwiseNullaryOp<CustomNullaryOp, typename DenseBase<Derived>::PlainObject>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+#ifndef EIGEN_PARSED_BY_DOXYGEN
+const CwiseNullaryOp<CustomNullaryOp,typename DenseBase<Derived>::PlainObject>
+#else
+const CwiseNullaryOp<CustomNullaryOp,PlainObject>
+#endif
 DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)
 {
   return CwiseNullaryOp<CustomNullaryOp, PlainObject>(rows, cols, func);
 }
 
 /** \returns an expression of a matrix defined by a custom functor \a func
   *
@@ -122,20 +127,25 @@
   * it is redundant to pass \a size as argument, so Zero() should be used
   * instead.
   *
   * The template parameter \a CustomNullaryOp is the type of the functor.
   *
   * Here is an example with C++11 random generators: \include random_cpp11.cpp
   * Output: \verbinclude random_cpp11.out
-  * 
+  *
   * \sa class CwiseNullaryOp
   */
 template<typename Derived>
 template<typename CustomNullaryOp>
-EIGEN_STRONG_INLINE const CwiseNullaryOp<CustomNullaryOp, typename DenseBase<Derived>::PlainObject>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+#ifndef EIGEN_PARSED_BY_DOXYGEN
+const CwiseNullaryOp<CustomNullaryOp, typename DenseBase<Derived>::PlainObject>
+#else
+const CwiseNullaryOp<CustomNullaryOp, PlainObject>
+#endif
 DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)
 {
   EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)
   if(RowsAtCompileTime == 1) return CwiseNullaryOp<CustomNullaryOp, PlainObject>(1, size, func);
   else return CwiseNullaryOp<CustomNullaryOp, PlainObject>(size, 1, func);
 }
 
@@ -146,15 +156,20 @@
   *
   * The template parameter \a CustomNullaryOp is the type of the functor.
   *
   * \sa class CwiseNullaryOp
   */
 template<typename Derived>
 template<typename CustomNullaryOp>
-EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CwiseNullaryOp<CustomNullaryOp, typename DenseBase<Derived>::PlainObject>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+#ifndef EIGEN_PARSED_BY_DOXYGEN
+const CwiseNullaryOp<CustomNullaryOp, typename DenseBase<Derived>::PlainObject>
+#else
+const CwiseNullaryOp<CustomNullaryOp, PlainObject>
+#endif
 DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)
 {
   return CwiseNullaryOp<CustomNullaryOp, PlainObject>(RowsAtCompileTime, ColsAtCompileTime, func);
 }
 
 /** \returns an expression of a constant matrix of value \a value
   *
@@ -166,15 +181,15 @@
   * instead.
   *
   * The template parameter \a CustomNullaryOp is the type of the functor.
   *
   * \sa class CwiseNullaryOp
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE const typename DenseBase<Derived>::ConstantReturnType
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename DenseBase<Derived>::ConstantReturnType
 DenseBase<Derived>::Constant(Index rows, Index cols, const Scalar& value)
 {
   return DenseBase<Derived>::NullaryExpr(rows, cols, internal::scalar_constant_op<Scalar>(value));
 }
 
 /** \returns an expression of a constant matrix of value \a value
   *
@@ -213,35 +228,40 @@
 {
   EIGEN_STATIC_ASSERT_FIXED_SIZE(Derived)
   return DenseBase<Derived>::NullaryExpr(RowsAtCompileTime, ColsAtCompileTime, internal::scalar_constant_op<Scalar>(value));
 }
 
 /** \deprecated because of accuracy loss. In Eigen 3.3, it is an alias for LinSpaced(Index,const Scalar&,const Scalar&)
   *
-  * \sa LinSpaced(Index,Scalar,Scalar), setLinSpaced(Index,const Scalar&,const Scalar&)
+  * \only_for_vectors
+  *
+  * Example: \include DenseBase_LinSpaced_seq_deprecated.cpp
+  * Output: \verbinclude DenseBase_LinSpaced_seq_deprecated.out
+  *
+  * \sa LinSpaced(Index,const Scalar&, const Scalar&), setLinSpaced(Index,const Scalar&,const Scalar&)
   */
 template<typename Derived>
-EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename DenseBase<Derived>::RandomAccessLinSpacedReturnType
+EIGEN_DEPRECATED EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename DenseBase<Derived>::RandomAccessLinSpacedReturnType
 DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)
 {
   EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)
-  return DenseBase<Derived>::NullaryExpr(size, internal::linspaced_op<Scalar,PacketScalar>(low,high,size));
+  return DenseBase<Derived>::NullaryExpr(size, internal::linspaced_op<Scalar>(low,high,size));
 }
 
 /** \deprecated because of accuracy loss. In Eigen 3.3, it is an alias for LinSpaced(const Scalar&,const Scalar&)
   *
-  * \sa LinSpaced(Scalar,Scalar)
+  * \sa LinSpaced(const Scalar&, const Scalar&)
   */
 template<typename Derived>
-EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename DenseBase<Derived>::RandomAccessLinSpacedReturnType
+EIGEN_DEPRECATED EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename DenseBase<Derived>::RandomAccessLinSpacedReturnType
 DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)
 {
   EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)
   EIGEN_STATIC_ASSERT_FIXED_SIZE(Derived)
-  return DenseBase<Derived>::NullaryExpr(Derived::SizeAtCompileTime, internal::linspaced_op<Scalar,PacketScalar>(low,high,Derived::SizeAtCompileTime));
+  return DenseBase<Derived>::NullaryExpr(Derived::SizeAtCompileTime, internal::linspaced_op<Scalar>(low,high,Derived::SizeAtCompileTime));
 }
 
 /**
   * \brief Sets a linearly spaced vector.
   *
   * The function generates 'size' equally spaced values in the closed interval [low,high].
   * When size is set to 1, a vector of length 1 containing 'high' is returned.
@@ -264,28 +284,28 @@
   * \sa setLinSpaced(Index,const Scalar&,const Scalar&), CwiseNullaryOp
   */
 template<typename Derived>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename DenseBase<Derived>::RandomAccessLinSpacedReturnType
 DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)
 {
   EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)
-  return DenseBase<Derived>::NullaryExpr(size, internal::linspaced_op<Scalar,PacketScalar>(low,high,size));
+  return DenseBase<Derived>::NullaryExpr(size, internal::linspaced_op<Scalar>(low,high,size));
 }
 
 /**
   * \copydoc DenseBase::LinSpaced(Index, const Scalar&, const Scalar&)
   * Special version for fixed size types which does not require the size parameter.
   */
 template<typename Derived>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename DenseBase<Derived>::RandomAccessLinSpacedReturnType
 DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)
 {
   EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)
   EIGEN_STATIC_ASSERT_FIXED_SIZE(Derived)
-  return DenseBase<Derived>::NullaryExpr(Derived::SizeAtCompileTime, internal::linspaced_op<Scalar,PacketScalar>(low,high,Derived::SizeAtCompileTime));
+  return DenseBase<Derived>::NullaryExpr(Derived::SizeAtCompileTime, internal::linspaced_op<Scalar>(low,high,Derived::SizeAtCompileTime));
 }
 
 /** \returns true if all coefficients in this matrix are approximately equal to \a val, to within precision \a prec */
 template<typename Derived>
 EIGEN_DEVICE_FUNC bool DenseBase<Derived>::isApproxToConstant
 (const Scalar& val, const RealScalar& prec) const
 {
@@ -359,14 +379,41 @@
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
 PlainObjectBase<Derived>::setConstant(Index rows, Index cols, const Scalar& val)
 {
   resize(rows, cols);
   return setConstant(val);
 }
 
+/** Resizes to the given size, changing only the number of columns, and sets all
+  * coefficients in this expression to the given value \a val. For the parameter
+  * of type NoChange_t, just pass the special value \c NoChange.
+  *
+  * \sa MatrixBase::setConstant(const Scalar&), setConstant(Index,const Scalar&), class CwiseNullaryOp, MatrixBase::Constant(const Scalar&)
+  */
+template<typename Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
+PlainObjectBase<Derived>::setConstant(NoChange_t, Index cols, const Scalar& val)
+{
+  return setConstant(rows(), cols, val);
+}
+
+/** Resizes to the given size, changing only the number of rows, and sets all
+  * coefficients in this expression to the given value \a val. For the parameter
+  * of type NoChange_t, just pass the special value \c NoChange.
+  *
+  * \sa MatrixBase::setConstant(const Scalar&), setConstant(Index,const Scalar&), class CwiseNullaryOp, MatrixBase::Constant(const Scalar&)
+  */
+template<typename Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
+PlainObjectBase<Derived>::setConstant(Index rows, NoChange_t, const Scalar& val)
+{
+  return setConstant(rows, cols(), val);
+}
+
+
 /**
   * \brief Sets a linearly spaced vector.
   *
   * The function generates 'size' equally spaced values in the closed interval [low,high].
   * When size is set to 1, a vector of length 1 containing 'high' is returned.
   *
   * \only_for_vectors
@@ -379,15 +426,15 @@
   *
   * \sa LinSpaced(Index,const Scalar&,const Scalar&), CwiseNullaryOp
   */
 template<typename Derived>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index newSize, const Scalar& low, const Scalar& high)
 {
   EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)
-  return derived() = Derived::NullaryExpr(newSize, internal::linspaced_op<Scalar,PacketScalar>(low,high,newSize));
+  return derived() = Derived::NullaryExpr(newSize, internal::linspaced_op<Scalar>(low,high,newSize));
 }
 
 /**
   * \brief Sets a linearly spaced vector.
   *
   * The function fills \c *this with equally spaced values in the closed interval [low,high].
   * When size is set to 1, a vector of length 1 containing 'high' is returned.
@@ -532,14 +579,40 @@
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
 PlainObjectBase<Derived>::setZero(Index rows, Index cols)
 {
   resize(rows, cols);
   return setConstant(Scalar(0));
 }
 
+/** Resizes to the given size, changing only the number of columns, and sets all
+  * coefficients in this expression to zero. For the parameter of type NoChange_t,
+  * just pass the special value \c NoChange.
+  *
+  * \sa DenseBase::setZero(), setZero(Index), setZero(Index, Index), setZero(Index, NoChange_t), class CwiseNullaryOp, DenseBase::Zero()
+  */
+template<typename Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
+PlainObjectBase<Derived>::setZero(NoChange_t, Index cols)
+{
+  return setZero(rows(), cols);
+}
+
+/** Resizes to the given size, changing only the number of rows, and sets all
+  * coefficients in this expression to zero. For the parameter of type NoChange_t,
+  * just pass the special value \c NoChange.
+  *
+  * \sa DenseBase::setZero(), setZero(Index), setZero(Index, Index), setZero(NoChange_t, Index), class CwiseNullaryOp, DenseBase::Zero()
+  */
+template<typename Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
+PlainObjectBase<Derived>::setZero(Index rows, NoChange_t)
+{
+  return setZero(rows, cols());
+}
+
 // ones:
 
 /** \returns an expression of a matrix where all coefficients equal one.
   *
   * The parameters \a rows and \a cols are the number of rows and of columns of
   * the returned matrix. Must be compatible with this MatrixBase type.
   *
@@ -658,14 +731,40 @@
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
 PlainObjectBase<Derived>::setOnes(Index rows, Index cols)
 {
   resize(rows, cols);
   return setConstant(Scalar(1));
 }
 
+/** Resizes to the given size, changing only the number of rows, and sets all
+  * coefficients in this expression to one. For the parameter of type NoChange_t,
+  * just pass the special value \c NoChange.
+  *
+ * \sa MatrixBase::setOnes(), setOnes(Index), setOnes(Index, Index), setOnes(NoChange_t, Index), class CwiseNullaryOp, MatrixBase::Ones()
+  */
+template<typename Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
+PlainObjectBase<Derived>::setOnes(Index rows, NoChange_t)
+{
+  return setOnes(rows, cols());
+}
+
+/** Resizes to the given size, changing only the number of columns, and sets all
+  * coefficients in this expression to one. For the parameter of type NoChange_t,
+  * just pass the special value \c NoChange.
+  *
+ * \sa MatrixBase::setOnes(), setOnes(Index), setOnes(Index, Index), setOnes(Index, NoChange_t) class CwiseNullaryOp, MatrixBase::Ones()
+  */
+template<typename Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived&
+PlainObjectBase<Derived>::setOnes(NoChange_t, Index cols)
+{
+  return setOnes(rows(), cols);
+}
+
 // Identity:
 
 /** \returns an expression of the identity matrix (not necessarily square).
   *
   * The parameters \a rows and \a cols are the number of rows and of columns of
   * the returned matrix. Must be compatible with this MatrixBase type.
   *
@@ -857,10 +956,46 @@
   *
   * \sa MatrixBase::Unit(Index,Index), MatrixBase::Unit(Index), MatrixBase::UnitY(), MatrixBase::UnitZ(), MatrixBase::UnitW()
   */
 template<typename Derived>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()
 { return Derived::Unit(3); }
 
+/** \brief Set the coefficients of \c *this to the i-th unit (basis) vector
+  *
+  * \param i index of the unique coefficient to be set to 1
+  *
+  * \only_for_vectors
+  *
+  * \sa MatrixBase::setIdentity(), class CwiseNullaryOp, MatrixBase::Unit(Index,Index)
+  */
+template<typename Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setUnit(Index i)
+{
+  EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived);
+  eigen_assert(i<size());
+  derived().setZero();
+  derived().coeffRef(i) = Scalar(1);
+  return derived();
+}
+
+/** \brief Resizes to the given \a newSize, and writes the i-th unit (basis) vector into *this.
+  *
+  * \param newSize the new size of the vector
+  * \param i index of the unique coefficient to be set to 1
+  *
+  * \only_for_vectors
+  *
+  * \sa MatrixBase::setIdentity(), class CwiseNullaryOp, MatrixBase::Unit(Index,Index)
+  */
+template<typename Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setUnit(Index newSize, Index i)
+{
+  EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived);
+  eigen_assert(i<newSize);
+  derived().resize(newSize);
+  return setUnit(i);
+}
+
 } // end namespace Eigen
 
 #endif // EIGEN_CWISE_NULLARY_OP_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/CwiseTernaryOp.h` & `chronogram-0.2.0/include/Eigen/src/Core/CwiseTernaryOp.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/CwiseUnaryOp.h` & `chronogram-0.2.0/include/Eigen/src/Core/CwiseUnaryOp.h`

 * *Files 7% similar despite different names*

```diff
@@ -7,28 +7,28 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_CWISE_UNARY_OP_H
 #define EIGEN_CWISE_UNARY_OP_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 template<typename UnaryOp, typename XprType>
 struct traits<CwiseUnaryOp<UnaryOp, XprType> >
  : traits<XprType>
 {
   typedef typename result_of<
                      UnaryOp(const typename XprType::Scalar&)
                    >::type Scalar;
   typedef typename XprType::Nested XprTypeNested;
   typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;
   enum {
-    Flags = _XprTypeNested::Flags & RowMajorBit 
+    Flags = _XprTypeNested::Flags & RowMajorBit
   };
 };
 }
 
 template<typename UnaryOp, typename XprType, typename StorageKind>
 class CwiseUnaryOpImpl;
 
@@ -61,18 +61,18 @@
     typedef typename internal::ref_selector<XprType>::type XprTypeNested;
     typedef typename internal::remove_all<XprType>::type NestedExpression;
 
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     explicit CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())
       : m_xpr(xpr), m_functor(func) {}
 
-    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
-    Index rows() const { return m_xpr.rows(); }
-    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
-    Index cols() const { return m_xpr.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return m_xpr.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return m_xpr.cols(); }
 
     /** \returns the functor representing the unary operation */
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     const UnaryOp& functor() const { return m_functor; }
 
     /** \returns the nested expression */
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/CwiseUnaryView.h` & `chronogram-0.2.0/include/Eigen/src/Core/CwiseUnaryView.h`

 * *Files 6% similar despite different names*

```diff
@@ -60,32 +60,34 @@
   public:
 
     typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;
     EIGEN_GENERIC_PUBLIC_INTERFACE(CwiseUnaryView)
     typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;
     typedef typename internal::remove_all<MatrixType>::type NestedExpression;
 
-    explicit inline CwiseUnaryView(MatrixType& mat, const ViewOp& func = ViewOp())
+    explicit EIGEN_DEVICE_FUNC inline CwiseUnaryView(MatrixType& mat, const ViewOp& func = ViewOp())
       : m_matrix(mat), m_functor(func) {}
 
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(CwiseUnaryView)
 
-    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }
-    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
 
     /** \returns the functor representing unary operation */
-    const ViewOp& functor() const { return m_functor; }
+    EIGEN_DEVICE_FUNC const ViewOp& functor() const { return m_functor; }
 
     /** \returns the nested expression */
-    const typename internal::remove_all<MatrixTypeNested>::type&
+    EIGEN_DEVICE_FUNC const typename internal::remove_all<MatrixTypeNested>::type&
     nestedExpression() const { return m_matrix; }
 
     /** \returns the nested expression */
-    typename internal::remove_reference<MatrixTypeNested>::type&
-    nestedExpression() { return m_matrix.const_cast_derived(); }
+    EIGEN_DEVICE_FUNC typename internal::remove_reference<MatrixTypeNested>::type&
+    nestedExpression() { return m_matrix; }
 
   protected:
     MatrixTypeNested m_matrix;
     ViewOp m_functor;
 };
 
 // Generic API dispatcher
@@ -104,25 +106,27 @@
   public:
 
     typedef CwiseUnaryView<ViewOp, MatrixType> Derived;
     typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;
 
     EIGEN_DENSE_PUBLIC_INTERFACE(Derived)
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(CwiseUnaryViewImpl)
-    
+
     EIGEN_DEVICE_FUNC inline Scalar* data() { return &(this->coeffRef(0)); }
     EIGEN_DEVICE_FUNC inline const Scalar* data() const { return &(this->coeff(0)); }
 
-    EIGEN_DEVICE_FUNC inline Index innerStride() const
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR inline Index innerStride() const
     {
       return derived().nestedExpression().innerStride() * sizeof(typename internal::traits<MatrixType>::Scalar) / sizeof(Scalar);
     }
 
-    EIGEN_DEVICE_FUNC inline Index outerStride() const
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR inline Index outerStride() const
     {
       return derived().nestedExpression().outerStride() * sizeof(typename internal::traits<MatrixType>::Scalar) / sizeof(Scalar);
     }
+  protected:
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(CwiseUnaryViewImpl)
 };
 
 } // end namespace Eigen
 
 #endif // EIGEN_CWISE_UNARY_VIEW_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/DenseBase.h` & `chronogram-0.2.0/include/Eigen/src/Core/DenseBase.h`

 * *Files 9% similar despite different names*

```diff
@@ -10,23 +10,23 @@
 
 #ifndef EIGEN_DENSEBASE_H
 #define EIGEN_DENSEBASE_H
 
 namespace Eigen {
 
 namespace internal {
-  
+
 // The index type defined by EIGEN_DEFAULT_DENSE_INDEX_TYPE must be a signed type.
 // This dummy function simply aims at checking that at compile time.
 static inline void check_DenseIndex_is_signed() {
-  EIGEN_STATIC_ASSERT(NumTraits<DenseIndex>::IsSigned,THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE); 
+  EIGEN_STATIC_ASSERT(NumTraits<DenseIndex>::IsSigned,THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE)
 }
 
 } // end namespace internal
-  
+
 /** \class DenseBase
   * \ingroup Core_Module
   *
   * \brief Base class for all dense matrices, vectors, and arrays
   *
   * This class is the base that is inherited by all dense objects (matrix, vector, arrays,
   * and related expression types). The common Eigen API for dense objects is contained in this class.
@@ -36,15 +36,15 @@
   * This class can be extended with the help of the plugin mechanism described on the page
   * \ref TopicCustomizing_Plugins by defining the preprocessor symbol \c EIGEN_DENSEBASE_PLUGIN.
   *
   * \sa \blank \ref TopicClassHierarchy
   */
 template<typename Derived> class DenseBase
 #ifndef EIGEN_PARSED_BY_DOXYGEN
-  : public DenseCoeffsBase<Derived>
+  : public DenseCoeffsBase<Derived, internal::accessors_level<Derived>::value>
 #else
   : public DenseCoeffsBase<Derived,DirectWriteAccessors>
 #endif // not EIGEN_PARSED_BY_DOXYGEN
 {
   public:
 
     /** Inner iterator type to iterate over the coefficients of a row or column.
@@ -60,22 +60,22 @@
       *          PermutationMatrix or Transpositions, otherwise it defaults to Eigen::Index
       * \sa \blank \ref TopicPreprocessorDirectives, Eigen::Index, SparseMatrixBase.
      */
     typedef typename internal::traits<Derived>::StorageIndex StorageIndex;
 
     /** The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<float>, etc. */
     typedef typename internal::traits<Derived>::Scalar Scalar;
-    
+
     /** The numeric type of the expression' coefficients, e.g. float, double, int or std::complex<float>, etc.
       *
       * It is an alias for the Scalar type */
     typedef Scalar value_type;
-    
+
     typedef typename NumTraits<Scalar>::Real RealScalar;
-    typedef DenseCoeffsBase<Derived> Base;
+    typedef DenseCoeffsBase<Derived, internal::accessors_level<Derived>::value> Base;
 
     using Base::derived;
     using Base::const_cast_derived;
     using Base::rows;
     using Base::cols;
     using Base::size;
     using Base::rowIndexByOuterInner;
@@ -146,49 +146,54 @@
           *
           * This value is useful to know when evaluating an expression, in order to determine
           * whether it is possible to avoid doing a dynamic memory allocation.
           *
           * \sa SizeAtCompileTime, MaxRowsAtCompileTime, MaxColsAtCompileTime
           */
 
-      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1
-                           || internal::traits<Derived>::MaxColsAtCompileTime == 1,
+      IsVectorAtCompileTime = internal::traits<Derived>::RowsAtCompileTime == 1
+                           || internal::traits<Derived>::ColsAtCompileTime == 1,
         /**< This is set to true if either the number of rows or the number of
           * columns is known at compile-time to be equal to 1. Indeed, in that case,
           * we are dealing with a column-vector (if there is only one column) or with
           * a row-vector (if there is only one row). */
 
+      NumDimensions = int(MaxSizeAtCompileTime) == 1 ? 0 : bool(IsVectorAtCompileTime) ? 1 : 2,
+        /**< This value is equal to Tensor::NumDimensions, i.e. 0 for scalars, 1 for vectors,
+         * and 2 for matrices.
+         */
+
       Flags = internal::traits<Derived>::Flags,
         /**< This stores expression \ref flags flags which may or may not be inherited by new expressions
           * constructed from this one. See the \ref flags "list of flags".
           */
 
       IsRowMajor = int(Flags) & RowMajorBit, /**< True if this expression has row-major storage order. */
 
       InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)
                              : int(IsRowMajor) ? int(ColsAtCompileTime) : int(RowsAtCompileTime),
 
       InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,
       OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret
     };
-    
+
     typedef typename internal::find_best_packet<Scalar,SizeAtCompileTime>::type PacketScalar;
 
     enum { IsPlainObjectBase = 0 };
-    
+
     /** The plain matrix type corresponding to this expression.
       * \sa PlainObject */
     typedef Matrix<typename internal::traits<Derived>::Scalar,
                 internal::traits<Derived>::RowsAtCompileTime,
                 internal::traits<Derived>::ColsAtCompileTime,
                 AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
                 internal::traits<Derived>::MaxRowsAtCompileTime,
                 internal::traits<Derived>::MaxColsAtCompileTime
           > PlainMatrix;
-    
+
     /** The plain array type corresponding to this expression.
       * \sa PlainObject */
     typedef Array<typename internal::traits<Derived>::Scalar,
                 internal::traits<Derived>::RowsAtCompileTime,
                 internal::traits<Derived>::ColsAtCompileTime,
                 AutoAlign | (internal::traits<Derived>::Flags&RowMajorBit ? RowMajor : ColMajor),
                 internal::traits<Derived>::MaxRowsAtCompileTime,
@@ -202,35 +207,35 @@
       * that the return type of eval() is either PlainObject or const PlainObject&.
       */
     typedef typename internal::conditional<internal::is_same<typename internal::traits<Derived>::XprKind,MatrixXpr >::value,
                                  PlainMatrix, PlainArray>::type PlainObject;
 
     /** \returns the number of nonzero coefficients which is in practice the number
       * of stored coefficients. */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index nonZeros() const { return size(); }
 
     /** \returns the outer size.
       *
       * \note For a vector, this returns just 1. For a matrix (non-vector), this is the major dimension
       * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of columns for a
       * column-major matrix, and the number of rows for a row-major matrix. */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     Index outerSize() const
     {
       return IsVectorAtCompileTime ? 1
            : int(IsRowMajor) ? this->rows() : this->cols();
     }
 
     /** \returns the inner size.
       *
       * \note For a vector, this is just the size. For a matrix (non-vector), this is the minor dimension
-      * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of rows for a 
+      * with respect to the \ref TopicStorageOrders "storage order", i.e., the number of rows for a
       * column-major matrix, and the number of columns for a row-major matrix. */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     Index innerSize() const
     {
       return IsVectorAtCompileTime ? this->size()
            : int(IsRowMajor) ? this->cols() : this->rows();
     }
 
     /** Only plain matrices/arrays, not expressions, may be resized; therefore the only useful resize methods are
@@ -257,17 +262,17 @@
                 && "DenseBase::resize() does not actually allow to resize.");
     }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
     /** \internal Represents a matrix with all coefficients equal to one another*/
     typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,PlainObject> ConstantReturnType;
     /** \internal \deprecated Represents a vector with linearly spaced coefficients that allows sequential access only. */
-    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,PacketScalar>,PlainObject> SequentialLinSpacedReturnType;
+    EIGEN_DEPRECATED typedef CwiseNullaryOp<internal::linspaced_op<Scalar>,PlainObject> SequentialLinSpacedReturnType;
     /** \internal Represents a vector with linearly spaced coefficients that allows random access. */
-    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,PacketScalar>,PlainObject> RandomAccessLinSpacedReturnType;
+    typedef CwiseNullaryOp<internal::linspaced_op<Scalar>,PlainObject> RandomAccessLinSpacedReturnType;
     /** \internal the return type of MatrixBase::eigenvalues() */
     typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;
 
 #endif // not EIGEN_PARSED_BY_DOXYGEN
 
     /** Copies \a other into *this. \returns a reference to *this. */
     template<typename OtherDerived>
@@ -293,25 +298,25 @@
     Derived& operator-=(const EigenBase<OtherDerived> &other);
 
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     Derived& operator=(const ReturnByValue<OtherDerived>& func);
 
     /** \internal
-      * Copies \a other into *this without evaluating other. \returns a reference to *this.
-      * \deprecated */
+      * Copies \a other into *this without evaluating other. \returns a reference to *this. */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC
+    /** \deprecated */
+    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC
     Derived& lazyAssign(const DenseBase<OtherDerived>& other);
 
     EIGEN_DEVICE_FUNC
     CommaInitializer<Derived> operator<< (const Scalar& s);
 
-    /** \deprecated it now returns \c *this */
     template<unsigned int Added,unsigned int Removed>
+    /** \deprecated it now returns \c *this */
     EIGEN_DEPRECATED
     const Derived& flagged() const
     { return derived(); }
 
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     CommaInitializer<Derived> operator<< (const DenseBase<OtherDerived>& other);
@@ -328,20 +333,21 @@
     EIGEN_DEVICE_FUNC static const ConstantReturnType
     Constant(Index rows, Index cols, const Scalar& value);
     EIGEN_DEVICE_FUNC static const ConstantReturnType
     Constant(Index size, const Scalar& value);
     EIGEN_DEVICE_FUNC static const ConstantReturnType
     Constant(const Scalar& value);
 
-    EIGEN_DEVICE_FUNC static const SequentialLinSpacedReturnType
+    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
     LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high);
+    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
+    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);
+
     EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
     LinSpaced(Index size, const Scalar& low, const Scalar& high);
-    EIGEN_DEVICE_FUNC static const SequentialLinSpacedReturnType
-    LinSpaced(Sequential_t, const Scalar& low, const Scalar& high);
     EIGEN_DEVICE_FUNC static const RandomAccessLinSpacedReturnType
     LinSpaced(const Scalar& low, const Scalar& high);
 
     template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
     static const CwiseNullaryOp<CustomNullaryOp, PlainObject>
     NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func);
     template<typename CustomNullaryOp> EIGEN_DEVICE_FUNC
@@ -365,68 +371,68 @@
     EIGEN_DEVICE_FUNC Derived& setZero();
     EIGEN_DEVICE_FUNC Derived& setOnes();
     EIGEN_DEVICE_FUNC Derived& setRandom();
 
     template<typename OtherDerived> EIGEN_DEVICE_FUNC
     bool isApprox(const DenseBase<OtherDerived>& other,
                   const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
-    EIGEN_DEVICE_FUNC 
+    EIGEN_DEVICE_FUNC
     bool isMuchSmallerThan(const RealScalar& other,
                            const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
     template<typename OtherDerived> EIGEN_DEVICE_FUNC
     bool isMuchSmallerThan(const DenseBase<OtherDerived>& other,
                            const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 
     EIGEN_DEVICE_FUNC bool isApproxToConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
     EIGEN_DEVICE_FUNC bool isConstant(const Scalar& value, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
     EIGEN_DEVICE_FUNC bool isZero(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
     EIGEN_DEVICE_FUNC bool isOnes(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
-    
+
     inline bool hasNaN() const;
     inline bool allFinite() const;
 
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     Derived& operator*=(const Scalar& other);
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     Derived& operator/=(const Scalar& other);
 
     typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;
     /** \returns the matrix or vector obtained by evaluating this expression.
       *
       * Notice that in the case of a plain matrix or vector (not an expression) this function just returns
       * a const reference, in order to avoid a useless copy.
-      * 
-      * \warning Be carefull with eval() and the auto C++ keyword, as detailed in this \link TopicPitfalls_auto_keyword page \endlink.
+      *
+      * \warning Be careful with eval() and the auto C++ keyword, as detailed in this \link TopicPitfalls_auto_keyword page \endlink.
       */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE EvalReturnType eval() const
     {
       // Even though MSVC does not honor strong inlining when the return type
       // is a dynamic matrix, we desperately need strong inlining for fixed
       // size types on MSVC.
       return typename internal::eval<Derived>::type(derived());
     }
-    
+
     /** swaps *this with the expression \a other.
       *
       */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     void swap(const DenseBase<OtherDerived>& other)
     {
       EIGEN_STATIC_ASSERT(!OtherDerived::IsPlainObjectBase,THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY);
       eigen_assert(rows()==other.rows() && cols()==other.cols());
       call_assignment(derived(), other.const_cast_derived(), internal::swap_assign_op<Scalar>());
     }
 
     /** swaps *this with the matrix or array \a other.
       *
       */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     void swap(PlainObjectBase<OtherDerived>& other)
     {
       eigen_assert(rows()==other.rows() && cols()==other.cols());
       call_assignment(derived(), other.derived(), internal::swap_assign_op<Scalar>());
     }
 
     EIGEN_DEVICE_FUNC inline const NestByValue<Derived> nestByValue() const;
@@ -439,26 +445,66 @@
 
     EIGEN_DEVICE_FUNC Scalar sum() const;
     EIGEN_DEVICE_FUNC Scalar mean() const;
     EIGEN_DEVICE_FUNC Scalar trace() const;
 
     EIGEN_DEVICE_FUNC Scalar prod() const;
 
+    template<int NaNPropagation>
     EIGEN_DEVICE_FUNC typename internal::traits<Derived>::Scalar minCoeff() const;
+    template<int NaNPropagation>
     EIGEN_DEVICE_FUNC typename internal::traits<Derived>::Scalar maxCoeff() const;
 
-    template<typename IndexType> EIGEN_DEVICE_FUNC
+
+    // By default, the fastest version with undefined NaN propagation semantics is
+    // used.
+    // TODO(rmlarsen): Replace with default template argument when we move to
+    // c++11 or beyond.
+    EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Scalar minCoeff() const {
+      return minCoeff<PropagateFast>();
+    }
+    EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Scalar maxCoeff() const {
+      return maxCoeff<PropagateFast>();
+    }
+
+    template<int NaNPropagation, typename IndexType>
+    EIGEN_DEVICE_FUNC
     typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const;
-    template<typename IndexType> EIGEN_DEVICE_FUNC
+    template<int NaNPropagation, typename IndexType>
+    EIGEN_DEVICE_FUNC
     typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const;
-    template<typename IndexType> EIGEN_DEVICE_FUNC
+    template<int NaNPropagation, typename IndexType>
+    EIGEN_DEVICE_FUNC
     typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const;
-    template<typename IndexType> EIGEN_DEVICE_FUNC
+    template<int NaNPropagation, typename IndexType>
+    EIGEN_DEVICE_FUNC
     typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const;
 
+    // TODO(rmlarsen): Replace these methods with a default template argument.
+    template<typename IndexType>
+    EIGEN_DEVICE_FUNC inline
+    typename internal::traits<Derived>::Scalar minCoeff(IndexType* row, IndexType* col) const {
+      return minCoeff<PropagateFast>(row, col);
+    }
+    template<typename IndexType>
+    EIGEN_DEVICE_FUNC inline
+    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* row, IndexType* col) const {
+      return maxCoeff<PropagateFast>(row, col);
+    }
+    template<typename IndexType>
+     EIGEN_DEVICE_FUNC inline
+    typename internal::traits<Derived>::Scalar minCoeff(IndexType* index) const {
+      return minCoeff<PropagateFast>(index);
+    }
+    template<typename IndexType>
+    EIGEN_DEVICE_FUNC inline
+    typename internal::traits<Derived>::Scalar maxCoeff(IndexType* index) const {
+      return maxCoeff<PropagateFast>(index);
+    }
+  
     template<typename BinaryOp>
     EIGEN_DEVICE_FUNC
     Scalar redux(const BinaryOp& func) const;
 
     template<typename Visitor>
     EIGEN_DEVICE_FUNC
     void visit(Visitor& func) const;
@@ -489,28 +535,28 @@
     EIGEN_DEVICE_FUNC Index count() const;
 
     typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;
     typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;
     typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;
     typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;
 
-    /** \returns a VectorwiseOp wrapper of *this providing additional partial reduction operations
+    /** \returns a VectorwiseOp wrapper of *this for broadcasting and partial reductions
     *
     * Example: \include MatrixBase_rowwise.cpp
     * Output: \verbinclude MatrixBase_rowwise.out
     *
     * \sa colwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
     */
     //Code moved here due to a CUDA compiler bug
     EIGEN_DEVICE_FUNC inline ConstRowwiseReturnType rowwise() const {
       return ConstRowwiseReturnType(derived());
     }
     EIGEN_DEVICE_FUNC RowwiseReturnType rowwise();
 
-    /** \returns a VectorwiseOp wrapper of *this providing additional partial reduction operations
+    /** \returns a VectorwiseOp wrapper of *this broadcasting and partial reductions
     *
     * Example: \include MatrixBase_colwise.cpp
     * Output: \verbinclude MatrixBase_colwise.out
     *
     * \sa rowwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
     */
     EIGEN_DEVICE_FUNC inline ConstColwiseReturnType colwise() const {
@@ -520,24 +566,24 @@
 
     typedef CwiseNullaryOp<internal::scalar_random_op<Scalar>,PlainObject> RandomReturnType;
     static const RandomReturnType Random(Index rows, Index cols);
     static const RandomReturnType Random(Index size);
     static const RandomReturnType Random();
 
     template<typename ThenDerived,typename ElseDerived>
-    const Select<Derived,ThenDerived,ElseDerived>
+    inline EIGEN_DEVICE_FUNC const Select<Derived,ThenDerived,ElseDerived>
     select(const DenseBase<ThenDerived>& thenMatrix,
            const DenseBase<ElseDerived>& elseMatrix) const;
 
     template<typename ThenDerived>
-    inline const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturnType>
+    inline EIGEN_DEVICE_FUNC const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturnType>
     select(const DenseBase<ThenDerived>& thenMatrix, const typename ThenDerived::Scalar& elseScalar) const;
 
     template<typename ElseDerived>
-    inline const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDerived >
+    inline EIGEN_DEVICE_FUNC const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDerived >
     select(const typename ElseDerived::Scalar& thenScalar, const DenseBase<ElseDerived>& elseMatrix) const;
 
     template<int p> RealScalar lpNorm() const;
 
     template<int RowFactor, int ColFactor>
     EIGEN_DEVICE_FUNC
     const Replicate<Derived,RowFactor,ColFactor> replicate() const;
@@ -563,39 +609,83 @@
     //Code moved here due to a CUDA compiler bug
     EIGEN_DEVICE_FUNC ConstReverseReturnType reverse() const
     {
       return ConstReverseReturnType(derived());
     }
     EIGEN_DEVICE_FUNC void reverseInPlace();
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
+    /** STL-like <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">RandomAccessIterator</a>
+      * iterator type as returned by the begin() and end() methods.
+      */
+    typedef random_access_iterator_type iterator;
+    /** This is the const version of iterator (aka read-only) */
+    typedef random_access_iterator_type const_iterator;
+    #else
+    typedef typename internal::conditional< (Flags&DirectAccessBit)==DirectAccessBit,
+                                            internal::pointer_based_stl_iterator<Derived>,
+                                            internal::generic_randaccess_stl_iterator<Derived>
+                                          >::type iterator_type;
+
+    typedef typename internal::conditional< (Flags&DirectAccessBit)==DirectAccessBit,
+                                            internal::pointer_based_stl_iterator<const Derived>,
+                                            internal::generic_randaccess_stl_iterator<const Derived>
+                                          >::type const_iterator_type;
+
+    // Stl-style iterators are supported only for vectors.
+
+    typedef typename internal::conditional< IsVectorAtCompileTime,
+                                            iterator_type,
+                                            void
+                                          >::type iterator;
+
+    typedef typename internal::conditional< IsVectorAtCompileTime,
+                                            const_iterator_type,
+                                            void
+                                          >::type const_iterator;
+    #endif
+
+    inline iterator begin();
+    inline const_iterator begin() const;
+    inline const_iterator cbegin() const;
+    inline iterator end();
+    inline const_iterator end() const;
+    inline const_iterator cend() const;
+
 #define EIGEN_CURRENT_STORAGE_BASE_CLASS Eigen::DenseBase
 #define EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL
 #define EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF(COND)
+#define EIGEN_DOC_UNARY_ADDONS(X,Y)
+#   include "../plugins/CommonCwiseUnaryOps.h"
 #   include "../plugins/BlockMethods.h"
+#   include "../plugins/IndexedViewMethods.h"
+#   include "../plugins/ReshapedMethods.h"
 #   ifdef EIGEN_DENSEBASE_PLUGIN
 #     include EIGEN_DENSEBASE_PLUGIN
 #   endif
 #undef EIGEN_CURRENT_STORAGE_BASE_CLASS
 #undef EIGEN_DOC_BLOCK_ADDONS_NOT_INNER_PANEL
 #undef EIGEN_DOC_BLOCK_ADDONS_INNER_PANEL_IF
+#undef EIGEN_DOC_UNARY_ADDONS
 
     // disable the use of evalTo for dense objects with a nice compilation error
     template<typename Dest>
     EIGEN_DEVICE_FUNC
     inline void evalTo(Dest& ) const
     {
       EIGEN_STATIC_ASSERT((internal::is_same<Dest,void>::value),THE_EVAL_EVALTO_FUNCTION_SHOULD_NEVER_BE_CALLED_FOR_DENSE_OBJECTS);
     }
 
   protected:
+    EIGEN_DEFAULT_COPY_CONSTRUCTOR(DenseBase)
     /** Default constructor. Do nothing. */
     EIGEN_DEVICE_FUNC DenseBase()
     {
       /* Just checks for self-consistency of the flags.
-       * Only do it when debugging Eigen, as this borders on paranoiac and could slow compilation down
+       * Only do it when debugging Eigen, as this borders on paranoia and could slow compilation down
        */
 #ifdef EIGEN_INTERNAL_DEBUGGING
       EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, int(IsRowMajor))
                         && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, int(!IsRowMajor))),
                           INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION)
 #endif
     }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/DenseCoeffsBase.h` & `chronogram-0.2.0/include/Eigen/src/Core/DenseCoeffsBase.h`

 * *Files 4% similar despite different names*

```diff
@@ -18,19 +18,20 @@
   typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;
 };
 }
 
 /** \brief Base class providing read-only coefficient access to matrices and arrays.
   * \ingroup Core_Module
   * \tparam Derived Type of the derived class
-  * \tparam #ReadOnlyAccessors Constant indicating read-only access
+  *
+  * \note #ReadOnlyAccessors Constant indicating read-only access
   *
   * This class defines the \c operator() \c const function and friends, which can be used to read specific
   * entries of a matrix or array.
-  * 
+  *
   * \sa DenseCoeffsBase<Derived, WriteAccessors>, DenseCoeffsBase<Derived, DirectAccessors>,
   *     \ref TopicClassHierarchy
   */
 template<typename Derived>
 class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>
 {
   public:
@@ -284,20 +285,21 @@
     void rowStride();
     void colStride();
 };
 
 /** \brief Base class providing read/write coefficient access to matrices and arrays.
   * \ingroup Core_Module
   * \tparam Derived Type of the derived class
-  * \tparam #WriteAccessors Constant indicating read/write access
+  *
+  * \note #WriteAccessors Constant indicating read/write access
   *
   * This class defines the non-const \c operator() function and friends, which can be used to write specific
   * entries of a matrix or array. This class inherits DenseCoeffsBase<Derived, ReadOnlyAccessors> which
   * defines the const variant for reading specific entries.
-  * 
+  *
   * \sa DenseCoeffsBase<Derived, DirectAccessors>, \ref TopicClassHierarchy
   */
 template<typename Derived>
 class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>
 {
   public:
 
@@ -462,15 +464,16 @@
       return (*this)[3];
     }
 };
 
 /** \brief Base class providing direct read-only coefficient access to matrices and arrays.
   * \ingroup Core_Module
   * \tparam Derived Type of the derived class
-  * \tparam #DirectAccessors Constant indicating direct access
+  *
+  * \note #DirectAccessors Constant indicating direct access
   *
   * This class defines functions to work with strides which can be used to access entries directly. This class
   * inherits DenseCoeffsBase<Derived, ReadOnlyAccessors> which defines functions to access entries read-only using
   * \c operator() .
   *
   * \sa \blank \ref TopicClassHierarchy
   */
@@ -488,62 +491,63 @@
     using Base::size;
     using Base::derived;
 
     /** \returns the pointer increment between two consecutive elements within a slice in the inner direction.
       *
       * \sa outerStride(), rowStride(), colStride()
       */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index innerStride() const
     {
       return derived().innerStride();
     }
 
     /** \returns the pointer increment between two consecutive inner slices (for example, between two consecutive columns
       *          in a column-major matrix).
       *
       * \sa innerStride(), rowStride(), colStride()
       */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index outerStride() const
     {
       return derived().outerStride();
     }
 
     // FIXME shall we remove it ?
-    inline Index stride() const
+    EIGEN_CONSTEXPR inline Index stride() const
     {
       return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
     }
 
     /** \returns the pointer increment between two consecutive rows.
       *
       * \sa innerStride(), outerStride(), colStride()
       */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index rowStride() const
     {
       return Derived::IsRowMajor ? outerStride() : innerStride();
     }
 
     /** \returns the pointer increment between two consecutive columns.
       *
       * \sa innerStride(), outerStride(), rowStride()
       */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index colStride() const
     {
       return Derived::IsRowMajor ? innerStride() : outerStride();
     }
 };
 
 /** \brief Base class providing direct read/write coefficient access to matrices and arrays.
   * \ingroup Core_Module
   * \tparam Derived Type of the derived class
-  * \tparam #DirectWriteAccessors Constant indicating direct access
+  *
+  * \note #DirectWriteAccessors Constant indicating direct access
   *
   * This class defines functions to work with strides which can be used to access entries directly. This class
   * inherits DenseCoeffsBase<Derived, WriteAccessors> which defines functions to access entries read/write using
   * \c operator().
   *
   * \sa \blank \ref TopicClassHierarchy
   */
@@ -562,64 +566,64 @@
     using Base::size;
     using Base::derived;
 
     /** \returns the pointer increment between two consecutive elements within a slice in the inner direction.
       *
       * \sa outerStride(), rowStride(), colStride()
       */
-    EIGEN_DEVICE_FUNC
-    inline Index innerStride() const
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT
     {
       return derived().innerStride();
     }
 
     /** \returns the pointer increment between two consecutive inner slices (for example, between two consecutive columns
       *          in a column-major matrix).
       *
       * \sa innerStride(), rowStride(), colStride()
       */
-    EIGEN_DEVICE_FUNC
-    inline Index outerStride() const
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT
     {
       return derived().outerStride();
     }
 
     // FIXME shall we remove it ?
-    inline Index stride() const
+    EIGEN_CONSTEXPR inline Index stride() const EIGEN_NOEXCEPT
     {
       return Derived::IsVectorAtCompileTime ? innerStride() : outerStride();
     }
 
     /** \returns the pointer increment between two consecutive rows.
       *
       * \sa innerStride(), outerStride(), colStride()
       */
-    EIGEN_DEVICE_FUNC
-    inline Index rowStride() const
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rowStride() const EIGEN_NOEXCEPT
     {
       return Derived::IsRowMajor ? outerStride() : innerStride();
     }
 
     /** \returns the pointer increment between two consecutive columns.
       *
       * \sa innerStride(), outerStride(), rowStride()
       */
-    EIGEN_DEVICE_FUNC
-    inline Index colStride() const
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index colStride() const EIGEN_NOEXCEPT
     {
       return Derived::IsRowMajor ? innerStride() : outerStride();
     }
 };
 
 namespace internal {
 
 template<int Alignment, typename Derived, bool JustReturnZero>
 struct first_aligned_impl
 {
-  static inline Index run(const Derived&)
+  static EIGEN_CONSTEXPR inline Index run(const Derived&) EIGEN_NOEXCEPT
   { return 0; }
 };
 
 template<int Alignment, typename Derived>
 struct first_aligned_impl<Alignment, Derived, false>
 {
   static inline Index run(const Derived& m)
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/DenseStorage.h` & `chronogram-0.2.0/include/Eigen/src/Core/DenseStorage.h`

 * *Files 12% similar despite different names*

```diff
@@ -43,29 +43,29 @@
                         : compute_default_alignment<T,Size>::value >
 struct plain_array
 {
   T array[Size];
 
   EIGEN_DEVICE_FUNC
   plain_array()
-  { 
+  {
     check_static_allocation_size<T,Size>();
   }
 
   EIGEN_DEVICE_FUNC
   plain_array(constructor_without_unaligned_array_assert)
-  { 
+  {
     check_static_allocation_size<T,Size>();
   }
 };
 
 #if defined(EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT)
   #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask)
-#elif EIGEN_GNUC_AT_LEAST(4,7) 
-  // GCC 4.7 is too aggressive in its optimizations and remove the alignement test based on the fact the array is declared to be aligned.
+#elif EIGEN_GNUC_AT_LEAST(4,7)
+  // GCC 4.7 is too aggressive in its optimizations and remove the alignment test based on the fact the array is declared to be aligned.
   // See this bug report: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53900
   // Hiding the origin of the array pointer behind a function argument seems to do the trick even if the function is inlined:
   template<typename PtrType>
   EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }
   #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \
     eigen_assert((internal::UIntPtr(eigen_unaligned_array_assert_workaround_gcc47(array)) & (sizemask)) == 0 \
               && "this assertion is explained here: " \
@@ -81,92 +81,116 @@
 
 template <typename T, int Size, int MatrixOrArrayOptions>
 struct plain_array<T, Size, MatrixOrArrayOptions, 8>
 {
   EIGEN_ALIGN_TO_BOUNDARY(8) T array[Size];
 
   EIGEN_DEVICE_FUNC
-  plain_array() 
+  plain_array()
   {
     EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(7);
     check_static_allocation_size<T,Size>();
   }
 
   EIGEN_DEVICE_FUNC
-  plain_array(constructor_without_unaligned_array_assert) 
-  { 
+  plain_array(constructor_without_unaligned_array_assert)
+  {
     check_static_allocation_size<T,Size>();
   }
 };
 
 template <typename T, int Size, int MatrixOrArrayOptions>
 struct plain_array<T, Size, MatrixOrArrayOptions, 16>
 {
   EIGEN_ALIGN_TO_BOUNDARY(16) T array[Size];
 
   EIGEN_DEVICE_FUNC
-  plain_array() 
-  { 
+  plain_array()
+  {
     EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(15);
     check_static_allocation_size<T,Size>();
   }
 
   EIGEN_DEVICE_FUNC
-  plain_array(constructor_without_unaligned_array_assert) 
-  { 
+  plain_array(constructor_without_unaligned_array_assert)
+  {
     check_static_allocation_size<T,Size>();
   }
 };
 
 template <typename T, int Size, int MatrixOrArrayOptions>
 struct plain_array<T, Size, MatrixOrArrayOptions, 32>
 {
   EIGEN_ALIGN_TO_BOUNDARY(32) T array[Size];
 
   EIGEN_DEVICE_FUNC
-  plain_array() 
+  plain_array()
   {
     EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(31);
     check_static_allocation_size<T,Size>();
   }
 
   EIGEN_DEVICE_FUNC
-  plain_array(constructor_without_unaligned_array_assert) 
-  { 
+  plain_array(constructor_without_unaligned_array_assert)
+  {
     check_static_allocation_size<T,Size>();
   }
 };
 
 template <typename T, int Size, int MatrixOrArrayOptions>
 struct plain_array<T, Size, MatrixOrArrayOptions, 64>
 {
   EIGEN_ALIGN_TO_BOUNDARY(64) T array[Size];
 
   EIGEN_DEVICE_FUNC
-  plain_array() 
-  { 
+  plain_array()
+  {
     EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(63);
     check_static_allocation_size<T,Size>();
   }
 
   EIGEN_DEVICE_FUNC
-  plain_array(constructor_without_unaligned_array_assert) 
-  { 
+  plain_array(constructor_without_unaligned_array_assert)
+  {
     check_static_allocation_size<T,Size>();
   }
 };
 
 template <typename T, int MatrixOrArrayOptions, int Alignment>
 struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>
 {
   T array[1];
   EIGEN_DEVICE_FUNC plain_array() {}
   EIGEN_DEVICE_FUNC plain_array(constructor_without_unaligned_array_assert) {}
 };
 
+struct plain_array_helper {
+  template<typename T, int Size, int MatrixOrArrayOptions, int Alignment>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  static void copy(const plain_array<T, Size, MatrixOrArrayOptions, Alignment>& src, const Eigen::Index size,
+                         plain_array<T, Size, MatrixOrArrayOptions, Alignment>& dst) {
+    smart_copy(src.array, src.array + size, dst.array);
+  }
+  
+  template<typename T, int Size, int MatrixOrArrayOptions, int Alignment>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  static void swap(plain_array<T, Size, MatrixOrArrayOptions, Alignment>& a, const Eigen::Index a_size,
+                   plain_array<T, Size, MatrixOrArrayOptions, Alignment>& b, const Eigen::Index b_size) {
+    if (a_size < b_size) {
+      std::swap_ranges(b.array, b.array + a_size, a.array);
+      smart_move(b.array + a_size, b.array + b_size, a.array + a_size);
+    } else if (a_size > b_size) {
+      std::swap_ranges(a.array, a.array + b_size, b.array);
+      smart_move(a.array + b_size, a.array + a_size, b.array + b_size);
+    } else {
+      std::swap_ranges(a.array, a.array + a_size, b.array);
+    }
+  }
+};
+
 } // end namespace internal
 
 /** \internal
   *
   * \class DenseStorage
   * \ingroup Core_Module
   *
@@ -186,34 +210,61 @@
   public:
     EIGEN_DEVICE_FUNC DenseStorage() {
       EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
     }
     EIGEN_DEVICE_FUNC
     explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
       : m_data(internal::constructor_without_unaligned_array_assert()) {}
-    EIGEN_DEVICE_FUNC 
+#if !EIGEN_HAS_CXX11 || defined(EIGEN_DENSE_STORAGE_CTOR_PLUGIN)
+    EIGEN_DEVICE_FUNC
     DenseStorage(const DenseStorage& other) : m_data(other.m_data) {
       EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)
     }
-    EIGEN_DEVICE_FUNC 
+#else
+    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&) = default;
+#endif
+#if !EIGEN_HAS_CXX11
+    EIGEN_DEVICE_FUNC
     DenseStorage& operator=(const DenseStorage& other)
-    { 
+    {
       if (this != &other) m_data = other.m_data;
-      return *this; 
+      return *this;
+    }
+#else
+    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage&) = default;
+#endif
+#if EIGEN_HAS_RVALUE_REFERENCES
+#if !EIGEN_HAS_CXX11
+    EIGEN_DEVICE_FUNC DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT
+      : m_data(std::move(other.m_data))
+    {
     }
+    EIGEN_DEVICE_FUNC DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
+    {
+      if (this != &other)
+        m_data = std::move(other.m_data);
+      return *this;
+    }
+#else
+    EIGEN_DEVICE_FUNC DenseStorage(DenseStorage&&) = default;
+    EIGEN_DEVICE_FUNC DenseStorage& operator=(DenseStorage&&) = default;
+#endif
+#endif
     EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) {
       EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
       eigen_internal_assert(size==rows*cols && rows==_Rows && cols==_Cols);
       EIGEN_UNUSED_VARIABLE(size);
       EIGEN_UNUSED_VARIABLE(rows);
       EIGEN_UNUSED_VARIABLE(cols);
     }
-    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }
-    EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}
-    EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
+    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {
+      numext::swap(m_data, other.m_data);
+    }
+    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return _Rows;}
+    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index cols(void) EIGEN_NOEXCEPT {return _Cols;}
     EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}
     EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}
     EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
     EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
 };
 
 // null matrix
@@ -222,16 +273,16 @@
   public:
     EIGEN_DEVICE_FUNC DenseStorage() {}
     EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert) {}
     EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&) {}
     EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage&) { return *this; }
     EIGEN_DEVICE_FUNC DenseStorage(Index,Index,Index) {}
     EIGEN_DEVICE_FUNC void swap(DenseStorage& ) {}
-    EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}
-    EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
+    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return _Rows;}
+    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index cols(void) EIGEN_NOEXCEPT {return _Cols;}
     EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}
     EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}
     EIGEN_DEVICE_FUNC const T *data() const { return 0; }
     EIGEN_DEVICE_FUNC T *data() { return 0; }
 };
 
 // more specializations for null matrices; these are necessary to resolve ambiguities
@@ -250,28 +301,36 @@
     internal::plain_array<T,Size,_Options> m_data;
     Index m_rows;
     Index m_cols;
   public:
     EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0), m_cols(0) {}
     EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
       : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0), m_cols(0) {}
-    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows), m_cols(other.m_cols) {}
-    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other) 
-    { 
+    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
+      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(other.m_rows), m_cols(other.m_cols)
+    {
+      internal::plain_array_helper::copy(other.m_data, m_rows * m_cols, m_data);
+    }
+    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
+    {
       if (this != &other)
       {
-        m_data = other.m_data;
         m_rows = other.m_rows;
         m_cols = other.m_cols;
+        internal::plain_array_helper::copy(other.m_data, m_rows * m_cols, m_data);
       }
-      return *this; 
+      return *this;
     }
     EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index cols) : m_rows(rows), m_cols(cols) {}
     EIGEN_DEVICE_FUNC void swap(DenseStorage& other)
-    { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); std::swap(m_cols,other.m_cols); }
+    {
+      internal::plain_array_helper::swap(m_data, m_rows * m_cols, other.m_data, other.m_rows * other.m_cols);
+      numext::swap(m_rows,other.m_rows);
+      numext::swap(m_cols,other.m_cols);
+    }
     EIGEN_DEVICE_FUNC Index rows() const {return m_rows;}
     EIGEN_DEVICE_FUNC Index cols() const {return m_cols;}
     EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }
     EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }
     EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
     EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
 };
@@ -281,28 +340,37 @@
 {
     internal::plain_array<T,Size,_Options> m_data;
     Index m_rows;
   public:
     EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0) {}
     EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
       : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0) {}
-    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows) {}
-    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other) 
+    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)
+      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(other.m_rows)
+    {
+      internal::plain_array_helper::copy(other.m_data, m_rows * _Cols, m_data);
+    }
+    
+    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
     {
       if (this != &other)
       {
-        m_data = other.m_data;
         m_rows = other.m_rows;
+        internal::plain_array_helper::copy(other.m_data, m_rows * _Cols, m_data);
       }
-      return *this; 
+      return *this;
     }
     EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index) : m_rows(rows) {}
-    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }
-    EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
-    EIGEN_DEVICE_FUNC Index cols(void) const {return _Cols;}
+    EIGEN_DEVICE_FUNC void swap(DenseStorage& other)
+    { 
+      internal::plain_array_helper::swap(m_data, m_rows * _Cols, other.m_data, other.m_rows * _Cols);
+      numext::swap(m_rows, other.m_rows);
+    }
+    EIGEN_DEVICE_FUNC Index rows(void) const EIGEN_NOEXCEPT {return m_rows;}
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index cols(void) const EIGEN_NOEXCEPT {return _Cols;}
     EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index) { m_rows = rows; }
     EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index) { m_rows = rows; }
     EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
     EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
 };
 
 // dynamic-size matrix with fixed-size storage and fixed height
@@ -310,30 +378,37 @@
 {
     internal::plain_array<T,Size,_Options> m_data;
     Index m_cols;
   public:
     EIGEN_DEVICE_FUNC DenseStorage() : m_cols(0) {}
     EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)
       : m_data(internal::constructor_without_unaligned_array_assert()), m_cols(0) {}
-    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_cols(other.m_cols) {}
+    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other) 
+      : m_data(internal::constructor_without_unaligned_array_assert()), m_cols(other.m_cols)
+    {
+      internal::plain_array_helper::copy(other.m_data, _Rows * m_cols, m_data);
+    }
     EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)
     {
       if (this != &other)
       {
-        m_data = other.m_data;
         m_cols = other.m_cols;
+        internal::plain_array_helper::copy(other.m_data, _Rows * m_cols, m_data);
       }
       return *this;
     }
     EIGEN_DEVICE_FUNC DenseStorage(Index, Index, Index cols) : m_cols(cols) {}
-    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }
-    EIGEN_DEVICE_FUNC Index rows(void) const {return _Rows;}
-    EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}
-    void conservativeResize(Index, Index, Index cols) { m_cols = cols; }
-    void resize(Index, Index, Index cols) { m_cols = cols; }
+    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {
+      internal::plain_array_helper::swap(m_data, _Rows * m_cols, other.m_data, _Rows * other.m_cols);
+      numext::swap(m_cols, other.m_cols);
+    }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index rows(void) const EIGEN_NOEXCEPT {return _Rows;}
+    EIGEN_DEVICE_FUNC Index cols(void) const EIGEN_NOEXCEPT {return m_cols;}
+    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index, Index cols) { m_cols = cols; }
+    EIGEN_DEVICE_FUNC void resize(Index, Index, Index cols) { m_cols = cols; }
     EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }
     EIGEN_DEVICE_FUNC T *data() { return m_data.array; }
 };
 
 // purely dynamic matrix.
 template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>
 {
@@ -377,38 +452,41 @@
       other.m_data = nullptr;
       other.m_rows = 0;
       other.m_cols = 0;
     }
     EIGEN_DEVICE_FUNC
     DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
     {
-      using std::swap;
-      swap(m_data, other.m_data);
-      swap(m_rows, other.m_rows);
-      swap(m_cols, other.m_cols);
+      numext::swap(m_data, other.m_data);
+      numext::swap(m_rows, other.m_rows);
+      numext::swap(m_cols, other.m_cols);
       return *this;
     }
 #endif
     EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }
     EIGEN_DEVICE_FUNC void swap(DenseStorage& other)
-    { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); std::swap(m_cols,other.m_cols); }
-    EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
-    EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}
+    {
+      numext::swap(m_data,other.m_data);
+      numext::swap(m_rows,other.m_rows);
+      numext::swap(m_cols,other.m_cols);
+    }
+    EIGEN_DEVICE_FUNC Index rows(void) const EIGEN_NOEXCEPT {return m_rows;}
+    EIGEN_DEVICE_FUNC Index cols(void) const EIGEN_NOEXCEPT {return m_cols;}
     void conservativeResize(Index size, Index rows, Index cols)
     {
       m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*m_cols);
       m_rows = rows;
       m_cols = cols;
     }
     EIGEN_DEVICE_FUNC void resize(Index size, Index rows, Index cols)
     {
       if(size != m_rows*m_cols)
       {
         internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols);
-        if (size)
+        if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative
           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
         else
           m_data = 0;
         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
       }
       m_rows = rows;
       m_cols = cols;
@@ -442,48 +520,50 @@
     {
       if (this != &other)
       {
         DenseStorage tmp(other);
         this->swap(tmp);
       }
       return *this;
-    }    
+    }
 #if EIGEN_HAS_RVALUE_REFERENCES
     EIGEN_DEVICE_FUNC
     DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT
       : m_data(std::move(other.m_data))
       , m_cols(std::move(other.m_cols))
     {
       other.m_data = nullptr;
       other.m_cols = 0;
     }
     EIGEN_DEVICE_FUNC
     DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
     {
-      using std::swap;
-      swap(m_data, other.m_data);
-      swap(m_cols, other.m_cols);
+      numext::swap(m_data, other.m_data);
+      numext::swap(m_cols, other.m_cols);
       return *this;
     }
 #endif
     EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }
-    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }
-    EIGEN_DEVICE_FUNC static Index rows(void) {return _Rows;}
-    EIGEN_DEVICE_FUNC Index cols(void) const {return m_cols;}
+    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {
+      numext::swap(m_data,other.m_data);
+      numext::swap(m_cols,other.m_cols);
+    }
+    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return _Rows;}
+    EIGEN_DEVICE_FUNC Index cols(void) const EIGEN_NOEXCEPT {return m_cols;}
     EIGEN_DEVICE_FUNC void conservativeResize(Index size, Index, Index cols)
     {
       m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, _Rows*m_cols);
       m_cols = cols;
     }
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index, Index cols)
     {
       if(size != _Rows*m_cols)
       {
         internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols);
-        if (size)
+        if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative
           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
         else
           m_data = 0;
         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
       }
       m_cols = cols;
     }
@@ -516,48 +596,50 @@
     {
       if (this != &other)
       {
         DenseStorage tmp(other);
         this->swap(tmp);
       }
       return *this;
-    }    
+    }
 #if EIGEN_HAS_RVALUE_REFERENCES
     EIGEN_DEVICE_FUNC
     DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT
       : m_data(std::move(other.m_data))
       , m_rows(std::move(other.m_rows))
     {
       other.m_data = nullptr;
       other.m_rows = 0;
     }
     EIGEN_DEVICE_FUNC
     DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT
     {
-      using std::swap;
-      swap(m_data, other.m_data);
-      swap(m_rows, other.m_rows);
+      numext::swap(m_data, other.m_data);
+      numext::swap(m_rows, other.m_rows);
       return *this;
     }
 #endif
     EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }
-    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }
-    EIGEN_DEVICE_FUNC Index rows(void) const {return m_rows;}
-    EIGEN_DEVICE_FUNC static Index cols(void) {return _Cols;}
+    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {
+      numext::swap(m_data,other.m_data);
+      numext::swap(m_rows,other.m_rows);
+    }
+    EIGEN_DEVICE_FUNC Index rows(void) const EIGEN_NOEXCEPT {return m_rows;}
+    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index cols(void) {return _Cols;}
     void conservativeResize(Index size, Index rows, Index)
     {
       m_data = internal::conditional_aligned_realloc_new_auto<T,(_Options&DontAlign)==0>(m_data, size, m_rows*_Cols);
       m_rows = rows;
     }
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index rows, Index)
     {
       if(size != m_rows*_Cols)
       {
         internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows);
-        if (size)
+        if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative
           m_data = internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size);
         else
           m_data = 0;
         EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})
       }
       m_rows = rows;
     }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Diagonal.h` & `chronogram-0.2.0/include/Eigen/src/Core/Diagonal.h`

 * *Files 7% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_DIAGONAL_H
 #define EIGEN_DIAGONAL_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \class Diagonal
   * \ingroup Core_Module
   *
   * \brief Expression of a diagonal/subdiagonal/superdiagonal in a matrix
   *
   * \param MatrixType the type of the object in which we are taking a sub/main/super diagonal
@@ -80,28 +80,24 @@
     EIGEN_DEVICE_FUNC
     inline Index rows() const
     {
       return m_index.value()<0 ? numext::mini<Index>(m_matrix.cols(),m_matrix.rows()+m_index.value())
                                : numext::mini<Index>(m_matrix.rows(),m_matrix.cols()-m_index.value());
     }
 
-    EIGEN_DEVICE_FUNC
-    inline Index cols() const { return 1; }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return 1; }
 
-    EIGEN_DEVICE_FUNC
-    inline Index innerStride() const
-    {
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT {
       return m_matrix.outerStride() + 1;
     }
 
-    EIGEN_DEVICE_FUNC
-    inline Index outerStride() const
-    {
-      return 0;
-    }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT { return 0; }
 
     typedef typename internal::conditional<
                        internal::is_lvalue<MatrixType>::value,
                        Scalar,
                        const Scalar
                      >::type ScalarWithConstIfNotLvalue;
 
@@ -145,16 +141,16 @@
     EIGEN_DEVICE_FUNC
     inline CoeffReturnType coeff(Index idx) const
     {
       return m_matrix.coeff(idx+rowOffset(), idx+colOffset());
     }
 
     EIGEN_DEVICE_FUNC
-    inline const typename internal::remove_all<typename MatrixType::Nested>::type& 
-    nestedExpression() const 
+    inline const typename internal::remove_all<typename MatrixType::Nested>::type&
+    nestedExpression() const
     {
       return m_matrix;
     }
 
     EIGEN_DEVICE_FUNC
     inline Index index() const
     {
@@ -163,43 +159,43 @@
 
   protected:
     typename internal::ref_selector<MatrixType>::non_const_type m_matrix;
     const internal::variable_if_dynamicindex<Index, DiagIndex> m_index;
 
   private:
     // some compilers may fail to optimize std::max etc in case of compile-time constants...
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index absDiagIndex() const { return m_index.value()>0 ? m_index.value() : -m_index.value(); }
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value()>0 ? 0 : -m_index.value(); }
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index absDiagIndex() const EIGEN_NOEXCEPT { return m_index.value()>0 ? m_index.value() : -m_index.value(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index rowOffset() const EIGEN_NOEXCEPT { return m_index.value()>0 ? 0 : -m_index.value(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index colOffset() const EIGEN_NOEXCEPT { return m_index.value()>0 ? m_index.value() : 0; }
     // trigger a compile-time error if someone try to call packet
     template<int LoadMode> typename MatrixType::PacketReturnType packet(Index) const;
     template<int LoadMode> typename MatrixType::PacketReturnType packet(Index,Index) const;
 };
 
 /** \returns an expression of the main diagonal of the matrix \c *this
   *
   * \c *this is not required to be square.
   *
   * Example: \include MatrixBase_diagonal.cpp
   * Output: \verbinclude MatrixBase_diagonal.out
   *
   * \sa class Diagonal */
 template<typename Derived>
-inline typename MatrixBase<Derived>::DiagonalReturnType
+EIGEN_DEVICE_FUNC inline typename MatrixBase<Derived>::DiagonalReturnType
 MatrixBase<Derived>::diagonal()
 {
   return DiagonalReturnType(derived());
 }
 
 /** This is the const version of diagonal(). */
 template<typename Derived>
-inline typename MatrixBase<Derived>::ConstDiagonalReturnType
+EIGEN_DEVICE_FUNC inline typename MatrixBase<Derived>::ConstDiagonalReturnType
 MatrixBase<Derived>::diagonal() const
 {
   return ConstDiagonalReturnType(derived());
 }
 
 /** \returns an expression of the \a DiagIndex-th sub or super diagonal of the matrix \c *this
   *
@@ -209,23 +205,23 @@
   * and a sub diagonal otherwise. \a DiagIndex == 0 is equivalent to the main diagonal.
   *
   * Example: \include MatrixBase_diagonal_int.cpp
   * Output: \verbinclude MatrixBase_diagonal_int.out
   *
   * \sa MatrixBase::diagonal(), class Diagonal */
 template<typename Derived>
-inline typename MatrixBase<Derived>::DiagonalDynamicIndexReturnType
+EIGEN_DEVICE_FUNC inline typename MatrixBase<Derived>::DiagonalDynamicIndexReturnType
 MatrixBase<Derived>::diagonal(Index index)
 {
   return DiagonalDynamicIndexReturnType(derived(), index);
 }
 
 /** This is the const version of diagonal(Index). */
 template<typename Derived>
-inline typename MatrixBase<Derived>::ConstDiagonalDynamicIndexReturnType
+EIGEN_DEVICE_FUNC inline typename MatrixBase<Derived>::ConstDiagonalDynamicIndexReturnType
 MatrixBase<Derived>::diagonal(Index index) const
 {
   return ConstDiagonalDynamicIndexReturnType(derived(), index);
 }
 
 /** \returns an expression of the \a DiagIndex-th sub or super diagonal of the matrix \c *this
   *
@@ -236,23 +232,25 @@
   *
   * Example: \include MatrixBase_diagonal_template_int.cpp
   * Output: \verbinclude MatrixBase_diagonal_template_int.out
   *
   * \sa MatrixBase::diagonal(), class Diagonal */
 template<typename Derived>
 template<int Index_>
+EIGEN_DEVICE_FUNC
 inline typename MatrixBase<Derived>::template DiagonalIndexReturnType<Index_>::Type
 MatrixBase<Derived>::diagonal()
 {
   return typename DiagonalIndexReturnType<Index_>::Type(derived());
 }
 
 /** This is the const version of diagonal<int>(). */
 template<typename Derived>
 template<int Index_>
+EIGEN_DEVICE_FUNC
 inline typename MatrixBase<Derived>::template ConstDiagonalIndexReturnType<Index_>::Type
 MatrixBase<Derived>::diagonal() const
 {
   return typename ConstDiagonalIndexReturnType<Index_>::Type(derived());
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/DiagonalMatrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/DiagonalMatrix.h`

 * *Files 9% similar despite different names*

```diff
@@ -40,15 +40,15 @@
     EIGEN_DEVICE_FUNC
     inline const Derived& derived() const { return *static_cast<const Derived*>(this); }
     EIGEN_DEVICE_FUNC
     inline Derived& derived() { return *static_cast<Derived*>(this); }
 
     EIGEN_DEVICE_FUNC
     DenseMatrixType toDenseMatrix() const { return derived(); }
-    
+
     EIGEN_DEVICE_FUNC
     inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }
     EIGEN_DEVICE_FUNC
     inline DiagonalVectorType& diagonal() { return derived().diagonal(); }
 
     EIGEN_DEVICE_FUNC
     inline Index rows() const { return diagonal().size(); }
@@ -79,14 +79,38 @@
     }
     EIGEN_DEVICE_FUNC
     friend inline const DiagonalWrapper<const EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar,DiagonalVectorType,product) >
     operator*(const Scalar& scalar, const DiagonalBase& other)
     {
       return DiagonalWrapper<const EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar,DiagonalVectorType,product) >(scalar * other.diagonal());
     }
+
+    template<typename OtherDerived>
+    EIGEN_DEVICE_FUNC
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
+    inline unspecified_expression_type
+    #else
+    inline const DiagonalWrapper<const EIGEN_CWISE_BINARY_RETURN_TYPE(DiagonalVectorType,typename OtherDerived::DiagonalVectorType,sum) >
+    #endif
+    operator+(const DiagonalBase<OtherDerived>& other) const
+    {
+      return (diagonal() + other.diagonal()).asDiagonal();
+    }
+
+    template<typename OtherDerived>
+    EIGEN_DEVICE_FUNC
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
+    inline unspecified_expression_type
+    #else
+    inline const DiagonalWrapper<const EIGEN_CWISE_BINARY_RETURN_TYPE(DiagonalVectorType,typename OtherDerived::DiagonalVectorType,difference) >
+    #endif
+    operator-(const DiagonalBase<OtherDerived>& other) const
+    {
+      return (diagonal() - other.diagonal()).asDiagonal();
+    }
 };
 
 #endif
 
 /** \class DiagonalMatrix
   * \ingroup Core_Module
   *
@@ -150,14 +174,38 @@
     EIGEN_DEVICE_FUNC
     inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}
 
     /** 3D constructor. */
     EIGEN_DEVICE_FUNC
     inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}
 
+    #if EIGEN_HAS_CXX11
+    /** \brief Construct a diagonal matrix with fixed size from an arbitrary number of coefficients. \cpp11
+      * 
+      * There exists C++98 anologue constructors for fixed-size diagonal matrices having 2 or 3 coefficients.
+      * 
+      * \warning To construct a diagonal matrix of fixed size, the number of values passed to this 
+      * constructor must match the fixed dimension of \c *this.
+      * 
+      * \sa DiagonalMatrix(const Scalar&, const Scalar&)
+      * \sa DiagonalMatrix(const Scalar&, const Scalar&, const Scalar&)
+      */
+    template <typename... ArgTypes>
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    DiagonalMatrix(const Scalar& a0, const Scalar& a1, const Scalar& a2, const ArgTypes&... args)
+      : m_diagonal(a0, a1, a2, args...) {}
+
+    /** \brief Constructs a DiagonalMatrix and initializes it by elements given by an initializer list of initializer
+      * lists \cpp11
+      */
+    EIGEN_DEVICE_FUNC
+    explicit EIGEN_STRONG_INLINE DiagonalMatrix(const std::initializer_list<std::initializer_list<Scalar>>& list)
+      : m_diagonal(list) {}
+    #endif  // EIGEN_HAS_CXX11
+
     /** Copy constructor. */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     /** copy constructor. prevent a default copy constructor from hiding the other templated constructor */
@@ -269,15 +317,15 @@
   *
   * Example: \include MatrixBase_asDiagonal.cpp
   * Output: \verbinclude MatrixBase_asDiagonal.out
   *
   * \sa class DiagonalWrapper, class DiagonalMatrix, diagonal(), isDiagonal()
   **/
 template<typename Derived>
-inline const DiagonalWrapper<const Derived>
+EIGEN_DEVICE_FUNC inline const DiagonalWrapper<const Derived>
 MatrixBase<Derived>::asDiagonal() const
 {
   return DiagonalWrapper<const Derived>(derived());
 }
 
 /** \returns true if *this is approximately equal to a diagonal matrix,
   *          within the precision given by \a prec.
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/DiagonalProduct.h` & `chronogram-0.2.0/include/Eigen/src/Core/DiagonalProduct.h`

 * *Files 13% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 
 namespace Eigen { 
 
 /** \returns the diagonal matrix product of \c *this by the diagonal matrix \a diagonal.
   */
 template<typename Derived>
 template<typename DiagonalDerived>
-inline const Product<Derived, DiagonalDerived, LazyProduct>
+EIGEN_DEVICE_FUNC inline const Product<Derived, DiagonalDerived, LazyProduct>
 MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &a_diagonal) const
 {
   return Product<Derived, DiagonalDerived, LazyProduct>(derived(),a_diagonal.derived());
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Dot.h` & `chronogram-0.2.0/include/Eigen/src/Core/Dot.h`

 * *Files 3% similar despite different names*

```diff
@@ -82,49 +82,49 @@
   eigen_assert(size() == other.size());
 
   return internal::dot_nocheck<Derived,OtherDerived>::run(*this, other);
 }
 
 //---------- implementation of L2 norm and related functions ----------
 
-/** \returns, for vectors, the squared \em l2 norm of \c *this, and for matrices the Frobenius norm.
+/** \returns, for vectors, the squared \em l2 norm of \c *this, and for matrices the squared Frobenius norm.
   * In both cases, it consists in the sum of the square of all the matrix entries.
   * For vectors, this is also equals to the dot product of \c *this with itself.
   *
   * \sa dot(), norm(), lpNorm()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const
 {
   return numext::real((*this).cwiseAbs2().sum());
 }
 
 /** \returns, for vectors, the \em l2 norm of \c *this, and for matrices the Frobenius norm.
   * In both cases, it consists in the square root of the sum of the square of all the matrix entries.
   * For vectors, this is also equals to the square root of the dot product of \c *this with itself.
   *
   * \sa lpNorm(), dot(), squaredNorm()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const
 {
   return numext::sqrt(squaredNorm());
 }
 
 /** \returns an expression of the quotient of \c *this by its own norm.
   *
   * \warning If the input vector is too small (i.e., this->norm()==0),
   *          then this function returns a copy of the input.
   *
   * \only_for_vectors
   *
   * \sa norm(), normalize()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::PlainObject
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::PlainObject
 MatrixBase<Derived>::normalized() const
 {
   typedef typename internal::nested_eval<Derived,2>::type _Nested;
   _Nested n(derived());
   RealScalar z = n.squaredNorm();
   // NOTE: after extensive benchmarking, this conditional does not impact performance, at least on recent x86 CPU
   if(z>RealScalar(0))
@@ -138,15 +138,15 @@
   * \only_for_vectors
   *
   * \warning If the input vector is too small (i.e., this->norm()==0), then \c *this is left unchanged.
   *
   * \sa norm(), normalized()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE void MatrixBase<Derived>::normalize()
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void MatrixBase<Derived>::normalize()
 {
   RealScalar z = squaredNorm();
   // NOTE: after extensive benchmarking, this conditional does not impact performance, at least on recent x86 CPU
   if(z>RealScalar(0))
     derived() /= numext::sqrt(z);
 }
 
@@ -159,15 +159,15 @@
   *
   * \warning If the input vector is too small (i.e., this->norm()==0),
   *          then this function returns a copy of the input.
   *
   * \sa stableNorm(), stableNormalize(), normalized()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::PlainObject
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::PlainObject
 MatrixBase<Derived>::stableNormalized() const
 {
   typedef typename internal::nested_eval<Derived,3>::type _Nested;
   _Nested n(derived());
   RealScalar w = n.cwiseAbs().maxCoeff();
   RealScalar z = (n/w).squaredNorm();
   if(z>RealScalar(0))
@@ -184,15 +184,15 @@
   * underflow and overflow when computing the norm.
   *
   * \warning If the input vector is too small (i.e., this->norm()==0), then \c *this is left unchanged.
   *
   * \sa stableNorm(), stableNormalized(), normalize()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE void MatrixBase<Derived>::stableNormalize()
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void MatrixBase<Derived>::stableNormalize()
 {
   RealScalar w = cwiseAbs().maxCoeff();
   RealScalar z = (derived()/w).squaredNorm();
   if(z>RealScalar(0))
     derived() /= numext::sqrt(z)*w;
 }
 
@@ -203,15 +203,15 @@
 template<typename Derived, int p>
 struct lpNorm_selector
 {
   typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;
   EIGEN_DEVICE_FUNC
   static inline RealScalar run(const MatrixBase<Derived>& m)
   {
-    EIGEN_USING_STD_MATH(pow)
+    EIGEN_USING_STD(pow)
     return pow(m.cwiseAbs().array().pow(p).sum(), RealScalar(1)/p);
   }
 };
 
 template<typename Derived>
 struct lpNorm_selector<Derived, 1>
 {
@@ -256,17 +256,17 @@
   * \note For matrices, this function does not compute the <a href="https://en.wikipedia.org/wiki/Operator_norm">operator-norm</a>. That is, if \c *this is a matrix, then its coefficients are interpreted as a 1D vector. Nonetheless, you can easily compute the 1-norm and \f$\infty\f$-norm matrix operator norms using \link TutorialReductionsVisitorsBroadcastingReductionsNorm partial reductions \endlink.
   *
   * \sa norm()
   */
 template<typename Derived>
 template<int p>
 #ifndef EIGEN_PARSED_BY_DOXYGEN
-inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real
+EIGEN_DEVICE_FUNC inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real
 #else
-MatrixBase<Derived>::RealScalar
+EIGEN_DEVICE_FUNC MatrixBase<Derived>::RealScalar
 #endif
 MatrixBase<Derived>::lpNorm() const
 {
   return internal::lpNorm_selector<Derived, p>::run(*this);
 }
 
 //---------- implementation of isOrthogonal / isUnitary ----------
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/EigenBase.h` & `chronogram-0.2.0/include/Eigen/src/Core/EigenBase.h`

 * *Files 3% similar despite different names*

```diff
@@ -11,33 +11,34 @@
 #ifndef EIGEN_EIGENBASE_H
 #define EIGEN_EIGENBASE_H
 
 namespace Eigen {
 
 /** \class EigenBase
   * \ingroup Core_Module
-  * 
+  *
   * Common base class for all classes T such that MatrixBase has an operator=(T) and a constructor MatrixBase(T).
   *
   * In other words, an EigenBase object is an object that can be copied into a MatrixBase.
   *
   * Besides MatrixBase-derived classes, this also includes special matrix classes such as diagonal matrices, etc.
   *
   * Notice that this class is trivial, it is only used to disambiguate overloaded functions.
   *
   * \sa \blank \ref TopicClassHierarchy
   */
 template<typename Derived> struct EigenBase
 {
 //   typedef typename internal::plain_matrix_type<Derived>::type PlainObject;
-  
+
   /** \brief The interface type of indices
     * \details To change this, \c \#define the preprocessor symbol \c EIGEN_DEFAULT_DENSE_INDEX_TYPE.
-    * \deprecated Since Eigen 3.3, its usage is deprecated. Use Eigen::Index instead.
     * \sa StorageIndex, \ref TopicPreprocessorDirectives.
+    * DEPRECATED: Since Eigen 3.3, its usage is deprecated. Use Eigen::Index instead.
+    * Deprecation is not marked with a doxygen comment because there are too many existing usages to add the deprecation attribute.
     */
   typedef Eigen::Index Index;
 
   // FIXME is it needed?
   typedef typename internal::traits<Derived>::StorageKind StorageKind;
 
   /** \returns a reference to the derived object */
@@ -51,23 +52,23 @@
   inline Derived& const_cast_derived() const
   { return *static_cast<Derived*>(const_cast<EigenBase*>(this)); }
   EIGEN_DEVICE_FUNC
   inline const Derived& const_derived() const
   { return *static_cast<const Derived*>(this); }
 
   /** \returns the number of rows. \sa cols(), RowsAtCompileTime */
-  EIGEN_DEVICE_FUNC
-  inline Index rows() const { return derived().rows(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  inline Index rows() const EIGEN_NOEXCEPT { return derived().rows(); }
   /** \returns the number of columns. \sa rows(), ColsAtCompileTime*/
-  EIGEN_DEVICE_FUNC
-  inline Index cols() const { return derived().cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  inline Index cols() const EIGEN_NOEXCEPT { return derived().cols(); }
   /** \returns the number of coefficients, which is rows()*cols().
     * \sa rows(), cols(), SizeAtCompileTime. */
-  EIGEN_DEVICE_FUNC
-  inline Index size() const { return rows() * cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  inline Index size() const EIGEN_NOEXCEPT { return rows() * cols(); }
 
   /** \internal Don't use it, but do the equivalent: \code dst = *this; \endcode */
   template<typename Dest>
   EIGEN_DEVICE_FUNC
   inline void evalTo(Dest& dst) const
   { derived().evalTo(dst); }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/ForceAlignedAccess.h` & `chronogram-0.2.0/include/Eigen/src/Core/ForceAlignedAccess.h`

 * *Files 7% similar despite different names*

```diff
@@ -37,18 +37,22 @@
   public:
 
     typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;
     EIGEN_DENSE_PUBLIC_INTERFACE(ForceAlignedAccess)
 
     EIGEN_DEVICE_FUNC explicit inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}
 
-    EIGEN_DEVICE_FUNC inline Index rows() const { return m_expression.rows(); }
-    EIGEN_DEVICE_FUNC inline Index cols() const { return m_expression.cols(); }
-    EIGEN_DEVICE_FUNC inline Index outerStride() const { return m_expression.outerStride(); }
-    EIGEN_DEVICE_FUNC inline Index innerStride() const { return m_expression.innerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_expression.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_expression.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT { return m_expression.outerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT { return m_expression.innerStride(); }
 
     EIGEN_DEVICE_FUNC inline const CoeffReturnType coeff(Index row, Index col) const
     {
       return m_expression.coeff(row, col);
     }
 
     EIGEN_DEVICE_FUNC inline Scalar& coeffRef(Index row, Index col)
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Fuzzy.h` & `chronogram-0.2.0/include/Eigen/src/Core/Fuzzy.h`

 * *Files 4% similar despite different names*

```diff
@@ -96,15 +96,15 @@
   * or vector. If you want to test whether \c *this is zero, use internal::isMuchSmallerThan(const
   * RealScalar&, RealScalar) instead.
   *
   * \sa internal::isMuchSmallerThan(const RealScalar&, RealScalar) const
   */
 template<typename Derived>
 template<typename OtherDerived>
-bool DenseBase<Derived>::isApprox(
+EIGEN_DEVICE_FUNC bool DenseBase<Derived>::isApprox(
   const DenseBase<OtherDerived>& other,
   const RealScalar& prec
 ) const
 {
   return internal::isApprox_selector<Derived, OtherDerived>::run(derived(), other.derived(), prec);
 }
 
@@ -118,15 +118,15 @@
   * For matrices, the comparison is done using the Hilbert-Schmidt norm. For this reason,
   * the value of the reference scalar \a other should come from the Hilbert-Schmidt norm
   * of a reference matrix of same dimensions.
   *
   * \sa isApprox(), isMuchSmallerThan(const DenseBase<OtherDerived>&, RealScalar) const
   */
 template<typename Derived>
-bool DenseBase<Derived>::isMuchSmallerThan(
+EIGEN_DEVICE_FUNC bool DenseBase<Derived>::isMuchSmallerThan(
   const typename NumTraits<Scalar>::Real& other,
   const RealScalar& prec
 ) const
 {
   return internal::isMuchSmallerThan_scalar_selector<Derived>::run(derived(), other, prec);
 }
 
@@ -138,15 +138,15 @@
   * \f[ \Vert v \Vert \leqslant p\,\Vert w\Vert. \f]
   * For matrices, the comparison is done using the Hilbert-Schmidt norm.
   *
   * \sa isApprox(), isMuchSmallerThan(const RealScalar&, RealScalar) const
   */
 template<typename Derived>
 template<typename OtherDerived>
-bool DenseBase<Derived>::isMuchSmallerThan(
+EIGEN_DEVICE_FUNC bool DenseBase<Derived>::isMuchSmallerThan(
   const DenseBase<OtherDerived>& other,
   const RealScalar& prec
 ) const
 {
   return internal::isMuchSmallerThan_object_selector<Derived, OtherDerived>::run(derived(), other.derived(), prec);
 }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/GeneralProduct.h` & `chronogram-0.2.0/include/Eigen/src/Core/GeneralProduct.h`

 * *Files 3% similar despite different names*

```diff
@@ -14,22 +14,32 @@
 namespace Eigen {
 
 enum {
   Large = 2,
   Small = 3
 };
 
+// Define the threshold value to fallback from the generic matrix-matrix product
+// implementation (heavy) to the lightweight coeff-based product one.
+// See generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemmProduct>
+// in products/GeneralMatrixMatrix.h for more details.
+// TODO This threshold should also be used in the compile-time selector below.
+#ifndef EIGEN_GEMM_TO_COEFFBASED_THRESHOLD
+// This default value has been obtained on a Haswell architecture.
+#define EIGEN_GEMM_TO_COEFFBASED_THRESHOLD 20
+#endif
+
 namespace internal {
 
 template<int Rows, int Cols, int Depth> struct product_type_selector;
 
 template<int Size, int MaxSize> struct product_size_category
 {
   enum {
-    #ifndef EIGEN_CUDA_ARCH
+    #ifndef EIGEN_GPU_COMPILE_PHASE
     is_large = MaxSize == Dynamic ||
                Size >= EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD ||
                (Size==Dynamic && MaxSize>=EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD),
     #else
     is_large = 0,
     #endif
     value = is_large  ? Large
@@ -149,21 +159,21 @@
 namespace internal {
 
 template<typename Scalar,int Size,int MaxSize,bool Cond> struct gemv_static_vector_if;
 
 template<typename Scalar,int Size,int MaxSize>
 struct gemv_static_vector_if<Scalar,Size,MaxSize,false>
 {
-  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }
+  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }
 };
 
 template<typename Scalar,int Size>
 struct gemv_static_vector_if<Scalar,Size,Dynamic,true>
 {
-  EIGEN_STRONG_INLINE Scalar* data() { return 0; }
+  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Scalar* data() { return 0; }
 };
 
 template<typename Scalar,int Size,int MaxSize>
 struct gemv_static_vector_if<Scalar,Size,MaxSize,true>
 {
   enum {
     ForceAlignment  = internal::packet_traits<Scalar>::Vectorizable,
@@ -214,26 +224,25 @@
     typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;
   
     typedef Map<Matrix<ResScalar,Dynamic,1>, EIGEN_PLAIN_ENUM_MIN(AlignedMax,internal::packet_traits<ResScalar>::size)> MappedDest;
 
     ActualLhsType actualLhs = LhsBlasTraits::extract(lhs);
     ActualRhsType actualRhs = RhsBlasTraits::extract(rhs);
 
-    ResScalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(lhs)
-                                  * RhsBlasTraits::extractScalarFactor(rhs);
+    ResScalar actualAlpha = combine_scalar_factors(alpha, lhs, rhs);
 
     // make sure Dest is a compile-time vector type (bug 1166)
     typedef typename conditional<Dest::IsVectorAtCompileTime, Dest, typename Dest::ColXpr>::type ActualDest;
 
     enum {
       // FIXME find a way to allow an inner stride on the result if packet_traits<Scalar>::size==1
       // on, the other hand it is good for the cache to pack the vector anyways...
       EvalToDestAtCompileTime = (ActualDest::InnerStrideAtCompileTime==1),
       ComplexByReal = (NumTraits<LhsScalar>::IsComplex) && (!NumTraits<RhsScalar>::IsComplex),
-      MightCannotUseDest = (!EvalToDestAtCompileTime) || ComplexByReal
+      MightCannotUseDest = ((!EvalToDestAtCompileTime) || ComplexByReal) && (ActualDest::MaxSizeAtCompileTime!=0)
     };
 
     typedef const_blas_data_mapper<LhsScalar,Index,ColMajor> LhsMapper;
     typedef const_blas_data_mapper<RhsScalar,Index,RowMajor> RhsMapper;
     RhsScalar compatibleAlpha = get_factor<ResScalar,RhsScalar>::run(actualAlpha);
 
     if(!MightCannotUseDest)
@@ -306,21 +315,20 @@
     typedef internal::blas_traits<Rhs> RhsBlasTraits;
     typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;
     typedef typename internal::remove_all<ActualRhsType>::type ActualRhsTypeCleaned;
 
     typename add_const<ActualLhsType>::type actualLhs = LhsBlasTraits::extract(lhs);
     typename add_const<ActualRhsType>::type actualRhs = RhsBlasTraits::extract(rhs);
 
-    ResScalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(lhs)
-                                  * RhsBlasTraits::extractScalarFactor(rhs);
+    ResScalar actualAlpha = combine_scalar_factors(alpha, lhs, rhs);
 
     enum {
       // FIXME find a way to allow an inner stride on the result if packet_traits<Scalar>::size==1
       // on, the other hand it is good for the cache to pack the vector anyways...
-      DirectlyUseRhs = ActualRhsTypeCleaned::InnerStrideAtCompileTime==1
+      DirectlyUseRhs = ActualRhsTypeCleaned::InnerStrideAtCompileTime==1 || ActualRhsTypeCleaned::MaxSizeAtCompileTime==0
     };
 
     gemv_static_vector_if<RhsScalar,ActualRhsTypeCleaned::SizeAtCompileTime,ActualRhsTypeCleaned::MaxSizeAtCompileTime,!DirectlyUseRhs> static_rhs;
 
     ei_declare_aligned_stack_constructed_variable(RhsScalar,actualRhsPtr,actualRhs.size(),
         DirectlyUseRhs ? const_cast<RhsScalar*>(actualRhs.data()) : static_rhs.data());
 
@@ -382,15 +390,16 @@
   *
   * \note If instead of the matrix product you want the coefficient-wise product, see Cwise::operator*().
   *
   * \sa lazyProduct(), operator*=(const MatrixBase&), Cwise::operator*()
   */
 template<typename Derived>
 template<typename OtherDerived>
-inline const Product<Derived, OtherDerived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+const Product<Derived, OtherDerived>
 MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const
 {
   // A note regarding the function declaration: In MSVC, this function will sometimes
   // not be inlined since DenseStorage is an unwindable object for dynamic
   // matrices and product types are holding a member to store the result.
   // Thus it does not help tagging this function with EIGEN_STRONG_INLINE.
   enum {
@@ -424,14 +433,15 @@
   * \warning This version of the matrix product can be much much slower. So use it only if you know
   * what you are doing and that you measured a true speed improvement.
   *
   * \sa operator*(const MatrixBase&)
   */
 template<typename Derived>
 template<typename OtherDerived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 const Product<Derived,OtherDerived,LazyProduct>
 MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const
 {
   enum {
     ProductIsValid =  Derived::ColsAtCompileTime==Dynamic
                    || OtherDerived::RowsAtCompileTime==Dynamic
                    || int(Derived::ColsAtCompileTime)==int(OtherDerived::RowsAtCompileTime),
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/GlobalFunctions.h` & `chronogram-0.2.0/include/Eigen/src/Core/GlobalFunctions.h`

 * *Files 7% similar despite different names*

```diff
@@ -62,118 +62,125 @@
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(tan,scalar_tan_op,tangent,\sa ArrayBase::tan)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(atan,scalar_atan_op,arc-tangent,\sa ArrayBase::atan)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(asin,scalar_asin_op,arc-sine,\sa ArrayBase::asin)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(acos,scalar_acos_op,arc-consine,\sa ArrayBase::acos)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(sinh,scalar_sinh_op,hyperbolic sine,\sa ArrayBase::sinh)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(cosh,scalar_cosh_op,hyperbolic cosine,\sa ArrayBase::cosh)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(tanh,scalar_tanh_op,hyperbolic tangent,\sa ArrayBase::tanh)
+#if EIGEN_HAS_CXX11_MATH
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(asinh,scalar_asinh_op,inverse hyperbolic sine,\sa ArrayBase::asinh)
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(acosh,scalar_acosh_op,inverse hyperbolic cosine,\sa ArrayBase::acosh)
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(atanh,scalar_atanh_op,inverse hyperbolic tangent,\sa ArrayBase::atanh)
+#endif
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(logistic,scalar_logistic_op,logistic function,\sa ArrayBase::logistic)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(lgamma,scalar_lgamma_op,natural logarithm of the gamma function,\sa ArrayBase::lgamma)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(digamma,scalar_digamma_op,derivative of lgamma,\sa ArrayBase::digamma)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(erf,scalar_erf_op,error function,\sa ArrayBase::erf)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(erfc,scalar_erfc_op,complement error function,\sa ArrayBase::erfc)
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(ndtri,scalar_ndtri_op,inverse normal distribution function,\sa ArrayBase::ndtri)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(exp,scalar_exp_op,exponential,\sa ArrayBase::exp)
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(expm1,scalar_expm1_op,exponential of a value minus 1,\sa ArrayBase::expm1)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(log,scalar_log_op,natural logarithm,\sa Eigen::log10 DOXCOMMA ArrayBase::log)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(log1p,scalar_log1p_op,natural logarithm of 1 plus the value,\sa ArrayBase::log1p)
-  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(log10,scalar_log10_op,base 10 logarithm,\sa Eigen::log DOXCOMMA ArrayBase::log)
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(log10,scalar_log10_op,base 10 logarithm,\sa Eigen::log DOXCOMMA ArrayBase::log10)
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(log2,scalar_log2_op,base 2 logarithm,\sa Eigen::log DOXCOMMA ArrayBase::log2)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(abs,scalar_abs_op,absolute value,\sa ArrayBase::abs DOXCOMMA MatrixBase::cwiseAbs)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(abs2,scalar_abs2_op,squared absolute value,\sa ArrayBase::abs2 DOXCOMMA MatrixBase::cwiseAbs2)
-  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(arg,scalar_arg_op,complex argument,\sa ArrayBase::arg)
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(arg,scalar_arg_op,complex argument,\sa ArrayBase::arg DOXCOMMA MatrixBase::cwiseArg)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(sqrt,scalar_sqrt_op,square root,\sa ArrayBase::sqrt DOXCOMMA MatrixBase::cwiseSqrt)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(rsqrt,scalar_rsqrt_op,reciprocal square root,\sa ArrayBase::rsqrt)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(square,scalar_square_op,square (power 2),\sa Eigen::abs2 DOXCOMMA Eigen::pow DOXCOMMA ArrayBase::square)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(cube,scalar_cube_op,cube (power 3),\sa Eigen::pow DOXCOMMA ArrayBase::cube)
+  EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(rint,scalar_rint_op,nearest integer,\sa Eigen::floor DOXCOMMA Eigen::ceil DOXCOMMA ArrayBase::round)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(round,scalar_round_op,nearest integer,\sa Eigen::floor DOXCOMMA Eigen::ceil DOXCOMMA ArrayBase::round)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(floor,scalar_floor_op,nearest integer not greater than the giben value,\sa Eigen::ceil DOXCOMMA ArrayBase::floor)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(ceil,scalar_ceil_op,nearest integer not less than the giben value,\sa Eigen::floor DOXCOMMA ArrayBase::ceil)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(isnan,scalar_isnan_op,not-a-number test,\sa Eigen::isinf DOXCOMMA Eigen::isfinite DOXCOMMA ArrayBase::isnan)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(isinf,scalar_isinf_op,infinite value test,\sa Eigen::isnan DOXCOMMA Eigen::isfinite DOXCOMMA ArrayBase::isinf)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(isfinite,scalar_isfinite_op,finite value test,\sa Eigen::isinf DOXCOMMA Eigen::isnan DOXCOMMA ArrayBase::isfinite)
   EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(sign,scalar_sign_op,sign (or 0),\sa ArrayBase::sign)
-  
+
   /** \returns an expression of the coefficient-wise power of \a x to the given constant \a exponent.
     *
     * \tparam ScalarExponent is the scalar type of \a exponent. It must be compatible with the scalar type of the given expression (\c Derived::Scalar).
     *
     * \sa ArrayBase::pow()
     *
     * \relates ArrayBase
     */
 #ifdef EIGEN_PARSED_BY_DOXYGEN
   template<typename Derived,typename ScalarExponent>
   inline const CwiseBinaryOp<internal::scalar_pow_op<Derived::Scalar,ScalarExponent>,Derived,Constant<ScalarExponent> >
   pow(const Eigen::ArrayBase<Derived>& x, const ScalarExponent& exponent);
 #else
-  template<typename Derived,typename ScalarExponent>
-  inline typename internal::enable_if<   !(internal::is_same<typename Derived::Scalar,ScalarExponent>::value) && EIGEN_SCALAR_BINARY_SUPPORTED(pow,typename Derived::Scalar,ScalarExponent),
-          const EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(Derived,ScalarExponent,pow) >::type
-  pow(const Eigen::ArrayBase<Derived>& x, const ScalarExponent& exponent) {
-    return x.derived().pow(exponent);
-  }
-
-  template<typename Derived>
-  inline const EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(Derived,typename Derived::Scalar,pow)
-  pow(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent) {
-    return x.derived().pow(exponent);
+  template <typename Derived,typename ScalarExponent>
+  EIGEN_DEVICE_FUNC inline
+  EIGEN_MSVC10_WORKAROUND_BINARYOP_RETURN_TYPE(
+    const EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(Derived,typename internal::promote_scalar_arg<typename Derived::Scalar
+                                                 EIGEN_COMMA ScalarExponent EIGEN_COMMA
+                                                 EIGEN_SCALAR_BINARY_SUPPORTED(pow,typename Derived::Scalar,ScalarExponent)>::type,pow))
+  pow(const Eigen::ArrayBase<Derived>& x, const ScalarExponent& exponent)
+  {
+    typedef typename internal::promote_scalar_arg<typename Derived::Scalar,ScalarExponent,
+                                                  EIGEN_SCALAR_BINARY_SUPPORTED(pow,typename Derived::Scalar,ScalarExponent)>::type PromotedExponent;
+    return EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(Derived,PromotedExponent,pow)(x.derived(),
+           typename internal::plain_constant_type<Derived,PromotedExponent>::type(x.derived().rows(), x.derived().cols(), internal::scalar_constant_op<PromotedExponent>(exponent)));
   }
 #endif
 
   /** \returns an expression of the coefficient-wise power of \a x to the given array of \a exponents.
     *
     * This function computes the coefficient-wise power.
     *
     * Example: \include Cwise_array_power_array.cpp
     * Output: \verbinclude Cwise_array_power_array.out
-    * 
+    *
     * \sa ArrayBase::pow()
     *
     * \relates ArrayBase
     */
   template<typename Derived,typename ExponentDerived>
   inline const Eigen::CwiseBinaryOp<Eigen::internal::scalar_pow_op<typename Derived::Scalar, typename ExponentDerived::Scalar>, const Derived, const ExponentDerived>
-  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<ExponentDerived>& exponents) 
+  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<ExponentDerived>& exponents)
   {
     return Eigen::CwiseBinaryOp<Eigen::internal::scalar_pow_op<typename Derived::Scalar, typename ExponentDerived::Scalar>, const Derived, const ExponentDerived>(
       x.derived(),
       exponents.derived()
     );
   }
-  
+
   /** \returns an expression of the coefficient-wise power of the scalar \a x to the given array of \a exponents.
     *
     * This function computes the coefficient-wise power between a scalar and an array of exponents.
     *
     * \tparam Scalar is the scalar type of \a x. It must be compatible with the scalar type of the given array expression (\c Derived::Scalar).
     *
     * Example: \include Cwise_scalar_power_array.cpp
     * Output: \verbinclude Cwise_scalar_power_array.out
-    * 
+    *
     * \sa ArrayBase::pow()
     *
     * \relates ArrayBase
     */
 #ifdef EIGEN_PARSED_BY_DOXYGEN
   template<typename Scalar,typename Derived>
   inline const CwiseBinaryOp<internal::scalar_pow_op<Scalar,Derived::Scalar>,Constant<Scalar>,Derived>
   pow(const Scalar& x,const Eigen::ArrayBase<Derived>& x);
 #else
-  template<typename Scalar, typename Derived>
-  inline typename internal::enable_if<   !(internal::is_same<typename Derived::Scalar,Scalar>::value) && EIGEN_SCALAR_BINARY_SUPPORTED(pow,Scalar,typename Derived::Scalar),
-          const EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar,Derived,pow) >::type
-  pow(const Scalar& x, const Eigen::ArrayBase<Derived>& exponents)
-  {
-    return EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar,Derived,pow)(
-            typename internal::plain_constant_type<Derived,Scalar>::type(exponents.rows(), exponents.cols(), x), exponents.derived() );
-  }
-
-  template<typename Derived>
-  inline const EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(typename Derived::Scalar,Derived,pow)
-  pow(const typename Derived::Scalar& x, const Eigen::ArrayBase<Derived>& exponents)
-  {
-    return EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(typename Derived::Scalar,Derived,pow)(
-      typename internal::plain_constant_type<Derived,typename Derived::Scalar>::type(exponents.rows(), exponents.cols(), x), exponents.derived() );
+  template <typename Scalar, typename Derived>
+  EIGEN_DEVICE_FUNC inline
+  EIGEN_MSVC10_WORKAROUND_BINARYOP_RETURN_TYPE(
+    const EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(typename internal::promote_scalar_arg<typename Derived::Scalar
+                                                 EIGEN_COMMA Scalar EIGEN_COMMA
+                                                 EIGEN_SCALAR_BINARY_SUPPORTED(pow,Scalar,typename Derived::Scalar)>::type,Derived,pow))
+  pow(const Scalar& x, const Eigen::ArrayBase<Derived>& exponents) {
+    typedef typename internal::promote_scalar_arg<typename Derived::Scalar,Scalar,
+                                                  EIGEN_SCALAR_BINARY_SUPPORTED(pow,Scalar,typename Derived::Scalar)>::type PromotedScalar;
+    return EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(PromotedScalar,Derived,pow)(
+           typename internal::plain_constant_type<Derived,PromotedScalar>::type(exponents.derived().rows(), exponents.derived().cols(), internal::scalar_constant_op<PromotedScalar>(x)), exponents.derived());
   }
 #endif
 
 
   namespace internal
   {
     EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY(real,scalar_real_op)
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/IO.h` & `chronogram-0.2.0/include/Eigen/src/Core/IO.h`

 * *Files 14% similar despite different names*

```diff
@@ -37,29 +37,30 @@
   *             allows to disable the alignment of columns, resulting in faster code.
   *  - \b coeffSeparator string printed between two coefficients of the same row
   *  - \b rowSeparator string printed between two rows
   *  - \b rowPrefix string printed at the beginning of each row
   *  - \b rowSuffix string printed at the end of each row
   *  - \b matPrefix string printed at the beginning of the matrix
   *  - \b matSuffix string printed at the end of the matrix
+  *  - \b fill character printed to fill the empty space in aligned columns
   *
   * Example: \include IOFormat.cpp
   * Output: \verbinclude IOFormat.out
   *
   * \sa DenseBase::format(), class WithFormat
   */
 struct IOFormat
 {
   /** Default constructor, see class IOFormat for the meaning of the parameters */
   IOFormat(int _precision = StreamPrecision, int _flags = 0,
     const std::string& _coeffSeparator = " ",
     const std::string& _rowSeparator = "\n", const std::string& _rowPrefix="", const std::string& _rowSuffix="",
-    const std::string& _matPrefix="", const std::string& _matSuffix="")
+    const std::string& _matPrefix="", const std::string& _matSuffix="", const char _fill=' ')
   : matPrefix(_matPrefix), matSuffix(_matSuffix), rowPrefix(_rowPrefix), rowSuffix(_rowSuffix), rowSeparator(_rowSeparator),
-    rowSpacer(""), coeffSeparator(_coeffSeparator), precision(_precision), flags(_flags)
+    rowSpacer(""), coeffSeparator(_coeffSeparator), fill(_fill), precision(_precision), flags(_flags)
   {
     // TODO check if rowPrefix, rowSuffix or rowSeparator contains a newline
     // don't add rowSpacer if columns are not to be aligned
     if((flags & DontAlignCols))
       return;
     int i = int(matSuffix.length())-1;
     while (i>=0 && matSuffix[i]!='\n')
@@ -67,14 +68,15 @@
       rowSpacer += ' ';
       i--;
     }
   }
   std::string matPrefix, matSuffix;
   std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;
   std::string coeffSeparator;
+  char fill;
   int precision;
   int flags;
 };
 
 /** \class WithFormat
   * \ingroup Core_Module
   *
@@ -124,22 +126,41 @@
 };
 
 /** \internal
   * print the matrix \a _m to the output stream \a s using the output format \a fmt */
 template<typename Derived>
 std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)
 {
+  using internal::is_same;
+  using internal::conditional;
+
   if(_m.size() == 0)
   {
     s << fmt.matPrefix << fmt.matSuffix;
     return s;
   }
   
   typename Derived::Nested m = _m;
   typedef typename Derived::Scalar Scalar;
+  typedef typename
+      conditional<
+          is_same<Scalar, char>::value ||
+            is_same<Scalar, unsigned char>::value ||
+            is_same<Scalar, numext::int8_t>::value ||
+            is_same<Scalar, numext::uint8_t>::value,
+          int,
+          typename conditional<
+              is_same<Scalar, std::complex<char> >::value ||
+                is_same<Scalar, std::complex<unsigned char> >::value ||
+                is_same<Scalar, std::complex<numext::int8_t> >::value ||
+                is_same<Scalar, std::complex<numext::uint8_t> >::value,
+              std::complex<int>,
+              const Scalar&
+            >::type
+        >::type PrintType;
 
   Index width = 0;
 
   std::streamsize explicit_precision;
   if(fmt.precision == StreamPrecision)
   {
     explicit_precision = 0;
@@ -168,38 +189,50 @@
   {
     // compute the largest width
     for(Index j = 0; j < m.cols(); ++j)
       for(Index i = 0; i < m.rows(); ++i)
       {
         std::stringstream sstr;
         sstr.copyfmt(s);
-        sstr << m.coeff(i,j);
+        sstr << static_cast<PrintType>(m.coeff(i,j));
         width = std::max<Index>(width, Index(sstr.str().length()));
       }
   }
+  std::streamsize old_width = s.width();
+  char old_fill_character = s.fill();
   s << fmt.matPrefix;
   for(Index i = 0; i < m.rows(); ++i)
   {
     if (i)
       s << fmt.rowSpacer;
     s << fmt.rowPrefix;
-    if(width) s.width(width);
-    s << m.coeff(i, 0);
+    if(width) {
+      s.fill(fmt.fill);
+      s.width(width);
+    }
+    s << static_cast<PrintType>(m.coeff(i, 0));
     for(Index j = 1; j < m.cols(); ++j)
     {
       s << fmt.coeffSeparator;
-      if (width) s.width(width);
-      s << m.coeff(i, j);
+      if(width) {
+        s.fill(fmt.fill);
+        s.width(width);
+      }
+      s << static_cast<PrintType>(m.coeff(i, j));
     }
     s << fmt.rowSuffix;
     if( i < m.rows() - 1)
       s << fmt.rowSeparator;
   }
   s << fmt.matSuffix;
   if(explicit_precision) s.precision(old_precision);
+  if(width) {
+    s.fill(old_fill_character);
+    s.width(old_width);
+  }
   return s;
 }
 
 } // end namespace internal
 
 /** \relates DenseBase
   *
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Inverse.h` & `chronogram-0.2.0/include/Eigen/src/Core/Inverse.h`

 * *Files 7% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
-// Copyright (C) 2014 Gael Guennebaud <gael.guennebaud@inria.fr>
+// Copyright (C) 2014-2019 Gael Guennebaud <gael.guennebaud@inria.fr>
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_INVERSE_H
 #define EIGEN_INVERSE_H
 
-namespace Eigen { 
+namespace Eigen {
 
 template<typename XprType,typename StorageKind> class InverseImpl;
 
 namespace internal {
 
 template<typename XprType>
 struct traits<Inverse<XprType> >
@@ -40,27 +40,26 @@
   *
   */
 template<typename XprType>
 class Inverse : public InverseImpl<XprType,typename internal::traits<XprType>::StorageKind>
 {
 public:
   typedef typename XprType::StorageIndex StorageIndex;
-  typedef typename XprType::PlainObject                       PlainObject;
   typedef typename XprType::Scalar                            Scalar;
   typedef typename internal::ref_selector<XprType>::type      XprTypeNested;
   typedef typename internal::remove_all<XprTypeNested>::type  XprTypeNestedCleaned;
   typedef typename internal::ref_selector<Inverse>::type Nested;
   typedef typename internal::remove_all<XprType>::type NestedExpression;
-  
+
   explicit EIGEN_DEVICE_FUNC Inverse(const XprType &xpr)
     : m_xpr(xpr)
   {}
 
-  EIGEN_DEVICE_FUNC Index rows() const { return m_xpr.rows(); }
-  EIGEN_DEVICE_FUNC Index cols() const { return m_xpr.cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR  Index rows() const EIGEN_NOEXCEPT { return m_xpr.cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR  Index cols() const EIGEN_NOEXCEPT { return m_xpr.rows(); }
 
   EIGEN_DEVICE_FUNC const XprTypeNestedCleaned& nestedExpression() const { return m_xpr; }
 
 protected:
   XprTypeNested m_xpr;
 };
 
@@ -78,41 +77,41 @@
   Scalar coeff(Index i) const;
 };
 
 namespace internal {
 
 /** \internal
   * \brief Default evaluator for Inverse expression.
-  * 
+  *
   * This default evaluator for Inverse expression simply evaluate the inverse into a temporary
   * by a call to internal::call_assignment_no_alias.
   * Therefore, inverse implementers only have to specialize Assignment<Dst,Inverse<...>, ...> for
   * there own nested expression.
   *
   * \sa class Inverse
   */
 template<typename ArgType>
 struct unary_evaluator<Inverse<ArgType> >
   : public evaluator<typename Inverse<ArgType>::PlainObject>
 {
   typedef Inverse<ArgType> InverseType;
   typedef typename InverseType::PlainObject PlainObject;
   typedef evaluator<PlainObject> Base;
-  
+
   enum { Flags = Base::Flags | EvalBeforeNestingBit };
 
   unary_evaluator(const InverseType& inv_xpr)
     : m_result(inv_xpr.rows(), inv_xpr.cols())
   {
     ::new (static_cast<Base*>(this)) Base(m_result);
     internal::call_assignment_no_alias(m_result, inv_xpr);
   }
-  
+
 protected:
   PlainObject m_result;
 };
-  
+
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_INVERSE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Map.h` & `chronogram-0.2.0/include/Eigen/src/Core/Map.h`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_MAP_H
 #define EIGEN_MAP_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 template<typename PlainObjectType, int MapOptions, typename StrideType>
 struct traits<Map<PlainObjectType, MapOptions, StrideType> >
   : public traits<PlainObjectType>
 {
   typedef traits<PlainObjectType> TraitsBase;
@@ -43,15 +43,15 @@
 
 /** \class Map
   * \ingroup Core_Module
   *
   * \brief A matrix or vector expression mapping an existing array of data.
   *
   * \tparam PlainObjectType the equivalent matrix type of the mapped data
-  * \tparam MapOptions specifies the pointer alignment in bytes. It can be: \c #Aligned128, , \c #Aligned64, \c #Aligned32, \c #Aligned16, \c #Aligned8 or \c #Unaligned.
+  * \tparam MapOptions specifies the pointer alignment in bytes. It can be: \c #Aligned128, \c #Aligned64, \c #Aligned32, \c #Aligned16, \c #Aligned8 or \c #Unaligned.
   *                The default is \c #Unaligned.
   * \tparam StrideType optionally specifies strides. By default, Map assumes the memory layout
   *                   of an ordinary, contiguous array. This can be overridden by specifying strides.
   *                   The type passed here must be a specialization of the Stride template, see examples below.
   *
   * This class represents a matrix or vector expression mapping an existing array of data.
   * It can be used to let Eigen interface without any overhead with non-Eigen data structures,
@@ -100,27 +100,27 @@
     EIGEN_DENSE_PUBLIC_INTERFACE(Map)
 
     typedef typename Base::PointerType PointerType;
     typedef PointerType PointerArgType;
     EIGEN_DEVICE_FUNC
     inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }
 
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index innerStride() const
     {
       return StrideType::InnerStrideAtCompileTime != 0 ? m_stride.inner() : 1;
     }
 
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index outerStride() const
     {
-      return int(StrideType::OuterStrideAtCompileTime) != 0 ? m_stride.outer()
-           : int(internal::traits<Map>::OuterStrideAtCompileTime) != Dynamic ? Index(internal::traits<Map>::OuterStrideAtCompileTime)
+      return StrideType::OuterStrideAtCompileTime != 0 ? m_stride.outer()
+           : internal::traits<Map>::OuterStrideAtCompileTime != Dynamic ? Index(internal::traits<Map>::OuterStrideAtCompileTime)
            : IsVectorAtCompileTime ? (this->size() * innerStride())
-           : (int(Flags)&RowMajorBit) ? (this->cols() * innerStride())
+           : int(Flags)&RowMajorBit ? (this->cols() * innerStride())
            : (this->rows() * innerStride());
     }
 
     /** Constructor in the fixed-size case.
       *
       * \param dataPtr pointer to the array to map
       * \param stride optional Stride object, passing the strides.
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/MapBase.h` & `chronogram-0.2.0/include/Eigen/src/Core/MapBase.h`

 * *Files 2% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 #ifndef EIGEN_MAPBASE_H
 #define EIGEN_MAPBASE_H
 
 #define EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(Derived) \
       EIGEN_STATIC_ASSERT((int(internal::evaluator<Derived>::Flags) & LinearAccessBit) || Derived::IsVectorAtCompileTime, \
                           YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT)
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \ingroup Core_Module
   *
   * \brief Base class for dense Map and Block expression with direct access
   *
   * This base class provides the const low-level accessors (e.g. coeff, coeffRef) of dense
   * Map and Block objects with direct access.
@@ -83,17 +83,19 @@
 
     // bug 217 - compile error on ICC 11.1
     using Base::operator=;
 
     typedef typename Base::CoeffReturnType CoeffReturnType;
 
     /** \copydoc DenseBase::rows() */
-    EIGEN_DEVICE_FUNC inline Index rows() const { return m_rows.value(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_rows.value(); }
     /** \copydoc DenseBase::cols() */
-    EIGEN_DEVICE_FUNC inline Index cols() const { return m_cols.value(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_cols.value(); }
 
     /** Returns a pointer to the first coefficient of the matrix or vector.
       *
       * \note When addressing this data, make sure to honor the strides returned by innerStride() and outerStride().
       *
       * \sa innerStride(), outerStride()
       */
@@ -178,14 +180,16 @@
     }
 
     #ifdef EIGEN_MAPBASE_PLUGIN
     #include EIGEN_MAPBASE_PLUGIN
     #endif
 
   protected:
+    EIGEN_DEFAULT_COPY_CONSTRUCTOR(MapBase)
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(MapBase)
 
     template<typename T>
     EIGEN_DEVICE_FUNC
     void checkSanity(typename internal::enable_if<(internal::traits<T>::Alignment>0),void*>::type = 0) const
     {
 #if EIGEN_MAX_ALIGN_BYTES>0
       // innerStride() is not set yet when this function is called, so we optimistically assume the lowest plausible value:
@@ -290,14 +294,17 @@
       ReadOnlyMapBase::Base::operator=(other);
       return derived();
     }
 
     // In theory we could simply refer to Base:Base::operator=, but MSVC does not like Base::Base,
     // see bugs 821 and 920.
     using ReadOnlyMapBase::Base::operator=;
+  protected:
+    EIGEN_DEFAULT_COPY_CONSTRUCTOR(MapBase)
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(MapBase)
 };
 
 #undef EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS
 
 } // end namespace Eigen
 
 #endif // EIGEN_MAPBASE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/MathFunctions.h` & `chronogram-0.2.0/include/Eigen/src/Core/MathFunctions.h`

 * *Files 23% similar despite different names*

```diff
@@ -1,23 +1,25 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
 // Copyright (C) 2006-2010 Benoit Jacob <jacob.benoit.1@gmail.com>
+// Copyright (c) 2021, NVIDIA CORPORATION. All rights reserved.
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_MATHFUNCTIONS_H
 #define EIGEN_MATHFUNCTIONS_H
 
-// source: http://www.geom.uiuc.edu/~huberty/math5337/groupe/digits.html
 // TODO this should better be moved to NumTraits
-#define EIGEN_PI 3.141592653589793238462643383279502884197169399375105820974944592307816406L
-
+// Source: WolframAlpha
+#define EIGEN_PI    3.141592653589793238462643383279502884197169399375105820974944592307816406L
+#define EIGEN_LOG2E 1.442695040888963407359924681001892137426645954152985934135449406931109219L
+#define EIGEN_LN2   0.693147180559945309417232121458176568075500134360255254120680009493393621L
 
 namespace Eigen {
 
 // On WINCE, std::abs is defined for int only, so let's defined our own overloads:
 // This issue has been confirmed with MSVC 2008 only, but the issue might exist for more recent versions too.
 #if EIGEN_OS_WINCE && EIGEN_COMP_MSVC && EIGEN_COMP_MSVC<=1500
 long        abs(long        x) { return (labs(x));  }
@@ -93,15 +95,15 @@
     using std::real;
     return real(x);
   }
 };
 
 template<typename Scalar> struct real_impl : real_default_impl<Scalar> {};
 
-#ifdef __CUDA_ARCH__
+#if defined(EIGEN_GPU_COMPILE_PHASE)
 template<typename T>
 struct real_impl<std::complex<T> >
 {
   typedef T RealScalar;
   EIGEN_DEVICE_FUNC
   static inline T run(const std::complex<T>& x)
   {
@@ -141,15 +143,15 @@
     using std::imag;
     return imag(x);
   }
 };
 
 template<typename Scalar> struct imag_impl : imag_default_impl<Scalar> {};
 
-#ifdef __CUDA_ARCH__
+#if defined(EIGEN_GPU_COMPILE_PHASE)
 template<typename T>
 struct imag_impl<std::complex<T> >
 {
   typedef T RealScalar;
   EIGEN_DEVICE_FUNC
   static inline T run(const std::complex<T>& x)
   {
@@ -209,20 +211,20 @@
     return reinterpret_cast<RealScalar*>(&x)[1];
   }
 };
 
 template<typename Scalar>
 struct imag_ref_default_impl<Scalar, false>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline Scalar run(Scalar&)
   {
     return Scalar(0);
   }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline const Scalar run(const Scalar&)
   {
     return Scalar(0);
   }
 };
 
 template<typename Scalar>
@@ -235,34 +237,37 @@
 };
 
 /****************************************************************************
 * Implementation of conj                                                 *
 ****************************************************************************/
 
 template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
-struct conj_impl
+struct conj_default_impl
 {
   EIGEN_DEVICE_FUNC
   static inline Scalar run(const Scalar& x)
   {
     return x;
   }
 };
 
 template<typename Scalar>
-struct conj_impl<Scalar,true>
+struct conj_default_impl<Scalar,true>
 {
   EIGEN_DEVICE_FUNC
   static inline Scalar run(const Scalar& x)
   {
     using std::conj;
     return conj(x);
   }
 };
 
+template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
+struct conj_impl : conj_default_impl<Scalar, IsComplex> {};
+
 template<typename Scalar>
 struct conj_retval
 {
   typedef Scalar type;
 };
 
 /****************************************************************************
@@ -283,15 +288,15 @@
 template<typename Scalar>
 struct abs2_impl_default<Scalar, true> // IsComplex
 {
   typedef typename NumTraits<Scalar>::Real RealScalar;
   EIGEN_DEVICE_FUNC
   static inline RealScalar run(const Scalar& x)
   {
-    return real(x)*real(x) + imag(x)*imag(x);
+    return x.real()*x.real() + x.imag()*x.imag();
   }
 };
 
 template<typename Scalar>
 struct abs2_impl
 {
   typedef typename NumTraits<Scalar>::Real RealScalar;
@@ -305,36 +310,98 @@
 template<typename Scalar>
 struct abs2_retval
 {
   typedef typename NumTraits<Scalar>::Real type;
 };
 
 /****************************************************************************
+* Implementation of sqrt/rsqrt                                             *
+****************************************************************************/
+
+template<typename Scalar>
+struct sqrt_impl
+{
+  EIGEN_DEVICE_FUNC
+  static EIGEN_ALWAYS_INLINE Scalar run(const Scalar& x)
+  {
+    EIGEN_USING_STD(sqrt);
+    return sqrt(x);
+  }
+};
+
+// Complex sqrt defined in MathFunctionsImpl.h.
+template<typename T> EIGEN_DEVICE_FUNC std::complex<T> complex_sqrt(const std::complex<T>& a_x);
+
+// Custom implementation is faster than `std::sqrt`, works on
+// GPU, and correctly handles special cases (unlike MSVC).
+template<typename T>
+struct sqrt_impl<std::complex<T> >
+{
+  EIGEN_DEVICE_FUNC
+  static EIGEN_ALWAYS_INLINE std::complex<T> run(const std::complex<T>& x)
+  {
+    return complex_sqrt<T>(x);
+  }
+};
+
+template<typename Scalar>
+struct sqrt_retval
+{
+  typedef Scalar type;
+};
+
+// Default implementation relies on numext::sqrt, at bottom of file.
+template<typename T>
+struct rsqrt_impl;
+
+// Complex rsqrt defined in MathFunctionsImpl.h.
+template<typename T> EIGEN_DEVICE_FUNC std::complex<T> complex_rsqrt(const std::complex<T>& a_x);
+
+template<typename T>
+struct rsqrt_impl<std::complex<T> >
+{
+  EIGEN_DEVICE_FUNC
+  static EIGEN_ALWAYS_INLINE std::complex<T> run(const std::complex<T>& x)
+  {
+    return complex_rsqrt<T>(x);
+  }
+};
+
+template<typename Scalar>
+struct rsqrt_retval
+{
+  typedef Scalar type;
+};
+
+/****************************************************************************
 * Implementation of norm1                                                *
 ****************************************************************************/
 
 template<typename Scalar, bool IsComplex>
-struct norm1_default_impl
+struct norm1_default_impl;
+
+template<typename Scalar>
+struct norm1_default_impl<Scalar,true>
 {
   typedef typename NumTraits<Scalar>::Real RealScalar;
   EIGEN_DEVICE_FUNC
   static inline RealScalar run(const Scalar& x)
   {
-    EIGEN_USING_STD_MATH(abs);
-    return abs(real(x)) + abs(imag(x));
+    EIGEN_USING_STD(abs);
+    return abs(x.real()) + abs(x.imag());
   }
 };
 
 template<typename Scalar>
 struct norm1_default_impl<Scalar, false>
 {
   EIGEN_DEVICE_FUNC
   static inline Scalar run(const Scalar& x)
   {
-    EIGEN_USING_STD_MATH(abs);
+    EIGEN_USING_STD(abs);
     return abs(x);
   }
 };
 
 template<typename Scalar>
 struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};
 
@@ -356,142 +423,344 @@
   typedef typename NumTraits<Scalar>::Real type;
 };
 
 /****************************************************************************
 * Implementation of cast                                                 *
 ****************************************************************************/
 
-template<typename OldType, typename NewType>
+template<typename OldType, typename NewType, typename EnableIf = void>
 struct cast_impl
 {
   EIGEN_DEVICE_FUNC
   static inline NewType run(const OldType& x)
   {
     return static_cast<NewType>(x);
   }
 };
 
+// Casting from S -> Complex<T> leads to an implicit conversion from S to T,
+// generating warnings on clang.  Here we explicitly cast the real component.
+template<typename OldType, typename NewType>
+struct cast_impl<OldType, NewType,
+  typename internal::enable_if<
+    !NumTraits<OldType>::IsComplex && NumTraits<NewType>::IsComplex
+  >::type>
+{
+  EIGEN_DEVICE_FUNC
+  static inline NewType run(const OldType& x)
+  {
+    typedef typename NumTraits<NewType>::Real NewReal;
+    return static_cast<NewType>(static_cast<NewReal>(x));
+  }
+};
+
 // here, for once, we're plainly returning NewType: we don't want cast to do weird things.
 
 template<typename OldType, typename NewType>
 EIGEN_DEVICE_FUNC
 inline NewType cast(const OldType& x)
 {
   return cast_impl<OldType, NewType>::run(x);
 }
 
 /****************************************************************************
 * Implementation of round                                                   *
 ****************************************************************************/
 
+template<typename Scalar>
+struct round_impl
+{
+  EIGEN_DEVICE_FUNC
+  static inline Scalar run(const Scalar& x)
+  {
+    EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
 #if EIGEN_HAS_CXX11_MATH
-  template<typename Scalar>
-  struct round_impl {
-    static inline Scalar run(const Scalar& x)
-    {
-      EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
-      using std::round;
-      return round(x);
-    }
-  };
+    EIGEN_USING_STD(round);
+#endif
+    return Scalar(round(x));
+  }
+};
+
+#if !EIGEN_HAS_CXX11_MATH
+#if EIGEN_HAS_C99_MATH
+// Use ::roundf for float.
+template<>
+struct round_impl<float> {
+  EIGEN_DEVICE_FUNC
+  static inline float run(const float& x)
+  {
+    return ::roundf(x);
+  }
+};
 #else
-  template<typename Scalar>
-  struct round_impl
+template<typename Scalar>
+struct round_using_floor_ceil_impl
+{
+  EIGEN_DEVICE_FUNC
+  static inline Scalar run(const Scalar& x)
   {
-    static inline Scalar run(const Scalar& x)
-    {
-      EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
-      EIGEN_USING_STD_MATH(floor);
-      EIGEN_USING_STD_MATH(ceil);
-      return (x > Scalar(0)) ? floor(x + Scalar(0.5)) : ceil(x - Scalar(0.5));
+    EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
+    // Without C99 round/roundf, resort to floor/ceil.
+    EIGEN_USING_STD(floor);
+    EIGEN_USING_STD(ceil);
+    // If not enough precision to resolve a decimal at all, return the input.
+    // Otherwise, adding 0.5 can trigger an increment by 1.
+    const Scalar limit = Scalar(1ull << (NumTraits<Scalar>::digits() - 1));
+    if (x >= limit || x <= -limit) {
+      return x;
     }
-  };
-#endif
+    return (x > Scalar(0)) ? Scalar(floor(x + Scalar(0.5))) : Scalar(ceil(x - Scalar(0.5)));
+  }
+};
+
+template<>
+struct round_impl<float> : round_using_floor_ceil_impl<float> {};
+
+template<>
+struct round_impl<double> : round_using_floor_ceil_impl<double> {};
+#endif // EIGEN_HAS_C99_MATH
+#endif // !EIGEN_HAS_CXX11_MATH
 
 template<typename Scalar>
 struct round_retval
 {
   typedef Scalar type;
 };
 
 /****************************************************************************
-* Implementation of arg                                                     *
+* Implementation of rint                                                    *
 ****************************************************************************/
 
+template<typename Scalar>
+struct rint_impl {
+  EIGEN_DEVICE_FUNC
+  static inline Scalar run(const Scalar& x)
+  {
+    EIGEN_STATIC_ASSERT((!NumTraits<Scalar>::IsComplex), NUMERIC_TYPE_MUST_BE_REAL)
 #if EIGEN_HAS_CXX11_MATH
-  template<typename Scalar>
-  struct arg_impl {
-    static inline Scalar run(const Scalar& x)
-    {
-      EIGEN_USING_STD_MATH(arg);
-      return arg(x);
-    }
-  };
-#else
-  template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
-  struct arg_default_impl
+      EIGEN_USING_STD(rint);
+#endif
+    return rint(x);
+  }
+};
+
+#if !EIGEN_HAS_CXX11_MATH
+template<>
+struct rint_impl<double> {
+  EIGEN_DEVICE_FUNC
+  static inline double run(const double& x)
   {
-    typedef typename NumTraits<Scalar>::Real RealScalar;
-    EIGEN_DEVICE_FUNC
-    static inline RealScalar run(const Scalar& x)
-    {
-      return (x < Scalar(0)) ? Scalar(EIGEN_PI) : Scalar(0); }
-  };
+    return ::rint(x);
+  }
+};
+template<>
+struct rint_impl<float> {
+  EIGEN_DEVICE_FUNC
+  static inline float run(const float& x)
+  {
+    return ::rintf(x);
+  }
+};
+#endif
 
-  template<typename Scalar>
-  struct arg_default_impl<Scalar,true>
+template<typename Scalar>
+struct rint_retval
+{
+  typedef Scalar type;
+};
+
+/****************************************************************************
+* Implementation of arg                                                     *
+****************************************************************************/
+
+// Visual Studio 2017 has a bug where arg(float) returns 0 for negative inputs.
+// This seems to be fixed in VS 2019.
+#if EIGEN_HAS_CXX11_MATH && (!EIGEN_COMP_MSVC || EIGEN_COMP_MSVC >= 1920)
+// std::arg is only defined for types of std::complex, or integer types or float/double/long double
+template<typename Scalar,
+          bool HasStdImpl = NumTraits<Scalar>::IsComplex || is_integral<Scalar>::value
+                            || is_same<Scalar, float>::value || is_same<Scalar, double>::value
+                            || is_same<Scalar, long double>::value >
+struct arg_default_impl;
+
+template<typename Scalar>
+struct arg_default_impl<Scalar, true> {
+  typedef typename NumTraits<Scalar>::Real RealScalar;
+  EIGEN_DEVICE_FUNC
+  static inline RealScalar run(const Scalar& x)
   {
-    typedef typename NumTraits<Scalar>::Real RealScalar;
-    EIGEN_DEVICE_FUNC
-    static inline RealScalar run(const Scalar& x)
-    {
-      EIGEN_USING_STD_MATH(arg);
-      return arg(x);
-    }
-  };
+    #if defined(EIGEN_HIP_DEVICE_COMPILE)
+    // HIP does not seem to have a native device side implementation for the math routine "arg"
+    using std::arg;
+    #else
+    EIGEN_USING_STD(arg);
+    #endif
+    return static_cast<RealScalar>(arg(x));
+  }
+};
 
-  template<typename Scalar> struct arg_impl : arg_default_impl<Scalar> {};
+// Must be non-complex floating-point type (e.g. half/bfloat16).
+template<typename Scalar>
+struct arg_default_impl<Scalar, false> {
+  typedef typename NumTraits<Scalar>::Real RealScalar;
+  EIGEN_DEVICE_FUNC
+  static inline RealScalar run(const Scalar& x)
+  {
+    return (x < Scalar(0)) ? RealScalar(EIGEN_PI) : RealScalar(0);
+  }
+};
+#else
+template<typename Scalar, bool IsComplex = NumTraits<Scalar>::IsComplex>
+struct arg_default_impl
+{
+  typedef typename NumTraits<Scalar>::Real RealScalar;
+  EIGEN_DEVICE_FUNC
+  static inline RealScalar run(const Scalar& x)
+  {
+    return (x < RealScalar(0)) ? RealScalar(EIGEN_PI) : RealScalar(0);
+  }
+};
+
+template<typename Scalar>
+struct arg_default_impl<Scalar,true>
+{
+  typedef typename NumTraits<Scalar>::Real RealScalar;
+  EIGEN_DEVICE_FUNC
+  static inline RealScalar run(const Scalar& x)
+  {
+    EIGEN_USING_STD(arg);
+    return arg(x);
+  }
+};
 #endif
+template<typename Scalar> struct arg_impl : arg_default_impl<Scalar> {};
 
 template<typename Scalar>
 struct arg_retval
 {
   typedef typename NumTraits<Scalar>::Real type;
 };
 
 /****************************************************************************
+* Implementation of expm1                                                   *
+****************************************************************************/
+
+// This implementation is based on GSL Math's expm1.
+namespace std_fallback {
+  // fallback expm1 implementation in case there is no expm1(Scalar) function in namespace of Scalar,
+  // or that there is no suitable std::expm1 function available. Implementation
+  // attributed to Kahan. See: http://www.plunk.org/~hatch/rightway.php.
+  template<typename Scalar>
+  EIGEN_DEVICE_FUNC inline Scalar expm1(const Scalar& x) {
+    EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
+    typedef typename NumTraits<Scalar>::Real RealScalar;
+
+    EIGEN_USING_STD(exp);
+    Scalar u = exp(x);
+    if (numext::equal_strict(u, Scalar(1))) {
+      return x;
+    }
+    Scalar um1 = u - RealScalar(1);
+    if (numext::equal_strict(um1, Scalar(-1))) {
+      return RealScalar(-1);
+    }
+
+    EIGEN_USING_STD(log);
+    Scalar logu = log(u);
+    return numext::equal_strict(u, logu) ? u : (u - RealScalar(1)) * x / logu;
+  }
+}
+
+template<typename Scalar>
+struct expm1_impl {
+  EIGEN_DEVICE_FUNC static inline Scalar run(const Scalar& x)
+  {
+    EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
+    #if EIGEN_HAS_CXX11_MATH
+    using std::expm1;
+    #else
+    using std_fallback::expm1;
+    #endif
+    return expm1(x);
+  }
+};
+
+template<typename Scalar>
+struct expm1_retval
+{
+  typedef Scalar type;
+};
+
+/****************************************************************************
+* Implementation of log                                                     *
+****************************************************************************/
+
+// Complex log defined in MathFunctionsImpl.h.
+template<typename T> EIGEN_DEVICE_FUNC std::complex<T> complex_log(const std::complex<T>& z);
+
+template<typename Scalar>
+struct log_impl {
+  EIGEN_DEVICE_FUNC static inline Scalar run(const Scalar& x)
+  {
+    EIGEN_USING_STD(log);
+    return static_cast<Scalar>(log(x));
+  }
+};
+
+template<typename Scalar>
+struct log_impl<std::complex<Scalar> > {
+  EIGEN_DEVICE_FUNC static inline std::complex<Scalar> run(const std::complex<Scalar>& z)
+  {
+    return complex_log(z);
+  }
+};
+
+/****************************************************************************
 * Implementation of log1p                                                   *
 ****************************************************************************/
 
 namespace std_fallback {
   // fallback log1p implementation in case there is no log1p(Scalar) function in namespace of Scalar,
   // or that there is no suitable std::log1p function available
   template<typename Scalar>
   EIGEN_DEVICE_FUNC inline Scalar log1p(const Scalar& x) {
     EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
     typedef typename NumTraits<Scalar>::Real RealScalar;
-    EIGEN_USING_STD_MATH(log);
+    EIGEN_USING_STD(log);
     Scalar x1p = RealScalar(1) + x;
-    return numext::equal_strict(x1p, Scalar(1)) ? x : x * ( log(x1p) / (x1p - RealScalar(1)) );
+    Scalar log_1p = log_impl<Scalar>::run(x1p);
+    const bool is_small = numext::equal_strict(x1p, Scalar(1));
+    const bool is_inf = numext::equal_strict(x1p, log_1p);
+    return (is_small || is_inf) ? x : x * (log_1p / (x1p - RealScalar(1)));
   }
 }
 
 template<typename Scalar>
 struct log1p_impl {
-  static inline Scalar run(const Scalar& x)
+  EIGEN_DEVICE_FUNC static inline Scalar run(const Scalar& x)
   {
     EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)
     #if EIGEN_HAS_CXX11_MATH
     using std::log1p;
-    #endif
+    #else
     using std_fallback::log1p;
+    #endif
     return log1p(x);
   }
 };
 
+// Specialization for complex types that are not supported by std::log1p.
+template <typename RealScalar>
+struct log1p_impl<std::complex<RealScalar> > {
+  EIGEN_DEVICE_FUNC static inline std::complex<RealScalar> run(
+      const std::complex<RealScalar>& x) {
+    EIGEN_STATIC_ASSERT_NON_INTEGER(RealScalar)
+    return std_fallback::log1p(x);
+  }
+};
 
 template<typename Scalar>
 struct log1p_retval
 {
   typedef Scalar type;
 };
 
@@ -502,15 +771,15 @@
 template<typename ScalarX,typename ScalarY, bool IsInteger = NumTraits<ScalarX>::IsInteger&&NumTraits<ScalarY>::IsInteger>
 struct pow_impl
 {
   //typedef Scalar retval;
   typedef typename ScalarBinaryOpTraits<ScalarX,ScalarY,internal::scalar_pow_op<ScalarX,ScalarY> >::ReturnType result_type;
   static EIGEN_DEVICE_FUNC inline result_type run(const ScalarX& x, const ScalarY& y)
   {
-    EIGEN_USING_STD_MATH(pow);
+    EIGEN_USING_STD(pow);
     return pow(x, y);
   }
 };
 
 template<typename ScalarX,typename ScalarY>
 struct pow_impl<ScalarX,ScalarY, true>
 {
@@ -658,16 +927,16 @@
 };
 
 template<typename Scalar>
 struct random_default_impl<Scalar, true, false>
 {
   static inline Scalar run(const Scalar& x, const Scalar& y)
   {
-    return Scalar(random(real(x), real(y)),
-                  random(imag(x), imag(y)));
+    return Scalar(random(x.real(), y.real()),
+                  random(x.imag(), y.imag()));
   }
   static inline Scalar run()
   {
     typedef typename NumTraits<Scalar>::Real RealScalar;
     return Scalar(random<RealScalar>(), random<RealScalar>());
   }
 };
@@ -680,15 +949,15 @@
 
 template<typename Scalar>
 inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()
 {
   return EIGEN_MATHFUNC_IMPL(random, Scalar)::run();
 }
 
-// Implementatin of is* functions
+// Implementation of is* functions
 
 // std::is* do not work with fast-math and gcc, std::is* are available on MSVC 2013 and newer, as well as in clang.
 #if (EIGEN_HAS_CXX11_MATH && !(EIGEN_COMP_GNUC_STRICT && __FINITE_MATH_ONLY__)) || (EIGEN_COMP_MSVC>=1800) || (EIGEN_COMP_CLANG)
 #define EIGEN_USE_STD_FPCLASSIFY 1
 #else
 #define EIGEN_USE_STD_FPCLASSIFY 0
 #endif
@@ -709,45 +978,45 @@
 isfinite_impl(const T&) { return true; }
 
 template<typename T>
 EIGEN_DEVICE_FUNC
 typename internal::enable_if<(!internal::is_integral<T>::value)&&(!NumTraits<T>::IsComplex),bool>::type
 isfinite_impl(const T& x)
 {
-  #ifdef __CUDA_ARCH__
+  #if defined(EIGEN_GPU_COMPILE_PHASE)
     return (::isfinite)(x);
   #elif EIGEN_USE_STD_FPCLASSIFY
     using std::isfinite;
     return isfinite EIGEN_NOT_A_MACRO (x);
   #else
     return x<=NumTraits<T>::highest() && x>=NumTraits<T>::lowest();
   #endif
 }
 
 template<typename T>
 EIGEN_DEVICE_FUNC
 typename internal::enable_if<(!internal::is_integral<T>::value)&&(!NumTraits<T>::IsComplex),bool>::type
 isinf_impl(const T& x)
 {
-  #ifdef __CUDA_ARCH__
+  #if defined(EIGEN_GPU_COMPILE_PHASE)
     return (::isinf)(x);
   #elif EIGEN_USE_STD_FPCLASSIFY
     using std::isinf;
     return isinf EIGEN_NOT_A_MACRO (x);
   #else
     return x>NumTraits<T>::highest() || x<NumTraits<T>::lowest();
   #endif
 }
 
 template<typename T>
 EIGEN_DEVICE_FUNC
 typename internal::enable_if<(!internal::is_integral<T>::value)&&(!NumTraits<T>::IsComplex),bool>::type
 isnan_impl(const T& x)
 {
-  #ifdef __CUDA_ARCH__
+  #if defined(EIGEN_GPU_COMPILE_PHASE)
     return (::isnan)(x);
   #elif EIGEN_USE_STD_FPCLASSIFY
     using std::isnan;
     return isnan EIGEN_NOT_A_MACRO (x);
   #else
     return x != x;
   #endif
@@ -796,37 +1065,36 @@
 
 // The following overload are defined at the end of this file
 template<typename T> EIGEN_DEVICE_FUNC bool isfinite_impl(const std::complex<T>& x);
 template<typename T> EIGEN_DEVICE_FUNC bool isnan_impl(const std::complex<T>& x);
 template<typename T> EIGEN_DEVICE_FUNC bool isinf_impl(const std::complex<T>& x);
 
 template<typename T> T generic_fast_tanh_float(const T& a_x);
-
 } // end namespace internal
 
 /****************************************************************************
 * Generic math functions                                                    *
 ****************************************************************************/
 
 namespace numext {
 
-#ifndef __CUDA_ARCH__
+#if (!defined(EIGEN_GPUCC) || defined(EIGEN_CONSTEXPR_ARE_DEVICE_FUNC))
 template<typename T>
 EIGEN_DEVICE_FUNC
 EIGEN_ALWAYS_INLINE T mini(const T& x, const T& y)
 {
-  EIGEN_USING_STD_MATH(min);
+  EIGEN_USING_STD(min)
   return min EIGEN_NOT_A_MACRO (x,y);
 }
 
 template<typename T>
 EIGEN_DEVICE_FUNC
 EIGEN_ALWAYS_INLINE T maxi(const T& x, const T& y)
 {
-  EIGEN_USING_STD_MATH(max);
+  EIGEN_USING_STD(max)
   return max EIGEN_NOT_A_MACRO (x,y);
 }
 #else
 template<typename T>
 EIGEN_DEVICE_FUNC
 EIGEN_ALWAYS_INLINE T mini(const T& x, const T& y)
 {
@@ -834,26 +1102,130 @@
 }
 template<>
 EIGEN_DEVICE_FUNC
 EIGEN_ALWAYS_INLINE float mini(const float& x, const float& y)
 {
   return fminf(x, y);
 }
+template<>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE double mini(const double& x, const double& y)
+{
+  return fmin(x, y);
+}
+template<>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE long double mini(const long double& x, const long double& y)
+{
+#if defined(EIGEN_HIPCC)
+  // no "fminl" on HIP yet
+  return (x < y) ? x : y;
+#else
+  return fminl(x, y);
+#endif
+}
+
 template<typename T>
 EIGEN_DEVICE_FUNC
 EIGEN_ALWAYS_INLINE T maxi(const T& x, const T& y)
 {
   return x < y ? y : x;
 }
 template<>
 EIGEN_DEVICE_FUNC
 EIGEN_ALWAYS_INLINE float maxi(const float& x, const float& y)
 {
   return fmaxf(x, y);
 }
+template<>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE double maxi(const double& x, const double& y)
+{
+  return fmax(x, y);
+}
+template<>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE long double maxi(const long double& x, const long double& y)
+{
+#if defined(EIGEN_HIPCC)
+  // no "fmaxl" on HIP yet
+  return (x > y) ? x : y;
+#else
+  return fmaxl(x, y);
+#endif
+}
+#endif
+
+#if defined(SYCL_DEVICE_ONLY)
+
+
+#define SYCL_SPECIALIZE_SIGNED_INTEGER_TYPES_BINARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_char)   \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_short)  \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_int)    \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_long)
+#define SYCL_SPECIALIZE_SIGNED_INTEGER_TYPES_UNARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_char)   \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_short)  \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_int)    \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_long)
+#define SYCL_SPECIALIZE_UNSIGNED_INTEGER_TYPES_BINARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_uchar)  \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_ushort) \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_uint)   \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_ulong)
+#define SYCL_SPECIALIZE_UNSIGNED_INTEGER_TYPES_UNARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_uchar)  \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_ushort) \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_uint)   \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_ulong)
+#define SYCL_SPECIALIZE_INTEGER_TYPES_BINARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_SIGNED_INTEGER_TYPES_BINARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_UNSIGNED_INTEGER_TYPES_BINARY(NAME, FUNC)
+#define SYCL_SPECIALIZE_INTEGER_TYPES_UNARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_SIGNED_INTEGER_TYPES_UNARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_UNSIGNED_INTEGER_TYPES_UNARY(NAME, FUNC)
+#define SYCL_SPECIALIZE_FLOATING_TYPES_BINARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, cl::sycl::cl_float) \
+  SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC,cl::sycl::cl_double)
+#define SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(NAME, FUNC) \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, cl::sycl::cl_float) \
+  SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC,cl::sycl::cl_double)
+#define SYCL_SPECIALIZE_FLOATING_TYPES_UNARY_FUNC_RET_TYPE(NAME, FUNC, RET_TYPE) \
+  SYCL_SPECIALIZE_GEN_UNARY_FUNC(NAME, FUNC, RET_TYPE, cl::sycl::cl_float) \
+  SYCL_SPECIALIZE_GEN_UNARY_FUNC(NAME, FUNC, RET_TYPE, cl::sycl::cl_double)
+
+#define SYCL_SPECIALIZE_GEN_UNARY_FUNC(NAME, FUNC, RET_TYPE, ARG_TYPE) \
+template<>                                               \
+  EIGEN_DEVICE_FUNC                                      \
+  EIGEN_ALWAYS_INLINE RET_TYPE NAME(const ARG_TYPE& x) { \
+    return cl::sycl::FUNC(x);                            \
+  }
+
+#define SYCL_SPECIALIZE_UNARY_FUNC(NAME, FUNC, TYPE) \
+  SYCL_SPECIALIZE_GEN_UNARY_FUNC(NAME, FUNC, TYPE, TYPE)
+
+#define SYCL_SPECIALIZE_GEN1_BINARY_FUNC(NAME, FUNC, RET_TYPE, ARG_TYPE1, ARG_TYPE2) \
+  template<>                                                                  \
+  EIGEN_DEVICE_FUNC                                                           \
+  EIGEN_ALWAYS_INLINE RET_TYPE NAME(const ARG_TYPE1& x, const ARG_TYPE2& y) { \
+    return cl::sycl::FUNC(x, y);                                              \
+  }
+
+#define SYCL_SPECIALIZE_GEN2_BINARY_FUNC(NAME, FUNC, RET_TYPE, ARG_TYPE) \
+  SYCL_SPECIALIZE_GEN1_BINARY_FUNC(NAME, FUNC, RET_TYPE, ARG_TYPE, ARG_TYPE)
+
+#define SYCL_SPECIALIZE_BINARY_FUNC(NAME, FUNC, TYPE) \
+  SYCL_SPECIALIZE_GEN2_BINARY_FUNC(NAME, FUNC, TYPE, TYPE)
+
+SYCL_SPECIALIZE_INTEGER_TYPES_BINARY(mini, min)
+SYCL_SPECIALIZE_FLOATING_TYPES_BINARY(mini, fmin)
+SYCL_SPECIALIZE_INTEGER_TYPES_BINARY(maxi, max)
+SYCL_SPECIALIZE_FLOATING_TYPES_BINARY(maxi, fmax)
+
 #endif
 
 
 template<typename Scalar>
 EIGEN_DEVICE_FUNC
 inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)
 {
@@ -912,86 +1284,154 @@
 template<typename Scalar>
 EIGEN_DEVICE_FUNC
 inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)
 {
   return EIGEN_MATHFUNC_IMPL(abs2, Scalar)::run(x);
 }
 
+EIGEN_DEVICE_FUNC
+inline bool abs2(bool x) { return x; }
+
+template<typename T>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE T absdiff(const T& x, const T& y)
+{
+  return x > y ? x - y : y - x;
+}
+template<>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE float absdiff(const float& x, const float& y)
+{
+  return fabsf(x - y);
+}
+template<>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE double absdiff(const double& x, const double& y)
+{
+  return fabs(x - y);
+}
+
+#if !defined(EIGEN_GPUCC)
+// HIP and CUDA do not support long double.
+template<>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE long double absdiff(const long double& x, const long double& y) {
+  return fabsl(x - y);
+}
+#endif
+
 template<typename Scalar>
 EIGEN_DEVICE_FUNC
 inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)
 {
   return EIGEN_MATHFUNC_IMPL(norm1, Scalar)::run(x);
 }
 
 template<typename Scalar>
 EIGEN_DEVICE_FUNC
 inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)
 {
   return EIGEN_MATHFUNC_IMPL(hypot, Scalar)::run(x, y);
 }
 
+#if defined(SYCL_DEVICE_ONLY)
+  SYCL_SPECIALIZE_FLOATING_TYPES_BINARY(hypot, hypot)
+#endif
+
 template<typename Scalar>
 EIGEN_DEVICE_FUNC
 inline EIGEN_MATHFUNC_RETVAL(log1p, Scalar) log1p(const Scalar& x)
 {
   return EIGEN_MATHFUNC_IMPL(log1p, Scalar)::run(x);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(log1p, log1p)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float log1p(const float &x) { return ::log1pf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double log1p(const double &x) { return ::log1p(x); }
 #endif
 
 template<typename ScalarX,typename ScalarY>
 EIGEN_DEVICE_FUNC
 inline typename internal::pow_impl<ScalarX,ScalarY>::result_type pow(const ScalarX& x, const ScalarY& y)
 {
   return internal::pow_impl<ScalarX,ScalarY>::run(x, y);
 }
 
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_BINARY(pow, pow)
+#endif
+
 template<typename T> EIGEN_DEVICE_FUNC bool (isnan)   (const T &x) { return internal::isnan_impl(x); }
 template<typename T> EIGEN_DEVICE_FUNC bool (isinf)   (const T &x) { return internal::isinf_impl(x); }
 template<typename T> EIGEN_DEVICE_FUNC bool (isfinite)(const T &x) { return internal::isfinite_impl(x); }
 
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY_FUNC_RET_TYPE(isnan, isnan, bool)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY_FUNC_RET_TYPE(isinf, isinf, bool)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY_FUNC_RET_TYPE(isfinite, isfinite, bool)
+#endif
+
+template<typename Scalar>
+EIGEN_DEVICE_FUNC
+inline EIGEN_MATHFUNC_RETVAL(rint, Scalar) rint(const Scalar& x)
+{
+  return EIGEN_MATHFUNC_IMPL(rint, Scalar)::run(x);
+}
+
 template<typename Scalar>
 EIGEN_DEVICE_FUNC
 inline EIGEN_MATHFUNC_RETVAL(round, Scalar) round(const Scalar& x)
 {
   return EIGEN_MATHFUNC_IMPL(round, Scalar)::run(x);
 }
 
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(round, round)
+#endif
+
 template<typename T>
 EIGEN_DEVICE_FUNC
 T (floor)(const T& x)
 {
-  EIGEN_USING_STD_MATH(floor);
+  EIGEN_USING_STD(floor)
   return floor(x);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(floor, floor)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float floor(const float &x) { return ::floorf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double floor(const double &x) { return ::floor(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC
 T (ceil)(const T& x)
 {
-  EIGEN_USING_STD_MATH(ceil);
+  EIGEN_USING_STD(ceil);
   return ceil(x);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(ceil, ceil)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float ceil(const float &x) { return ::ceilf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double ceil(const double &x) { return ::ceil(x); }
 #endif
 
@@ -1016,58 +1456,78 @@
   * It is essentially equivalent to
   * \code using std::sqrt; return sqrt(x); \endcode
   * but slightly faster for float/double and some compilers (e.g., gcc), thanks to
   * specializations when SSE is enabled.
   *
   * It's usage is justified in performance critical functions, like norm/normalize.
   */
+template<typename Scalar>
+EIGEN_DEVICE_FUNC
+EIGEN_ALWAYS_INLINE EIGEN_MATHFUNC_RETVAL(sqrt, Scalar) sqrt(const Scalar& x)
+{
+  return EIGEN_MATHFUNC_IMPL(sqrt, Scalar)::run(x);
+}
+
+// Boolean specialization, avoids implicit float to bool conversion (-Wimplicit-conversion-floating-point-to-bool).
+template<>
+EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_DEVICE_FUNC
+bool sqrt<bool>(const bool &x) { return x; }
+
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(sqrt, sqrt)
+#endif
+
+/** \returns the reciprocal square root of \a x. **/
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
-T sqrt(const T &x)
+T rsqrt(const T& x)
 {
-  EIGEN_USING_STD_MATH(sqrt);
-  return sqrt(x);
+  return internal::rsqrt_impl<T>::run(x);
 }
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T log(const T &x) {
-  EIGEN_USING_STD_MATH(log);
-  return log(x);
+  return internal::log_impl<T>::run(x);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(log, log)
+#endif
+
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float log(const float &x) { return ::logf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double log(const double &x) { return ::log(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 typename internal::enable_if<NumTraits<T>::IsSigned || NumTraits<T>::IsComplex,typename NumTraits<T>::Real>::type
 abs(const T &x) {
-  EIGEN_USING_STD_MATH(abs);
+  EIGEN_USING_STD(abs);
   return abs(x);
 }
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 typename internal::enable_if<!(NumTraits<T>::IsSigned || NumTraits<T>::IsComplex),typename NumTraits<T>::Real>::type
 abs(const T &x) {
   return x;
 }
 
-#if defined(__SYCL_DEVICE_ONLY__)
-EIGEN_ALWAYS_INLINE float   abs(float x) { return cl::sycl::fabs(x); }
-EIGEN_ALWAYS_INLINE double  abs(double x) { return cl::sycl::fabs(x); }
-#endif // defined(__SYCL_DEVICE_ONLY__)
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_INTEGER_TYPES_UNARY(abs, abs)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(abs, fabs)
+#endif
 
-#ifdef __CUDACC__
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float abs(const float &x) { return ::fabsf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double abs(const double &x) { return ::fabs(x); }
 
 template <> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
@@ -1080,188 +1540,314 @@
   return ::hypot(x.real(), x.imag());
 }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T exp(const T &x) {
-  EIGEN_USING_STD_MATH(exp);
+  EIGEN_USING_STD(exp);
   return exp(x);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(exp, exp)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float exp(const float &x) { return ::expf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double exp(const double &x) { return ::exp(x); }
+
+template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
+std::complex<float> exp(const std::complex<float>& x) {
+  float com = ::expf(x.real());
+  float res_real = com * ::cosf(x.imag());
+  float res_imag = com * ::sinf(x.imag());
+  return std::complex<float>(res_real, res_imag);
+}
+
+template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
+std::complex<double> exp(const std::complex<double>& x) {
+  double com = ::exp(x.real());
+  double res_real = com * ::cos(x.imag());
+  double res_imag = com * ::sin(x.imag());
+  return std::complex<double>(res_real, res_imag);
+}
+#endif
+
+template<typename Scalar>
+EIGEN_DEVICE_FUNC
+inline EIGEN_MATHFUNC_RETVAL(expm1, Scalar) expm1(const Scalar& x)
+{
+  return EIGEN_MATHFUNC_IMPL(expm1, Scalar)::run(x);
+}
+
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(expm1, expm1)
+#endif
+
+#if defined(EIGEN_GPUCC)
+template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
+float expm1(const float &x) { return ::expm1f(x); }
+
+template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
+double expm1(const double &x) { return ::expm1(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T cos(const T &x) {
-  EIGEN_USING_STD_MATH(cos);
+  EIGEN_USING_STD(cos);
   return cos(x);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(cos,cos)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float cos(const float &x) { return ::cosf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double cos(const double &x) { return ::cos(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T sin(const T &x) {
-  EIGEN_USING_STD_MATH(sin);
+  EIGEN_USING_STD(sin);
   return sin(x);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(sin, sin)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float sin(const float &x) { return ::sinf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double sin(const double &x) { return ::sin(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T tan(const T &x) {
-  EIGEN_USING_STD_MATH(tan);
+  EIGEN_USING_STD(tan);
   return tan(x);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(tan, tan)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float tan(const float &x) { return ::tanf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double tan(const double &x) { return ::tan(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T acos(const T &x) {
-  EIGEN_USING_STD_MATH(acos);
+  EIGEN_USING_STD(acos);
   return acos(x);
 }
 
-#ifdef __CUDACC__
+#if EIGEN_HAS_CXX11_MATH
+template<typename T>
+EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
+T acosh(const T &x) {
+  EIGEN_USING_STD(acosh);
+  return static_cast<T>(acosh(x));
+}
+#endif
+
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(acos, acos)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(acosh, acosh)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float acos(const float &x) { return ::acosf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double acos(const double &x) { return ::acos(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T asin(const T &x) {
-  EIGEN_USING_STD_MATH(asin);
+  EIGEN_USING_STD(asin);
   return asin(x);
 }
 
-#ifdef __CUDACC__
+#if EIGEN_HAS_CXX11_MATH
+template<typename T>
+EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
+T asinh(const T &x) {
+  EIGEN_USING_STD(asinh);
+  return static_cast<T>(asinh(x));
+}
+#endif
+
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(asin, asin)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(asinh, asinh)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float asin(const float &x) { return ::asinf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double asin(const double &x) { return ::asin(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T atan(const T &x) {
-  EIGEN_USING_STD_MATH(atan);
-  return atan(x);
+  EIGEN_USING_STD(atan);
+  return static_cast<T>(atan(x));
+}
+
+#if EIGEN_HAS_CXX11_MATH
+template<typename T>
+EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
+T atanh(const T &x) {
+  EIGEN_USING_STD(atanh);
+  return static_cast<T>(atanh(x));
 }
+#endif
+
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(atan, atan)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(atanh, atanh)
+#endif
 
-#ifdef __CUDACC__
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float atan(const float &x) { return ::atanf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double atan(const double &x) { return ::atan(x); }
 #endif
 
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T cosh(const T &x) {
-  EIGEN_USING_STD_MATH(cosh);
-  return cosh(x);
+  EIGEN_USING_STD(cosh);
+  return static_cast<T>(cosh(x));
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(cosh, cosh)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float cosh(const float &x) { return ::coshf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double cosh(const double &x) { return ::cosh(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T sinh(const T &x) {
-  EIGEN_USING_STD_MATH(sinh);
-  return sinh(x);
+  EIGEN_USING_STD(sinh);
+  return static_cast<T>(sinh(x));
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(sinh, sinh)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float sinh(const float &x) { return ::sinhf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double sinh(const double &x) { return ::sinh(x); }
 #endif
 
 template<typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T tanh(const T &x) {
-  EIGEN_USING_STD_MATH(tanh);
+  EIGEN_USING_STD(tanh);
   return tanh(x);
 }
 
-#if (!defined(__CUDACC__)) && EIGEN_FAST_MATH
+#if (!defined(EIGEN_GPUCC)) && EIGEN_FAST_MATH && !defined(SYCL_DEVICE_ONLY)
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float tanh(float x) { return internal::generic_fast_tanh_float(x); }
 #endif
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_UNARY(tanh, tanh)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float tanh(const float &x) { return ::tanhf(x); }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double tanh(const double &x) { return ::tanh(x); }
 #endif
 
 template <typename T>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 T fmod(const T& a, const T& b) {
-  EIGEN_USING_STD_MATH(fmod);
+  EIGEN_USING_STD(fmod);
   return fmod(a, b);
 }
 
-#ifdef __CUDACC__
+#if defined(SYCL_DEVICE_ONLY)
+SYCL_SPECIALIZE_FLOATING_TYPES_BINARY(fmod, fmod)
+#endif
+
+#if defined(EIGEN_GPUCC)
 template <>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 float fmod(const float& a, const float& b) {
   return ::fmodf(a, b);
 }
 
 template <>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
 double fmod(const double& a, const double& b) {
   return ::fmod(a, b);
 }
 #endif
 
+#if defined(SYCL_DEVICE_ONLY)
+#undef SYCL_SPECIALIZE_SIGNED_INTEGER_TYPES_BINARY
+#undef SYCL_SPECIALIZE_SIGNED_INTEGER_TYPES_UNARY
+#undef SYCL_SPECIALIZE_UNSIGNED_INTEGER_TYPES_BINARY
+#undef SYCL_SPECIALIZE_UNSIGNED_INTEGER_TYPES_UNARY
+#undef SYCL_SPECIALIZE_INTEGER_TYPES_BINARY
+#undef SYCL_SPECIALIZE_UNSIGNED_INTEGER_TYPES_UNARY
+#undef SYCL_SPECIALIZE_FLOATING_TYPES_BINARY
+#undef SYCL_SPECIALIZE_FLOATING_TYPES_UNARY
+#undef SYCL_SPECIALIZE_FLOATING_TYPES_UNARY_FUNC_RET_TYPE
+#undef SYCL_SPECIALIZE_GEN_UNARY_FUNC
+#undef SYCL_SPECIALIZE_UNARY_FUNC
+#undef SYCL_SPECIALIZE_GEN1_BINARY_FUNC
+#undef SYCL_SPECIALIZE_GEN2_BINARY_FUNC
+#undef SYCL_SPECIALIZE_BINARY_FUNC
+#endif
+
 } // end namespace numext
 
 namespace internal {
 
 template<typename T>
 EIGEN_DEVICE_FUNC bool isfinite_impl(const std::complex<T>& x)
 {
@@ -1377,39 +1963,95 @@
 
 template<> struct random_impl<bool>
 {
   static inline bool run()
   {
     return random<int>(0,1)==0 ? false : true;
   }
+
+  static inline bool run(const bool& a, const bool& b)
+  {
+    return random<int>(a, b)==0 ? false : true;
+  }
 };
 
 template<> struct scalar_fuzzy_impl<bool>
 {
   typedef bool RealScalar;
-  
+
   template<typename OtherScalar> EIGEN_DEVICE_FUNC
   static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)
   {
     return !x;
   }
-  
+
   EIGEN_DEVICE_FUNC
   static inline bool isApprox(bool x, bool y, bool)
   {
     return x == y;
   }
 
   EIGEN_DEVICE_FUNC
   static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)
   {
     return (!x) || y;
   }
-  
+
+};
+
+} // end namespace internal
+
+// Default implementations that rely on other numext implementations
+namespace internal {
+
+// Specialization for complex types that are not supported by std::expm1.
+template <typename RealScalar>
+struct expm1_impl<std::complex<RealScalar> > {
+  EIGEN_DEVICE_FUNC static inline std::complex<RealScalar> run(
+      const std::complex<RealScalar>& x) {
+    EIGEN_STATIC_ASSERT_NON_INTEGER(RealScalar)
+    RealScalar xr = x.real();
+    RealScalar xi = x.imag();
+    // expm1(z) = exp(z) - 1
+    //          = exp(x +  i * y) - 1
+    //          = exp(x) * (cos(y) + i * sin(y)) - 1
+    //          = exp(x) * cos(y) - 1 + i * exp(x) * sin(y)
+    // Imag(expm1(z)) = exp(x) * sin(y)
+    // Real(expm1(z)) = exp(x) * cos(y) - 1
+    //          = exp(x) * cos(y) - 1.
+    //          = expm1(x) + exp(x) * (cos(y) - 1)
+    //          = expm1(x) + exp(x) * (2 * sin(y / 2) ** 2)
+    RealScalar erm1 = numext::expm1<RealScalar>(xr);
+    RealScalar er = erm1 + RealScalar(1.);
+    RealScalar sin2 = numext::sin(xi / RealScalar(2.));
+    sin2 = sin2 * sin2;
+    RealScalar s = numext::sin(xi);
+    RealScalar real_part = erm1 - RealScalar(2.) * er * sin2;
+    return std::complex<RealScalar>(real_part, er * s);
+  }
 };
 
-  
+template<typename T>
+struct rsqrt_impl {
+  EIGEN_DEVICE_FUNC
+  static EIGEN_ALWAYS_INLINE T run(const T& x) {
+    return T(1)/numext::sqrt(x);
+  }
+};
+
+#if defined(EIGEN_GPU_COMPILE_PHASE)
+template<typename T>
+struct conj_impl<std::complex<T>, true>
+{
+  EIGEN_DEVICE_FUNC
+  static inline std::complex<T> run(const std::complex<T>& x)
+  {
+    return std::complex<T>(numext::real(x), -numext::imag(x));
+  }
+};
+#endif
+
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_MATHFUNCTIONS_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Matrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/Matrix.h`

 * *Files 18% similar despite different names*

```diff
@@ -25,30 +25,30 @@
       is_dynamic_size_storage = _MaxRows==Dynamic || _MaxCols==Dynamic,
       max_size = is_dynamic_size_storage ? Dynamic : _MaxRows*_MaxCols,
       default_alignment = compute_default_alignment<_Scalar,max_size>::value,
       actual_alignment = ((_Options&DontAlign)==0) ? default_alignment : 0,
       required_alignment = unpacket_traits<PacketScalar>::alignment,
       packet_access_bit = (packet_traits<_Scalar>::Vectorizable && (EIGEN_UNALIGNED_VECTORIZE || (actual_alignment>=required_alignment))) ? PacketAccessBit : 0
     };
-    
+
 public:
   typedef _Scalar Scalar;
   typedef Dense StorageKind;
   typedef Eigen::Index StorageIndex;
   typedef MatrixXpr XprKind;
   enum {
     RowsAtCompileTime = _Rows,
     ColsAtCompileTime = _Cols,
     MaxRowsAtCompileTime = _MaxRows,
     MaxColsAtCompileTime = _MaxCols,
     Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,
     Options = _Options,
     InnerStrideAtCompileTime = 1,
     OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime,
-    
+
     // FIXME, the following flag in only used to define NeedsToAlign in PlainObjectBase
     EvaluatorFlags = LinearAccessBit | DirectAccessBit | packet_access_bit | row_major_bit,
     Alignment = actual_alignment
   };
 };
 }
 
@@ -251,110 +251,156 @@
       *
       * For dynamic-size matrices, creates an empty matrix of size 0. Does not allocate any array. Such a matrix
       * is called a null matrix. This constructor is the unique way to create null matrices: resizing
       * a matrix to 0 is not supported.
       *
       * \sa resize(Index,Index)
       */
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Matrix() : Base()
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Matrix() : Base()
     {
       Base::_check_template_params();
       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
     }
 
     // FIXME is it still needed
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     explicit Matrix(internal::constructor_without_unaligned_array_assert)
       : Base(internal::constructor_without_unaligned_array_assert())
     { Base::_check_template_params(); EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED }
 
 #if EIGEN_HAS_RVALUE_REFERENCES
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     Matrix(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)
       : Base(std::move(other))
     {
       Base::_check_template_params();
     }
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     Matrix& operator=(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)
     {
-      other.swap(*this);
+      Base::operator=(std::move(other));
       return *this;
     }
 #endif
 
-    #ifndef EIGEN_PARSED_BY_DOXYGEN
+#if EIGEN_HAS_CXX11
+    /** \copydoc PlainObjectBase(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&... args)
+     *
+     * Example: \include Matrix_variadic_ctor_cxx11.cpp
+     * Output: \verbinclude Matrix_variadic_ctor_cxx11.out
+     *
+     * \sa Matrix(const std::initializer_list<std::initializer_list<Scalar>>&)
+     */
+    template <typename... ArgTypes>
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Matrix(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const ArgTypes&... args)
+      : Base(a0, a1, a2, a3, args...) {}
+
+    /** \brief Constructs a Matrix and initializes it from the coefficients given as initializer-lists grouped by row. \cpp11
+      *
+      * In the general case, the constructor takes a list of rows, each row being represented as a list of coefficients:
+      *
+      * Example: \include Matrix_initializer_list_23_cxx11.cpp
+      * Output: \verbinclude Matrix_initializer_list_23_cxx11.out
+      *
+      * Each of the inner initializer lists must contain the exact same number of elements, otherwise an assertion is triggered.
+      *
+      * In the case of a compile-time column vector, implicit transposition from a single row is allowed.
+      * Therefore <code>VectorXd{{1,2,3,4,5}}</code> is legal and the more verbose syntax
+      * <code>RowVectorXd{{1},{2},{3},{4},{5}}</code> can be avoided:
+      *
+      * Example: \include Matrix_initializer_list_vector_cxx11.cpp
+      * Output: \verbinclude Matrix_initializer_list_vector_cxx11.out
+      *
+      * In the case of fixed-sized matrices, the initializer list sizes must exactly match the matrix sizes,
+      * and implicit transposition is allowed for compile-time vectors only.
+      *
+      * \sa Matrix(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const ArgTypes&... args)
+      */
+    EIGEN_DEVICE_FUNC
+    explicit EIGEN_STRONG_INLINE Matrix(const std::initializer_list<std::initializer_list<Scalar>>& list) : Base(list) {}
+#endif // end EIGEN_HAS_CXX11
+
+#ifndef EIGEN_PARSED_BY_DOXYGEN
 
     // This constructor is for both 1x1 matrices and dynamic vectors
     template<typename T>
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE explicit Matrix(const T& x)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    explicit Matrix(const T& x)
     {
       Base::_check_template_params();
       Base::template _init1<T>(x);
     }
 
     template<typename T0, typename T1>
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Matrix(const T0& x, const T1& y)
     {
       Base::_check_template_params();
       Base::template _init2<T0,T1>(x, y);
     }
-    #else
+
+
+#else
     /** \brief Constructs a fixed-sized matrix initialized with coefficients starting at \a data */
     EIGEN_DEVICE_FUNC
     explicit Matrix(const Scalar *data);
 
     /** \brief Constructs a vector or row-vector with given dimension. \only_for_vectors
       *
       * This is useful for dynamic-size vectors. For fixed-size vectors,
       * it is redundant to pass these parameters, so one should use the default constructor
       * Matrix() instead.
-      * 
+      *
       * \warning This constructor is disabled for fixed-size \c 1x1 matrices. For instance,
       * calling Matrix<double,1,1>(1) will call the initialization constructor: Matrix(const Scalar&).
       * For fixed-size \c 1x1 matrices it is therefore recommended to use the default
       * constructor Matrix() instead, especially when using one of the non standard
       * \c EIGEN_INITIALIZE_MATRICES_BY_{ZERO,\c NAN} macros (see \ref TopicPreprocessorDirectives).
       */
     EIGEN_STRONG_INLINE explicit Matrix(Index dim);
-    /** \brief Constructs an initialized 1x1 matrix with the given coefficient */
+    /** \brief Constructs an initialized 1x1 matrix with the given coefficient
+      * \sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...) */
     Matrix(const Scalar& x);
     /** \brief Constructs an uninitialized matrix with \a rows rows and \a cols columns.
       *
       * This is useful for dynamic-size matrices. For fixed-size matrices,
       * it is redundant to pass these parameters, so one should use the default constructor
       * Matrix() instead.
-      * 
+      *
       * \warning This constructor is disabled for fixed-size \c 1x2 and \c 2x1 vectors. For instance,
       * calling Matrix2f(2,1) will call the initialization constructor: Matrix(const Scalar& x, const Scalar& y).
       * For fixed-size \c 1x2 or \c 2x1 vectors it is therefore recommended to use the default
       * constructor Matrix() instead, especially when using one of the non standard
       * \c EIGEN_INITIALIZE_MATRICES_BY_{ZERO,\c NAN} macros (see \ref TopicPreprocessorDirectives).
       */
     EIGEN_DEVICE_FUNC
     Matrix(Index rows, Index cols);
-    
-    /** \brief Constructs an initialized 2D vector with given coefficients */
+
+    /** \brief Constructs an initialized 2D vector with given coefficients
+      * \sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...) */
     Matrix(const Scalar& x, const Scalar& y);
-    #endif
+    #endif  // end EIGEN_PARSED_BY_DOXYGEN
 
-    /** \brief Constructs an initialized 3D vector with given coefficients */
+    /** \brief Constructs an initialized 3D vector with given coefficients
+      * \sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...)
+      */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)
     {
       Base::_check_template_params();
       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)
       m_storage.data()[0] = x;
       m_storage.data()[1] = y;
       m_storage.data()[2] = z;
     }
-    /** \brief Constructs an initialized 4D vector with given coefficients */
+    /** \brief Constructs an initialized 4D vector with given coefficients
+      * \sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...)
+      */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)
     {
       Base::_check_template_params();
       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 4)
       m_storage.data()[0] = x;
       m_storage.data()[1] = y;
@@ -373,16 +419,18 @@
       */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)
       : Base(other.derived())
     { }
 
-    EIGEN_DEVICE_FUNC inline Index innerStride() const { return 1; }
-    EIGEN_DEVICE_FUNC inline Index outerStride() const { return this->innerSize(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT { return 1; }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT { return this->innerSize(); }
 
     /////////// Geometry module ///////////
 
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     explicit Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r);
     template<typename OtherDerived>
@@ -401,27 +449,36 @@
     using Base::m_storage;
 };
 
 /** \defgroup matrixtypedefs Global matrix typedefs
   *
   * \ingroup Core_Module
   *
-  * Eigen defines several typedef shortcuts for most common matrix and vector types.
+  * %Eigen defines several typedef shortcuts for most common matrix and vector types.
   *
   * The general patterns are the following:
   *
   * \c MatrixSizeType where \c Size can be \c 2,\c 3,\c 4 for fixed size square matrices or \c X for dynamic size,
   * and where \c Type can be \c i for integer, \c f for float, \c d for double, \c cf for complex float, \c cd
   * for complex double.
   *
   * For example, \c Matrix3d is a fixed-size 3x3 matrix type of doubles, and \c MatrixXf is a dynamic-size matrix of floats.
   *
   * There are also \c VectorSizeType and \c RowVectorSizeType which are self-explanatory. For example, \c Vector4cf is
   * a fixed-size vector of 4 complex floats.
   *
+  * With \cpp11, template alias are also defined for common sizes.
+  * They follow the same pattern as above except that the scalar type suffix is replaced by a
+  * template parameter, i.e.:
+  *   - `MatrixSize<Type>` where `Size` can be \c 2,\c 3,\c 4 for fixed size square matrices or \c X for dynamic size.
+  *   - `MatrixXSize<Type>` and `MatrixSizeX<Type>` where `Size` can be \c 2,\c 3,\c 4 for hybrid dynamic/fixed matrices.
+  *   - `VectorSize<Type>` and `RowVectorSize<Type>` for column and row vectors.
+  *
+  * With \cpp11, you can also use fully generic column and row vector types: `Vector<Type,Size>` and `RowVector<Type,Size>`.
+  *
   * \sa class Matrix
   */
 
 #define EIGEN_MAKE_TYPEDEFS(Type, TypeSuffix, Size, SizeSuffix)   \
 /** \ingroup matrixtypedefs */                                    \
 typedef Matrix<Type, Size, Size> Matrix##SizeSuffix##TypeSuffix;  \
 /** \ingroup matrixtypedefs */                                    \
@@ -450,10 +507,59 @@
 EIGEN_MAKE_TYPEDEFS_ALL_SIZES(std::complex<float>,  cf)
 EIGEN_MAKE_TYPEDEFS_ALL_SIZES(std::complex<double>, cd)
 
 #undef EIGEN_MAKE_TYPEDEFS_ALL_SIZES
 #undef EIGEN_MAKE_TYPEDEFS
 #undef EIGEN_MAKE_FIXED_TYPEDEFS
 
+#if EIGEN_HAS_CXX11
+
+#define EIGEN_MAKE_TYPEDEFS(Size, SizeSuffix)                     \
+/** \ingroup matrixtypedefs */                                    \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using Matrix##SizeSuffix = Matrix<Type, Size, Size>;              \
+/** \ingroup matrixtypedefs */                                    \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using Vector##SizeSuffix = Matrix<Type, Size, 1>;                 \
+/** \ingroup matrixtypedefs */                                    \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using RowVector##SizeSuffix = Matrix<Type, 1, Size>;
+
+#define EIGEN_MAKE_FIXED_TYPEDEFS(Size)                           \
+/** \ingroup matrixtypedefs */                                    \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using Matrix##Size##X = Matrix<Type, Size, Dynamic>;              \
+/** \ingroup matrixtypedefs */                                    \
+/** \brief \cpp11 */                                              \
+template <typename Type>                                          \
+using Matrix##X##Size = Matrix<Type, Dynamic, Size>;
+
+EIGEN_MAKE_TYPEDEFS(2, 2)
+EIGEN_MAKE_TYPEDEFS(3, 3)
+EIGEN_MAKE_TYPEDEFS(4, 4)
+EIGEN_MAKE_TYPEDEFS(Dynamic, X)
+EIGEN_MAKE_FIXED_TYPEDEFS(2)
+EIGEN_MAKE_FIXED_TYPEDEFS(3)
+EIGEN_MAKE_FIXED_TYPEDEFS(4)
+
+/** \ingroup matrixtypedefs
+  * \brief \cpp11 */
+template <typename Type, int Size>
+using Vector = Matrix<Type, Size, 1>;
+
+/** \ingroup matrixtypedefs
+  * \brief \cpp11 */
+template <typename Type, int Size>
+using RowVector = Matrix<Type, 1, Size>;
+
+#undef EIGEN_MAKE_TYPEDEFS
+#undef EIGEN_MAKE_FIXED_TYPEDEFS
+
+#endif // EIGEN_HAS_CXX11
+
 } // end namespace Eigen
 
 #endif // EIGEN_MATRIX_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/MatrixBase.h` & `chronogram-0.2.0/include/Eigen/src/Core/MatrixBase.h`

 * *Files 4% similar despite different names*

```diff
@@ -72,14 +72,15 @@
     using Base::rows;
     using Base::cols;
     using Base::size;
     using Base::coeff;
     using Base::coeffRef;
     using Base::lazyAssign;
     using Base::eval;
+    using Base::operator-;
     using Base::operator+=;
     using Base::operator-=;
     using Base::operator*=;
     using Base::operator/=;
 
     typedef typename Base::CoeffReturnType CoeffReturnType;
     typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;
@@ -118,15 +119,14 @@
     typedef Block<const CwiseNullaryOp<internal::scalar_identity_op<Scalar>, SquareMatrixType>,
                   internal::traits<Derived>::RowsAtCompileTime,
                   internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;
 #endif // not EIGEN_PARSED_BY_DOXYGEN
 
 #define EIGEN_CURRENT_STORAGE_BASE_CLASS Eigen::MatrixBase
 #define EIGEN_DOC_UNARY_ADDONS(X,Y)
-#   include "../plugins/CommonCwiseUnaryOps.h"
 #   include "../plugins/CommonCwiseBinaryOps.h"
 #   include "../plugins/MatrixCwiseUnaryOps.h"
 #   include "../plugins/MatrixCwiseBinaryOps.h"
 #   ifdef EIGEN_MATRIXBASE_PLUGIN
 #     include EIGEN_MATRIXBASE_PLUGIN
 #   endif
 #undef EIGEN_CURRENT_STORAGE_BASE_CLASS
@@ -264,14 +264,16 @@
     const DiagonalWrapper<const Derived> asDiagonal() const;
     const PermutationWrapper<const Derived> asPermutation() const;
 
     EIGEN_DEVICE_FUNC
     Derived& setIdentity();
     EIGEN_DEVICE_FUNC
     Derived& setIdentity(Index rows, Index cols);
+    EIGEN_DEVICE_FUNC Derived& setUnit(Index i);
+    EIGEN_DEVICE_FUNC Derived& setUnit(Index newSize, Index i);
 
     bool isIdentity(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
     bool isDiagonal(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 
     bool isUpperTriangular(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
     bool isLowerTriangular(const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const;
 
@@ -292,15 +294,15 @@
       * \warning When using floating point scalar values you probably should rather use a
       *          fuzzy comparison such as isApprox()
       * \sa isApprox(), operator== */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC inline bool operator!=(const MatrixBase<OtherDerived>& other) const
     { return cwiseNotEqual(other).any(); }
 
-    NoAlias<Derived,Eigen::MatrixBase > noalias();
+    NoAlias<Derived,Eigen::MatrixBase > EIGEN_DEVICE_FUNC noalias();
 
     // TODO forceAlignedAccess is temporarily disabled
     // Need to find a nicer workaround.
     inline const Derived& forceAlignedAccess() const { return derived(); }
     inline Derived& forceAlignedAccess() { return derived(); }
     template<bool Enable> inline const Derived& forceAlignedAccessIf() const { return derived(); }
     template<bool Enable> inline Derived& forceAlignedAccessIf() { return derived(); }
@@ -322,29 +324,33 @@
 /////////// LU module ///////////
 
     inline const FullPivLU<PlainObject> fullPivLu() const;
     inline const PartialPivLU<PlainObject> partialPivLu() const;
 
     inline const PartialPivLU<PlainObject> lu() const;
 
+    EIGEN_DEVICE_FUNC
     inline const Inverse<Derived> inverse() const;
 
     template<typename ResultType>
     inline void computeInverseAndDetWithCheck(
       ResultType& inverse,
       typename ResultType::Scalar& determinant,
       bool& invertible,
       const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision()
     ) const;
+
     template<typename ResultType>
     inline void computeInverseWithCheck(
       ResultType& inverse,
       bool& invertible,
       const RealScalar& absDeterminantThreshold = NumTraits<Scalar>::dummy_precision()
     ) const;
+
+    EIGEN_DEVICE_FUNC
     Scalar determinant() const;
 
 /////////// Cholesky module ///////////
 
     inline const LLT<PlainObject>  llt() const;
     inline const LDLT<PlainObject> ldlt() const;
 
@@ -408,32 +414,38 @@
                   internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;
     typedef EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(ConstStartMinusOne,Scalar,quotient) HNormalizedReturnType;
     EIGEN_DEVICE_FUNC
     inline const HNormalizedReturnType hnormalized() const;
 
 ////////// Householder module ///////////
 
+    EIGEN_DEVICE_FUNC
     void makeHouseholderInPlace(Scalar& tau, RealScalar& beta);
     template<typename EssentialPart>
+    EIGEN_DEVICE_FUNC
     void makeHouseholder(EssentialPart& essential,
                          Scalar& tau, RealScalar& beta) const;
     template<typename EssentialPart>
+    EIGEN_DEVICE_FUNC
     void applyHouseholderOnTheLeft(const EssentialPart& essential,
                                    const Scalar& tau,
                                    Scalar* workspace);
     template<typename EssentialPart>
+    EIGEN_DEVICE_FUNC
     void applyHouseholderOnTheRight(const EssentialPart& essential,
                                     const Scalar& tau,
                                     Scalar* workspace);
 
 ///////// Jacobi module /////////
 
     template<typename OtherScalar>
+    EIGEN_DEVICE_FUNC
     void applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j);
     template<typename OtherScalar>
+    EIGEN_DEVICE_FUNC
     void applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j);
 
 ///////// SparseCore module /////////
 
     template<typename OtherDerived>
     EIGEN_STRONG_INLINE const typename SparseMatrixBase<OtherDerived>::template CwiseProductDenseReturnType<Derived>::Type
     cwiseProduct(const SparseMatrixBase<OtherDerived> &other) const
@@ -452,23 +464,29 @@
     const ReturnType<Derived> Name(Argument) const;
 
     EIGEN_MATRIX_FUNCTION(MatrixExponentialReturnValue, exp, exponential)
     /** \brief Helper function for the <a href="unsupported/group__MatrixFunctions__Module.html"> unsupported MatrixFunctions module</a>.*/
     const MatrixFunctionReturnValue<Derived> matrixFunction(StemFunction f) const;
     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, cosh, hyperbolic cosine)
     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, sinh, hyperbolic sine)
+#if EIGEN_HAS_CXX11_MATH
+    EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, atanh, inverse hyperbolic cosine)
+    EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, acosh, inverse hyperbolic cosine)
+    EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, asinh, inverse hyperbolic sine)
+#endif
     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, cos, cosine)
     EIGEN_MATRIX_FUNCTION(MatrixFunctionReturnValue, sin, sine)
     EIGEN_MATRIX_FUNCTION(MatrixSquareRootReturnValue, sqrt, square root)
     EIGEN_MATRIX_FUNCTION(MatrixLogarithmReturnValue, log, logarithm)
     EIGEN_MATRIX_FUNCTION_1(MatrixPowerReturnValue,        pow, power to \c p, const RealScalar& p)
     EIGEN_MATRIX_FUNCTION_1(MatrixComplexPowerReturnValue, pow, power to \c p, const std::complex<RealScalar>& p)
 
   protected:
-    EIGEN_DEVICE_FUNC MatrixBase() : Base() {}
+    EIGEN_DEFAULT_COPY_CONSTRUCTOR(MatrixBase)
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(MatrixBase)
 
   private:
     EIGEN_DEVICE_FUNC explicit MatrixBase(int);
     EIGEN_DEVICE_FUNC MatrixBase(int,int);
     template<typename OtherDerived> EIGEN_DEVICE_FUNC explicit MatrixBase(const MatrixBase<OtherDerived>&);
   protected:
     // mixing arrays and matrices is not legal
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/NoAlias.h` & `chronogram-0.2.0/include/Eigen/src/Core/NoAlias.h`

 * *Files 1% similar despite different names*

```diff
@@ -29,14 +29,15 @@
   */
 template<typename ExpressionType, template <typename> class StorageBase>
 class NoAlias
 {
   public:
     typedef typename ExpressionType::Scalar Scalar;
     
+    EIGEN_DEVICE_FUNC
     explicit NoAlias(ExpressionType& expression) : m_expression(expression) {}
     
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)
     {
       call_assignment_no_alias(m_expression, other.derived(), internal::assign_op<Scalar,typename OtherDerived::Scalar>());
@@ -70,18 +71,18 @@
 };
 
 /** \returns a pseudo expression of \c *this with an operator= assuming
   * no aliasing between \c *this and the source expression.
   *
   * More precisely, noalias() allows to bypass the EvalBeforeAssignBit flag.
   * Currently, even though several expressions may alias, only product
-  * expressions have this flag. Therefore, noalias() is only usefull when
+  * expressions have this flag. Therefore, noalias() is only useful when
   * the source expression contains a matrix product.
   *
-  * Here are some examples where noalias is usefull:
+  * Here are some examples where noalias is useful:
   * \code
   * D.noalias()  = A * B;
   * D.noalias() += A.transpose() * B;
   * D.noalias() -= 2 * A * B.adjoint();
   * \endcode
   *
   * On the other hand the following example will lead to a \b wrong result:
@@ -94,15 +95,15 @@
   * \code
   * A = A * B;
   * \endcode
   *
   * \sa class NoAlias
   */
 template<typename Derived>
-NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()
+NoAlias<Derived,MatrixBase> EIGEN_DEVICE_FUNC MatrixBase<Derived>::noalias()
 {
   return NoAlias<Derived, Eigen::MatrixBase >(derived());
 }
 
 } // end namespace Eigen
 
 #endif // EIGEN_NOALIAS_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/NumTraits.h` & `chronogram-0.2.0/include/Eigen/src/Core/NumTraits.h`

 * *Files 17% similar despite different names*

```diff
@@ -17,36 +17,91 @@
 // default implementation of digits10(), based on numeric_limits if specialized,
 // 0 for integer types, and log10(epsilon()) otherwise.
 template< typename T,
           bool use_numeric_limits = std::numeric_limits<T>::is_specialized,
           bool is_integer = NumTraits<T>::IsInteger>
 struct default_digits10_impl
 {
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static int run() { return std::numeric_limits<T>::digits10; }
 };
 
 template<typename T>
 struct default_digits10_impl<T,false,false> // Floating point
 {
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static int run() {
     using std::log10;
     using std::ceil;
     typedef typename NumTraits<T>::Real Real;
     return int(ceil(-log10(NumTraits<Real>::epsilon())));
   }
 };
 
 template<typename T>
 struct default_digits10_impl<T,false,true> // Integer
 {
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  static int run() { return 0; }
+};
+
+
+// default implementation of digits(), based on numeric_limits if specialized,
+// 0 for integer types, and log2(epsilon()) otherwise.
+template< typename T,
+          bool use_numeric_limits = std::numeric_limits<T>::is_specialized,
+          bool is_integer = NumTraits<T>::IsInteger>
+struct default_digits_impl
+{
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  static int run() { return std::numeric_limits<T>::digits; }
+};
+
+template<typename T>
+struct default_digits_impl<T,false,false> // Floating point
+{
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  static int run() {
+    using std::log;
+    using std::ceil;
+    typedef typename NumTraits<T>::Real Real;
+    return int(ceil(-log(NumTraits<Real>::epsilon())/log(static_cast<Real>(2))));
+  }
+};
+
+template<typename T>
+struct default_digits_impl<T,false,true> // Integer
+{
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static int run() { return 0; }
 };
 
 } // end namespace internal
 
+namespace numext {
+/** \internal bit-wise cast without changing the underlying bit representation. */
+
+// TODO: Replace by std::bit_cast (available in C++20)
+template <typename Tgt, typename Src>
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Tgt bit_cast(const Src& src) {
+#if EIGEN_HAS_TYPE_TRAITS
+  // The behaviour of memcpy is not specified for non-trivially copyable types
+  EIGEN_STATIC_ASSERT(std::is_trivially_copyable<Src>::value, THIS_TYPE_IS_NOT_SUPPORTED);
+  EIGEN_STATIC_ASSERT(std::is_trivially_copyable<Tgt>::value && std::is_default_constructible<Tgt>::value,
+                      THIS_TYPE_IS_NOT_SUPPORTED);
+#endif
+
+  EIGEN_STATIC_ASSERT(sizeof(Src) == sizeof(Tgt), THIS_TYPE_IS_NOT_SUPPORTED);
+  Tgt tgt;
+  EIGEN_USING_STD(memcpy)
+  memcpy(&tgt, &src, sizeof(Tgt));
+  return tgt;
+}
+}  // namespace numext
+
 /** \class NumTraits
   * \ingroup Core_Module
   *
   * \brief Holds information about the various numeric (i.e. scalar) types allowed by Eigen.
   *
   * \tparam T the numeric type at hand
   *
@@ -67,26 +122,35 @@
   *     this means, just use \a T here.
   * \li An enum value \a IsComplex. It is equal to 1 if \a T is a \c std::complex
   *     type, and to 0 otherwise.
   * \li An enum value \a IsInteger. It is equal to \c 1 if \a T is an integer type such as \c int,
   *     and to \c 0 otherwise.
   * \li Enum values ReadCost, AddCost and MulCost representing a rough estimate of the number of CPU cycles needed
   *     to by move / add / mul instructions respectively, assuming the data is already stored in CPU registers.
-  *     Stay vague here. No need to do architecture-specific stuff.
+  *     Stay vague here. No need to do architecture-specific stuff. If you don't know what this means, just use \c Eigen::HugeCost.
   * \li An enum value \a IsSigned. It is equal to \c 1 if \a T is a signed type and to 0 if \a T is unsigned.
   * \li An enum value \a RequireInitialization. It is equal to \c 1 if the constructor of the numeric type \a T must
   *     be called, and to 0 if it is safe not to call it. Default is 0 if \a T is an arithmetic type, and 1 otherwise.
   * \li An epsilon() function which, unlike <a href="http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon">std::numeric_limits::epsilon()</a>,
   *     it returns a \a Real instead of a \a T.
   * \li A dummy_precision() function returning a weak epsilon value. It is mainly used as a default
   *     value by the fuzzy comparison operators.
   * \li highest() and lowest() functions returning the highest and lowest possible values respectively.
+  * \li digits() function returning the number of radix digits (non-sign digits for integers, mantissa for floating-point). This is
+  *     the analogue of <a href="http://en.cppreference.com/w/cpp/types/numeric_limits/digits">std::numeric_limits<T>::digits</a>
+  *     which is used as the default implementation if specialized.
   * \li digits10() function returning the number of decimal digits that can be represented without change. This is
   *     the analogue of <a href="http://en.cppreference.com/w/cpp/types/numeric_limits/digits10">std::numeric_limits<T>::digits10</a>
   *     which is used as the default implementation if specialized.
+  * \li min_exponent() and max_exponent() functions returning the highest and lowest possible values, respectively,
+  *     such that the radix raised to the power exponent-1 is a normalized floating-point number.  These are equivalent to
+  *     <a href="http://en.cppreference.com/w/cpp/types/numeric_limits/min_exponent">std::numeric_limits<T>::min_exponent</a>/
+  *     <a href="http://en.cppreference.com/w/cpp/types/numeric_limits/max_exponent">std::numeric_limits<T>::max_exponent</a>.
+  * \li infinity() function returning a representation of positive infinity, if available.
+  * \li quiet_NaN function returning a non-signaling "not-a-number", if available.
   */
 
 template<typename T> struct GenericNumTraits
 {
   enum {
     IsInteger = std::numeric_limits<T>::is_integer,
     IsSigned = std::numeric_limits<T>::is_signed,
@@ -102,74 +166,93 @@
                      IsInteger,
                      typename internal::conditional<sizeof(T)<=2, float, double>::type,
                      T
                    >::type NonInteger;
   typedef T Nested;
   typedef T Literal;
 
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline Real epsilon()
   {
     return numext::numeric_limits<T>::epsilon();
   }
 
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline int digits10()
   {
     return internal::default_digits10_impl<T>::run();
   }
 
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  static inline int digits()
+  {
+    return internal::default_digits_impl<T>::run();
+  }
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  static inline int min_exponent()
+  {
+    return numext::numeric_limits<T>::min_exponent;
+  }
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  static inline int max_exponent()
+  {
+    return numext::numeric_limits<T>::max_exponent;
+  }
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline Real dummy_precision()
   {
     // make sure to override this for floating-point types
     return Real(0);
   }
 
-
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline T highest() {
     return (numext::numeric_limits<T>::max)();
   }
 
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline T lowest()  {
-    return IsInteger ? (numext::numeric_limits<T>::min)() : (-(numext::numeric_limits<T>::max)());
+    return IsInteger ? (numext::numeric_limits<T>::min)()
+                     : static_cast<T>(-(numext::numeric_limits<T>::max)());
   }
 
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline T infinity() {
     return numext::numeric_limits<T>::infinity();
   }
 
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline T quiet_NaN() {
     return numext::numeric_limits<T>::quiet_NaN();
   }
 };
 
 template<typename T> struct NumTraits : GenericNumTraits<T>
 {};
 
 template<> struct NumTraits<float>
   : GenericNumTraits<float>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline float dummy_precision() { return 1e-5f; }
 };
 
 template<> struct NumTraits<double> : GenericNumTraits<double>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline double dummy_precision() { return 1e-12; }
 };
 
 template<> struct NumTraits<long double>
   : GenericNumTraits<long double>
 {
+  EIGEN_CONSTEXPR
   static inline long double dummy_precision() { return 1e-15l; }
 };
 
 template<typename _Real> struct NumTraits<std::complex<_Real> >
   : GenericNumTraits<std::complex<_Real> >
 {
   typedef _Real Real;
@@ -178,19 +261,19 @@
     IsComplex = 1,
     RequireInitialization = NumTraits<_Real>::RequireInitialization,
     ReadCost = 2 * NumTraits<_Real>::ReadCost,
     AddCost = 2 * NumTraits<Real>::AddCost,
     MulCost = 4 * NumTraits<Real>::MulCost + 2 * NumTraits<Real>::AddCost
   };
 
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline Real epsilon() { return NumTraits<Real>::epsilon(); }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline Real dummy_precision() { return NumTraits<Real>::dummy_precision(); }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline int digits10() { return NumTraits<Real>::digits10(); }
 };
 
 template<typename Scalar, int Rows, int Cols, int Options, int MaxRows, int MaxCols>
 struct NumTraits<Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> >
 {
   typedef Array<Scalar, Rows, Cols, Options, MaxRows, MaxCols> ArrayType;
@@ -202,47 +285,51 @@
   typedef typename NumTraits<Scalar>::Literal Literal;
 
   enum {
     IsComplex = NumTraits<Scalar>::IsComplex,
     IsInteger = NumTraits<Scalar>::IsInteger,
     IsSigned  = NumTraits<Scalar>::IsSigned,
     RequireInitialization = 1,
-    ReadCost = ArrayType::SizeAtCompileTime==Dynamic ? HugeCost : ArrayType::SizeAtCompileTime * NumTraits<Scalar>::ReadCost,
-    AddCost  = ArrayType::SizeAtCompileTime==Dynamic ? HugeCost : ArrayType::SizeAtCompileTime * NumTraits<Scalar>::AddCost,
-    MulCost  = ArrayType::SizeAtCompileTime==Dynamic ? HugeCost : ArrayType::SizeAtCompileTime * NumTraits<Scalar>::MulCost
+    ReadCost = ArrayType::SizeAtCompileTime==Dynamic ? HugeCost : ArrayType::SizeAtCompileTime * int(NumTraits<Scalar>::ReadCost),
+    AddCost  = ArrayType::SizeAtCompileTime==Dynamic ? HugeCost : ArrayType::SizeAtCompileTime * int(NumTraits<Scalar>::AddCost),
+    MulCost  = ArrayType::SizeAtCompileTime==Dynamic ? HugeCost : ArrayType::SizeAtCompileTime * int(NumTraits<Scalar>::MulCost)
   };
 
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline RealScalar epsilon() { return NumTraits<RealScalar>::epsilon(); }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static inline RealScalar dummy_precision() { return NumTraits<RealScalar>::dummy_precision(); }
 
+  EIGEN_CONSTEXPR
   static inline int digits10() { return NumTraits<Scalar>::digits10(); }
 };
 
 template<> struct NumTraits<std::string>
   : GenericNumTraits<std::string>
 {
   enum {
     RequireInitialization = 1,
     ReadCost = HugeCost,
     AddCost  = HugeCost,
     MulCost  = HugeCost
   };
 
+  EIGEN_CONSTEXPR
   static inline int digits10() { return 0; }
 
 private:
   static inline std::string epsilon();
   static inline std::string dummy_precision();
   static inline std::string lowest();
   static inline std::string highest();
   static inline std::string infinity();
   static inline std::string quiet_NaN();
 };
 
 // Empty specialization for void to allow template specialization based on NumTraits<T>::Real with T==void and SFINAE.
 template<> struct NumTraits<void> {};
 
+template<> struct NumTraits<bool> : GenericNumTraits<bool> {};
+
 } // end namespace Eigen
 
 #endif // EIGEN_NUMTRAITS_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/PermutationMatrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/PermutationMatrix.h`

 * *Files 3% similar despite different names*

```diff
@@ -83,33 +83,22 @@
     {
       setIdentity(tr.size());
       for(Index k=size()-1; k>=0; --k)
         applyTranspositionOnTheRight(k,tr.coeff(k));
       return derived();
     }
 
-    #ifndef EIGEN_PARSED_BY_DOXYGEN
-    /** This is a special case of the templated operator=. Its purpose is to
-      * prevent a default operator= from hiding the templated operator=.
-      */
-    Derived& operator=(const PermutationBase& other)
-    {
-      indices() = other.indices();
-      return derived();
-    }
-    #endif
-
     /** \returns the number of rows */
-    inline Index rows() const { return Index(indices().size()); }
+    inline EIGEN_DEVICE_FUNC Index rows() const { return Index(indices().size()); }
 
     /** \returns the number of columns */
-    inline Index cols() const { return Index(indices().size()); }
+    inline EIGEN_DEVICE_FUNC Index cols() const { return Index(indices().size()); }
 
     /** \returns the size of a side of the respective square matrix, i.e., the number of indices */
-    inline Index size() const { return Index(indices().size()); }
+    inline EIGEN_DEVICE_FUNC Index size() const { return Index(indices().size()); }
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename DenseDerived>
     void evalTo(MatrixBase<DenseDerived>& other) const
     {
       other.setZero();
       for (Index i=0; i<rows(); ++i)
@@ -329,20 +318,14 @@
     }
 
     /** Copy constructor. */
     template<typename OtherDerived>
     inline PermutationMatrix(const PermutationBase<OtherDerived>& other)
       : m_indices(other.indices()) {}
 
-    #ifndef EIGEN_PARSED_BY_DOXYGEN
-    /** Standard copy constructor. Defined only to prevent a default copy constructor
-      * from hiding the other templated constructor */
-    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}
-    #endif
-
     /** Generic constructor from expression of the indices. The indices
       * array has the meaning that the permutations sends each integer i to indices[i].
       *
       * \warning It is your responsibility to check that the indices array that you passes actually
       * describes a permutation, i.e., each value between 0 and n-1 occurs exactly once, where n is the
       * array's size.
       */
@@ -369,25 +352,14 @@
     /** Assignment from the Transpositions \a tr */
     template<typename Other>
     PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)
     {
       return Base::operator=(tr.derived());
     }
 
-    #ifndef EIGEN_PARSED_BY_DOXYGEN
-    /** This is a special case of the templated operator=. Its purpose is to
-      * prevent a default operator= from hiding the templated operator=.
-      */
-    PermutationMatrix& operator=(const PermutationMatrix& other)
-    {
-      m_indices = other.m_indices;
-      return *this;
-    }
-    #endif
-
     /** const version of indices(). */
     const IndicesType& indices() const { return m_indices; }
     /** \returns a reference to the stored array representing the permutation. */
     IndicesType& indices() { return m_indices; }
 
 
     /**** multiplication helpers to hopefully get RVO ****/
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/PlainObjectBase.h` & `chronogram-0.2.0/include/Eigen/src/Core/PlainObjectBase.h`

 * *Files 4% similar despite different names*

```diff
@@ -9,18 +9,18 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_DENSESTORAGEBASE_H
 #define EIGEN_DENSESTORAGEBASE_H
 
 #if defined(EIGEN_INITIALIZE_MATRICES_BY_ZERO)
 # define EIGEN_INITIALIZE_COEFFS
-# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(int i=0;i<base().size();++i) coeffRef(i)=Scalar(0);
+# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(Index i=0;i<base().size();++i) coeffRef(i)=Scalar(0);
 #elif defined(EIGEN_INITIALIZE_MATRICES_BY_NAN)
 # define EIGEN_INITIALIZE_COEFFS
-# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(int i=0;i<base().size();++i) coeffRef(i)=std::numeric_limits<Scalar>::quiet_NaN();
+# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(Index i=0;i<base().size();++i) coeffRef(i)=std::numeric_limits<Scalar>::quiet_NaN();
 #else
 # undef EIGEN_INITIALIZE_COEFFS
 # define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
 #endif
 
 namespace Eigen {
 
@@ -100,38 +100,30 @@
 {
   public:
     enum { Options = internal::traits<Derived>::Options };
     typedef typename internal::dense_xpr_base<Derived>::type Base;
 
     typedef typename internal::traits<Derived>::StorageKind StorageKind;
     typedef typename internal::traits<Derived>::Scalar Scalar;
-    
+
     typedef typename internal::packet_traits<Scalar>::type PacketScalar;
     typedef typename NumTraits<Scalar>::Real RealScalar;
     typedef Derived DenseType;
 
     using Base::RowsAtCompileTime;
     using Base::ColsAtCompileTime;
     using Base::SizeAtCompileTime;
     using Base::MaxRowsAtCompileTime;
     using Base::MaxColsAtCompileTime;
     using Base::MaxSizeAtCompileTime;
     using Base::IsVectorAtCompileTime;
     using Base::Flags;
 
-    template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
-    friend  class Eigen::Map<Derived, Unaligned>;
     typedef Eigen::Map<Derived, Unaligned>  MapType;
-    friend  class Eigen::Map<const Derived, Unaligned>;
     typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;
-#if EIGEN_MAX_ALIGN_BYTES>0
-    // for EIGEN_MAX_ALIGN_BYTES==0, AlignedMax==Unaligned, and many compilers generate warnings for friend-ing a class twice.
-    friend  class Eigen::Map<Derived, AlignedMax>;
-    friend  class Eigen::Map<const Derived, AlignedMax>;
-#endif
     typedef Eigen::Map<Derived, AlignedMax> AlignedMapType;
     typedef const Eigen::Map<const Derived, AlignedMax> ConstAlignedMapType;
     template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };
     template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };
     template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, AlignedMax, StrideType> type; };
     template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, AlignedMax, StrideType> type; };
 
@@ -143,18 +135,18 @@
     EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
 
     EIGEN_DEVICE_FUNC
     Base& base() { return *static_cast<Base*>(this); }
     EIGEN_DEVICE_FUNC
     const Base& base() const { return *static_cast<const Base*>(this); }
 
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }
-    EIGEN_DEVICE_FUNC
-    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return m_storage.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return m_storage.cols(); }
 
     /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index,Index) const
       * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts.
       *
       * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const
@@ -354,15 +346,15 @@
       * Takes care of doing all the checking that's needed.
       *
       * Note that copying a row-vector into a vector (and conversely) is allowed.
       * The resizing, if any, is then done in the appropriate way so that row-vectors
       * remain row-vectors and vectors remain vectors.
       */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC 
+    EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)
     {
       const OtherDerived& other = _other.derived();
       internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(other.rows(), other.cols());
       const Index othersize = other.rows()*other.cols();
       if(RowsAtCompileTime == 1)
       {
@@ -379,15 +371,15 @@
 
     /** Resizes the matrix to \a rows x \a cols while leaving old values untouched.
       *
       * The method is intended for matrices of dynamic size. If you only want to change the number
       * of rows and/or of columns, you can use conservativeResize(NoChange_t, Index) or
       * conservativeResize(Index, NoChange_t).
       *
-      * Matrices are resized relative to the top-left element. In case values need to be 
+      * Matrices are resized relative to the top-left element. In case values need to be
       * appended to the matrix they will be uninitialized.
       */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void conservativeResize(Index rows, Index cols)
     {
       internal::conservative_resize_like_impl<Derived>::run(*this, rows, cols);
     }
@@ -436,15 +428,15 @@
 
     /** Resizes the matrix to \a rows x \a cols of \c other, while leaving old values untouched.
       *
       * The method is intended for matrices of dynamic size. If you only want to change the number
       * of rows and/or of columns, you can use conservativeResize(NoChange_t, Index) or
       * conservativeResize(Index, NoChange_t).
       *
-      * Matrices are resized relative to the top-left element. In case values need to be 
+      * Matrices are resized relative to the top-left element. In case values need to be
       * appended to the matrix they will copied from \c other.
       */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)
     {
       internal::conservative_resize_like_impl<Derived,OtherDerived>::run(*this, other);
@@ -504,16 +496,16 @@
       : m_storage( std::move(other.m_storage) )
     {
     }
 
     EIGEN_DEVICE_FUNC
     PlainObjectBase& operator=(PlainObjectBase&& other) EIGEN_NOEXCEPT
     {
-      using std::swap;
-      swap(m_storage, other.m_storage);
+      _check_template_params();
+      m_storage = std::move(other.m_storage);
       return *this;
     }
 #endif
 
     /** Copy constructor */
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)
@@ -522,14 +514,79 @@
     EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)
       : m_storage(size, rows, cols)
     {
 //       _check_template_params();
 //       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED
     }
 
+    #if EIGEN_HAS_CXX11
+    /** \brief Construct a row of column vector with fixed size from an arbitrary number of coefficients. \cpp11
+      *
+      * \only_for_vectors
+      *
+      * This constructor is for 1D array or vectors with more than 4 coefficients.
+      * There exists C++98 analogue constructors for fixed-size array/vector having 1, 2, 3, or 4 coefficients.
+      *
+      * \warning To construct a column (resp. row) vector of fixed length, the number of values passed to this
+      * constructor must match the the fixed number of rows (resp. columns) of \c *this.
+      */
+    template <typename... ArgTypes>
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    PlainObjectBase(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const ArgTypes&... args)
+      : m_storage()
+    {
+      _check_template_params();
+      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, sizeof...(args) + 4);
+      m_storage.data()[0] = a0;
+      m_storage.data()[1] = a1;
+      m_storage.data()[2] = a2;
+      m_storage.data()[3] = a3;
+      Index i = 4;
+      auto x = {(m_storage.data()[i++] = args, 0)...};
+      static_cast<void>(x);
+    }
+
+    /** \brief Constructs a Matrix or Array and initializes it by elements given by an initializer list of initializer
+      * lists \cpp11
+      */
+    EIGEN_DEVICE_FUNC
+    explicit EIGEN_STRONG_INLINE PlainObjectBase(const std::initializer_list<std::initializer_list<Scalar>>& list)
+      : m_storage()
+    {
+      _check_template_params();
+
+      size_t list_size = 0;
+      if (list.begin() != list.end()) {
+        list_size = list.begin()->size();
+      }
+
+      // This is to allow syntax like VectorXi {{1, 2, 3, 4}}
+      if (ColsAtCompileTime == 1 && list.size() == 1) {
+        eigen_assert(list_size == static_cast<size_t>(RowsAtCompileTime) || RowsAtCompileTime == Dynamic);
+        resize(list_size, ColsAtCompileTime);
+        std::copy(list.begin()->begin(), list.begin()->end(), m_storage.data());
+      } else {
+        eigen_assert(list.size() == static_cast<size_t>(RowsAtCompileTime) || RowsAtCompileTime == Dynamic);
+        eigen_assert(list_size == static_cast<size_t>(ColsAtCompileTime) || ColsAtCompileTime == Dynamic);
+        resize(list.size(), list_size);
+
+        Index row_index = 0;
+        for (const std::initializer_list<Scalar>& row : list) {
+          eigen_assert(list_size == row.size());
+          Index col_index = 0;
+          for (const Scalar& e : row) {
+            coeffRef(row_index, col_index) = e;
+            ++col_index;
+          }
+          ++row_index;
+        }
+      }
+    }
+    #endif  // end EIGEN_HAS_CXX11
+
     /** \sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)
       : m_storage()
     {
       _check_template_params();
@@ -560,15 +617,15 @@
 
   public:
 
     /** \brief Copies the generic expression \a other into *this.
       * \copydetails DenseBase::operator=(const EigenBase<OtherDerived> &other)
       */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC 
+    EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)
     {
       _resize_to_match(other);
       Base::operator=(other.derived());
       return this->derived();
     }
 
@@ -648,41 +705,49 @@
     static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)
     { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }
     //@}
 
     using Base::setConstant;
     EIGEN_DEVICE_FUNC Derived& setConstant(Index size, const Scalar& val);
     EIGEN_DEVICE_FUNC Derived& setConstant(Index rows, Index cols, const Scalar& val);
+    EIGEN_DEVICE_FUNC Derived& setConstant(NoChange_t, Index cols, const Scalar& val);
+    EIGEN_DEVICE_FUNC Derived& setConstant(Index rows, NoChange_t, const Scalar& val);
 
     using Base::setZero;
     EIGEN_DEVICE_FUNC Derived& setZero(Index size);
     EIGEN_DEVICE_FUNC Derived& setZero(Index rows, Index cols);
+    EIGEN_DEVICE_FUNC Derived& setZero(NoChange_t, Index cols);
+    EIGEN_DEVICE_FUNC Derived& setZero(Index rows, NoChange_t);
 
     using Base::setOnes;
     EIGEN_DEVICE_FUNC Derived& setOnes(Index size);
     EIGEN_DEVICE_FUNC Derived& setOnes(Index rows, Index cols);
+    EIGEN_DEVICE_FUNC Derived& setOnes(NoChange_t, Index cols);
+    EIGEN_DEVICE_FUNC Derived& setOnes(Index rows, NoChange_t);
 
     using Base::setRandom;
     Derived& setRandom(Index size);
     Derived& setRandom(Index rows, Index cols);
+    Derived& setRandom(NoChange_t, Index cols);
+    Derived& setRandom(Index rows, NoChange_t);
 
     #ifdef EIGEN_PLAINOBJECTBASE_PLUGIN
     #include EIGEN_PLAINOBJECTBASE_PLUGIN
     #endif
 
   protected:
     /** \internal Resizes *this in preparation for assigning \a other to it.
       * Takes care of doing all the checking that's needed.
       *
       * Note that copying a row-vector into a vector (and conversely) is allowed.
       * The resizing, if any, is then done in the appropriate way so that row-vectors
       * remain row-vectors and vectors remain vectors.
       */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC 
+    EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)
     {
       #ifdef EIGEN_NO_AUTOMATIC_RESIZING
       eigen_assert((this->size()==0 || (IsVectorAtCompileTime ? (this->size() == other.size())
                  : (rows() == other.rows() && cols() == other.cols())))
         && "Size mismatch. Automatic resizing is disabled because EIGEN_NO_AUTOMATIC_RESIZING is defined");
       EIGEN_ONLY_USED_FOR_DEBUG(other);
@@ -701,31 +766,31 @@
       * The resizing, if any, is then done in the appropriate way so that row-vectors
       * remain row-vectors and vectors remain vectors.
       *
       * \sa operator=(const MatrixBase<OtherDerived>&), _set_noalias()
       *
       * \internal
       */
-    // aliasing is dealt once in internall::call_assignment
+    // aliasing is dealt once in internal::call_assignment
     // so at this stage we have to assume aliasing... and resising has to be done later.
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC 
+    EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)
     {
       internal::call_assignment(this->derived(), other.derived());
       return this->derived();
     }
 
     /** \internal Like _set() but additionally makes the assumption that no aliasing effect can happen (which
       * is the case when creating a new matrix) so one can enforce lazy evaluation.
       *
       * \sa operator=(const MatrixBase<OtherDerived>&), _set()
       */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC 
+    EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)
     {
       // I don't think we need this resize call since the lazyAssign will anyways resize
       // and lazyAssign will be called by the assign selector.
       //_resize_to_match(other);
       // the 'false' below means to enforce lazy evaluation. We don't use lazyAssign() because
       // it wouldn't allow to copy a row-vector into a column-vector.
@@ -733,31 +798,33 @@
       return this->derived();
     }
 
     template<typename T0, typename T1>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)
     {
-      EIGEN_STATIC_ASSERT(bool(NumTraits<T0>::IsInteger) &&
-                          bool(NumTraits<T1>::IsInteger),
+      const bool t0_is_integer_alike = internal::is_valid_index_type<T0>::value;
+      const bool t1_is_integer_alike = internal::is_valid_index_type<T1>::value;
+      EIGEN_STATIC_ASSERT(t0_is_integer_alike &&
+                          t1_is_integer_alike,
                           FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)
       resize(rows,cols);
     }
-    
+
     template<typename T0, typename T1>
-    EIGEN_DEVICE_FUNC 
+    EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init2(const T0& val0, const T1& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)
     {
       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2)
       m_storage.data()[0] = Scalar(val0);
       m_storage.data()[1] = Scalar(val1);
     }
-    
+
     template<typename T0, typename T1>
-    EIGEN_DEVICE_FUNC 
+    EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init2(const Index& val0, const Index& val1,
                                     typename internal::enable_if<    (!internal::is_same<Index,Scalar>::value)
                                                                   && (internal::is_same<T0,Index>::value)
                                                                   && (internal::is_same<T1,Index>::value)
                                                                   && Base::SizeAtCompileTime==2,T1>::type* = 0)
     {
       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2)
@@ -769,30 +836,30 @@
     // then the argument is meant to be the size of the object.
     template<typename T>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init1(Index size, typename internal::enable_if<    (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value)
                                                                               && ((!internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value || Base::SizeAtCompileTime==Dynamic)),T>::type* = 0)
     {
       // NOTE MSVC 2008 complains if we directly put bool(NumTraits<T>::IsInteger) as the EIGEN_STATIC_ASSERT argument.
-      const bool is_integer = NumTraits<T>::IsInteger;
-      EIGEN_UNUSED_VARIABLE(is_integer);
-      EIGEN_STATIC_ASSERT(is_integer,
+      const bool is_integer_alike = internal::is_valid_index_type<T>::value;
+      EIGEN_UNUSED_VARIABLE(is_integer_alike);
+      EIGEN_STATIC_ASSERT(is_integer_alike,
                           FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)
       resize(size);
     }
-    
-    // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coefficient (case where scalar type can be implicitely converted)
+
+    // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coefficient (case where scalar type can be implicitly converted)
     template<typename T>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init1(const Scalar& val0, typename internal::enable_if<Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T>::type* = 0)
     {
       EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1)
       m_storage.data()[0] = val0;
     }
-    
+
     // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coefficient (case where scalar type match the index type)
     template<typename T>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init1(const Index& val0,
                                     typename internal::enable_if<    (!internal::is_same<Index,Scalar>::value)
                                                                   && (internal::is_same<Index,T>::value)
                                                                   && Base::SizeAtCompileTime==1
@@ -840,106 +907,123 @@
 
     template<typename T, typename OtherDerived, int ColsAtCompileTime>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived,ColsAtCompileTime>& r)
     {
       this->derived() = r;
     }
-    
+
     // For fixed-size Array<Scalar,...>
     template<typename T>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init1(const Scalar& val0,
                                     typename internal::enable_if<    Base::SizeAtCompileTime!=Dynamic
                                                                   && Base::SizeAtCompileTime!=1
                                                                   && internal::is_convertible<T, Scalar>::value
                                                                   && internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value,T>::type* = 0)
     {
       Base::setConstant(val0);
     }
-    
+
     // For fixed-size Array<Index,...>
     template<typename T>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE void _init1(const Index& val0,
                                     typename internal::enable_if<    (!internal::is_same<Index,Scalar>::value)
                                                                   && (internal::is_same<Index,T>::value)
                                                                   && Base::SizeAtCompileTime!=Dynamic
                                                                   && Base::SizeAtCompileTime!=1
                                                                   && internal::is_convertible<T, Scalar>::value
                                                                   && internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value,T*>::type* = 0)
     {
       Base::setConstant(val0);
     }
-    
+
     template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>
     friend struct internal::matrix_swap_impl;
 
   public:
-    
+
 #ifndef EIGEN_PARSED_BY_DOXYGEN
     /** \internal
       * \brief Override DenseBase::swap() since for dynamic-sized matrices
       * of same type it is enough to swap the data pointers.
       */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     void swap(DenseBase<OtherDerived> & other)
     {
       enum { SwapPointers = internal::is_same<Derived, OtherDerived>::value && Base::SizeAtCompileTime==Dynamic };
       internal::matrix_swap_impl<Derived, OtherDerived, bool(SwapPointers)>::run(this->derived(), other.derived());
     }
-    
+
     /** \internal
       * \brief const version forwarded to DenseBase::swap
       */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     void swap(DenseBase<OtherDerived> const & other)
     { Base::swap(other.derived()); }
-    
-    EIGEN_DEVICE_FUNC 
+
+    EIGEN_DEVICE_FUNC
     static EIGEN_STRONG_INLINE void _check_template_params()
     {
-      EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, (Options&RowMajor)==RowMajor)
-                        && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, (Options&RowMajor)==0)
+      EIGEN_STATIC_ASSERT((EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, (int(Options)&RowMajor)==RowMajor)
+                        && EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, (int(Options)&RowMajor)==0)
                         && ((RowsAtCompileTime == Dynamic) || (RowsAtCompileTime >= 0))
                         && ((ColsAtCompileTime == Dynamic) || (ColsAtCompileTime >= 0))
                         && ((MaxRowsAtCompileTime == Dynamic) || (MaxRowsAtCompileTime >= 0))
                         && ((MaxColsAtCompileTime == Dynamic) || (MaxColsAtCompileTime >= 0))
                         && (MaxRowsAtCompileTime == RowsAtCompileTime || RowsAtCompileTime==Dynamic)
                         && (MaxColsAtCompileTime == ColsAtCompileTime || ColsAtCompileTime==Dynamic)
                         && (Options & (DontAlign|RowMajor)) == Options),
         INVALID_MATRIX_TEMPLATE_PARAMETERS)
     }
 
     enum { IsPlainObjectBase = 1 };
 #endif
+  public:
+    // These apparently need to be down here for nvcc+icc to prevent duplicate
+    // Map symbol.
+    template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;
+    friend class Eigen::Map<Derived, Unaligned>;
+    friend class Eigen::Map<const Derived, Unaligned>;
+#if EIGEN_MAX_ALIGN_BYTES>0
+    // for EIGEN_MAX_ALIGN_BYTES==0, AlignedMax==Unaligned, and many compilers generate warnings for friend-ing a class twice.
+    friend class Eigen::Map<Derived, AlignedMax>;
+    friend class Eigen::Map<const Derived, AlignedMax>;
+#endif
 };
 
 namespace internal {
 
 template <typename Derived, typename OtherDerived, bool IsVector>
 struct conservative_resize_like_impl
 {
+  #if EIGEN_HAS_TYPE_TRAITS
+  static const bool IsRelocatable = std::is_trivially_copyable<typename Derived::Scalar>::value;
+  #else
+  static const bool IsRelocatable = !NumTraits<typename Derived::Scalar>::RequireInitialization;
+  #endif
   static void run(DenseBase<Derived>& _this, Index rows, Index cols)
   {
     if (_this.rows() == rows && _this.cols() == cols) return;
     EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(Derived)
 
-    if ( ( Derived::IsRowMajor && _this.cols() == cols) || // row-major and we change only the number of rows
-         (!Derived::IsRowMajor && _this.rows() == rows) )  // column-major and we change only the number of columns
+    if ( IsRelocatable
+          && (( Derived::IsRowMajor && _this.cols() == cols) ||  // row-major and we change only the number of rows
+              (!Derived::IsRowMajor && _this.rows() == rows) ))  // column-major and we change only the number of columns
     {
       internal::check_rows_cols_for_overflow<Derived::MaxSizeAtCompileTime>::run(rows, cols);
       _this.derived().m_storage.conservativeResize(rows*cols,rows,cols);
     }
     else
     {
       // The storage order does not allow us to use reallocation.
-      typename Derived::PlainObject tmp(rows,cols);
+      Derived tmp(rows,cols);
       const Index common_rows = numext::mini(rows, _this.rows());
       const Index common_cols = numext::mini(cols, _this.cols());
       tmp.block(0,0,common_rows,common_cols) = _this.block(0,0,common_rows,common_cols);
       _this.derived().swap(tmp);
     }
   }
 
@@ -951,72 +1035,81 @@
     // neither RowsAtCompileTime or ColsAtCompileTime must be Dynamic. If only one of the
     // dimensions is dynamic, one could use either conservativeResize(Index rows, NoChange_t) or
     // conservativeResize(NoChange_t, Index cols). For these methods new static asserts like
     // EIGEN_STATIC_ASSERT_DYNAMIC_ROWS and EIGEN_STATIC_ASSERT_DYNAMIC_COLS would be good.
     EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(Derived)
     EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(OtherDerived)
 
-    if ( ( Derived::IsRowMajor && _this.cols() == other.cols()) || // row-major and we change only the number of rows
-         (!Derived::IsRowMajor && _this.rows() == other.rows()) )  // column-major and we change only the number of columns
+    if ( IsRelocatable &&
+          (( Derived::IsRowMajor && _this.cols() == other.cols()) ||  // row-major and we change only the number of rows
+           (!Derived::IsRowMajor && _this.rows() == other.rows()) ))  // column-major and we change only the number of columns
     {
       const Index new_rows = other.rows() - _this.rows();
       const Index new_cols = other.cols() - _this.cols();
       _this.derived().m_storage.conservativeResize(other.size(),other.rows(),other.cols());
       if (new_rows>0)
         _this.bottomRightCorner(new_rows, other.cols()) = other.bottomRows(new_rows);
       else if (new_cols>0)
         _this.bottomRightCorner(other.rows(), new_cols) = other.rightCols(new_cols);
     }
     else
     {
       // The storage order does not allow us to use reallocation.
-      typename Derived::PlainObject tmp(other);
+      Derived tmp(other);
       const Index common_rows = numext::mini(tmp.rows(), _this.rows());
       const Index common_cols = numext::mini(tmp.cols(), _this.cols());
       tmp.block(0,0,common_rows,common_cols) = _this.block(0,0,common_rows,common_cols);
       _this.derived().swap(tmp);
     }
   }
 };
 
 // Here, the specialization for vectors inherits from the general matrix case
 // to allow calling .conservativeResize(rows,cols) on vectors.
 template <typename Derived, typename OtherDerived>
 struct conservative_resize_like_impl<Derived,OtherDerived,true>
   : conservative_resize_like_impl<Derived,OtherDerived,false>
 {
-  using conservative_resize_like_impl<Derived,OtherDerived,false>::run;
-  
+  typedef conservative_resize_like_impl<Derived,OtherDerived,false> Base;
+  using Base::run;
+  using Base::IsRelocatable;
+
   static void run(DenseBase<Derived>& _this, Index size)
   {
     const Index new_rows = Derived::RowsAtCompileTime==1 ? 1 : size;
     const Index new_cols = Derived::RowsAtCompileTime==1 ? size : 1;
-    _this.derived().m_storage.conservativeResize(size,new_rows,new_cols);
+    if(IsRelocatable)
+      _this.derived().m_storage.conservativeResize(size,new_rows,new_cols);
+    else
+      Base::run(_this.derived(), new_rows, new_cols);
   }
 
   static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)
   {
     if (_this.rows() == other.rows() && _this.cols() == other.cols()) return;
 
     const Index num_new_elements = other.size() - _this.size();
 
     const Index new_rows = Derived::RowsAtCompileTime==1 ? 1 : other.rows();
     const Index new_cols = Derived::RowsAtCompileTime==1 ? other.cols() : 1;
-    _this.derived().m_storage.conservativeResize(other.size(),new_rows,new_cols);
+    if(IsRelocatable)
+      _this.derived().m_storage.conservativeResize(other.size(),new_rows,new_cols);
+    else
+      Base::run(_this.derived(), new_rows, new_cols);
 
     if (num_new_elements > 0)
       _this.tail(num_new_elements) = other.tail(num_new_elements);
   }
 };
 
 template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>
 struct matrix_swap_impl
 {
   EIGEN_DEVICE_FUNC
-  static inline void run(MatrixTypeA& a, MatrixTypeB& b)
+  static EIGEN_STRONG_INLINE void run(MatrixTypeA& a, MatrixTypeB& b)
   {
     a.base().swap(b);
   }
 };
 
 template<typename MatrixTypeA, typename MatrixTypeB>
 struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Product.h` & `chronogram-0.2.0/include/Eigen/src/Core/Product.h`

 * *Files 4% similar despite different names*

```diff
@@ -19,33 +19,33 @@
 template<typename Lhs, typename Rhs, int Option>
 struct traits<Product<Lhs, Rhs, Option> >
 {
   typedef typename remove_all<Lhs>::type LhsCleaned;
   typedef typename remove_all<Rhs>::type RhsCleaned;
   typedef traits<LhsCleaned> LhsTraits;
   typedef traits<RhsCleaned> RhsTraits;
-  
+
   typedef MatrixXpr XprKind;
-  
+
   typedef typename ScalarBinaryOpTraits<typename traits<LhsCleaned>::Scalar, typename traits<RhsCleaned>::Scalar>::ReturnType Scalar;
   typedef typename product_promote_storage_type<typename LhsTraits::StorageKind,
                                                 typename RhsTraits::StorageKind,
                                                 internal::product_type<Lhs,Rhs>::ret>::ret StorageKind;
   typedef typename promote_index_type<typename LhsTraits::StorageIndex,
                                       typename RhsTraits::StorageIndex>::type StorageIndex;
-  
+
   enum {
     RowsAtCompileTime    = LhsTraits::RowsAtCompileTime,
     ColsAtCompileTime    = RhsTraits::ColsAtCompileTime,
     MaxRowsAtCompileTime = LhsTraits::MaxRowsAtCompileTime,
     MaxColsAtCompileTime = RhsTraits::MaxColsAtCompileTime,
-    
+
     // FIXME: only needed by GeneralMatrixMatrixTriangular
     InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(LhsTraits::ColsAtCompileTime, RhsTraits::RowsAtCompileTime),
-    
+
     // The storage order is somewhat arbitrary here. The correct one will be determined through the evaluator.
     Flags = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? RowMajorBit
           : (MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1) ? 0
           : (   ((LhsTraits::Flags&NoPreferredStorageOrderBit) && (RhsTraits::Flags&RowMajorBit))
              || ((RhsTraits::Flags&NoPreferredStorageOrderBit) && (LhsTraits::Flags&RowMajorBit)) ) ? RowMajorBit
           : NoPreferredStorageOrderBit
   };
@@ -70,68 +70,73 @@
 template<typename _Lhs, typename _Rhs, int Option>
 class Product : public ProductImpl<_Lhs,_Rhs,Option,
                                    typename internal::product_promote_storage_type<typename internal::traits<_Lhs>::StorageKind,
                                                                                    typename internal::traits<_Rhs>::StorageKind,
                                                                                    internal::product_type<_Lhs,_Rhs>::ret>::ret>
 {
   public:
-    
+
     typedef _Lhs Lhs;
     typedef _Rhs Rhs;
-    
+
     typedef typename ProductImpl<
         Lhs, Rhs, Option,
         typename internal::product_promote_storage_type<typename internal::traits<Lhs>::StorageKind,
                                                         typename internal::traits<Rhs>::StorageKind,
                                                         internal::product_type<Lhs,Rhs>::ret>::ret>::Base Base;
     EIGEN_GENERIC_PUBLIC_INTERFACE(Product)
 
     typedef typename internal::ref_selector<Lhs>::type LhsNested;
     typedef typename internal::ref_selector<Rhs>::type RhsNested;
     typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;
     typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;
 
-    EIGEN_DEVICE_FUNC Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)
     {
       eigen_assert(lhs.cols() == rhs.rows()
         && "invalid matrix product"
         && "if you wanted a coeff-wise or a dot product use the respective explicit functions");
     }
 
-    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }
-    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }
-
-    EIGEN_DEVICE_FUNC const LhsNestedCleaned& lhs() const { return m_lhs; }
-    EIGEN_DEVICE_FUNC const RhsNestedCleaned& rhs() const { return m_rhs; }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return m_lhs.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }
+
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const LhsNestedCleaned& lhs() const { return m_lhs; }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const RhsNestedCleaned& rhs() const { return m_rhs; }
 
   protected:
 
     LhsNested m_lhs;
     RhsNested m_rhs;
 };
 
 namespace internal {
-  
+
 template<typename Lhs, typename Rhs, int Option, int ProductTag = internal::product_type<Lhs,Rhs>::ret>
 class dense_product_base
  : public internal::dense_xpr_base<Product<Lhs,Rhs,Option> >::type
 {};
 
-/** Convertion to scalar for inner-products */
+/** Conversion to scalar for inner-products */
 template<typename Lhs, typename Rhs, int Option>
 class dense_product_base<Lhs, Rhs, Option, InnerProduct>
  : public internal::dense_xpr_base<Product<Lhs,Rhs,Option> >::type
 {
   typedef Product<Lhs,Rhs,Option> ProductXpr;
   typedef typename internal::dense_xpr_base<ProductXpr>::type Base;
 public:
   using Base::derived;
   typedef typename Base::Scalar Scalar;
-  
-  EIGEN_STRONG_INLINE operator const Scalar() const
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE operator const Scalar() const
   {
     return internal::evaluator<ProductXpr>(derived()).coeff(0,0);
   }
 };
 
 } // namespace internal
 
@@ -144,43 +149,43 @@
 };
 
 template<typename Lhs, typename Rhs, int Option>
 class ProductImpl<Lhs,Rhs,Option,Dense>
   : public internal::dense_product_base<Lhs,Rhs,Option>
 {
     typedef Product<Lhs, Rhs, Option> Derived;
-    
+
   public:
-    
+
     typedef typename internal::dense_product_base<Lhs, Rhs, Option> Base;
     EIGEN_DENSE_PUBLIC_INTERFACE(Derived)
   protected:
     enum {
-      IsOneByOne = (RowsAtCompileTime == 1 || RowsAtCompileTime == Dynamic) && 
+      IsOneByOne = (RowsAtCompileTime == 1 || RowsAtCompileTime == Dynamic) &&
                    (ColsAtCompileTime == 1 || ColsAtCompileTime == Dynamic),
       EnableCoeff = IsOneByOne || Option==LazyProduct
     };
-    
+
   public:
-  
+
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar coeff(Index row, Index col) const
     {
       EIGEN_STATIC_ASSERT(EnableCoeff, THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS);
       eigen_assert( (Option==LazyProduct) || (this->rows() == 1 && this->cols() == 1) );
-      
+
       return internal::evaluator<Derived>(derived()).coeff(row,col);
     }
 
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar coeff(Index i) const
     {
       EIGEN_STATIC_ASSERT(EnableCoeff, THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS);
       eigen_assert( (Option==LazyProduct) || (this->rows() == 1 && this->cols() == 1) );
-      
+
       return internal::evaluator<Derived>(derived()).coeff(i);
     }
-    
-  
+
+
 };
 
 } // end namespace Eigen
 
 #endif // EIGEN_PRODUCT_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/ProductEvaluators.h` & `chronogram-0.2.0/include/Eigen/src/Core/ProductEvaluators.h`

 * *Files 4% similar despite different names*

```diff
@@ -10,35 +10,35 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 
 #ifndef EIGEN_PRODUCTEVALUATORS_H
 #define EIGEN_PRODUCTEVALUATORS_H
 
 namespace Eigen {
-  
+
 namespace internal {
 
 /** \internal
   * Evaluator of a product expression.
   * Since products require special treatments to handle all possible cases,
-  * we simply deffer the evaluation logic to a product_evaluator class
+  * we simply defer the evaluation logic to a product_evaluator class
   * which offers more partial specialization possibilities.
-  * 
+  *
   * \sa class product_evaluator
   */
 template<typename Lhs, typename Rhs, int Options>
-struct evaluator<Product<Lhs, Rhs, Options> > 
+struct evaluator<Product<Lhs, Rhs, Options> >
  : public product_evaluator<Product<Lhs, Rhs, Options> >
 {
   typedef Product<Lhs, Rhs, Options> XprType;
   typedef product_evaluator<XprType> Base;
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit evaluator(const XprType& xpr) : Base(xpr) {}
 };
- 
+
 // Catch "scalar * ( A * B )" and transform it to "(A*scalar) * B"
 // TODO we should apply that rule only if that's really helpful
 template<typename Lhs, typename Rhs, typename Scalar1, typename Scalar2, typename Plain1>
 struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,
                                                const CwiseNullaryOp<internal::scalar_constant_op<Scalar1>, Plain1>,
                                                const Product<Lhs, Rhs, DefaultProduct> > >
 {
@@ -58,20 +58,20 @@
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit evaluator(const XprType& xpr)
     : Base(xpr.lhs().functor().m_other * xpr.rhs().lhs() * xpr.rhs().rhs())
   {}
 };
 
 
 template<typename Lhs, typename Rhs, int DiagIndex>
-struct evaluator<Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> > 
+struct evaluator<Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> >
  : public evaluator<Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex> >
 {
   typedef Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> XprType;
   typedef evaluator<Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex> > Base;
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit evaluator(const XprType& xpr)
     : Base(Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex>(
         Product<Lhs, Rhs, LazyProduct>(xpr.nestedExpression().lhs(), xpr.nestedExpression().rhs()),
         xpr.index() ))
   {}
 };
 
@@ -104,44 +104,44 @@
   };
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   explicit product_evaluator(const XprType& xpr)
     : m_result(xpr.rows(), xpr.cols())
   {
     ::new (static_cast<Base*>(this)) Base(m_result);
-    
+
 // FIXME shall we handle nested_eval here?,
 // if so, then we must take care at removing the call to nested_eval in the specializations (e.g., in permutation_matrix_product, transposition_matrix_product, etc.)
 //     typedef typename internal::nested_eval<Lhs,Rhs::ColsAtCompileTime>::type LhsNested;
 //     typedef typename internal::nested_eval<Rhs,Lhs::RowsAtCompileTime>::type RhsNested;
 //     typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;
 //     typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;
-//     
+//
 //     const LhsNested lhs(xpr.lhs());
 //     const RhsNested rhs(xpr.rhs());
-//   
+//
 //     generic_product_impl<LhsNestedCleaned, RhsNestedCleaned>::evalTo(m_result, lhs, rhs);
 
     generic_product_impl<Lhs, Rhs, LhsShape, RhsShape, ProductTag>::evalTo(m_result, xpr.lhs(), xpr.rhs());
   }
-  
-protected:  
+
+protected:
   PlainObject m_result;
 };
 
-// The following three shortcuts are enabled only if the scalar types match excatly.
+// The following three shortcuts are enabled only if the scalar types match exactly.
 // TODO: we could enable them for different scalar types when the product is not vectorized.
 
 // Dense = Product
 template< typename DstXprType, typename Lhs, typename Rhs, int Options, typename Scalar>
 struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::assign_op<Scalar,Scalar>, Dense2Dense,
   typename enable_if<(Options==DefaultProduct || Options==AliasFreeProduct)>::type>
 {
   typedef Product<Lhs,Rhs,Options> SrcXprType;
-  static EIGEN_STRONG_INLINE
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)
   {
     Index dstRows = src.rows();
     Index dstCols = src.cols();
     if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
       dst.resize(dstRows, dstCols);
     // FIXME shall we handle nested_eval here?
@@ -151,30 +151,30 @@
 
 // Dense += Product
 template< typename DstXprType, typename Lhs, typename Rhs, int Options, typename Scalar>
 struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::add_assign_op<Scalar,Scalar>, Dense2Dense,
   typename enable_if<(Options==DefaultProduct || Options==AliasFreeProduct)>::type>
 {
   typedef Product<Lhs,Rhs,Options> SrcXprType;
-  static EIGEN_STRONG_INLINE
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,Scalar> &)
   {
     eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
     // FIXME shall we handle nested_eval here?
     generic_product_impl<Lhs, Rhs>::addTo(dst, src.lhs(), src.rhs());
   }
 };
 
 // Dense -= Product
 template< typename DstXprType, typename Lhs, typename Rhs, int Options, typename Scalar>
 struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::sub_assign_op<Scalar,Scalar>, Dense2Dense,
   typename enable_if<(Options==DefaultProduct || Options==AliasFreeProduct)>::type>
 {
   typedef Product<Lhs,Rhs,Options> SrcXprType;
-  static EIGEN_STRONG_INLINE
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,Scalar> &)
   {
     eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());
     // FIXME shall we handle nested_eval here?
     generic_product_impl<Lhs, Rhs>::subTo(dst, src.lhs(), src.rhs());
   }
 };
@@ -186,15 +186,15 @@
 template< typename DstXprType, typename Lhs, typename Rhs, typename AssignFunc, typename Scalar, typename ScalarBis, typename Plain>
 struct Assignment<DstXprType, CwiseBinaryOp<internal::scalar_product_op<ScalarBis,Scalar>, const CwiseNullaryOp<internal::scalar_constant_op<ScalarBis>,Plain>,
                                            const Product<Lhs,Rhs,DefaultProduct> >, AssignFunc, Dense2Dense>
 {
   typedef CwiseBinaryOp<internal::scalar_product_op<ScalarBis,Scalar>,
                         const CwiseNullaryOp<internal::scalar_constant_op<ScalarBis>,Plain>,
                         const Product<Lhs,Rhs,DefaultProduct> > SrcXprType;
-  static EIGEN_STRONG_INLINE
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   void run(DstXprType &dst, const SrcXprType &src, const AssignFunc& func)
   {
     call_assignment_no_alias(dst, (src.lhs().functor().m_other * src.rhs().lhs())*src.rhs().rhs(), func);
   }
 };
 
 //----------------------------------------
@@ -213,15 +213,15 @@
   static const bool value = true;
 };
 
 template<typename DstXprType, typename OtherXpr, typename ProductType, typename Func1, typename Func2>
 struct assignment_from_xpr_op_product
 {
   template<typename SrcXprType, typename InitialFunc>
-  static EIGEN_STRONG_INLINE
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   void run(DstXprType &dst, const SrcXprType &src, const InitialFunc& /*func*/)
   {
     call_assignment_no_alias(dst, src.lhs(), Func1());
     call_assignment_no_alias(dst, src.rhs(), Func2());
   }
 };
 
@@ -242,126 +242,126 @@
 
 //----------------------------------------
 
 template<typename Lhs, typename Rhs>
 struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,InnerProduct>
 {
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
     dst.coeffRef(0,0) = (lhs.transpose().cwiseProduct(rhs)).sum();
   }
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
     dst.coeffRef(0,0) += (lhs.transpose().cwiseProduct(rhs)).sum();
   }
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   { dst.coeffRef(0,0) -= (lhs.transpose().cwiseProduct(rhs)).sum(); }
 };
 
 
 /***********************************************************************
 *  Implementation of outer dense * dense vector product
 ***********************************************************************/
 
 // Column major result
 template<typename Dst, typename Lhs, typename Rhs, typename Func>
-void outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const false_type&)
+void EIGEN_DEVICE_FUNC outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const false_type&)
 {
   evaluator<Rhs> rhsEval(rhs);
-  typename nested_eval<Lhs,Rhs::SizeAtCompileTime>::type actual_lhs(lhs);
+  ei_declare_local_nested_eval(Lhs,lhs,Rhs::SizeAtCompileTime,actual_lhs);
   // FIXME if cols is large enough, then it might be useful to make sure that lhs is sequentially stored
   // FIXME not very good if rhs is real and lhs complex while alpha is real too
   const Index cols = dst.cols();
   for (Index j=0; j<cols; ++j)
     func(dst.col(j), rhsEval.coeff(Index(0),j) * actual_lhs);
 }
 
 // Row major result
 template<typename Dst, typename Lhs, typename Rhs, typename Func>
-void outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const true_type&)
+void EIGEN_DEVICE_FUNC outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const true_type&)
 {
   evaluator<Lhs> lhsEval(lhs);
-  typename nested_eval<Rhs,Lhs::SizeAtCompileTime>::type actual_rhs(rhs);
+  ei_declare_local_nested_eval(Rhs,rhs,Lhs::SizeAtCompileTime,actual_rhs);
   // FIXME if rows is large enough, then it might be useful to make sure that rhs is sequentially stored
   // FIXME not very good if lhs is real and rhs complex while alpha is real too
   const Index rows = dst.rows();
   for (Index i=0; i<rows; ++i)
     func(dst.row(i), lhsEval.coeff(i,Index(0)) * actual_rhs);
 }
 
 template<typename Lhs, typename Rhs>
 struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,OuterProduct>
 {
   template<typename T> struct is_row_major : internal::conditional<(int(T::Flags)&RowMajorBit), internal::true_type, internal::false_type>::type {};
   typedef typename Product<Lhs,Rhs>::Scalar Scalar;
-  
+
   // TODO it would be nice to be able to exploit our *_assign_op functors for that purpose
-  struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };
-  struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };
-  struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };
+  struct set  { template<typename Dst, typename Src> EIGEN_DEVICE_FUNC void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };
+  struct add  { template<typename Dst, typename Src> EIGEN_DEVICE_FUNC void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };
+  struct sub  { template<typename Dst, typename Src> EIGEN_DEVICE_FUNC void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };
   struct adds {
     Scalar m_scale;
     explicit adds(const Scalar& s) : m_scale(s) {}
-    template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const {
+    template<typename Dst, typename Src> void EIGEN_DEVICE_FUNC operator()(const Dst& dst, const Src& src) const {
       dst.const_cast_derived() += m_scale * src;
     }
   };
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
     internal::outer_product_selector_run(dst, lhs, rhs, set(), is_row_major<Dst>());
   }
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
     internal::outer_product_selector_run(dst, lhs, rhs, add(), is_row_major<Dst>());
   }
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
     internal::outer_product_selector_run(dst, lhs, rhs, sub(), is_row_major<Dst>());
   }
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
   {
     internal::outer_product_selector_run(dst, lhs, rhs, adds(alpha), is_row_major<Dst>());
   }
-  
+
 };
 
 
 // This base class provides default implementations for evalTo, addTo, subTo, in terms of scaleAndAddTo
 template<typename Lhs, typename Rhs, typename Derived>
 struct generic_product_impl_base
 {
   typedef typename Product<Lhs,Rhs>::Scalar Scalar;
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   { dst.setZero(); scaleAndAddTo(dst, lhs, rhs, Scalar(1)); }
 
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   { scaleAndAddTo(dst,lhs, rhs, Scalar(1)); }
 
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   { scaleAndAddTo(dst, lhs, rhs, Scalar(-1)); }
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
   { Derived::scaleAndAddTo(dst,lhs,rhs,alpha); }
 
 };
 
 template<typename Lhs, typename Rhs>
 struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemvProduct>
   : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemvProduct> >
@@ -369,55 +369,109 @@
   typedef typename nested_eval<Lhs,1>::type LhsNested;
   typedef typename nested_eval<Rhs,1>::type RhsNested;
   typedef typename Product<Lhs,Rhs>::Scalar Scalar;
   enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };
   typedef typename internal::remove_all<typename internal::conditional<int(Side)==OnTheRight,LhsNested,RhsNested>::type>::type MatrixType;
 
   template<typename Dest>
-  static EIGEN_STRONG_INLINE void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
   {
+    // Fallback to inner product if both the lhs and rhs is a runtime vector.
+    if (lhs.rows() == 1 && rhs.cols() == 1) {
+      dst.coeffRef(0,0) += alpha * lhs.row(0).conjugate().dot(rhs.col(0));
+      return;
+    }
     LhsNested actual_lhs(lhs);
     RhsNested actual_rhs(rhs);
     internal::gemv_dense_selector<Side,
                             (int(MatrixType::Flags)&RowMajorBit) ? RowMajor : ColMajor,
                             bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess)
                            >::run(actual_lhs, actual_rhs, dst, alpha);
   }
 };
 
 template<typename Lhs, typename Rhs>
-struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> 
+struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode>
 {
   typedef typename Product<Lhs,Rhs>::Scalar Scalar;
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
     // Same as: dst.noalias() = lhs.lazyProduct(rhs);
     // but easier on the compiler side
     call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::assign_op<typename Dst::Scalar,Scalar>());
   }
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
     // dst.noalias() += lhs.lazyProduct(rhs);
     call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::add_assign_op<typename Dst::Scalar,Scalar>());
   }
-  
+
   template<typename Dst>
-  static EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
     // dst.noalias() -= lhs.lazyProduct(rhs);
     call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::sub_assign_op<typename Dst::Scalar,Scalar>());
   }
-  
-//   template<typename Dst>
-//   static inline void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
-//   { dst.noalias() += alpha * lhs.lazyProduct(rhs); }
+
+  // This is a special evaluation path called from generic_product_impl<...,GemmProduct> in file GeneralMatrixMatrix.h
+  // This variant tries to extract scalar multiples from both the LHS and RHS and factor them out. For instance:
+  //   dst {,+,-}= (s1*A)*(B*s2)
+  // will be rewritten as:
+  //   dst {,+,-}= (s1*s2) * (A.lazyProduct(B))
+  // There are at least four benefits of doing so:
+  //  1 - huge performance gain for heap-allocated matrix types as it save costly allocations.
+  //  2 - it is faster than simply by-passing the heap allocation through stack allocation.
+  //  3 - it makes this fallback consistent with the heavy GEMM routine.
+  //  4 - it fully by-passes huge stack allocation attempts when multiplying huge fixed-size matrices.
+  //      (see https://stackoverflow.com/questions/54738495)
+  // For small fixed sizes matrices, howver, the gains are less obvious, it is sometimes x2 faster, but sometimes x3 slower,
+  // and the behavior depends also a lot on the compiler... This is why this re-writting strategy is currently
+  // enabled only when falling back from the main GEMM.
+  template<typename Dst, typename Func>
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  void eval_dynamic(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Func &func)
+  {
+    enum {
+      HasScalarFactor = blas_traits<Lhs>::HasScalarFactor || blas_traits<Rhs>::HasScalarFactor,
+      ConjLhs = blas_traits<Lhs>::NeedToConjugate,
+      ConjRhs = blas_traits<Rhs>::NeedToConjugate
+    };
+    // FIXME: in c++11 this should be auto, and extractScalarFactor should also return auto
+    //        this is important for real*complex_mat
+    Scalar actualAlpha = combine_scalar_factors<Scalar>(lhs, rhs);
+
+    eval_dynamic_impl(dst,
+                      blas_traits<Lhs>::extract(lhs).template conjugateIf<ConjLhs>(),
+                      blas_traits<Rhs>::extract(rhs).template conjugateIf<ConjRhs>(),
+                      func,
+                      actualAlpha,
+                      typename conditional<HasScalarFactor,true_type,false_type>::type());
+  }
+
+protected:
+
+  template<typename Dst, typename LhsT, typename RhsT, typename Func, typename Scalar>
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  void eval_dynamic_impl(Dst& dst, const LhsT& lhs, const RhsT& rhs, const Func &func, const Scalar&  s /* == 1 */, false_type)
+  {
+    EIGEN_UNUSED_VARIABLE(s);
+    eigen_internal_assert(s==Scalar(1));
+    call_restricted_packet_assignment_no_alias(dst, lhs.lazyProduct(rhs), func);
+  }
+
+  template<typename Dst, typename LhsT, typename RhsT, typename Func, typename Scalar>
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  void eval_dynamic_impl(Dst& dst, const LhsT& lhs, const RhsT& rhs, const Func &func, const Scalar& s, true_type)
+  {
+    call_restricted_packet_assignment_no_alias(dst, s * lhs.lazyProduct(rhs), func);
+  }
 };
 
 // This specialization enforces the use of a coefficient-based evaluation strategy
 template<typename Lhs, typename Rhs>
 struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,LazyCoeffBasedProductMode>
   : generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> {};
 
@@ -467,15 +521,15 @@
 #endif
   }
 
   // Everything below here is taken from CoeffBasedProduct.h
 
   typedef typename internal::nested_eval<Lhs,Rhs::ColsAtCompileTime>::type LhsNested;
   typedef typename internal::nested_eval<Rhs,Lhs::RowsAtCompileTime>::type RhsNested;
-  
+
   typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;
   typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;
 
   typedef evaluator<LhsNestedCleaned> LhsEtorType;
   typedef evaluator<RhsNestedCleaned> RhsEtorType;
 
   enum {
@@ -486,52 +540,52 @@
     MaxColsAtCompileTime = RhsNestedCleaned::MaxColsAtCompileTime
   };
 
   typedef typename find_best_packet<Scalar,RowsAtCompileTime>::type LhsVecPacketType;
   typedef typename find_best_packet<Scalar,ColsAtCompileTime>::type RhsVecPacketType;
 
   enum {
-      
+
     LhsCoeffReadCost = LhsEtorType::CoeffReadCost,
     RhsCoeffReadCost = RhsEtorType::CoeffReadCost,
     CoeffReadCost = InnerSize==0 ? NumTraits<Scalar>::ReadCost
                   : InnerSize == Dynamic ? HugeCost
-                  : InnerSize * (NumTraits<Scalar>::MulCost + LhsCoeffReadCost + RhsCoeffReadCost)
+                    : InnerSize * (NumTraits<Scalar>::MulCost + int(LhsCoeffReadCost) + int(RhsCoeffReadCost))
                     + (InnerSize - 1) * NumTraits<Scalar>::AddCost,
 
     Unroll = CoeffReadCost <= EIGEN_UNROLLING_LIMIT,
-    
+
     LhsFlags = LhsEtorType::Flags,
     RhsFlags = RhsEtorType::Flags,
-    
+
     LhsRowMajor = LhsFlags & RowMajorBit,
     RhsRowMajor = RhsFlags & RowMajorBit,
 
     LhsVecPacketSize = unpacket_traits<LhsVecPacketType>::size,
     RhsVecPacketSize = unpacket_traits<RhsVecPacketType>::size,
 
     // Here, we don't care about alignment larger than the usable packet size.
     LhsAlignment = EIGEN_PLAIN_ENUM_MIN(LhsEtorType::Alignment,LhsVecPacketSize*int(sizeof(typename LhsNestedCleaned::Scalar))),
     RhsAlignment = EIGEN_PLAIN_ENUM_MIN(RhsEtorType::Alignment,RhsVecPacketSize*int(sizeof(typename RhsNestedCleaned::Scalar))),
-      
+
     SameType = is_same<typename LhsNestedCleaned::Scalar,typename RhsNestedCleaned::Scalar>::value,
 
     CanVectorizeRhs = bool(RhsRowMajor) && (RhsFlags & PacketAccessBit) && (ColsAtCompileTime!=1),
     CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit) && (RowsAtCompileTime!=1),
 
     EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1
                     : (MaxColsAtCompileTime==1&&MaxRowsAtCompileTime!=1) ? 0
                     : (bool(RhsRowMajor) && !CanVectorizeLhs),
 
-    Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)
+    Flags = ((int(LhsFlags) | int(RhsFlags)) & HereditaryBits & ~RowMajorBit)
           | (EvalToRowMajor ? RowMajorBit : 0)
           // TODO enable vectorization for mixed types
           | (SameType && (CanVectorizeLhs || CanVectorizeRhs) ? PacketAccessBit : 0)
           | (XprType::IsVectorAtCompileTime ? LinearAccessBit : 0),
-          
+
     LhsOuterStrideBytes = int(LhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename LhsNestedCleaned::Scalar)),
     RhsOuterStrideBytes = int(RhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename RhsNestedCleaned::Scalar)),
 
     Alignment = bool(CanVectorizeLhs) ? (LhsOuterStrideBytes<=0 || (int(LhsOuterStrideBytes) % EIGEN_PLAIN_ENUM_MAX(1,LhsAlignment))!=0 ? 0 : LhsAlignment)
               : bool(CanVectorizeRhs) ? (RhsOuterStrideBytes<=0 || (int(RhsOuterStrideBytes) % EIGEN_PLAIN_ENUM_MAX(1,RhsAlignment))!=0 ? 0 : RhsAlignment)
               : 0,
 
@@ -539,57 +593,60 @@
      * of Product. If the Product itself is not a packet-access expression, there is still a chance that the inner
      * loop of the product might be vectorized. This is the meaning of CanVectorizeInner. Since it doesn't affect
      * the Flags, it is safe to make this value depend on ActualPacketAccessBit, that doesn't affect the ABI.
      */
     CanVectorizeInner =    SameType
                         && LhsRowMajor
                         && (!RhsRowMajor)
-                        && (LhsFlags & RhsFlags & ActualPacketAccessBit)
-                        && (InnerSize % packet_traits<Scalar>::size == 0)
+                        && (int(LhsFlags) & int(RhsFlags) & ActualPacketAccessBit)
+                        && (int(InnerSize) % packet_traits<Scalar>::size == 0)
   };
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index row, Index col) const
   {
     return (m_lhs.row(row).transpose().cwiseProduct( m_rhs.col(col) )).sum();
   }
 
   /* Allow index-based non-packet access. It is impossible though to allow index-based packed access,
    * which is why we don't set the LinearAccessBit.
    * TODO: this seems possible when the result is a vector
    */
-  EIGEN_DEVICE_FUNC const CoeffReturnType coeff(Index index) const
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  const CoeffReturnType coeff(Index index) const
   {
     const Index row = (RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1) ? 0 : index;
     const Index col = (RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1) ? index : 0;
     return (m_lhs.row(row).transpose().cwiseProduct( m_rhs.col(col) )).sum();
   }
 
   template<int LoadMode, typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   const PacketType packet(Index row, Index col) const
   {
     PacketType res;
     typedef etor_product_packet_impl<bool(int(Flags)&RowMajorBit) ? RowMajor : ColMajor,
                                      Unroll ? int(InnerSize) : Dynamic,
                                      LhsEtorType, RhsEtorType, PacketType, LoadMode> PacketImpl;
     PacketImpl::run(row, col, m_lhsImpl, m_rhsImpl, m_innerDim, res);
     return res;
   }
 
   template<int LoadMode, typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   const PacketType packet(Index index) const
   {
     const Index row = (RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1) ? 0 : index;
     const Index col = (RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1) ? index : 0;
     return packet<LoadMode,PacketType>(row,col);
   }
 
 protected:
   typename internal::add_const_on_value_type<LhsNested>::type m_lhs;
   typename internal::add_const_on_value_type<RhsNested>::type m_rhs;
-  
+
   LhsEtorType m_lhsImpl;
   RhsEtorType m_rhsImpl;
 
   // TODO: Get rid of m_innerDim if known at compile time
   Index m_innerDim;
 };
 
@@ -599,94 +656,95 @@
 {
   typedef Product<Lhs, Rhs, DefaultProduct> XprType;
   typedef Product<Lhs, Rhs, LazyProduct> BaseProduct;
   typedef product_evaluator<BaseProduct, CoeffBasedProductMode, DenseShape, DenseShape> Base;
   enum {
     Flags = Base::Flags | EvalBeforeNestingBit
   };
-  EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit product_evaluator(const XprType& xpr)
     : Base(BaseProduct(xpr.lhs(),xpr.rhs()))
   {}
 };
 
 /****************************************
 *** Coeff based product, Packet path  ***
 ****************************************/
 
 template<int UnrollingIndex, typename Lhs, typename Rhs, typename Packet, int LoadMode>
 struct etor_product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>
 {
-  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)
   {
     etor_product_packet_impl<RowMajor, UnrollingIndex-1, Lhs, Rhs, Packet, LoadMode>::run(row, col, lhs, rhs, innerDim, res);
     res =  pmadd(pset1<Packet>(lhs.coeff(row, Index(UnrollingIndex-1))), rhs.template packet<LoadMode,Packet>(Index(UnrollingIndex-1), col), res);
   }
 };
 
 template<int UnrollingIndex, typename Lhs, typename Rhs, typename Packet, int LoadMode>
 struct etor_product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>
 {
-  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)
   {
     etor_product_packet_impl<ColMajor, UnrollingIndex-1, Lhs, Rhs, Packet, LoadMode>::run(row, col, lhs, rhs, innerDim, res);
     res =  pmadd(lhs.template packet<LoadMode,Packet>(row, Index(UnrollingIndex-1)), pset1<Packet>(rhs.coeff(Index(UnrollingIndex-1), col)), res);
   }
 };
 
 template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
 struct etor_product_packet_impl<RowMajor, 1, Lhs, Rhs, Packet, LoadMode>
 {
-  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index /*innerDim*/, Packet &res)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index /*innerDim*/, Packet &res)
   {
     res = pmul(pset1<Packet>(lhs.coeff(row, Index(0))),rhs.template packet<LoadMode,Packet>(Index(0), col));
   }
 };
 
 template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
 struct etor_product_packet_impl<ColMajor, 1, Lhs, Rhs, Packet, LoadMode>
 {
-  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index /*innerDim*/, Packet &res)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index /*innerDim*/, Packet &res)
   {
     res = pmul(lhs.template packet<LoadMode,Packet>(row, Index(0)), pset1<Packet>(rhs.coeff(Index(0), col)));
   }
 };
 
 template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
 struct etor_product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>
 {
-  static EIGEN_STRONG_INLINE void run(Index /*row*/, Index /*col*/, const Lhs& /*lhs*/, const Rhs& /*rhs*/, Index /*innerDim*/, Packet &res)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index /*row*/, Index /*col*/, const Lhs& /*lhs*/, const Rhs& /*rhs*/, Index /*innerDim*/, Packet &res)
   {
     res = pset1<Packet>(typename unpacket_traits<Packet>::type(0));
   }
 };
 
 template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
 struct etor_product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>
 {
-  static EIGEN_STRONG_INLINE void run(Index /*row*/, Index /*col*/, const Lhs& /*lhs*/, const Rhs& /*rhs*/, Index /*innerDim*/, Packet &res)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index /*row*/, Index /*col*/, const Lhs& /*lhs*/, const Rhs& /*rhs*/, Index /*innerDim*/, Packet &res)
   {
     res = pset1<Packet>(typename unpacket_traits<Packet>::type(0));
   }
 };
 
 template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
 struct etor_product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>
 {
-  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)
   {
     res = pset1<Packet>(typename unpacket_traits<Packet>::type(0));
     for(Index i = 0; i < innerDim; ++i)
       res =  pmadd(pset1<Packet>(lhs.coeff(row, i)), rhs.template packet<LoadMode,Packet>(i, col), res);
   }
 };
 
 template<typename Lhs, typename Rhs, typename Packet, int LoadMode>
 struct etor_product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>
 {
-  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)
   {
     res = pset1<Packet>(typename unpacket_traits<Packet>::type(0));
     for(Index i = 0; i < innerDim; ++i)
       res =  pmadd(lhs.template packet<LoadMode,Packet>(row, i), pset1<Packet>(rhs.coeff(i, col)), res);
   }
 };
 
@@ -700,29 +758,29 @@
 struct triangular_product_impl;
 
 template<typename Lhs, typename Rhs, int ProductTag>
 struct generic_product_impl<Lhs,Rhs,TriangularShape,DenseShape,ProductTag>
   : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,TriangularShape,DenseShape,ProductTag> >
 {
   typedef typename Product<Lhs,Rhs>::Scalar Scalar;
-  
+
   template<typename Dest>
   static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
   {
     triangular_product_impl<Lhs::Mode,true,typename Lhs::MatrixType,false,Rhs, Rhs::ColsAtCompileTime==1>
         ::run(dst, lhs.nestedExpression(), rhs, alpha);
   }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag>
 struct generic_product_impl<Lhs,Rhs,DenseShape,TriangularShape,ProductTag>
 : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,DenseShape,TriangularShape,ProductTag> >
 {
   typedef typename Product<Lhs,Rhs>::Scalar Scalar;
-  
+
   template<typename Dest>
   static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
   {
     triangular_product_impl<Rhs::Mode,false,Lhs,Lhs::RowsAtCompileTime==1, typename Rhs::MatrixType, false>::run(dst, lhs, rhs.nestedExpression(), alpha);
   }
 };
 
@@ -735,143 +793,152 @@
 struct selfadjoint_product_impl;
 
 template<typename Lhs, typename Rhs, int ProductTag>
 struct generic_product_impl<Lhs,Rhs,SelfAdjointShape,DenseShape,ProductTag>
   : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,SelfAdjointShape,DenseShape,ProductTag> >
 {
   typedef typename Product<Lhs,Rhs>::Scalar Scalar;
-  
+
   template<typename Dest>
-  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
+  static EIGEN_DEVICE_FUNC
+  void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
   {
     selfadjoint_product_impl<typename Lhs::MatrixType,Lhs::Mode,false,Rhs,0,Rhs::IsVectorAtCompileTime>::run(dst, lhs.nestedExpression(), rhs, alpha);
   }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag>
 struct generic_product_impl<Lhs,Rhs,DenseShape,SelfAdjointShape,ProductTag>
 : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,DenseShape,SelfAdjointShape,ProductTag> >
 {
   typedef typename Product<Lhs,Rhs>::Scalar Scalar;
-  
+
   template<typename Dest>
   static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)
   {
     selfadjoint_product_impl<Lhs,0,Lhs::IsVectorAtCompileTime,typename Rhs::MatrixType,Rhs::Mode,false>::run(dst, lhs, rhs.nestedExpression(), alpha);
   }
 };
 
 
 /***************************************************************************
 * Diagonal products
 ***************************************************************************/
-  
+
 template<typename MatrixType, typename DiagonalType, typename Derived, int ProductOrder>
 struct diagonal_product_evaluator_base
   : evaluator_base<Derived>
 {
    typedef typename ScalarBinaryOpTraits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;
 public:
   enum {
-    CoeffReadCost = NumTraits<Scalar>::MulCost + evaluator<MatrixType>::CoeffReadCost + evaluator<DiagonalType>::CoeffReadCost,
-    
+    CoeffReadCost = int(NumTraits<Scalar>::MulCost) + int(evaluator<MatrixType>::CoeffReadCost) + int(evaluator<DiagonalType>::CoeffReadCost),
+
     MatrixFlags = evaluator<MatrixType>::Flags,
     DiagFlags = evaluator<DiagonalType>::Flags,
-    _StorageOrder = MatrixFlags & RowMajorBit ? RowMajor : ColMajor,
+
+    _StorageOrder = (Derived::MaxRowsAtCompileTime==1 && Derived::MaxColsAtCompileTime!=1) ? RowMajor
+                  : (Derived::MaxColsAtCompileTime==1 && Derived::MaxRowsAtCompileTime!=1) ? ColMajor
+                  : MatrixFlags & RowMajorBit ? RowMajor : ColMajor,
+    _SameStorageOrder = _StorageOrder == (MatrixFlags & RowMajorBit ? RowMajor : ColMajor),
+
     _ScalarAccessOnDiag =  !((int(_StorageOrder) == ColMajor && int(ProductOrder) == OnTheLeft)
                            ||(int(_StorageOrder) == RowMajor && int(ProductOrder) == OnTheRight)),
     _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,
     // FIXME currently we need same types, but in the future the next rule should be the one
     //_Vectorizable = bool(int(MatrixFlags)&PacketAccessBit) && ((!_PacketOnDiag) || (_SameTypes && bool(int(DiagFlags)&PacketAccessBit))),
-    _Vectorizable = bool(int(MatrixFlags)&PacketAccessBit) && _SameTypes && (_ScalarAccessOnDiag || (bool(int(DiagFlags)&PacketAccessBit))),
+    _Vectorizable =   bool(int(MatrixFlags)&PacketAccessBit)
+                  &&  _SameTypes
+                  && (_SameStorageOrder || (MatrixFlags&LinearAccessBit)==LinearAccessBit)
+                  && (_ScalarAccessOnDiag || (bool(int(DiagFlags)&PacketAccessBit))),
     _LinearAccessMask = (MatrixType::RowsAtCompileTime==1 || MatrixType::ColsAtCompileTime==1) ? LinearAccessBit : 0,
     Flags = ((HereditaryBits|_LinearAccessMask) & (unsigned int)(MatrixFlags)) | (_Vectorizable ? PacketAccessBit : 0),
     Alignment = evaluator<MatrixType>::Alignment,
 
     AsScalarProduct =     (DiagonalType::SizeAtCompileTime==1)
                       ||  (DiagonalType::SizeAtCompileTime==Dynamic && MatrixType::RowsAtCompileTime==1 && ProductOrder==OnTheLeft)
                       ||  (DiagonalType::SizeAtCompileTime==Dynamic && MatrixType::ColsAtCompileTime==1 && ProductOrder==OnTheRight)
   };
-  
-  diagonal_product_evaluator_base(const MatrixType &mat, const DiagonalType &diag)
+
+  EIGEN_DEVICE_FUNC diagonal_product_evaluator_base(const MatrixType &mat, const DiagonalType &diag)
     : m_diagImpl(diag), m_matImpl(mat)
   {
     EIGEN_INTERNAL_CHECK_COST_VALUE(NumTraits<Scalar>::MulCost);
     EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
   }
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index idx) const
   {
     if(AsScalarProduct)
       return m_diagImpl.coeff(0) * m_matImpl.coeff(idx);
     else
       return m_diagImpl.coeff(idx) * m_matImpl.coeff(idx);
   }
-  
+
 protected:
   template<int LoadMode,typename PacketType>
   EIGEN_STRONG_INLINE PacketType packet_impl(Index row, Index col, Index id, internal::true_type) const
   {
     return internal::pmul(m_matImpl.template packet<LoadMode,PacketType>(row, col),
                           internal::pset1<PacketType>(m_diagImpl.coeff(id)));
   }
-  
+
   template<int LoadMode,typename PacketType>
   EIGEN_STRONG_INLINE PacketType packet_impl(Index row, Index col, Index id, internal::false_type) const
   {
     enum {
       InnerSize = (MatrixType::Flags & RowMajorBit) ? MatrixType::ColsAtCompileTime : MatrixType::RowsAtCompileTime,
       DiagonalPacketLoadMode = EIGEN_PLAIN_ENUM_MIN(LoadMode,((InnerSize%16) == 0) ? int(Aligned16) : int(evaluator<DiagonalType>::Alignment)) // FIXME hardcoded 16!!
     };
     return internal::pmul(m_matImpl.template packet<LoadMode,PacketType>(row, col),
                           m_diagImpl.template packet<DiagonalPacketLoadMode,PacketType>(id));
   }
-  
+
   evaluator<DiagonalType> m_diagImpl;
   evaluator<MatrixType>   m_matImpl;
 };
 
 // diagonal * dense
 template<typename Lhs, typename Rhs, int ProductKind, int ProductTag>
 struct product_evaluator<Product<Lhs, Rhs, ProductKind>, ProductTag, DiagonalShape, DenseShape>
   : diagonal_product_evaluator_base<Rhs, typename Lhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheLeft>
 {
   typedef diagonal_product_evaluator_base<Rhs, typename Lhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheLeft> Base;
   using Base::m_diagImpl;
   using Base::m_matImpl;
   using Base::coeff;
   typedef typename Base::Scalar Scalar;
-  
+
   typedef Product<Lhs, Rhs, ProductKind> XprType;
   typedef typename XprType::PlainObject PlainObject;
-  
-  enum {
-    StorageOrder = int(Rhs::Flags) & RowMajorBit ? RowMajor : ColMajor
-  };
+  typedef typename Lhs::DiagonalVectorType DiagonalType;
+
+
+  enum { StorageOrder = Base::_StorageOrder };
 
   EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)
     : Base(xpr.rhs(), xpr.lhs().diagonal())
   {
   }
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const
   {
     return m_diagImpl.coeff(row) * m_matImpl.coeff(row, col);
   }
-  
-#ifndef __CUDACC__
+
+#ifndef EIGEN_GPUCC
   template<int LoadMode,typename PacketType>
   EIGEN_STRONG_INLINE PacketType packet(Index row, Index col) const
   {
     // FIXME: NVCC used to complain about the template keyword, but we have to check whether this is still the case.
     // See also similar calls below.
     return this->template packet_impl<LoadMode,PacketType>(row,col, row,
                                  typename internal::conditional<int(StorageOrder)==RowMajor, internal::true_type, internal::false_type>::type());
   }
-  
+
   template<int LoadMode,typename PacketType>
   EIGEN_STRONG_INLINE PacketType packet(Index idx) const
   {
     return packet<LoadMode,PacketType>(int(StorageOrder)==ColMajor?idx:0,int(StorageOrder)==ColMajor?0:idx);
   }
 #endif
 };
@@ -882,38 +949,38 @@
   : diagonal_product_evaluator_base<Lhs, typename Rhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheRight>
 {
   typedef diagonal_product_evaluator_base<Lhs, typename Rhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheRight> Base;
   using Base::m_diagImpl;
   using Base::m_matImpl;
   using Base::coeff;
   typedef typename Base::Scalar Scalar;
-  
+
   typedef Product<Lhs, Rhs, ProductKind> XprType;
   typedef typename XprType::PlainObject PlainObject;
-  
-  enum { StorageOrder = int(Lhs::Flags) & RowMajorBit ? RowMajor : ColMajor };
+
+  enum { StorageOrder = Base::_StorageOrder };
 
   EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)
     : Base(xpr.lhs(), xpr.rhs().diagonal())
   {
   }
-  
+
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const
   {
     return m_matImpl.coeff(row, col) * m_diagImpl.coeff(col);
   }
-  
-#ifndef __CUDACC__
+
+#ifndef EIGEN_GPUCC
   template<int LoadMode,typename PacketType>
   EIGEN_STRONG_INLINE PacketType packet(Index row, Index col) const
   {
     return this->template packet_impl<LoadMode,PacketType>(row,col, col,
                                  typename internal::conditional<int(StorageOrder)==ColMajor, internal::true_type, internal::false_type>::type());
   }
-  
+
   template<int LoadMode,typename PacketType>
   EIGEN_STRONG_INLINE PacketType packet(Index idx) const
   {
     return packet<LoadMode,PacketType>(int(StorageOrder)==ColMajor?idx:0,int(StorageOrder)==ColMajor?0:idx);
   }
 #endif
 };
@@ -933,15 +1000,15 @@
 template<typename ExpressionType, int Side, bool Transposed>
 struct permutation_matrix_product<ExpressionType, Side, Transposed, DenseShape>
 {
     typedef typename nested_eval<ExpressionType, 1>::type MatrixType;
     typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;
 
     template<typename Dest, typename PermutationType>
-    static inline void run(Dest& dst, const PermutationType& perm, const ExpressionType& xpr)
+    static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Dest& dst, const PermutationType& perm, const ExpressionType& xpr)
     {
       MatrixType mat(xpr);
       const Index n = Side==OnTheLeft ? mat.rows() : mat.cols();
       // FIXME we need an is_same for expression that is not sensitive to constness. For instance
       // is_same_xpr<Block<const Matrix>, Block<Matrix> >::value should be true.
       //if(is_same<MatrixTypeCleaned,Dest>::value && extract_data(dst) == extract_data(mat))
       if(is_same_dense(dst, mat))
@@ -987,45 +1054,45 @@
     }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>
 struct generic_product_impl<Lhs, Rhs, PermutationShape, MatrixShape, ProductTag>
 {
   template<typename Dest>
-  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)
   {
     permutation_matrix_product<Rhs, OnTheLeft, false, MatrixShape>::run(dst, lhs, rhs);
   }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>
 struct generic_product_impl<Lhs, Rhs, MatrixShape, PermutationShape, ProductTag>
 {
   template<typename Dest>
-  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)
   {
     permutation_matrix_product<Lhs, OnTheRight, false, MatrixShape>::run(dst, rhs, lhs);
   }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>
 struct generic_product_impl<Inverse<Lhs>, Rhs, PermutationShape, MatrixShape, ProductTag>
 {
   template<typename Dest>
-  static void evalTo(Dest& dst, const Inverse<Lhs>& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Inverse<Lhs>& lhs, const Rhs& rhs)
   {
     permutation_matrix_product<Rhs, OnTheLeft, true, MatrixShape>::run(dst, lhs.nestedExpression(), rhs);
   }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>
 struct generic_product_impl<Lhs, Inverse<Rhs>, MatrixShape, PermutationShape, ProductTag>
 {
   template<typename Dest>
-  static void evalTo(Dest& dst, const Lhs& lhs, const Inverse<Rhs>& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Inverse<Rhs>& rhs)
   {
     permutation_matrix_product<Lhs, OnTheRight, true, MatrixShape>::run(dst, rhs.nestedExpression(), lhs);
   }
 };
 
 
 /***************************************************************************
@@ -1039,17 +1106,17 @@
   * Internal helper class implementing the product between a permutation matrix and a matrix.
   */
 template<typename ExpressionType, int Side, bool Transposed, typename ExpressionShape>
 struct transposition_matrix_product
 {
   typedef typename nested_eval<ExpressionType, 1>::type MatrixType;
   typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;
-  
+
   template<typename Dest, typename TranspositionType>
-  static inline void run(Dest& dst, const TranspositionType& tr, const ExpressionType& xpr)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Dest& dst, const TranspositionType& tr, const ExpressionType& xpr)
   {
     MatrixType mat(xpr);
     typedef typename TranspositionType::StorageIndex StorageIndex;
     const Index size = tr.size();
     StorageIndex j = 0;
 
     if(!is_same_dense(dst,mat))
@@ -1064,46 +1131,46 @@
   }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>
 struct generic_product_impl<Lhs, Rhs, TranspositionsShape, MatrixShape, ProductTag>
 {
   template<typename Dest>
-  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)
   {
     transposition_matrix_product<Rhs, OnTheLeft, false, MatrixShape>::run(dst, lhs, rhs);
   }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>
 struct generic_product_impl<Lhs, Rhs, MatrixShape, TranspositionsShape, ProductTag>
 {
   template<typename Dest>
-  static void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)
   {
     transposition_matrix_product<Lhs, OnTheRight, false, MatrixShape>::run(dst, rhs, lhs);
   }
 };
 
 
 template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>
 struct generic_product_impl<Transpose<Lhs>, Rhs, TranspositionsShape, MatrixShape, ProductTag>
 {
   template<typename Dest>
-  static void evalTo(Dest& dst, const Transpose<Lhs>& lhs, const Rhs& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Transpose<Lhs>& lhs, const Rhs& rhs)
   {
     transposition_matrix_product<Rhs, OnTheLeft, true, MatrixShape>::run(dst, lhs.nestedExpression(), rhs);
   }
 };
 
 template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>
 struct generic_product_impl<Lhs, Transpose<Rhs>, MatrixShape, TranspositionsShape, ProductTag>
 {
   template<typename Dest>
-  static void evalTo(Dest& dst, const Lhs& lhs, const Transpose<Rhs>& rhs)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Transpose<Rhs>& rhs)
   {
     transposition_matrix_product<Lhs, OnTheRight, true, MatrixShape>::run(dst, rhs.nestedExpression(), lhs);
   }
 };
 
 } // end namespace internal
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Random.h` & `chronogram-0.2.0/include/Eigen/src/Core/Random.h`

 * *Files 13% similar despite different names*

```diff
@@ -124,15 +124,15 @@
   * 
   * Example: \include MatrixBase_setRandom.cpp
   * Output: \verbinclude MatrixBase_setRandom.out
   *
   * \sa class CwiseNullaryOp, setRandom(Index), setRandom(Index,Index)
   */
 template<typename Derived>
-inline Derived& DenseBase<Derived>::setRandom()
+EIGEN_DEVICE_FUNC inline Derived& DenseBase<Derived>::setRandom()
 {
   return *this = Random(rows(), cols());
 }
 
 /** Resizes to the given \a newSize, and sets all coefficients in this expression to random values.
   *
   * Numbers are uniformly spread through their whole definition range for integer types,
@@ -173,10 +173,46 @@
 EIGEN_STRONG_INLINE Derived&
 PlainObjectBase<Derived>::setRandom(Index rows, Index cols)
 {
   resize(rows, cols);
   return setRandom();
 }
 
+/** Resizes to the given size, changing only the number of columns, and sets all
+  * coefficients in this expression to random values. For the parameter of type
+  * NoChange_t, just pass the special value \c NoChange.
+  *
+  * Numbers are uniformly spread through their whole definition range for integer types,
+  * and in the [-1:1] range for floating point scalar types.
+  *
+  * \not_reentrant
+  *
+  * \sa DenseBase::setRandom(), setRandom(Index), setRandom(Index, NoChange_t), class CwiseNullaryOp, DenseBase::Random()
+  */
+template<typename Derived>
+EIGEN_STRONG_INLINE Derived&
+PlainObjectBase<Derived>::setRandom(NoChange_t, Index cols)
+{
+  return setRandom(rows(), cols);
+}
+
+/** Resizes to the given size, changing only the number of rows, and sets all
+  * coefficients in this expression to random values. For the parameter of type
+  * NoChange_t, just pass the special value \c NoChange.
+  *
+  * Numbers are uniformly spread through their whole definition range for integer types,
+  * and in the [-1:1] range for floating point scalar types.
+  *
+  * \not_reentrant
+  *
+  * \sa DenseBase::setRandom(), setRandom(Index), setRandom(NoChange_t, Index), class CwiseNullaryOp, DenseBase::Random()
+  */
+template<typename Derived>
+EIGEN_STRONG_INLINE Derived&
+PlainObjectBase<Derived>::setRandom(Index rows, NoChange_t)
+{
+  return setRandom(rows, cols());
+}
+
 } // end namespace Eigen
 
 #endif // EIGEN_RANDOM_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Redux.h` & `chronogram-0.2.0/include/Eigen/src/Core/Redux.h`

 * *Files 13% similar despite different names*

```diff
@@ -19,450 +19,460 @@
 //  * implement other kind of vectorization
 //  * factorize code
 
 /***************************************************************************
 * Part 1 : the logic deciding a strategy for vectorization and unrolling
 ***************************************************************************/
 
-template<typename Func, typename Derived>
+template<typename Func, typename Evaluator>
 struct redux_traits
 {
 public:
-    typedef typename find_best_packet<typename Derived::Scalar,Derived::SizeAtCompileTime>::type PacketType;
+    typedef typename find_best_packet<typename Evaluator::Scalar,Evaluator::SizeAtCompileTime>::type PacketType;
   enum {
     PacketSize = unpacket_traits<PacketType>::size,
-    InnerMaxSize = int(Derived::IsRowMajor)
-                 ? Derived::MaxColsAtCompileTime
-                 : Derived::MaxRowsAtCompileTime
+    InnerMaxSize = int(Evaluator::IsRowMajor)
+                 ? Evaluator::MaxColsAtCompileTime
+                 : Evaluator::MaxRowsAtCompileTime,
+    OuterMaxSize = int(Evaluator::IsRowMajor)
+                 ? Evaluator::MaxRowsAtCompileTime
+                 : Evaluator::MaxColsAtCompileTime,
+    SliceVectorizedWork = int(InnerMaxSize)==Dynamic ? Dynamic
+                        : int(OuterMaxSize)==Dynamic ? (int(InnerMaxSize)>=int(PacketSize) ? Dynamic : 0)
+                        : (int(InnerMaxSize)/int(PacketSize)) * int(OuterMaxSize)
   };
 
   enum {
-    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)
+    MightVectorize = (int(Evaluator::Flags)&ActualPacketAccessBit)
                   && (functor_traits<Func>::PacketAccess),
-    MayLinearVectorize = bool(MightVectorize) && (int(Derived::Flags)&LinearAccessBit),
-    MaySliceVectorize  = bool(MightVectorize) && int(InnerMaxSize)>=3*PacketSize
+    MayLinearVectorize = bool(MightVectorize) && (int(Evaluator::Flags)&LinearAccessBit),
+    MaySliceVectorize  = bool(MightVectorize) && (int(SliceVectorizedWork)==Dynamic || int(SliceVectorizedWork)>=3)
   };
 
 public:
   enum {
     Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)
               : int(MaySliceVectorize)  ? int(SliceVectorizedTraversal)
                                         : int(DefaultTraversal)
   };
 
 public:
   enum {
-    Cost = Derived::SizeAtCompileTime == Dynamic ? HugeCost
-         : Derived::SizeAtCompileTime * Derived::CoeffReadCost + (Derived::SizeAtCompileTime-1) * functor_traits<Func>::Cost,
+    Cost = Evaluator::SizeAtCompileTime == Dynamic ? HugeCost
+         : int(Evaluator::SizeAtCompileTime) * int(Evaluator::CoeffReadCost) + (Evaluator::SizeAtCompileTime-1) * functor_traits<Func>::Cost,
     UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))
   };
 
 public:
   enum {
     Unrolling = Cost <= UnrollingLimit ? CompleteUnrolling : NoUnrolling
   };
   
 #ifdef EIGEN_DEBUG_ASSIGN
   static void debug()
   {
-    std::cerr << "Xpr: " << typeid(typename Derived::XprType).name() << std::endl;
+    std::cerr << "Xpr: " << typeid(typename Evaluator::XprType).name() << std::endl;
     std::cerr.setf(std::ios::hex, std::ios::basefield);
-    EIGEN_DEBUG_VAR(Derived::Flags)
+    EIGEN_DEBUG_VAR(Evaluator::Flags)
     std::cerr.unsetf(std::ios::hex);
     EIGEN_DEBUG_VAR(InnerMaxSize)
+    EIGEN_DEBUG_VAR(OuterMaxSize)
+    EIGEN_DEBUG_VAR(SliceVectorizedWork)
     EIGEN_DEBUG_VAR(PacketSize)
     EIGEN_DEBUG_VAR(MightVectorize)
     EIGEN_DEBUG_VAR(MayLinearVectorize)
     EIGEN_DEBUG_VAR(MaySliceVectorize)
-    EIGEN_DEBUG_VAR(Traversal)
+    std::cerr << "Traversal" << " = " << Traversal << " (" << demangle_traversal(Traversal) << ")" << std::endl;
     EIGEN_DEBUG_VAR(UnrollingLimit)
-    EIGEN_DEBUG_VAR(Unrolling)
+    std::cerr << "Unrolling" << " = " << Unrolling << " (" << demangle_unrolling(Unrolling) << ")" << std::endl;
     std::cerr << std::endl;
   }
 #endif
 };
 
 /***************************************************************************
 * Part 2 : unrollers
 ***************************************************************************/
 
 /*** no vectorization ***/
 
-template<typename Func, typename Derived, int Start, int Length>
+template<typename Func, typename Evaluator, int Start, int Length>
 struct redux_novec_unroller
 {
   enum {
     HalfLength = Length/2
   };
 
-  typedef typename Derived::Scalar Scalar;
+  typedef typename Evaluator::Scalar Scalar;
 
   EIGEN_DEVICE_FUNC
-  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)
+  static EIGEN_STRONG_INLINE Scalar run(const Evaluator &eval, const Func& func)
   {
-    return func(redux_novec_unroller<Func, Derived, Start, HalfLength>::run(mat,func),
-                redux_novec_unroller<Func, Derived, Start+HalfLength, Length-HalfLength>::run(mat,func));
+    return func(redux_novec_unroller<Func, Evaluator, Start, HalfLength>::run(eval,func),
+                redux_novec_unroller<Func, Evaluator, Start+HalfLength, Length-HalfLength>::run(eval,func));
   }
 };
 
-template<typename Func, typename Derived, int Start>
-struct redux_novec_unroller<Func, Derived, Start, 1>
+template<typename Func, typename Evaluator, int Start>
+struct redux_novec_unroller<Func, Evaluator, Start, 1>
 {
   enum {
-    outer = Start / Derived::InnerSizeAtCompileTime,
-    inner = Start % Derived::InnerSizeAtCompileTime
+    outer = Start / Evaluator::InnerSizeAtCompileTime,
+    inner = Start % Evaluator::InnerSizeAtCompileTime
   };
 
-  typedef typename Derived::Scalar Scalar;
+  typedef typename Evaluator::Scalar Scalar;
 
   EIGEN_DEVICE_FUNC
-  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)
+  static EIGEN_STRONG_INLINE Scalar run(const Evaluator &eval, const Func&)
   {
-    return mat.coeffByOuterInner(outer, inner);
+    return eval.coeffByOuterInner(outer, inner);
   }
 };
 
 // This is actually dead code and will never be called. It is required
 // to prevent false warnings regarding failed inlining though
 // for 0 length run() will never be called at all.
-template<typename Func, typename Derived, int Start>
-struct redux_novec_unroller<Func, Derived, Start, 0>
+template<typename Func, typename Evaluator, int Start>
+struct redux_novec_unroller<Func, Evaluator, Start, 0>
 {
-  typedef typename Derived::Scalar Scalar;
+  typedef typename Evaluator::Scalar Scalar;
   EIGEN_DEVICE_FUNC 
-  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }
+  static EIGEN_STRONG_INLINE Scalar run(const Evaluator&, const Func&) { return Scalar(); }
 };
 
 /*** vectorization ***/
 
-template<typename Func, typename Derived, int Start, int Length>
+template<typename Func, typename Evaluator, int Start, int Length>
 struct redux_vec_unroller
 {
-  enum {
-    PacketSize = redux_traits<Func, Derived>::PacketSize,
-    HalfLength = Length/2
-  };
-
-  typedef typename Derived::Scalar Scalar;
-  typedef typename redux_traits<Func, Derived>::PacketType PacketScalar;
-
-  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)
+  template<typename PacketType>
+  EIGEN_DEVICE_FUNC
+  static EIGEN_STRONG_INLINE PacketType run(const Evaluator &eval, const Func& func)
   {
+    enum {
+      PacketSize = unpacket_traits<PacketType>::size,
+      HalfLength = Length/2
+    };
+
     return func.packetOp(
-            redux_vec_unroller<Func, Derived, Start, HalfLength>::run(mat,func),
-            redux_vec_unroller<Func, Derived, Start+HalfLength, Length-HalfLength>::run(mat,func) );
+            redux_vec_unroller<Func, Evaluator, Start, HalfLength>::template run<PacketType>(eval,func),
+            redux_vec_unroller<Func, Evaluator, Start+HalfLength, Length-HalfLength>::template run<PacketType>(eval,func) );
   }
 };
 
-template<typename Func, typename Derived, int Start>
-struct redux_vec_unroller<Func, Derived, Start, 1>
+template<typename Func, typename Evaluator, int Start>
+struct redux_vec_unroller<Func, Evaluator, Start, 1>
 {
-  enum {
-    index = Start * redux_traits<Func, Derived>::PacketSize,
-    outer = index / int(Derived::InnerSizeAtCompileTime),
-    inner = index % int(Derived::InnerSizeAtCompileTime),
-    alignment = Derived::Alignment
-  };
-
-  typedef typename Derived::Scalar Scalar;
-  typedef typename redux_traits<Func, Derived>::PacketType PacketScalar;
-
-  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)
+  template<typename PacketType>
+  EIGEN_DEVICE_FUNC
+  static EIGEN_STRONG_INLINE PacketType run(const Evaluator &eval, const Func&)
   {
-    return mat.template packetByOuterInner<alignment,PacketScalar>(outer, inner);
+    enum {
+      PacketSize = unpacket_traits<PacketType>::size,
+      index = Start * PacketSize,
+      outer = index / int(Evaluator::InnerSizeAtCompileTime),
+      inner = index % int(Evaluator::InnerSizeAtCompileTime),
+      alignment = Evaluator::Alignment
+    };
+    return eval.template packetByOuterInner<alignment,PacketType>(outer, inner);
   }
 };
 
 /***************************************************************************
 * Part 3 : implementation of all cases
 ***************************************************************************/
 
-template<typename Func, typename Derived,
-         int Traversal = redux_traits<Func, Derived>::Traversal,
-         int Unrolling = redux_traits<Func, Derived>::Unrolling
+template<typename Func, typename Evaluator,
+         int Traversal = redux_traits<Func, Evaluator>::Traversal,
+         int Unrolling = redux_traits<Func, Evaluator>::Unrolling
 >
 struct redux_impl;
 
-template<typename Func, typename Derived>
-struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>
+template<typename Func, typename Evaluator>
+struct redux_impl<Func, Evaluator, DefaultTraversal, NoUnrolling>
 {
-  typedef typename Derived::Scalar Scalar;
-  EIGEN_DEVICE_FUNC
-  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)
+  typedef typename Evaluator::Scalar Scalar;
+
+  template<typename XprType>
+  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE
+  Scalar run(const Evaluator &eval, const Func& func, const XprType& xpr)
   {
-    eigen_assert(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix");
+    eigen_assert(xpr.rows()>0 && xpr.cols()>0 && "you are using an empty matrix");
     Scalar res;
-    res = mat.coeffByOuterInner(0, 0);
-    for(Index i = 1; i < mat.innerSize(); ++i)
-      res = func(res, mat.coeffByOuterInner(0, i));
-    for(Index i = 1; i < mat.outerSize(); ++i)
-      for(Index j = 0; j < mat.innerSize(); ++j)
-        res = func(res, mat.coeffByOuterInner(i, j));
+    res = eval.coeffByOuterInner(0, 0);
+    for(Index i = 1; i < xpr.innerSize(); ++i)
+      res = func(res, eval.coeffByOuterInner(0, i));
+    for(Index i = 1; i < xpr.outerSize(); ++i)
+      for(Index j = 0; j < xpr.innerSize(); ++j)
+        res = func(res, eval.coeffByOuterInner(i, j));
     return res;
   }
 };
 
-template<typename Func, typename Derived>
-struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>
-  : public redux_novec_unroller<Func,Derived, 0, Derived::SizeAtCompileTime>
-{};
+template<typename Func, typename Evaluator>
+struct redux_impl<Func,Evaluator, DefaultTraversal, CompleteUnrolling>
+  : redux_novec_unroller<Func,Evaluator, 0, Evaluator::SizeAtCompileTime>
+{
+  typedef redux_novec_unroller<Func,Evaluator, 0, Evaluator::SizeAtCompileTime> Base;
+  typedef typename Evaluator::Scalar Scalar;
+  template<typename XprType>
+  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE
+  Scalar run(const Evaluator &eval, const Func& func, const XprType& /*xpr*/)
+  {
+    return Base::run(eval,func);
+  }
+};
 
-template<typename Func, typename Derived>
-struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>
+template<typename Func, typename Evaluator>
+struct redux_impl<Func, Evaluator, LinearVectorizedTraversal, NoUnrolling>
 {
-  typedef typename Derived::Scalar Scalar;
-  typedef typename redux_traits<Func, Derived>::PacketType PacketScalar;
+  typedef typename Evaluator::Scalar Scalar;
+  typedef typename redux_traits<Func, Evaluator>::PacketType PacketScalar;
 
-  static Scalar run(const Derived &mat, const Func& func)
+  template<typename XprType>
+  static Scalar run(const Evaluator &eval, const Func& func, const XprType& xpr)
   {
-    const Index size = mat.size();
+    const Index size = xpr.size();
     
-    const Index packetSize = redux_traits<Func, Derived>::PacketSize;
+    const Index packetSize = redux_traits<Func, Evaluator>::PacketSize;
     const int packetAlignment = unpacket_traits<PacketScalar>::alignment;
     enum {
-      alignment0 = (bool(Derived::Flags & DirectAccessBit) && bool(packet_traits<Scalar>::AlignedOnScalar)) ? int(packetAlignment) : int(Unaligned),
-      alignment = EIGEN_PLAIN_ENUM_MAX(alignment0, Derived::Alignment)
+      alignment0 = (bool(Evaluator::Flags & DirectAccessBit) && bool(packet_traits<Scalar>::AlignedOnScalar)) ? int(packetAlignment) : int(Unaligned),
+      alignment = EIGEN_PLAIN_ENUM_MAX(alignment0, Evaluator::Alignment)
     };
-    const Index alignedStart = internal::first_default_aligned(mat.nestedExpression());
+    const Index alignedStart = internal::first_default_aligned(xpr);
     const Index alignedSize2 = ((size-alignedStart)/(2*packetSize))*(2*packetSize);
     const Index alignedSize = ((size-alignedStart)/(packetSize))*(packetSize);
     const Index alignedEnd2 = alignedStart + alignedSize2;
     const Index alignedEnd  = alignedStart + alignedSize;
     Scalar res;
     if(alignedSize)
     {
-      PacketScalar packet_res0 = mat.template packet<alignment,PacketScalar>(alignedStart);
+      PacketScalar packet_res0 = eval.template packet<alignment,PacketScalar>(alignedStart);
       if(alignedSize>packetSize) // we have at least two packets to partly unroll the loop
       {
-        PacketScalar packet_res1 = mat.template packet<alignment,PacketScalar>(alignedStart+packetSize);
+        PacketScalar packet_res1 = eval.template packet<alignment,PacketScalar>(alignedStart+packetSize);
         for(Index index = alignedStart + 2*packetSize; index < alignedEnd2; index += 2*packetSize)
         {
-          packet_res0 = func.packetOp(packet_res0, mat.template packet<alignment,PacketScalar>(index));
-          packet_res1 = func.packetOp(packet_res1, mat.template packet<alignment,PacketScalar>(index+packetSize));
+          packet_res0 = func.packetOp(packet_res0, eval.template packet<alignment,PacketScalar>(index));
+          packet_res1 = func.packetOp(packet_res1, eval.template packet<alignment,PacketScalar>(index+packetSize));
         }
 
         packet_res0 = func.packetOp(packet_res0,packet_res1);
         if(alignedEnd>alignedEnd2)
-          packet_res0 = func.packetOp(packet_res0, mat.template packet<alignment,PacketScalar>(alignedEnd2));
+          packet_res0 = func.packetOp(packet_res0, eval.template packet<alignment,PacketScalar>(alignedEnd2));
       }
       res = func.predux(packet_res0);
 
       for(Index index = 0; index < alignedStart; ++index)
-        res = func(res,mat.coeff(index));
+        res = func(res,eval.coeff(index));
 
       for(Index index = alignedEnd; index < size; ++index)
-        res = func(res,mat.coeff(index));
+        res = func(res,eval.coeff(index));
     }
     else // too small to vectorize anything.
          // since this is dynamic-size hence inefficient anyway for such small sizes, don't try to optimize.
     {
-      res = mat.coeff(0);
+      res = eval.coeff(0);
       for(Index index = 1; index < size; ++index)
-        res = func(res,mat.coeff(index));
+        res = func(res,eval.coeff(index));
     }
 
     return res;
   }
 };
 
 // NOTE: for SliceVectorizedTraversal we simply bypass unrolling
-template<typename Func, typename Derived, int Unrolling>
-struct redux_impl<Func, Derived, SliceVectorizedTraversal, Unrolling>
+template<typename Func, typename Evaluator, int Unrolling>
+struct redux_impl<Func, Evaluator, SliceVectorizedTraversal, Unrolling>
 {
-  typedef typename Derived::Scalar Scalar;
-  typedef typename redux_traits<Func, Derived>::PacketType PacketType;
+  typedef typename Evaluator::Scalar Scalar;
+  typedef typename redux_traits<Func, Evaluator>::PacketType PacketType;
 
-  EIGEN_DEVICE_FUNC static Scalar run(const Derived &mat, const Func& func)
+  template<typename XprType>
+  EIGEN_DEVICE_FUNC static Scalar run(const Evaluator &eval, const Func& func, const XprType& xpr)
   {
-    eigen_assert(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix");
-    const Index innerSize = mat.innerSize();
-    const Index outerSize = mat.outerSize();
+    eigen_assert(xpr.rows()>0 && xpr.cols()>0 && "you are using an empty matrix");
+    const Index innerSize = xpr.innerSize();
+    const Index outerSize = xpr.outerSize();
     enum {
-      packetSize = redux_traits<Func, Derived>::PacketSize
+      packetSize = redux_traits<Func, Evaluator>::PacketSize
     };
     const Index packetedInnerSize = ((innerSize)/packetSize)*packetSize;
     Scalar res;
     if(packetedInnerSize)
     {
-      PacketType packet_res = mat.template packet<Unaligned,PacketType>(0,0);
+      PacketType packet_res = eval.template packet<Unaligned,PacketType>(0,0);
       for(Index j=0; j<outerSize; ++j)
         for(Index i=(j==0?packetSize:0); i<packetedInnerSize; i+=Index(packetSize))
-          packet_res = func.packetOp(packet_res, mat.template packetByOuterInner<Unaligned,PacketType>(j,i));
+          packet_res = func.packetOp(packet_res, eval.template packetByOuterInner<Unaligned,PacketType>(j,i));
 
       res = func.predux(packet_res);
       for(Index j=0; j<outerSize; ++j)
         for(Index i=packetedInnerSize; i<innerSize; ++i)
-          res = func(res, mat.coeffByOuterInner(j,i));
+          res = func(res, eval.coeffByOuterInner(j,i));
     }
     else // too small to vectorize anything.
          // since this is dynamic-size hence inefficient anyway for such small sizes, don't try to optimize.
     {
-      res = redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>::run(mat, func);
+      res = redux_impl<Func, Evaluator, DefaultTraversal, NoUnrolling>::run(eval, func, xpr);
     }
 
     return res;
   }
 };
 
-template<typename Func, typename Derived>
-struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>
+template<typename Func, typename Evaluator>
+struct redux_impl<Func, Evaluator, LinearVectorizedTraversal, CompleteUnrolling>
 {
-  typedef typename Derived::Scalar Scalar;
+  typedef typename Evaluator::Scalar Scalar;
 
-  typedef typename redux_traits<Func, Derived>::PacketType PacketScalar;
+  typedef typename redux_traits<Func, Evaluator>::PacketType PacketType;
   enum {
-    PacketSize = redux_traits<Func, Derived>::PacketSize,
-    Size = Derived::SizeAtCompileTime,
-    VectorizedSize = (Size / PacketSize) * PacketSize
+    PacketSize = redux_traits<Func, Evaluator>::PacketSize,
+    Size = Evaluator::SizeAtCompileTime,
+    VectorizedSize = (int(Size) / int(PacketSize)) * int(PacketSize)
   };
-  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)
+
+  template<typename XprType>
+  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE
+  Scalar run(const Evaluator &eval, const Func& func, const XprType &xpr)
   {
-    eigen_assert(mat.rows()>0 && mat.cols()>0 && "you are using an empty matrix");
+    EIGEN_ONLY_USED_FOR_DEBUG(xpr)
+    eigen_assert(xpr.rows()>0 && xpr.cols()>0 && "you are using an empty matrix");
     if (VectorizedSize > 0) {
-      Scalar res = func.predux(redux_vec_unroller<Func, Derived, 0, Size / PacketSize>::run(mat,func));
+      Scalar res = func.predux(redux_vec_unroller<Func, Evaluator, 0, Size / PacketSize>::template run<PacketType>(eval,func));
       if (VectorizedSize != Size)
-        res = func(res,redux_novec_unroller<Func, Derived, VectorizedSize, Size-VectorizedSize>::run(mat,func));
+        res = func(res,redux_novec_unroller<Func, Evaluator, VectorizedSize, Size-VectorizedSize>::run(eval,func));
       return res;
     }
     else {
-      return redux_novec_unroller<Func, Derived, 0, Size>::run(mat,func);
+      return redux_novec_unroller<Func, Evaluator, 0, Size>::run(eval,func);
     }
   }
 };
 
 // evaluator adaptor
 template<typename _XprType>
-class redux_evaluator
+class redux_evaluator : public internal::evaluator<_XprType>
 {
+  typedef internal::evaluator<_XprType> Base;
 public:
   typedef _XprType XprType;
-  EIGEN_DEVICE_FUNC explicit redux_evaluator(const XprType &xpr) : m_evaluator(xpr), m_xpr(xpr) {}
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  explicit redux_evaluator(const XprType &xpr) : Base(xpr) {}
   
   typedef typename XprType::Scalar Scalar;
   typedef typename XprType::CoeffReturnType CoeffReturnType;
   typedef typename XprType::PacketScalar PacketScalar;
-  typedef typename XprType::PacketReturnType PacketReturnType;
   
   enum {
     MaxRowsAtCompileTime = XprType::MaxRowsAtCompileTime,
     MaxColsAtCompileTime = XprType::MaxColsAtCompileTime,
     // TODO we should not remove DirectAccessBit and rather find an elegant way to query the alignment offset at runtime from the evaluator
-    Flags = evaluator<XprType>::Flags & ~DirectAccessBit,
+    Flags = Base::Flags & ~DirectAccessBit,
     IsRowMajor = XprType::IsRowMajor,
     SizeAtCompileTime = XprType::SizeAtCompileTime,
-    InnerSizeAtCompileTime = XprType::InnerSizeAtCompileTime,
-    CoeffReadCost = evaluator<XprType>::CoeffReadCost,
-    Alignment = evaluator<XprType>::Alignment
+    InnerSizeAtCompileTime = XprType::InnerSizeAtCompileTime
   };
   
-  EIGEN_DEVICE_FUNC Index rows() const { return m_xpr.rows(); }
-  EIGEN_DEVICE_FUNC Index cols() const { return m_xpr.cols(); }
-  EIGEN_DEVICE_FUNC Index size() const { return m_xpr.size(); }
-  EIGEN_DEVICE_FUNC Index innerSize() const { return m_xpr.innerSize(); }
-  EIGEN_DEVICE_FUNC Index outerSize() const { return m_xpr.outerSize(); }
-
-  EIGEN_DEVICE_FUNC
-  CoeffReturnType coeff(Index row, Index col) const
-  { return m_evaluator.coeff(row, col); }
-
-  EIGEN_DEVICE_FUNC
-  CoeffReturnType coeff(Index index) const
-  { return m_evaluator.coeff(index); }
-
-  template<int LoadMode, typename PacketType>
-  PacketType packet(Index row, Index col) const
-  { return m_evaluator.template packet<LoadMode,PacketType>(row, col); }
-
-  template<int LoadMode, typename PacketType>
-  PacketType packet(Index index) const
-  { return m_evaluator.template packet<LoadMode,PacketType>(index); }
-  
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   CoeffReturnType coeffByOuterInner(Index outer, Index inner) const
-  { return m_evaluator.coeff(IsRowMajor ? outer : inner, IsRowMajor ? inner : outer); }
+  { return Base::coeff(IsRowMajor ? outer : inner, IsRowMajor ? inner : outer); }
   
   template<int LoadMode, typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
   PacketType packetByOuterInner(Index outer, Index inner) const
-  { return m_evaluator.template packet<LoadMode,PacketType>(IsRowMajor ? outer : inner, IsRowMajor ? inner : outer); }
+  { return Base::template packet<LoadMode,PacketType>(IsRowMajor ? outer : inner, IsRowMajor ? inner : outer); }
   
-  const XprType & nestedExpression() const { return m_xpr; }
-  
-protected:
-  internal::evaluator<XprType> m_evaluator;
-  const XprType &m_xpr;
 };
 
 } // end namespace internal
 
 /***************************************************************************
 * Part 4 : public API
 ***************************************************************************/
 
 
 /** \returns the result of a full redux operation on the whole matrix or vector using \a func
   *
   * The template parameter \a BinaryOp is the type of the functor \a func which must be
   * an associative operator. Both current C++98 and C++11 functor styles are handled.
   *
+  * \warning the matrix must be not empty, otherwise an assertion is triggered.
+  *
   * \sa DenseBase::sum(), DenseBase::minCoeff(), DenseBase::maxCoeff(), MatrixBase::colwise(), MatrixBase::rowwise()
   */
 template<typename Derived>
 template<typename Func>
-EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
 DenseBase<Derived>::redux(const Func& func) const
 {
   eigen_assert(this->rows()>0 && this->cols()>0 && "you are using an empty matrix");
 
   typedef typename internal::redux_evaluator<Derived> ThisEvaluator;
   ThisEvaluator thisEval(derived());
-  
-  return internal::redux_impl<Func, ThisEvaluator>::run(thisEval, func);
+
+  // The initial expression is passed to the reducer as an additional argument instead of
+  // passing it as a member of redux_evaluator to help  
+  return internal::redux_impl<Func, ThisEvaluator>::run(thisEval, func, derived());
 }
 
 /** \returns the minimum of all coefficients of \c *this.
-  * \warning the result is undefined if \c *this contains NaN.
+  * In case \c *this contains NaN, NaNPropagation determines the behavior:
+  *   NaNPropagation == PropagateFast : undefined
+  *   NaNPropagation == PropagateNaN : result is NaN
+  *   NaNPropagation == PropagateNumbers : result is minimum of elements that are not NaN
+  * \warning the matrix must be not empty, otherwise an assertion is triggered.
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
+template<int NaNPropagation>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
 DenseBase<Derived>::minCoeff() const
 {
-  return derived().redux(Eigen::internal::scalar_min_op<Scalar,Scalar>());
+  return derived().redux(Eigen::internal::scalar_min_op<Scalar,Scalar, NaNPropagation>());
 }
 
-/** \returns the maximum of all coefficients of \c *this.
-  * \warning the result is undefined if \c *this contains NaN.
+/** \returns the maximum of all coefficients of \c *this. 
+  * In case \c *this contains NaN, NaNPropagation determines the behavior:
+  *   NaNPropagation == PropagateFast : undefined
+  *   NaNPropagation == PropagateNaN : result is NaN
+  *   NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN
+  * \warning the matrix must be not empty, otherwise an assertion is triggered.
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
+template<int NaNPropagation>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
 DenseBase<Derived>::maxCoeff() const
 {
-  return derived().redux(Eigen::internal::scalar_max_op<Scalar,Scalar>());
+  return derived().redux(Eigen::internal::scalar_max_op<Scalar,Scalar, NaNPropagation>());
 }
 
 /** \returns the sum of all coefficients of \c *this
   *
   * If \c *this is empty, then the value 0 is returned.
   *
   * \sa trace(), prod(), mean()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
 DenseBase<Derived>::sum() const
 {
   if(SizeAtCompileTime==0 || (SizeAtCompileTime==Dynamic && size()==0))
     return Scalar(0);
   return derived().redux(Eigen::internal::scalar_sum_op<Scalar,Scalar>());
 }
 
 /** \returns the mean of all coefficients of *this
 *
 * \sa trace(), prod(), sum()
 */
 template<typename Derived>
-EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
 DenseBase<Derived>::mean() const
 {
 #ifdef __INTEL_COMPILER
   #pragma warning push
   #pragma warning ( disable : 2259 )
 #endif
   return Scalar(derived().redux(Eigen::internal::scalar_sum_op<Scalar,Scalar>())) / Scalar(this->size());
@@ -475,30 +485,30 @@
   *
   * Example: \include MatrixBase_prod.cpp
   * Output: \verbinclude MatrixBase_prod.out
   *
   * \sa sum(), mean(), trace()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
 DenseBase<Derived>::prod() const
 {
   if(SizeAtCompileTime==0 || (SizeAtCompileTime==Dynamic && size()==0))
     return Scalar(1);
   return derived().redux(Eigen::internal::scalar_product_op<Scalar>());
 }
 
 /** \returns the trace of \c *this, i.e. the sum of the coefficients on the main diagonal.
   *
   * \c *this can be any matrix, not necessarily square.
   *
   * \sa diagonal(), sum()
   */
 template<typename Derived>
-EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar
 MatrixBase<Derived>::trace() const
 {
   return derived().diagonal().sum();
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Ref.h` & `chronogram-0.2.0/include/Eigen/src/Core/Ref.h`

 * *Files 22% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_REF_H
 #define EIGEN_REF_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 
 template<typename _PlainObjectType, int _Options, typename _StrideType>
 struct traits<Ref<_PlainObjectType, _Options, _StrideType> >
   : public traits<Map<_PlainObjectType, _Options, _StrideType> >
 {
@@ -24,34 +24,35 @@
     Options = _Options,
     Flags = traits<Map<_PlainObjectType, _Options, _StrideType> >::Flags | NestByRefBit,
     Alignment = traits<Map<_PlainObjectType, _Options, _StrideType> >::Alignment
   };
 
   template<typename Derived> struct match {
     enum {
+      IsVectorAtCompileTime = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime,
       HasDirectAccess = internal::has_direct_access<Derived>::ret,
-      StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),
+      StorageOrderMatch = IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),
       InnerStrideMatch = int(StrideType::InnerStrideAtCompileTime)==int(Dynamic)
                       || int(StrideType::InnerStrideAtCompileTime)==int(Derived::InnerStrideAtCompileTime)
                       || (int(StrideType::InnerStrideAtCompileTime)==0 && int(Derived::InnerStrideAtCompileTime)==1),
-      OuterStrideMatch = Derived::IsVectorAtCompileTime
+      OuterStrideMatch = IsVectorAtCompileTime
                       || int(StrideType::OuterStrideAtCompileTime)==int(Dynamic) || int(StrideType::OuterStrideAtCompileTime)==int(Derived::OuterStrideAtCompileTime),
       // NOTE, this indirection of evaluator<Derived>::Alignment is needed
       // to workaround a very strange bug in MSVC related to the instantiation
       // of has_*ary_operator in evaluator<CwiseNullaryOp>.
       // This line is surprisingly very sensitive. For instance, simply adding parenthesis
       // as "DerivedAlignment = (int(evaluator<Derived>::Alignment))," will make MSVC fail...
       DerivedAlignment = int(evaluator<Derived>::Alignment),
       AlignmentMatch = (int(traits<PlainObjectType>::Alignment)==int(Unaligned)) || (DerivedAlignment >= int(Alignment)), // FIXME the first condition is not very clear, it should be replaced by the required alignment
       ScalarTypeMatch = internal::is_same<typename PlainObjectType::Scalar, typename Derived::Scalar>::value,
       MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && AlignmentMatch && ScalarTypeMatch
     };
     typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;
   };
-  
+
 };
 
 template<typename Derived>
 struct traits<RefBase<Derived> > : public traits<Derived> {};
 
 }
 
@@ -62,63 +63,149 @@
   typedef typename internal::traits<Derived>::StrideType StrideType;
 
 public:
 
   typedef MapBase<Derived> Base;
   EIGEN_DENSE_PUBLIC_INTERFACE(RefBase)
 
-  EIGEN_DEVICE_FUNC inline Index innerStride() const
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR inline Index innerStride() const
   {
     return StrideType::InnerStrideAtCompileTime != 0 ? m_stride.inner() : 1;
   }
 
-  EIGEN_DEVICE_FUNC inline Index outerStride() const
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR inline Index outerStride() const
   {
     return StrideType::OuterStrideAtCompileTime != 0 ? m_stride.outer()
          : IsVectorAtCompileTime ? this->size()
          : int(Flags)&RowMajorBit ? this->cols()
          : this->rows();
   }
 
   EIGEN_DEVICE_FUNC RefBase()
     : Base(0,RowsAtCompileTime==Dynamic?0:RowsAtCompileTime,ColsAtCompileTime==Dynamic?0:ColsAtCompileTime),
       // Stride<> does not allow default ctor for Dynamic strides, so let' initialize it with dummy values:
       m_stride(StrideType::OuterStrideAtCompileTime==Dynamic?0:StrideType::OuterStrideAtCompileTime,
                StrideType::InnerStrideAtCompileTime==Dynamic?0:StrideType::InnerStrideAtCompileTime)
   {}
-  
+
   EIGEN_INHERIT_ASSIGNMENT_OPERATORS(RefBase)
 
 protected:
 
   typedef Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase;
 
+  // Resolves inner stride if default 0.
+  static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index resolveInnerStride(Index inner) {
+    return inner == 0 ? 1 : inner;
+  }
+
+  // Resolves outer stride if default 0.
+  static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index resolveOuterStride(Index inner, Index outer, Index rows, Index cols, bool isVectorAtCompileTime, bool isRowMajor) {
+    return outer == 0 ? isVectorAtCompileTime ? inner * rows * cols : isRowMajor ? inner * cols : inner * rows : outer;
+  }
+
+  // Returns true if construction is valid, false if there is a stride mismatch,
+  // and fails if there is a size mismatch.
   template<typename Expression>
-  EIGEN_DEVICE_FUNC void construct(Expression& expr)
+  EIGEN_DEVICE_FUNC bool construct(Expression& expr)
   {
-    EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(PlainObjectType,Expression);
-
+    // Check matrix sizes.  If this is a compile-time vector, we do allow
+    // implicitly transposing.
+    EIGEN_STATIC_ASSERT(
+      EIGEN_PREDICATE_SAME_MATRIX_SIZE(PlainObjectType, Expression)
+      // If it is a vector, the transpose sizes might match.
+      || ( PlainObjectType::IsVectorAtCompileTime
+            && ((int(PlainObjectType::RowsAtCompileTime)==Eigen::Dynamic
+              || int(Expression::ColsAtCompileTime)==Eigen::Dynamic
+              || int(PlainObjectType::RowsAtCompileTime)==int(Expression::ColsAtCompileTime))
+            &&  (int(PlainObjectType::ColsAtCompileTime)==Eigen::Dynamic
+              || int(Expression::RowsAtCompileTime)==Eigen::Dynamic
+              || int(PlainObjectType::ColsAtCompileTime)==int(Expression::RowsAtCompileTime)))),
+      YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES
+    )
+
+    // Determine runtime rows and columns.
+    Index rows = expr.rows();
+    Index cols = expr.cols();
     if(PlainObjectType::RowsAtCompileTime==1)
     {
       eigen_assert(expr.rows()==1 || expr.cols()==1);
-      ::new (static_cast<Base*>(this)) Base(expr.data(), 1, expr.size());
+      rows = 1;
+      cols = expr.size();
     }
     else if(PlainObjectType::ColsAtCompileTime==1)
     {
       eigen_assert(expr.rows()==1 || expr.cols()==1);
-      ::new (static_cast<Base*>(this)) Base(expr.data(), expr.size(), 1);
+      rows = expr.size();
+      cols = 1;
+    }
+    // Verify that the sizes are valid.
+    eigen_assert(
+      (PlainObjectType::RowsAtCompileTime == Dynamic) || (PlainObjectType::RowsAtCompileTime == rows));
+    eigen_assert(
+      (PlainObjectType::ColsAtCompileTime == Dynamic) || (PlainObjectType::ColsAtCompileTime == cols));
+
+
+    // If this is a vector, we might be transposing, which means that stride should swap.
+    const bool transpose = PlainObjectType::IsVectorAtCompileTime && (rows != expr.rows());
+    // If the storage format differs, we also need to swap the stride.
+    const bool row_major = ((PlainObjectType::Flags)&RowMajorBit) != 0;
+    const bool expr_row_major = (Expression::Flags&RowMajorBit) != 0;
+    const bool storage_differs =  (row_major != expr_row_major);
+
+    const bool swap_stride = (transpose != storage_differs);
+
+    // Determine expr's actual strides, resolving any defaults if zero.
+    const Index expr_inner_actual = resolveInnerStride(expr.innerStride());
+    const Index expr_outer_actual = resolveOuterStride(expr_inner_actual,
+                                                       expr.outerStride(),
+                                                       expr.rows(),
+                                                       expr.cols(),
+                                                       Expression::IsVectorAtCompileTime != 0,
+                                                       expr_row_major);
+
+    // If this is a column-major row vector or row-major column vector, the inner-stride
+    // is arbitrary, so set it to either the compile-time inner stride or 1.
+    const bool row_vector = (rows == 1);
+    const bool col_vector = (cols == 1);
+    const Index inner_stride =
+        ( (!row_major && row_vector) || (row_major && col_vector) ) ?
+            ( StrideType::InnerStrideAtCompileTime > 0 ? Index(StrideType::InnerStrideAtCompileTime) : 1)
+            : swap_stride ? expr_outer_actual : expr_inner_actual;
+
+    // If this is a column-major column vector or row-major row vector, the outer-stride
+    // is arbitrary, so set it to either the compile-time outer stride or vector size.
+    const Index outer_stride =
+      ( (!row_major && col_vector) || (row_major && row_vector) ) ?
+          ( StrideType::OuterStrideAtCompileTime > 0 ? Index(StrideType::OuterStrideAtCompileTime) : rows * cols * inner_stride)
+          : swap_stride ? expr_inner_actual : expr_outer_actual;
+
+    // Check if given inner/outer strides are compatible with compile-time strides.
+    const bool inner_valid = (StrideType::InnerStrideAtCompileTime == Dynamic)
+        || (resolveInnerStride(Index(StrideType::InnerStrideAtCompileTime)) == inner_stride);
+    if (!inner_valid) {
+      return false;
     }
-    else
-      ::new (static_cast<Base*>(this)) Base(expr.data(), expr.rows(), expr.cols());
-    
-    if(Expression::IsVectorAtCompileTime && (!PlainObjectType::IsVectorAtCompileTime) && ((Expression::Flags&RowMajorBit)!=(PlainObjectType::Flags&RowMajorBit)))
-      ::new (&m_stride) StrideBase(expr.innerStride(), StrideType::InnerStrideAtCompileTime==0?0:1);
-    else
-      ::new (&m_stride) StrideBase(StrideType::OuterStrideAtCompileTime==0?0:expr.outerStride(),
-                                   StrideType::InnerStrideAtCompileTime==0?0:expr.innerStride());    
+
+    const bool outer_valid = (StrideType::OuterStrideAtCompileTime == Dynamic)
+        || (resolveOuterStride(
+              inner_stride,
+              Index(StrideType::OuterStrideAtCompileTime),
+              rows, cols, PlainObjectType::IsVectorAtCompileTime != 0,
+              row_major)
+            == outer_stride);
+    if (!outer_valid) {
+      return false;
+    }
+
+    ::new (static_cast<Base*>(this)) Base(expr.data(), rows, cols);
+    ::new (&m_stride) StrideBase(
+      (StrideType::OuterStrideAtCompileTime == 0) ? 0 : outer_stride,
+      (StrideType::InnerStrideAtCompileTime == 0) ? 0 : inner_stride );
+    return true;
   }
 
   StrideBase m_stride;
 };
 
 /** \class Ref
   * \ingroup Core_Module
@@ -182,14 +269,16 @@
   * template<typename TypeOfA> void foo_impl(const TypeOfA& A) {
   *     ... // crazy code goes here
   * }
   * void foo(const Ref<MatrixXf>& A) { foo_impl(A); }
   * void foo(const Ref<MatrixXf,0,Stride<> >& A) { foo_impl(A); }
   * \endcode
   *
+  * See also the following stackoverflow questions for further references:
+  *  - <a href="http://stackoverflow.com/questions/21132538/correct-usage-of-the-eigenref-class">Correct usage of the Eigen::Ref<> class</a>
   *
   * \sa PlainObjectBase::Map(), \ref TopicStorageOrders
   */
 template<typename PlainObjectType, int Options, typename StrideType> class Ref
   : public RefBase<Ref<PlainObjectType, Options, StrideType> >
 {
   private:
@@ -205,29 +294,35 @@
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename Derived>
     EIGEN_DEVICE_FUNC inline Ref(PlainObjectBase<Derived>& expr,
                                  typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
     {
       EIGEN_STATIC_ASSERT(bool(Traits::template match<Derived>::MatchAtCompileTime), STORAGE_LAYOUT_DOES_NOT_MATCH);
-      Base::construct(expr.derived());
+      // Construction must pass since we will not create temprary storage in the non-const case.
+      const bool success = Base::construct(expr.derived());
+      EIGEN_UNUSED_VARIABLE(success)
+      eigen_assert(success);
     }
     template<typename Derived>
     EIGEN_DEVICE_FUNC inline Ref(const DenseBase<Derived>& expr,
                                  typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)
     #else
     /** Implicit constructor from any dense expression */
     template<typename Derived>
     inline Ref(DenseBase<Derived>& expr)
     #endif
     {
       EIGEN_STATIC_ASSERT(bool(internal::is_lvalue<Derived>::value), THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY);
       EIGEN_STATIC_ASSERT(bool(Traits::template match<Derived>::MatchAtCompileTime), STORAGE_LAYOUT_DOES_NOT_MATCH);
       EIGEN_STATIC_ASSERT(!Derived::IsPlainObjectBase,THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY);
-      Base::construct(expr.const_cast_derived());
+      // Construction must pass since we will not create temporary storage in the non-const case.
+      const bool success = Base::construct(expr.const_cast_derived());
+      EIGEN_UNUSED_VARIABLE(success)
+      eigen_assert(success);
     }
 
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Ref)
 
 };
 
 // this is the const ref version
@@ -260,15 +355,18 @@
     }
 
   protected:
 
     template<typename Expression>
     EIGEN_DEVICE_FUNC void construct(const Expression& expr,internal::true_type)
     {
-      Base::construct(expr);
+      // Check if we can use the underlying expr's storage directly, otherwise call the copy version.
+      if (!Base::construct(expr)) {
+        construct(expr, internal::false_type());
+      }
     }
 
     template<typename Expression>
     EIGEN_DEVICE_FUNC void construct(const Expression& expr, internal::false_type)
     {
       internal::call_assignment_no_alias(m_object,expr,internal::assign_op<Scalar,Scalar>());
       Base::construct(m_object);
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Replicate.h` & `chronogram-0.2.0/include/Eigen/src/Core/Replicate.h`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_REPLICATE_H
 #define EIGEN_REPLICATE_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 template<typename MatrixType,int RowFactor,int ColFactor>
 struct traits<Replicate<MatrixType,RowFactor,ColFactor> >
  : traits<MatrixType>
 {
   typedef typename MatrixType::Scalar Scalar;
@@ -31,15 +31,15 @@
                       : ColFactor * MatrixType::ColsAtCompileTime,
    //FIXME we don't propagate the max sizes !!!
     MaxRowsAtCompileTime = RowsAtCompileTime,
     MaxColsAtCompileTime = ColsAtCompileTime,
     IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1
                : MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1 ? 0
                : (MatrixType::Flags & RowMajorBit) ? 1 : 0,
-    
+
     // FIXME enable DirectAccess with negative strides?
     Flags = IsRowMajor ? RowMajorBit : 0
   };
 };
 }
 
 /**
@@ -84,23 +84,23 @@
     inline Replicate(const OriginalMatrixType& matrix, Index rowFactor, Index colFactor)
       : m_matrix(matrix), m_rowFactor(rowFactor), m_colFactor(colFactor)
     {
       EIGEN_STATIC_ASSERT((internal::is_same<typename internal::remove_const<MatrixType>::type,OriginalMatrixType>::value),
                           THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE)
     }
 
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }
 
     EIGEN_DEVICE_FUNC
     const _MatrixTypeNested& nestedExpression() const
-    { 
-      return m_matrix; 
+    {
+      return m_matrix;
     }
 
   protected:
     MatrixTypeNested m_matrix;
     const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;
     const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;
 };
@@ -111,30 +111,30 @@
   * Example: \include MatrixBase_replicate.cpp
   * Output: \verbinclude MatrixBase_replicate.out
   *
   * \sa VectorwiseOp::replicate(), DenseBase::replicate(Index,Index), class Replicate
   */
 template<typename Derived>
 template<int RowFactor, int ColFactor>
-const Replicate<Derived,RowFactor,ColFactor>
+EIGEN_DEVICE_FUNC const Replicate<Derived,RowFactor,ColFactor>
 DenseBase<Derived>::replicate() const
 {
   return Replicate<Derived,RowFactor,ColFactor>(derived());
 }
 
 /**
   * \return an expression of the replication of each column (or row) of \c *this
   *
   * Example: \include DirectionWise_replicate_int.cpp
   * Output: \verbinclude DirectionWise_replicate_int.out
   *
   * \sa VectorwiseOp::replicate(), DenseBase::replicate(), class Replicate
   */
 template<typename ExpressionType, int Direction>
-const typename VectorwiseOp<ExpressionType,Direction>::ReplicateReturnType
+EIGEN_DEVICE_FUNC const typename VectorwiseOp<ExpressionType,Direction>::ReplicateReturnType
 VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const
 {
   return typename VectorwiseOp<ExpressionType,Direction>::ReplicateReturnType
           (_expression(),Direction==Vertical?factor:1,Direction==Horizontal?factor:1);
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/ReturnByValue.h` & `chronogram-0.2.0/include/Eigen/src/Core/ReturnByValue.h`

 * *Files 2% similar despite different names*

```diff
@@ -56,16 +56,18 @@
     typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;
     EIGEN_DENSE_PUBLIC_INTERFACE(ReturnByValue)
 
     template<typename Dest>
     EIGEN_DEVICE_FUNC
     inline void evalTo(Dest& dst) const
     { static_cast<const Derived*>(this)->evalTo(dst); }
-    EIGEN_DEVICE_FUNC inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }
-    EIGEN_DEVICE_FUNC inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return static_cast<const Derived*>(this)->rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return static_cast<const Derived*>(this)->cols(); }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 #define Unusable YOU_ARE_TRYING_TO_ACCESS_A_SINGLE_COEFFICIENT_IN_A_SPECIAL_EXPRESSION_WHERE_THAT_IS_NOT_ALLOWED_BECAUSE_THAT_WOULD_BE_INEFFICIENT
     class Unusable{
       Unusable(const Unusable&) {}
       Unusable& operator=(const Unusable&) {return *this;}
     };
@@ -75,34 +77,34 @@
     Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }
 #undef Unusable
 #endif
 };
 
 template<typename Derived>
 template<typename OtherDerived>
-Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)
+EIGEN_DEVICE_FUNC Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)
 {
   other.evalTo(derived());
   return derived();
 }
 
 namespace internal {
 
 // Expression is evaluated in a temporary; default implementation of Assignment is bypassed so that
 // when a ReturnByValue expression is assigned, the evaluator is not constructed.
 // TODO: Finalize port to new regime; ReturnByValue should not exist in the expression world
-  
+
 template<typename Derived>
 struct evaluator<ReturnByValue<Derived> >
   : public evaluator<typename internal::traits<Derived>::ReturnType>
 {
   typedef ReturnByValue<Derived> XprType;
   typedef typename internal::traits<Derived>::ReturnType PlainObject;
   typedef evaluator<PlainObject> Base;
-  
+
   EIGEN_DEVICE_FUNC explicit evaluator(const XprType& xpr)
     : m_result(xpr.rows(), xpr.cols())
   {
     ::new (static_cast<Base*>(this)) Base(m_result);
     xpr.evalTo(m_result);
   }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Reverse.h` & `chronogram-0.2.0/include/Eigen/src/Core/Reverse.h`

 * *Files 8% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_REVERSE_H
 #define EIGEN_REVERSE_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 
 template<typename MatrixType, int Direction>
 struct traits<Reverse<MatrixType, Direction> >
  : traits<MatrixType>
 {
@@ -40,15 +40,15 @@
 };
 
 template<typename PacketType> struct reverse_packet_cond<PacketType,false>
 {
   static inline PacketType run(const PacketType& x) { return x; }
 };
 
-} // end namespace internal 
+} // end namespace internal
 
 /** \class Reverse
   * \ingroup Core_Module
   *
   * \brief Expression of the reverse of a vector or matrix
   *
   * \tparam MatrixType the type of the object of which we are taking the reverse
@@ -85,24 +85,26 @@
     typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;
   public:
 
     EIGEN_DEVICE_FUNC explicit inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }
 
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Reverse)
 
-    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.rows(); }
-    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
 
     EIGEN_DEVICE_FUNC inline Index innerStride() const
     {
       return -m_matrix.innerStride();
     }
 
     EIGEN_DEVICE_FUNC const typename internal::remove_all<typename MatrixType::Nested>::type&
-    nestedExpression() const 
+    nestedExpression() const
     {
       return m_matrix;
     }
 
   protected:
     typename MatrixType::Nested m_matrix;
 };
@@ -110,15 +112,15 @@
 /** \returns an expression of the reverse of *this.
   *
   * Example: \include MatrixBase_reverse.cpp
   * Output: \verbinclude MatrixBase_reverse.out
   *
   */
 template<typename Derived>
-inline typename DenseBase<Derived>::ReverseReturnType
+EIGEN_DEVICE_FUNC inline typename DenseBase<Derived>::ReverseReturnType
 DenseBase<Derived>::reverse()
 {
   return ReverseReturnType(derived());
 }
 
 
 //reverse const overload moved DenseBase.h due to a CUDA compiler bug
@@ -132,15 +134,15 @@
   *  - less error prone: doing the same operation with .reverse() requires special care:
   *    \code m = m.reverse().eval(); \endcode
   *  - this API enables reverse operations without the need for a temporary
   *  - it allows future optimizations (cache friendliness, etc.)
   *
   * \sa VectorwiseOp::reverseInPlace(), reverse() */
 template<typename Derived>
-inline void DenseBase<Derived>::reverseInPlace()
+EIGEN_DEVICE_FUNC inline void DenseBase<Derived>::reverseInPlace()
 {
   if(cols()>rows())
   {
     Index half = cols()/2;
     leftCols(half).swap(rightCols(half).reverse());
     if((cols()%2)==1)
     {
@@ -157,37 +159,41 @@
       Index half2 = cols()/2;
       row(half).head(half2).swap(row(half).tail(half2).reverse());
     }
   }
 }
 
 namespace internal {
-  
+
 template<int Direction>
 struct vectorwise_reverse_inplace_impl;
 
 template<>
 struct vectorwise_reverse_inplace_impl<Vertical>
 {
   template<typename ExpressionType>
   static void run(ExpressionType &xpr)
   {
+    const int HalfAtCompileTime = ExpressionType::RowsAtCompileTime==Dynamic?Dynamic:ExpressionType::RowsAtCompileTime/2;
     Index half = xpr.rows()/2;
-    xpr.topRows(half).swap(xpr.bottomRows(half).colwise().reverse());
+    xpr.topRows(fix<HalfAtCompileTime>(half))
+       .swap(xpr.bottomRows(fix<HalfAtCompileTime>(half)).colwise().reverse());
   }
 };
 
 template<>
 struct vectorwise_reverse_inplace_impl<Horizontal>
 {
   template<typename ExpressionType>
   static void run(ExpressionType &xpr)
   {
+    const int HalfAtCompileTime = ExpressionType::ColsAtCompileTime==Dynamic?Dynamic:ExpressionType::ColsAtCompileTime/2;
     Index half = xpr.cols()/2;
-    xpr.leftCols(half).swap(xpr.rightCols(half).rowwise().reverse());
+    xpr.leftCols(fix<HalfAtCompileTime>(half))
+       .swap(xpr.rightCols(fix<HalfAtCompileTime>(half)).rowwise().reverse());
   }
 };
 
 } // end namespace internal
 
 /** This is the "in place" version of VectorwiseOp::reverse: it reverses each column or row of \c *this.
   *
@@ -197,15 +203,15 @@
   * the following additional benefits:
   *  - less error prone: doing the same operation with .reverse() requires special care:
   *    \code m = m.reverse().eval(); \endcode
   *  - this API enables reverse operations without the need for a temporary
   *
   * \sa DenseBase::reverseInPlace(), reverse() */
 template<typename ExpressionType, int Direction>
-void VectorwiseOp<ExpressionType,Direction>::reverseInPlace()
+EIGEN_DEVICE_FUNC void VectorwiseOp<ExpressionType,Direction>::reverseInPlace()
 {
-  internal::vectorwise_reverse_inplace_impl<Direction>::run(_expression().const_cast_derived());
+  internal::vectorwise_reverse_inplace_impl<Direction>::run(m_matrix);
 }
 
 } // end namespace Eigen
 
 #endif // EIGEN_REVERSE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Select.h` & `chronogram-0.2.0/include/Eigen/src/Core/Select.h`

 * *Files 9% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_SELECT_H
 #define EIGEN_SELECT_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \class Select
   * \ingroup Core_Module
   *
   * \brief Expression of a coefficient wise version of the C++ ternary operator ?:
   *
   * \param ConditionMatrixType the type of the \em condition expression which must be a boolean matrix
@@ -63,16 +63,18 @@
            const ElseMatrixType& a_elseMatrix)
       : m_condition(a_conditionMatrix), m_then(a_thenMatrix), m_else(a_elseMatrix)
     {
       eigen_assert(m_condition.rows() == m_then.rows() && m_condition.rows() == m_else.rows());
       eigen_assert(m_condition.cols() == m_then.cols() && m_condition.cols() == m_else.cols());
     }
 
-    inline EIGEN_DEVICE_FUNC Index rows() const { return m_condition.rows(); }
-    inline EIGEN_DEVICE_FUNC Index cols() const { return m_condition.cols(); }
+    inline EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return m_condition.rows(); }
+    inline EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return m_condition.cols(); }
 
     inline EIGEN_DEVICE_FUNC
     const Scalar coeff(Index i, Index j) const
     {
       if (m_condition.coeff(i,j))
         return m_then.coeff(i,j);
       else
@@ -116,44 +118,44 @@
   * Example: \include MatrixBase_select.cpp
   * Output: \verbinclude MatrixBase_select.out
   *
   * \sa class Select
   */
 template<typename Derived>
 template<typename ThenDerived,typename ElseDerived>
-inline const Select<Derived,ThenDerived,ElseDerived>
+inline EIGEN_DEVICE_FUNC const Select<Derived,ThenDerived,ElseDerived>
 DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,
                             const DenseBase<ElseDerived>& elseMatrix) const
 {
   return Select<Derived,ThenDerived,ElseDerived>(derived(), thenMatrix.derived(), elseMatrix.derived());
 }
 
 /** Version of DenseBase::select(const DenseBase&, const DenseBase&) with
   * the \em else expression being a scalar value.
   *
   * \sa DenseBase::select(const DenseBase<ThenDerived>&, const DenseBase<ElseDerived>&) const, class Select
   */
 template<typename Derived>
 template<typename ThenDerived>
-inline const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturnType>
+inline EIGEN_DEVICE_FUNC const Select<Derived,ThenDerived, typename ThenDerived::ConstantReturnType>
 DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,
                            const typename ThenDerived::Scalar& elseScalar) const
 {
   return Select<Derived,ThenDerived,typename ThenDerived::ConstantReturnType>(
     derived(), thenMatrix.derived(), ThenDerived::Constant(rows(),cols(),elseScalar));
 }
 
 /** Version of DenseBase::select(const DenseBase&, const DenseBase&) with
   * the \em then expression being a scalar value.
   *
   * \sa DenseBase::select(const DenseBase<ThenDerived>&, const DenseBase<ElseDerived>&) const, class Select
   */
 template<typename Derived>
 template<typename ElseDerived>
-inline const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDerived >
+inline EIGEN_DEVICE_FUNC const Select<Derived, typename ElseDerived::ConstantReturnType, ElseDerived >
 DenseBase<Derived>::select(const typename ElseDerived::Scalar& thenScalar,
                            const DenseBase<ElseDerived>& elseMatrix) const
 {
   return Select<Derived,typename ElseDerived::ConstantReturnType,ElseDerived>(
     derived(), ElseDerived::Constant(rows(),cols(),thenScalar), elseMatrix.derived());
 }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/SelfAdjointView.h` & `chronogram-0.2.0/include/Eigen/src/Core/SelfAdjointView.h`

 * *Files 3% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_SELFADJOINTMATRIX_H
 #define EIGEN_SELFADJOINTMATRIX_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \class SelfAdjointView
   * \ingroup Core_Module
   *
   *
   * \brief Expression of a selfadjoint matrix from a triangular part of a dense matrix
   *
@@ -54,39 +54,40 @@
     typedef _MatrixType MatrixType;
     typedef TriangularBase<SelfAdjointView> Base;
     typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;
     typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;
     typedef MatrixTypeNestedCleaned NestedExpression;
 
     /** \brief The type of coefficients in this matrix */
-    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; 
+    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar;
     typedef typename MatrixType::StorageIndex StorageIndex;
     typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;
+    typedef SelfAdjointView<typename internal::add_const<MatrixType>::type, UpLo> ConstSelfAdjointView;
 
     enum {
       Mode = internal::traits<SelfAdjointView>::Mode,
       Flags = internal::traits<SelfAdjointView>::Flags,
-      TransposeMode = ((Mode & Upper) ? Lower : 0) | ((Mode & Lower) ? Upper : 0)
+      TransposeMode = ((int(Mode) & int(Upper)) ? Lower : 0) | ((int(Mode) & int(Lower)) ? Upper : 0)
     };
     typedef typename MatrixType::PlainObject PlainObject;
 
     EIGEN_DEVICE_FUNC
     explicit inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)
     {
       EIGEN_STATIC_ASSERT(UpLo==Lower || UpLo==Upper,SELFADJOINTVIEW_ACCEPTS_UPPER_AND_LOWER_MODE_ONLY);
     }
 
-    EIGEN_DEVICE_FUNC
-    inline Index rows() const { return m_matrix.rows(); }
-    EIGEN_DEVICE_FUNC
-    inline Index cols() const { return m_matrix.cols(); }
-    EIGEN_DEVICE_FUNC
-    inline Index outerStride() const { return m_matrix.outerStride(); }
-    EIGEN_DEVICE_FUNC
-    inline Index innerStride() const { return m_matrix.innerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT { return m_matrix.outerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT { return m_matrix.innerStride(); }
 
     /** \sa MatrixBase::coeff()
       * \warning the coordinates must fit into the referenced triangular part
       */
     EIGEN_DEVICE_FUNC
     inline Scalar coeff(Index row, Index col) const
     {
@@ -127,15 +128,15 @@
     template<typename OtherDerived> friend
     EIGEN_DEVICE_FUNC
     const Product<OtherDerived,SelfAdjointView>
     operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)
     {
       return Product<OtherDerived,SelfAdjointView>(lhs.derived(),rhs);
     }
-    
+
     friend EIGEN_DEVICE_FUNC
     const SelfAdjointView<const EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar,MatrixType,product),UpLo>
     operator*(const Scalar& s, const SelfAdjointView& mat)
     {
       return (s*mat.nestedExpression()).template selfadjointView<UpLo>();
     }
 
@@ -193,14 +194,26 @@
 
     typedef SelfAdjointView<const MatrixConjugateReturnType,UpLo> ConjugateReturnType;
     /** \sa MatrixBase::conjugate() const */
     EIGEN_DEVICE_FUNC
     inline const ConjugateReturnType conjugate() const
     { return ConjugateReturnType(m_matrix.conjugate()); }
 
+    /** \returns an expression of the complex conjugate of \c *this if Cond==true,
+     *           returns \c *this otherwise.
+     */
+    template<bool Cond>
+    EIGEN_DEVICE_FUNC
+    inline typename internal::conditional<Cond,ConjugateReturnType,ConstSelfAdjointView>::type
+    conjugateIf() const
+    {
+      typedef typename internal::conditional<Cond,ConjugateReturnType,ConstSelfAdjointView>::type ReturnType;
+      return ReturnType(m_matrix.template conjugateIf<Cond>());
+    }
+
     typedef SelfAdjointView<const typename MatrixType::AdjointReturnType,TransposeMode> AdjointReturnType;
     /** \sa MatrixBase::adjoint() const */
     EIGEN_DEVICE_FUNC
     inline const AdjointReturnType adjoint() const
     { return AdjointReturnType(m_matrix.adjoint()); }
 
     typedef SelfAdjointView<typename MatrixType::TransposeReturnType,TransposeMode> TransposeReturnType;
@@ -283,52 +296,52 @@
   typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version> Base;
   typedef typename Base::DstXprType DstXprType;
   typedef typename Base::SrcXprType SrcXprType;
   using Base::m_dst;
   using Base::m_src;
   using Base::m_functor;
 public:
-  
+
   typedef typename Base::DstEvaluatorType DstEvaluatorType;
   typedef typename Base::SrcEvaluatorType SrcEvaluatorType;
   typedef typename Base::Scalar Scalar;
   typedef typename Base::AssignmentTraits AssignmentTraits;
-  
-  
+
+
   EIGEN_DEVICE_FUNC triangular_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)
     : Base(dst, src, func, dstExpr)
   {}
-  
+
   EIGEN_DEVICE_FUNC void assignCoeff(Index row, Index col)
   {
     eigen_internal_assert(row!=col);
     Scalar tmp = m_src.coeff(row,col);
     m_functor.assignCoeff(m_dst.coeffRef(row,col), tmp);
     m_functor.assignCoeff(m_dst.coeffRef(col,row), numext::conj(tmp));
   }
-  
+
   EIGEN_DEVICE_FUNC void assignDiagonalCoeff(Index id)
   {
     Base::assignCoeff(id,id);
   }
-  
+
   EIGEN_DEVICE_FUNC void assignOppositeCoeff(Index, Index)
   { eigen_internal_assert(false && "should never be called"); }
 };
 
 } // end namespace internal
 
 /***************************************************************************
 * Implementation of MatrixBase methods
 ***************************************************************************/
 
 /** This is the const version of MatrixBase::selfadjointView() */
 template<typename Derived>
 template<unsigned int UpLo>
-typename MatrixBase<Derived>::template ConstSelfAdjointViewReturnType<UpLo>::Type
+EIGEN_DEVICE_FUNC typename MatrixBase<Derived>::template ConstSelfAdjointViewReturnType<UpLo>::Type
 MatrixBase<Derived>::selfadjointView() const
 {
   return typename ConstSelfAdjointViewReturnType<UpLo>::Type(derived());
 }
 
 /** \returns an expression of a symmetric/self-adjoint view extracted from the upper or lower triangular part of the current matrix
   *
@@ -337,15 +350,15 @@
   * Example: \include MatrixBase_selfadjointView.cpp
   * Output: \verbinclude MatrixBase_selfadjointView.out
   *
   * \sa class SelfAdjointView
   */
 template<typename Derived>
 template<unsigned int UpLo>
-typename MatrixBase<Derived>::template SelfAdjointViewReturnType<UpLo>::Type
+EIGEN_DEVICE_FUNC typename MatrixBase<Derived>::template SelfAdjointViewReturnType<UpLo>::Type
 MatrixBase<Derived>::selfadjointView()
 {
   return typename SelfAdjointViewReturnType<UpLo>::Type(derived());
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/SelfCwiseBinaryOp.h` & `chronogram-0.2.0/include/Eigen/src/Core/SelfCwiseBinaryOp.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Solve.h` & `chronogram-0.2.0/include/Eigen/src/Core/Solve.h`

 * *Files 2% similar despite different names*

```diff
@@ -9,21 +9,21 @@
 
 #ifndef EIGEN_SOLVE_H
 #define EIGEN_SOLVE_H
 
 namespace Eigen {
 
 template<typename Decomposition, typename RhsType, typename StorageKind> class SolveImpl;
-  
+
 /** \class Solve
   * \ingroup Core_Module
   *
   * \brief Pseudo expression representing a solving operation
   *
-  * \tparam Decomposition the type of the matrix or decomposion object
+  * \tparam Decomposition the type of the matrix or decomposition object
   * \tparam Rhstype the type of the right-hand side
   *
   * This class represents an expression of A.solve(B)
   * and most of the time this is the only way it is used.
   *
   */
 namespace internal {
@@ -60,21 +60,21 @@
 
 template<typename Decomposition, typename RhsType>
 class Solve : public SolveImpl<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>
 {
 public:
   typedef typename internal::traits<Solve>::PlainObject PlainObject;
   typedef typename internal::traits<Solve>::StorageIndex StorageIndex;
-  
+
   Solve(const Decomposition &dec, const RhsType &rhs)
     : m_dec(dec), m_rhs(rhs)
   {}
-  
-  EIGEN_DEVICE_FUNC Index rows() const { return m_dec.cols(); }
-  EIGEN_DEVICE_FUNC Index cols() const { return m_rhs.cols(); }
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_dec.cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }
 
   EIGEN_DEVICE_FUNC const Decomposition& dec() const { return m_dec; }
   EIGEN_DEVICE_FUNC const RhsType&       rhs() const { return m_rhs; }
 
 protected:
   const Decomposition &m_dec;
   const RhsType       &m_rhs;
@@ -83,22 +83,22 @@
 
 // Specialization of the Solve expression for dense results
 template<typename Decomposition, typename RhsType>
 class SolveImpl<Decomposition,RhsType,Dense>
   : public MatrixBase<Solve<Decomposition,RhsType> >
 {
   typedef Solve<Decomposition,RhsType> Derived;
-  
+
 public:
-  
+
   typedef MatrixBase<Solve<Decomposition,RhsType> > Base;
   EIGEN_DENSE_PUBLIC_INTERFACE(Derived)
 
 private:
-  
+
   Scalar coeff(Index row, Index col) const;
   Scalar coeff(Index i) const;
 };
 
 // Generic API dispatcher
 template<typename Decomposition, typename RhsType, typename StorageKind>
 class SolveImpl : public internal::generic_xpr_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>::type
@@ -115,23 +115,23 @@
   : public evaluator<typename Solve<Decomposition,RhsType>::PlainObject>
 {
   typedef Solve<Decomposition,RhsType> SolveType;
   typedef typename SolveType::PlainObject PlainObject;
   typedef evaluator<PlainObject> Base;
 
   enum { Flags = Base::Flags | EvalBeforeNestingBit };
-  
+
   EIGEN_DEVICE_FUNC explicit evaluator(const SolveType& solve)
     : m_result(solve.rows(), solve.cols())
   {
     ::new (static_cast<Base*>(this)) Base(m_result);
     solve.dec()._solve_impl(solve.rhs(), m_result);
   }
-  
-protected:  
+
+protected:
   PlainObject m_result;
 };
 
 // Specialization for "dst = dec.solve(rhs)"
 // NOTE we need to specialize it for Dense2Dense to avoid ambiguous specialization error and a Sparse2Sparse specialization must exist somewhere
 template<typename DstXprType, typename DecType, typename RhsType, typename Scalar>
 struct Assignment<DstXprType, Solve<DecType,RhsType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>
@@ -172,17 +172,17 @@
   typedef Solve<CwiseUnaryOp<internal::scalar_conjugate_op<typename DecType::Scalar>, const Transpose<const DecType> >,RhsType> SrcXprType;
   static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)
   {
     Index dstRows = src.rows();
     Index dstCols = src.cols();
     if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
       dst.resize(dstRows, dstCols);
-    
+
     src.dec().nestedExpression().nestedExpression().template _solve_impl_transposed<true>(src.rhs(), dst);
   }
 };
 
-} // end namepsace internal
+} // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_SOLVE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/SolveTriangular.h` & `chronogram-0.2.0/include/Eigen/src/Core/SolveTriangular.h`

 * *Files 10% similar despite different names*

```diff
@@ -6,24 +6,24 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_SOLVETRIANGULAR_H
 #define EIGEN_SOLVETRIANGULAR_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 
 // Forward declarations:
 // The following two routines are implemented in the products/TriangularSolver*.h files
 template<typename LhsScalar, typename RhsScalar, typename Index, int Side, int Mode, bool Conjugate, int StorageOrder>
 struct triangular_solve_vector;
 
-template <typename Scalar, typename Index, int Side, int Mode, bool Conjugate, int TriStorageOrder, int OtherStorageOrder>
+template <typename Scalar, typename Index, int Side, int Mode, bool Conjugate, int TriStorageOrder, int OtherStorageOrder, int OtherInnerStride>
 struct triangular_solve_matrix;
 
 // small helper struct extracting some traits on the underlying solver operation
 template<typename Lhs, typename Rhs, int Side>
 class trsolve_traits
 {
   private:
@@ -50,25 +50,25 @@
 struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>
 {
   typedef typename Lhs::Scalar LhsScalar;
   typedef typename Rhs::Scalar RhsScalar;
   typedef blas_traits<Lhs> LhsProductTraits;
   typedef typename LhsProductTraits::ExtractType ActualLhsType;
   typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;
-  static void run(const Lhs& lhs, Rhs& rhs)
+  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)
   {
     ActualLhsType actualLhs = LhsProductTraits::extract(lhs);
 
     // FIXME find a way to allow an inner stride if packet_traits<Scalar>::size==1
 
     bool useRhsDirectly = Rhs::InnerStrideAtCompileTime==1 || rhs.innerStride()==1;
 
     ei_declare_aligned_stack_constructed_variable(RhsScalar,actualRhs,rhs.size(),
                                                   (useRhsDirectly ? rhs.data() : 0));
-                                                  
+
     if(!useRhsDirectly)
       MappedRhs(actualRhs,rhs.size()) = rhs;
 
     triangular_solve_vector<LhsScalar, RhsScalar, Index, Side, Mode, LhsProductTraits::NeedToConjugate,
                             (int(Lhs::Flags) & RowMajorBit) ? RowMajor : ColMajor>
       ::run(actualLhs.cols(), actualLhs.data(), actualLhs.outerStride(), actualRhs);
 
@@ -81,29 +81,29 @@
 template<typename Lhs, typename Rhs, int Side, int Mode>
 struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>
 {
   typedef typename Rhs::Scalar Scalar;
   typedef blas_traits<Lhs> LhsProductTraits;
   typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;
 
-  static void run(const Lhs& lhs, Rhs& rhs)
+  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)
   {
     typename internal::add_const_on_value_type<ActualLhsType>::type actualLhs = LhsProductTraits::extract(lhs);
 
     const Index size = lhs.rows();
     const Index othersize = Side==OnTheLeft? rhs.cols() : rhs.rows();
 
     typedef internal::gemm_blocking_space<(Rhs::Flags&RowMajorBit) ? RowMajor : ColMajor,Scalar,Scalar,
               Rhs::MaxRowsAtCompileTime, Rhs::MaxColsAtCompileTime, Lhs::MaxRowsAtCompileTime,4> BlockingType;
 
     BlockingType blocking(rhs.rows(), rhs.cols(), size, 1, false);
 
     triangular_solve_matrix<Scalar,Index,Side,Mode,LhsProductTraits::NeedToConjugate,(int(Lhs::Flags) & RowMajorBit) ? RowMajor : ColMajor,
-                               (Rhs::Flags&RowMajorBit) ? RowMajor : ColMajor>
-      ::run(size, othersize, &actualLhs.coeffRef(0,0), actualLhs.outerStride(), &rhs.coeffRef(0,0), rhs.outerStride(), blocking);
+                               (Rhs::Flags&RowMajorBit) ? RowMajor : ColMajor, Rhs::InnerStrideAtCompileTime>
+      ::run(size, othersize, &actualLhs.coeffRef(0,0), actualLhs.outerStride(), &rhs.coeffRef(0,0), rhs.innerStride(), rhs.outerStride(), blocking);
   }
 };
 
 /***************************************************************************
 * meta-unrolling implementation
 ***************************************************************************/
 
@@ -114,45 +114,45 @@
 template<typename Lhs, typename Rhs, int Mode, int LoopIndex, int Size>
 struct triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex,Size,false> {
   enum {
     IsLower = ((Mode&Lower)==Lower),
     DiagIndex  = IsLower ? LoopIndex : Size - LoopIndex - 1,
     StartIndex = IsLower ? 0         : DiagIndex+1
   };
-  static void run(const Lhs& lhs, Rhs& rhs)
+  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)
   {
     if (LoopIndex>0)
       rhs.coeffRef(DiagIndex) -= lhs.row(DiagIndex).template segment<LoopIndex>(StartIndex).transpose()
                                 .cwiseProduct(rhs.template segment<LoopIndex>(StartIndex)).sum();
 
     if(!(Mode & UnitDiag))
       rhs.coeffRef(DiagIndex) /= lhs.coeff(DiagIndex,DiagIndex);
 
     triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex+1,Size>::run(lhs,rhs);
   }
 };
 
 template<typename Lhs, typename Rhs, int Mode, int LoopIndex, int Size>
 struct triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex,Size,true> {
-  static void run(const Lhs&, Rhs&) {}
+  static EIGEN_DEVICE_FUNC void run(const Lhs&, Rhs&) {}
 };
 
 template<typename Lhs, typename Rhs, int Mode>
 struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {
-  static void run(const Lhs& lhs, Rhs& rhs)
+  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)
   { triangular_solver_unroller<Lhs,Rhs,Mode,0,Rhs::SizeAtCompileTime>::run(lhs,rhs); }
 };
 
 template<typename Lhs, typename Rhs, int Mode>
 struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {
-  static void run(const Lhs& lhs, Rhs& rhs)
+  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)
   {
     Transpose<const Lhs> trLhs(lhs);
     Transpose<Rhs> trRhs(rhs);
-    
+
     triangular_solver_unroller<Transpose<const Lhs>,Transpose<Rhs>,
                               ((Mode&Upper)==Upper ? Lower : Upper) | (Mode&UnitDiag),
                               0,Rhs::SizeAtCompileTime>::run(trLhs,trRhs);
   }
 };
 
 } // end namespace internal
@@ -160,19 +160,19 @@
 /***************************************************************************
 * TriangularView methods
 ***************************************************************************/
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template<typename MatrixType, unsigned int Mode>
 template<int Side, typename OtherDerived>
-void TriangularViewImpl<MatrixType,Mode,Dense>::solveInPlace(const MatrixBase<OtherDerived>& _other) const
+EIGEN_DEVICE_FUNC void TriangularViewImpl<MatrixType,Mode,Dense>::solveInPlace(const MatrixBase<OtherDerived>& _other) const
 {
   OtherDerived& other = _other.const_cast_derived();
   eigen_assert( derived().cols() == derived().rows() && ((Side==OnTheLeft && derived().cols() == other.rows()) || (Side==OnTheRight && derived().cols() == other.cols())) );
-  eigen_assert((!(Mode & ZeroDiag)) && bool(Mode & (Upper|Lower)));
+  eigen_assert((!(int(Mode) & int(ZeroDiag))) && bool(int(Mode) & (int(Upper) | int(Lower))));
   // If solving for a 0x0 matrix, nothing to do, simply return.
   if (derived().cols() == 0)
     return;
 
   enum { copy = (internal::traits<OtherDerived>::Flags & RowMajorBit)  && OtherDerived::IsVectorAtCompileTime && OtherDerived::SizeAtCompileTime!=1};
   typedef typename internal::conditional<copy,
     typename internal::plain_matrix_type_column_major<OtherDerived>::type, OtherDerived&>::type OtherCopy;
@@ -209,16 +209,16 @@
   typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;
   typedef ReturnByValue<triangular_solve_retval> Base;
 
   triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)
     : m_triangularMatrix(tri), m_rhs(rhs)
   {}
 
-  inline Index rows() const { return m_rhs.rows(); }
-  inline Index cols() const { return m_rhs.cols(); }
+  inline EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_rhs.rows(); }
+  inline EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }
 
   template<typename Dest> inline void evalTo(Dest& dst) const
   {
     if(!is_same_dense(dst,m_rhs))
       dst = m_rhs;
     m_triangularMatrix.template solveInPlace<Side>(dst);
   }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/SolverBase.h` & `chronogram-0.2.0/include/Eigen/src/Core/SolverBase.h`

 * *Files 25% similar despite different names*

```diff
@@ -10,16 +10,43 @@
 #ifndef EIGEN_SOLVERBASE_H
 #define EIGEN_SOLVERBASE_H
 
 namespace Eigen {
 
 namespace internal {
 
+template<typename Derived>
+struct solve_assertion {
+    template<bool Transpose_, typename Rhs>
+    static void run(const Derived& solver, const Rhs& b) { solver.template _check_solve_assertion<Transpose_>(b); }
+};
+
+template<typename Derived>
+struct solve_assertion<Transpose<Derived> >
+{
+    typedef Transpose<Derived> type;
+
+    template<bool Transpose_, typename Rhs>
+    static void run(const type& transpose, const Rhs& b)
+    {
+        internal::solve_assertion<typename internal::remove_all<Derived>::type>::template run<true>(transpose.nestedExpression(), b);
+    }
+};
 
+template<typename Scalar, typename Derived>
+struct solve_assertion<CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<Scalar>, const Transpose<Derived> > >
+{
+    typedef CwiseUnaryOp<Eigen::internal::scalar_conjugate_op<Scalar>, const Transpose<Derived> > type;
 
+    template<bool Transpose_, typename Rhs>
+    static void run(const type& adjoint, const Rhs& b)
+    {
+        internal::solve_assertion<typename internal::remove_all<Transpose<Derived> >::type>::template run<true>(adjoint.nestedExpression(), b);
+    }
+};
 } // end namespace internal
 
 /** \class SolverBase
   * \brief A base class for matrix decomposition and solvers
   *
   * \tparam Derived the actual type of the decomposition/solver.
   *
@@ -31,36 +58,40 @@
   * x = dec.solve(b);             // solve A   * x = b
   * x = dec.transpose().solve(b); // solve A^T * x = b
   * x = dec.adjoint().solve(b);   // solve A'  * x = b
   * \endcode
   *
   * \warning Currently, any other usage of transpose() and adjoint() are not supported and will produce compilation errors.
   *
-  * \sa class PartialPivLU, class FullPivLU
+  * \sa class PartialPivLU, class FullPivLU, class HouseholderQR, class ColPivHouseholderQR, class FullPivHouseholderQR, class CompleteOrthogonalDecomposition, class LLT, class LDLT, class SVDBase
   */
 template<typename Derived>
 class SolverBase : public EigenBase<Derived>
 {
   public:
 
     typedef EigenBase<Derived> Base;
     typedef typename internal::traits<Derived>::Scalar Scalar;
     typedef Scalar CoeffReturnType;
 
+    template<typename Derived_>
+    friend struct internal::solve_assertion;
+
     enum {
       RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
       ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
       SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,
                                                           internal::traits<Derived>::ColsAtCompileTime>::ret),
       MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,
       MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,
                                                              internal::traits<Derived>::MaxColsAtCompileTime>::ret),
       IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1
-                           || internal::traits<Derived>::MaxColsAtCompileTime == 1
+                           || internal::traits<Derived>::MaxColsAtCompileTime == 1,
+      NumDimensions = int(MaxSizeAtCompileTime) == 1 ? 0 : bool(IsVectorAtCompileTime) ? 1 : 2
     };
 
     /** Default constructor */
     SolverBase()
     {}
 
     ~SolverBase()
@@ -70,15 +101,15 @@
 
     /** \returns an expression of the solution x of \f$ A x = b \f$ using the current decomposition of A.
       */
     template<typename Rhs>
     inline const Solve<Derived, Rhs>
     solve(const MatrixBase<Rhs>& b) const
     {
-      eigen_assert(derived().rows()==b.rows() && "solve(): invalid number of rows of the right hand side matrix b");
+      internal::solve_assertion<typename internal::remove_all<Derived>::type>::template run<false>(derived(), b);
       return Solve<Derived, Rhs>(derived(), b.derived());
     }
 
     /** \internal the return type of transpose() */
     typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;
     /** \returns an expression of the transposed of the factored matrix.
       *
@@ -108,14 +139,21 @@
       */
     inline AdjointReturnType adjoint() const
     {
       return AdjointReturnType(derived().transpose());
     }
 
   protected:
+
+    template<bool Transpose_, typename Rhs>
+    void _check_solve_assertion(const Rhs& b) const {
+        EIGEN_ONLY_USED_FOR_DEBUG(b);
+        eigen_assert(derived().m_isInitialized && "Solver is not initialized.");
+        eigen_assert((Transpose_?derived().cols():derived().rows())==b.rows() && "SolverBase::solve(): invalid number of rows of the right hand side matrix b");
+    }
 };
 
 namespace internal {
 
 template<typename Derived>
 struct generic_xpr_base<Derived, MatrixXpr, SolverStorage>
 {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/StableNorm.h` & `chronogram-0.2.0/include/Eigen/src/Core/StableNorm.h`

 * *Files 14% similar despite different names*

```diff
@@ -46,68 +46,124 @@
   
   // TODO if the maxCoeff is much much smaller than the current scale,
   // then we can neglect this sub vector
   if(scale>Scalar(0)) // if scale==0, then bl is 0 
     ssq += (bl*invScale).squaredNorm();
 }
 
+template<typename VectorType, typename RealScalar>
+void stable_norm_impl_inner_step(const VectorType &vec, RealScalar& ssq, RealScalar& scale, RealScalar& invScale)
+{
+  typedef typename VectorType::Scalar Scalar;
+  const Index blockSize = 4096;
+  
+  typedef typename internal::nested_eval<VectorType,2>::type VectorTypeCopy;
+  typedef typename internal::remove_all<VectorTypeCopy>::type VectorTypeCopyClean;
+  const VectorTypeCopy copy(vec);
+  
+  enum {
+    CanAlign = (   (int(VectorTypeCopyClean::Flags)&DirectAccessBit)
+                || (int(internal::evaluator<VectorTypeCopyClean>::Alignment)>0) // FIXME Alignment)>0 might not be enough
+               ) && (blockSize*sizeof(Scalar)*2<EIGEN_STACK_ALLOCATION_LIMIT)
+                 && (EIGEN_MAX_STATIC_ALIGN_BYTES>0) // if we cannot allocate on the stack, then let's not bother about this optimization
+  };
+  typedef typename internal::conditional<CanAlign, Ref<const Matrix<Scalar,Dynamic,1,0,blockSize,1>, internal::evaluator<VectorTypeCopyClean>::Alignment>,
+                                                   typename VectorTypeCopyClean::ConstSegmentReturnType>::type SegmentWrapper;
+  Index n = vec.size();
+  
+  Index bi = internal::first_default_aligned(copy);
+  if (bi>0)
+    internal::stable_norm_kernel(copy.head(bi), ssq, scale, invScale);
+  for (; bi<n; bi+=blockSize)
+    internal::stable_norm_kernel(SegmentWrapper(copy.segment(bi,numext::mini(blockSize, n - bi))), ssq, scale, invScale);
+}
+
+template<typename VectorType>
+typename VectorType::RealScalar
+stable_norm_impl(const VectorType &vec, typename enable_if<VectorType::IsVectorAtCompileTime>::type* = 0 )
+{
+  using std::sqrt;
+  using std::abs;
+
+  Index n = vec.size();
+
+  if(n==1)
+    return abs(vec.coeff(0));
+
+  typedef typename VectorType::RealScalar RealScalar;
+  RealScalar scale(0);
+  RealScalar invScale(1);
+  RealScalar ssq(0); // sum of squares
+
+  stable_norm_impl_inner_step(vec, ssq, scale, invScale);
+  
+  return scale * sqrt(ssq);
+}
+
+template<typename MatrixType>
+typename MatrixType::RealScalar
+stable_norm_impl(const MatrixType &mat, typename enable_if<!MatrixType::IsVectorAtCompileTime>::type* = 0 )
+{
+  using std::sqrt;
+
+  typedef typename MatrixType::RealScalar RealScalar;
+  RealScalar scale(0);
+  RealScalar invScale(1);
+  RealScalar ssq(0); // sum of squares
+
+  for(Index j=0; j<mat.outerSize(); ++j)
+    stable_norm_impl_inner_step(mat.innerVector(j), ssq, scale, invScale);
+  return scale * sqrt(ssq);
+}
+
 template<typename Derived>
 inline typename NumTraits<typename traits<Derived>::Scalar>::Real
 blueNorm_impl(const EigenBase<Derived>& _vec)
 {
   typedef typename Derived::RealScalar RealScalar;  
   using std::pow;
   using std::sqrt;
   using std::abs;
+
+  // This program calculates the machine-dependent constants
+  // bl, b2, slm, s2m, relerr overfl
+  // from the "basic" machine-dependent numbers
+  // nbig, ibeta, it, iemin, iemax, rbig.
+  // The following define the basic machine-dependent constants.
+  // For portability, the PORT subprograms "ilmaeh" and "rlmach"
+  // are used. For any specific computer, each of the assignment
+  // statements can be replaced
+  static const int ibeta = std::numeric_limits<RealScalar>::radix;  // base for floating-point numbers
+  static const int it    = NumTraits<RealScalar>::digits();  // number of base-beta digits in mantissa
+  static const int iemin = NumTraits<RealScalar>::min_exponent();  // minimum exponent
+  static const int iemax = NumTraits<RealScalar>::max_exponent();  // maximum exponent
+  static const RealScalar rbig   = NumTraits<RealScalar>::highest();  // largest floating-point number
+  static const RealScalar b1     = RealScalar(pow(RealScalar(ibeta),RealScalar(-((1-iemin)/2))));  // lower boundary of midrange
+  static const RealScalar b2     = RealScalar(pow(RealScalar(ibeta),RealScalar((iemax + 1 - it)/2)));  // upper boundary of midrange
+  static const RealScalar s1m    = RealScalar(pow(RealScalar(ibeta),RealScalar((2-iemin)/2)));  // scaling factor for lower range
+  static const RealScalar s2m    = RealScalar(pow(RealScalar(ibeta),RealScalar(- ((iemax+it)/2))));  // scaling factor for upper range
+  static const RealScalar eps    = RealScalar(pow(double(ibeta), 1-it));
+  static const RealScalar relerr = sqrt(eps);  // tolerance for neglecting asml
+
   const Derived& vec(_vec.derived());
-  static bool initialized = false;
-  static RealScalar b1, b2, s1m, s2m, rbig, relerr;
-  if(!initialized)
-  {
-    int ibeta, it, iemin, iemax, iexp;
-    RealScalar eps;
-    // This program calculates the machine-dependent constants
-    // bl, b2, slm, s2m, relerr overfl
-    // from the "basic" machine-dependent numbers
-    // nbig, ibeta, it, iemin, iemax, rbig.
-    // The following define the basic machine-dependent constants.
-    // For portability, the PORT subprograms "ilmaeh" and "rlmach"
-    // are used. For any specific computer, each of the assignment
-    // statements can be replaced
-    ibeta = std::numeric_limits<RealScalar>::radix;                 // base for floating-point numbers
-    it    = std::numeric_limits<RealScalar>::digits;                // number of base-beta digits in mantissa
-    iemin = std::numeric_limits<RealScalar>::min_exponent;          // minimum exponent
-    iemax = std::numeric_limits<RealScalar>::max_exponent;          // maximum exponent
-    rbig  = (std::numeric_limits<RealScalar>::max)();               // largest floating-point number
-
-    iexp  = -((1-iemin)/2);
-    b1    = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));    // lower boundary of midrange
-    iexp  = (iemax + 1 - it)/2;
-    b2    = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));    // upper boundary of midrange
-
-    iexp  = (2-iemin)/2;
-    s1m   = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));    // scaling factor for lower range
-    iexp  = - ((iemax+it)/2);
-    s2m   = RealScalar(pow(RealScalar(ibeta),RealScalar(iexp)));    // scaling factor for upper range
-
-    eps     = RealScalar(pow(double(ibeta), 1-it));
-    relerr  = sqrt(eps);                                            // tolerance for neglecting asml
-    initialized = true;
-  }
   Index n = vec.size();
   RealScalar ab2 = b2 / RealScalar(n);
   RealScalar asml = RealScalar(0);
   RealScalar amed = RealScalar(0);
   RealScalar abig = RealScalar(0);
-  for(typename Derived::InnerIterator it(vec, 0); it; ++it)
+
+  for(Index j=0; j<vec.outerSize(); ++j)
   {
-    RealScalar ax = abs(it.value());
-    if(ax > ab2)     abig += numext::abs2(ax*s2m);
-    else if(ax < b1) asml += numext::abs2(ax*s1m);
-    else             amed += numext::abs2(ax);
+    for(typename Derived::InnerIterator iter(vec, j); iter; ++iter)
+    {
+      RealScalar ax = abs(iter.value());
+      if(ax > ab2)     abig += numext::abs2(ax*s2m);
+      else if(ax < b1) asml += numext::abs2(ax*s1m);
+      else             amed += numext::abs2(ax);
+    }
   }
   if(amed!=amed)
     return amed;  // we got a NaN
   if(abig > RealScalar(0))
   {
     abig = sqrt(abig);
     if(abig > rbig) // overflow, or *this contains INF values
@@ -152,44 +208,15 @@
   *
   * \sa norm(), blueNorm(), hypotNorm()
   */
 template<typename Derived>
 inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real
 MatrixBase<Derived>::stableNorm() const
 {
-  using std::sqrt;
-  using std::abs;
-  const Index blockSize = 4096;
-  RealScalar scale(0);
-  RealScalar invScale(1);
-  RealScalar ssq(0); // sum of square
-  
-  typedef typename internal::nested_eval<Derived,2>::type DerivedCopy;
-  typedef typename internal::remove_all<DerivedCopy>::type DerivedCopyClean;
-  const DerivedCopy copy(derived());
-  
-  enum {
-    CanAlign = (   (int(DerivedCopyClean::Flags)&DirectAccessBit)
-                || (int(internal::evaluator<DerivedCopyClean>::Alignment)>0) // FIXME Alignment)>0 might not be enough
-               ) && (blockSize*sizeof(Scalar)*2<EIGEN_STACK_ALLOCATION_LIMIT)
-                 && (EIGEN_MAX_STATIC_ALIGN_BYTES>0) // if we cannot allocate on the stack, then let's not bother about this optimization
-  };
-  typedef typename internal::conditional<CanAlign, Ref<const Matrix<Scalar,Dynamic,1,0,blockSize,1>, internal::evaluator<DerivedCopyClean>::Alignment>,
-                                                   typename DerivedCopyClean::ConstSegmentReturnType>::type SegmentWrapper;
-  Index n = size();
-  
-  if(n==1)
-    return abs(this->coeff(0));
-  
-  Index bi = internal::first_default_aligned(copy);
-  if (bi>0)
-    internal::stable_norm_kernel(copy.head(bi), ssq, scale, invScale);
-  for (; bi<n; bi+=blockSize)
-    internal::stable_norm_kernel(SegmentWrapper(copy.segment(bi,numext::mini(blockSize, n - bi))), ssq, scale, invScale);
-  return scale * sqrt(ssq);
+  return internal::stable_norm_impl(derived());
 }
 
 /** \returns the \em l2 norm of \c *this using the Blue's algorithm.
   * A Portable Fortran Program to Find the Euclidean Norm of a Vector,
   * ACM TOMS, Vol 4, Issue 1, 1978.
   *
   * For architecture/scalar types without vectorization, this version
@@ -209,13 +236,16 @@
   *
   * \sa norm(), stableNorm()
   */
 template<typename Derived>
 inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real
 MatrixBase<Derived>::hypotNorm() const
 {
-  return this->cwiseAbs().redux(internal::scalar_hypot_op<RealScalar>());
+  if(size()==1)
+    return numext::abs(coeff(0,0));
+  else
+    return this->cwiseAbs().redux(internal::scalar_hypot_op<RealScalar>());
 }
 
 } // end namespace Eigen
 
 #endif // EIGEN_STABLENORM_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Stride.h` & `chronogram-0.2.0/include/Eigen/src/Core/Stride.h`

 * *Files 3% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_STRIDE_H
 #define EIGEN_STRIDE_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \class Stride
   * \ingroup Core_Module
   *
   * \brief Holds strides information for Map
   *
   * This class holds the strides information for mapping arrays with strides with class Map.
@@ -34,14 +34,18 @@
   *  \tparam _OuterStrideAtCompileTime the outer stride, or Dynamic if you want to specify it at runtime.
   *  \tparam _InnerStrideAtCompileTime the inner stride, or Dynamic if you want to specify it at runtime.
   *
   * Here is an example:
   * \include Map_general_stride.cpp
   * Output: \verbinclude Map_general_stride.out
   *
+  * Both strides can be negative, however, a negative stride of -1 cannot be specified at compiletime
+  * because of the ambiguity with Dynamic which is defined to -1 (historically, negative strides were
+  * not allowed).
+  *
   * \sa class InnerStride, class OuterStride, \ref TopicStorageOrders
   */
 template<int _OuterStrideAtCompileTime, int _InnerStrideAtCompileTime>
 class Stride
 {
   public:
     typedef Eigen::Index Index; ///< \deprecated since Eigen 3.3
@@ -51,36 +55,37 @@
     };
 
     /** Default constructor, for use when strides are fixed at compile time */
     EIGEN_DEVICE_FUNC
     Stride()
       : m_outer(OuterStrideAtCompileTime), m_inner(InnerStrideAtCompileTime)
     {
+      // FIXME: for Eigen 4 we should use DynamicIndex instead of Dynamic.
+      // FIXME: for Eigen 4 we should also unify this API with fix<>
       eigen_assert(InnerStrideAtCompileTime != Dynamic && OuterStrideAtCompileTime != Dynamic);
     }
 
     /** Constructor allowing to pass the strides at runtime */
     EIGEN_DEVICE_FUNC
     Stride(Index outerStride, Index innerStride)
       : m_outer(outerStride), m_inner(innerStride)
     {
-      eigen_assert(innerStride>=0 && outerStride>=0);
     }
 
     /** Copy constructor */
     EIGEN_DEVICE_FUNC
     Stride(const Stride& other)
       : m_outer(other.outer()), m_inner(other.inner())
     {}
 
     /** \returns the outer stride */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index outer() const { return m_outer.value(); }
     /** \returns the inner stride */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
     inline Index inner() const { return m_inner.value(); }
 
   protected:
     internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;
     internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;
 };
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Swap.h` & `chronogram-0.2.0/include/Eigen/src/Core/Swap.h`

 * *Files 6% similar despite different names*

```diff
@@ -26,37 +26,38 @@
   using Base::m_functor;
   
 public:
   typedef typename Base::Scalar Scalar;
   typedef typename Base::DstXprType DstXprType;
   typedef swap_assign_op<Scalar> Functor;
   
-  EIGEN_DEVICE_FUNC generic_dense_assignment_kernel(DstEvaluatorTypeT &dst, const SrcEvaluatorTypeT &src, const Functor &func, DstXprType& dstExpr)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  generic_dense_assignment_kernel(DstEvaluatorTypeT &dst, const SrcEvaluatorTypeT &src, const Functor &func, DstXprType& dstExpr)
     : Base(dst, src, func, dstExpr)
   {}
   
   template<int StoreMode, int LoadMode, typename PacketType>
-  void assignPacket(Index row, Index col)
+  EIGEN_STRONG_INLINE void assignPacket(Index row, Index col)
   {
     PacketType tmp = m_src.template packet<LoadMode,PacketType>(row,col);
     const_cast<SrcEvaluatorTypeT&>(m_src).template writePacket<LoadMode>(row,col, m_dst.template packet<StoreMode,PacketType>(row,col));
     m_dst.template writePacket<StoreMode>(row,col,tmp);
   }
   
   template<int StoreMode, int LoadMode, typename PacketType>
-  void assignPacket(Index index)
+  EIGEN_STRONG_INLINE void assignPacket(Index index)
   {
     PacketType tmp = m_src.template packet<LoadMode,PacketType>(index);
     const_cast<SrcEvaluatorTypeT&>(m_src).template writePacket<LoadMode>(index, m_dst.template packet<StoreMode,PacketType>(index));
     m_dst.template writePacket<StoreMode>(index,tmp);
   }
   
   // TODO find a simple way not to have to copy/paste this function from generic_dense_assignment_kernel, by simple I mean no CRTP (Gael)
   template<int StoreMode, int LoadMode, typename PacketType>
-  void assignPacketByOuterInner(Index outer, Index inner)
+  EIGEN_STRONG_INLINE void assignPacketByOuterInner(Index outer, Index inner)
   {
     Index row = Base::rowIndexByOuterInner(outer, inner); 
     Index col = Base::colIndexByOuterInner(outer, inner);
     assignPacket<StoreMode,LoadMode,PacketType>(row, col);
   }
 };
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Transpose.h` & `chronogram-0.2.0/include/Eigen/src/Core/Transpose.h`

 * *Files 10% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_TRANSPOSE_H
 #define EIGEN_TRANSPOSE_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 template<typename MatrixType>
 struct traits<Transpose<MatrixType> > : public traits<MatrixType>
 {
   typedef typename ref_selector<MatrixType>::type MatrixTypeNested;
   typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;
@@ -57,32 +57,35 @@
     typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;
 
     typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;
     EIGEN_GENERIC_PUBLIC_INTERFACE(Transpose)
     typedef typename internal::remove_all<MatrixType>::type NestedExpression;
 
     EIGEN_DEVICE_FUNC
-    explicit inline Transpose(MatrixType& matrix) : m_matrix(matrix) {}
+    explicit EIGEN_STRONG_INLINE Transpose(MatrixType& matrix) : m_matrix(matrix) {}
 
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Transpose)
 
-    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.cols(); }
-    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return m_matrix.rows(); }
 
     /** \returns the nested expression */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     const typename internal::remove_all<MatrixTypeNested>::type&
     nestedExpression() const { return m_matrix; }
 
     /** \returns the nested expression */
-    EIGEN_DEVICE_FUNC
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     typename internal::remove_reference<MatrixTypeNested>::type&
     nestedExpression() { return m_matrix; }
 
     /** \internal */
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
     void resize(Index nrows, Index ncols) {
       m_matrix.resize(ncols,nrows);
     }
 
   protected:
     typename internal::ref_selector<MatrixType>::non_const_type m_matrix;
 };
@@ -118,38 +121,44 @@
   public:
 
     typedef typename internal::TransposeImpl_base<MatrixType>::type Base;
     using Base::coeffRef;
     EIGEN_DENSE_PUBLIC_INTERFACE(Transpose<MatrixType>)
     EIGEN_INHERIT_ASSIGNMENT_OPERATORS(TransposeImpl)
 
-    EIGEN_DEVICE_FUNC inline Index innerStride() const { return derived().nestedExpression().innerStride(); }
-    EIGEN_DEVICE_FUNC inline Index outerStride() const { return derived().nestedExpression().outerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Index innerStride() const { return derived().nestedExpression().innerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    Index outerStride() const { return derived().nestedExpression().outerStride(); }
 
     typedef typename internal::conditional<
                        internal::is_lvalue<MatrixType>::value,
                        Scalar,
                        const Scalar
                      >::type ScalarWithConstIfNotLvalue;
 
-    EIGEN_DEVICE_FUNC inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }
-    EIGEN_DEVICE_FUNC inline const Scalar* data() const { return derived().nestedExpression().data(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const Scalar* data() const { return derived().nestedExpression().data(); }
 
     // FIXME: shall we keep the const version of coeffRef?
-    EIGEN_DEVICE_FUNC
-    inline const Scalar& coeffRef(Index rowId, Index colId) const
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const Scalar& coeffRef(Index rowId, Index colId) const
     {
       return derived().nestedExpression().coeffRef(colId, rowId);
     }
 
-    EIGEN_DEVICE_FUNC
-    inline const Scalar& coeffRef(Index index) const
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    const Scalar& coeffRef(Index index) const
     {
       return derived().nestedExpression().coeffRef(index);
     }
+  protected:
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(TransposeImpl)
 };
 
 /** \returns an expression of the transpose of *this.
   *
   * Example: \include MatrixBase_transpose.cpp
   * Output: \verbinclude MatrixBase_transpose.out
   *
@@ -164,27 +173,29 @@
   * which gives Eigen good opportunities for optimization, or alternatively you can also do:
   * \code
   * m = m.transpose().eval();
   * \endcode
   *
   * \sa transposeInPlace(), adjoint() */
 template<typename Derived>
-inline Transpose<Derived>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+Transpose<Derived>
 DenseBase<Derived>::transpose()
 {
   return TransposeReturnType(derived());
 }
 
 /** This is the const version of transpose().
   *
   * Make sure you read the warning for transpose() !
   *
   * \sa transposeInPlace(), adjoint() */
 template<typename Derived>
-inline typename DenseBase<Derived>::ConstTransposeReturnType
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+typename DenseBase<Derived>::ConstTransposeReturnType
 DenseBase<Derived>::transpose() const
 {
   return ConstTransposeReturnType(derived());
 }
 
 /** \returns an expression of the adjoint (i.e. conjugate transpose) of *this.
   *
@@ -202,15 +213,15 @@
   * which gives Eigen good opportunities for optimization, or alternatively you can also do:
   * \code
   * m = m.adjoint().eval();
   * \endcode
   *
   * \sa adjointInPlace(), transpose(), conjugate(), class Transpose, class internal::scalar_conjugate_op */
 template<typename Derived>
-inline const typename MatrixBase<Derived>::AdjointReturnType
+EIGEN_DEVICE_FUNC inline const typename MatrixBase<Derived>::AdjointReturnType
 MatrixBase<Derived>::adjoint() const
 {
   return AdjointReturnType(this->transpose());
 }
 
 /***************************************************************************
 * "in place" transpose implementation
@@ -224,19 +235,18 @@
         (int(MatrixType::RowsAtCompileTime) == int(internal::packet_traits<typename MatrixType::Scalar>::size))
     &&  (internal::evaluator<MatrixType>::Flags&PacketAccessBit) >
 struct inplace_transpose_selector;
 
 template<typename MatrixType>
 struct inplace_transpose_selector<MatrixType,true,false> { // square matrix
   static void run(MatrixType& m) {
-    m.matrix().template triangularView<StrictlyUpper>().swap(m.matrix().transpose());
+    m.matrix().template triangularView<StrictlyUpper>().swap(m.matrix().transpose().template triangularView<StrictlyUpper>());
   }
 };
 
-// TODO: vectorized path is currently limited to LargestPacketSize x LargestPacketSize cases only.
 template<typename MatrixType>
 struct inplace_transpose_selector<MatrixType,true,true> { // PacketSize x PacketSize
   static void run(MatrixType& m) {
     typedef typename MatrixType::Scalar Scalar;
     typedef typename internal::packet_traits<typename MatrixType::Scalar>::type Packet;
     const Index PacketSize = internal::packet_traits<Scalar>::size;
     const Index Alignment = internal::evaluator<MatrixType>::Alignment;
@@ -245,24 +255,74 @@
       A.packet[i] = m.template packetByOuterInner<Alignment>(i,0);
     internal::ptranspose(A);
     for (Index i=0; i<PacketSize; ++i)
       m.template writePacket<Alignment>(m.rowIndexByOuterInner(i,0), m.colIndexByOuterInner(i,0), A.packet[i]);
   }
 };
 
+
+template <typename MatrixType, Index Alignment>
+void BlockedInPlaceTranspose(MatrixType& m) {
+  typedef typename MatrixType::Scalar Scalar;
+  typedef typename internal::packet_traits<typename MatrixType::Scalar>::type Packet;
+  const Index PacketSize = internal::packet_traits<Scalar>::size;
+  eigen_assert(m.rows() == m.cols());
+  int row_start = 0;
+  for (; row_start + PacketSize <= m.rows(); row_start += PacketSize) {
+    for (int col_start = row_start; col_start + PacketSize <= m.cols(); col_start += PacketSize) {
+      PacketBlock<Packet> A;
+      if (row_start == col_start) {
+        for (Index i=0; i<PacketSize; ++i)
+          A.packet[i] = m.template packetByOuterInner<Alignment>(row_start + i,col_start);
+        internal::ptranspose(A);
+        for (Index i=0; i<PacketSize; ++i)
+          m.template writePacket<Alignment>(m.rowIndexByOuterInner(row_start + i, col_start), m.colIndexByOuterInner(row_start + i,col_start), A.packet[i]);
+      } else {
+        PacketBlock<Packet> B;
+        for (Index i=0; i<PacketSize; ++i) {
+          A.packet[i] = m.template packetByOuterInner<Alignment>(row_start + i,col_start);
+          B.packet[i] = m.template packetByOuterInner<Alignment>(col_start + i, row_start);
+        }
+        internal::ptranspose(A);
+        internal::ptranspose(B);
+        for (Index i=0; i<PacketSize; ++i) {
+          m.template writePacket<Alignment>(m.rowIndexByOuterInner(row_start + i, col_start), m.colIndexByOuterInner(row_start + i,col_start), B.packet[i]);
+          m.template writePacket<Alignment>(m.rowIndexByOuterInner(col_start + i, row_start), m.colIndexByOuterInner(col_start + i,row_start), A.packet[i]);
+        }
+      }
+    }
+  }
+  for (Index row = row_start; row < m.rows(); ++row) {
+    m.matrix().row(row).head(row).swap(
+        m.matrix().col(row).head(row).transpose());
+  }
+}
+
 template<typename MatrixType,bool MatchPacketSize>
-struct inplace_transpose_selector<MatrixType,false,MatchPacketSize> { // non square matrix
+struct inplace_transpose_selector<MatrixType,false,MatchPacketSize> { // non square or dynamic matrix
   static void run(MatrixType& m) {
-    if (m.rows()==m.cols())
-      m.matrix().template triangularView<StrictlyUpper>().swap(m.matrix().transpose());
-    else
+    typedef typename MatrixType::Scalar Scalar;
+    if (m.rows() == m.cols()) {
+      const Index PacketSize = internal::packet_traits<Scalar>::size;
+      if (!NumTraits<Scalar>::IsComplex && m.rows() >= PacketSize) {
+        if ((m.rows() % PacketSize) == 0)
+          BlockedInPlaceTranspose<MatrixType,internal::evaluator<MatrixType>::Alignment>(m);
+        else
+          BlockedInPlaceTranspose<MatrixType,Unaligned>(m);
+      }
+      else {
+        m.matrix().template triangularView<StrictlyUpper>().swap(m.matrix().transpose().template triangularView<StrictlyUpper>());
+      }
+    } else {
       m = m.transpose().eval();
+    }
   }
 };
 
+
 } // end namespace internal
 
 /** This is the "in place" version of transpose(): it replaces \c *this by its own transpose.
   * Thus, doing
   * \code
   * m.transposeInPlace();
   * \endcode
@@ -272,20 +332,20 @@
   * \endcode
   * and is faster and also safer because in the latter line of code, forgetting the eval() results
   * in a bug caused by \ref TopicAliasing "aliasing".
   *
   * Notice however that this method is only useful if you want to replace a matrix by its own transpose.
   * If you just need the transpose of a matrix, use transpose().
   *
-  * \note if the matrix is not square, then \c *this must be a resizable matrix. 
+  * \note if the matrix is not square, then \c *this must be a resizable matrix.
   * This excludes (non-square) fixed-size matrices, block-expressions and maps.
   *
   * \sa transpose(), adjoint(), adjointInPlace() */
 template<typename Derived>
-inline void DenseBase<Derived>::transposeInPlace()
+EIGEN_DEVICE_FUNC inline void DenseBase<Derived>::transposeInPlace()
 {
   eigen_assert((rows() == cols() || (RowsAtCompileTime == Dynamic && ColsAtCompileTime == Dynamic))
                && "transposeInPlace() called on a non-square non-resizable matrix");
   internal::inplace_transpose_selector<Derived>::run(derived());
 }
 
 /***************************************************************************
@@ -308,15 +368,15 @@
   * If you just need the adjoint of a matrix, use adjoint().
   *
   * \note if the matrix is not square, then \c *this must be a resizable matrix.
   * This excludes (non-square) fixed-size matrices, block-expressions and maps.
   *
   * \sa transpose(), adjoint(), transposeInPlace() */
 template<typename Derived>
-inline void MatrixBase<Derived>::adjointInPlace()
+EIGEN_DEVICE_FUNC inline void MatrixBase<Derived>::adjointInPlace()
 {
   derived() = adjoint().eval();
 }
 
 #ifndef EIGEN_NO_DEBUG
 
 // The following is to detect aliasing problems in most common cases.
@@ -387,15 +447,16 @@
     {
     }
 };
 
 template<typename Dst, typename Src>
 void check_for_aliasing(const Dst &dst, const Src &src)
 {
-  internal::checkTransposeAliasing_impl<Dst, Src>::run(dst, src);
+  if((!Dst::IsVectorAtCompileTime) && dst.rows()>1 && dst.cols()>1)
+    internal::checkTransposeAliasing_impl<Dst, Src>::run(dst, src);
 }
 
 } // end namespace internal
 
 #endif // EIGEN_NO_DEBUG
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/Transpositions.h` & `chronogram-0.2.0/include/Eigen/src/Core/Transpositions.h`

 * *Files 9% similar despite different names*

```diff
@@ -6,72 +6,69 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_TRANSPOSITIONS_H
 #define EIGEN_TRANSPOSITIONS_H
 
-namespace Eigen { 
+namespace Eigen {
 
 template<typename Derived>
 class TranspositionsBase
 {
     typedef internal::traits<Derived> Traits;
-    
+
   public:
 
     typedef typename Traits::IndicesType IndicesType;
     typedef typename IndicesType::Scalar StorageIndex;
     typedef Eigen::Index Index; ///< \deprecated since Eigen 3.3
 
+    EIGEN_DEVICE_FUNC
     Derived& derived() { return *static_cast<Derived*>(this); }
+    EIGEN_DEVICE_FUNC
     const Derived& derived() const { return *static_cast<const Derived*>(this); }
 
     /** Copies the \a other transpositions into \c *this */
     template<typename OtherDerived>
     Derived& operator=(const TranspositionsBase<OtherDerived>& other)
     {
       indices() = other.indices();
       return derived();
     }
-    
-    #ifndef EIGEN_PARSED_BY_DOXYGEN
-    /** This is a special case of the templated operator=. Its purpose is to
-      * prevent a default operator= from hiding the templated operator=.
-      */
-    Derived& operator=(const TranspositionsBase& other)
-    {
-      indices() = other.indices();
-      return derived();
-    }
-    #endif
 
     /** \returns the number of transpositions */
+    EIGEN_DEVICE_FUNC
     Index size() const { return indices().size(); }
     /** \returns the number of rows of the equivalent permutation matrix */
+    EIGEN_DEVICE_FUNC
     Index rows() const { return indices().size(); }
     /** \returns the number of columns of the equivalent permutation matrix */
+    EIGEN_DEVICE_FUNC
     Index cols() const { return indices().size(); }
 
     /** Direct access to the underlying index vector */
+    EIGEN_DEVICE_FUNC
     inline const StorageIndex& coeff(Index i) const { return indices().coeff(i); }
     /** Direct access to the underlying index vector */
     inline StorageIndex& coeffRef(Index i) { return indices().coeffRef(i); }
     /** Direct access to the underlying index vector */
     inline const StorageIndex& operator()(Index i) const { return indices()(i); }
     /** Direct access to the underlying index vector */
     inline StorageIndex& operator()(Index i) { return indices()(i); }
     /** Direct access to the underlying index vector */
     inline const StorageIndex& operator[](Index i) const { return indices()(i); }
     /** Direct access to the underlying index vector */
     inline StorageIndex& operator[](Index i) { return indices()(i); }
 
     /** const version of indices(). */
+    EIGEN_DEVICE_FUNC
     const IndicesType& indices() const { return derived().indices(); }
     /** \returns a reference to the stored array representing the transpositions. */
+    EIGEN_DEVICE_FUNC
     IndicesType& indices() { return derived().indices(); }
 
     /** Resizes to given size. */
     inline void resize(Index newSize)
     {
       indices().resize(newSize);
     }
@@ -80,15 +77,15 @@
     void setIdentity()
     {
       for(StorageIndex i = 0; i < indices().size(); ++i)
         coeffRef(i) = i;
     }
 
     // FIXME: do we want such methods ?
-    // might be usefull when the target matrix expression is complex, e.g.:
+    // might be useful when the target matrix expression is complex, e.g.:
     // object.matrix().block(..,..,..,..) = trans * object.matrix().block(..,..,..,..);
     /*
     template<typename MatrixType>
     void applyForwardToRows(MatrixType& mat) const
     {
       for(Index k=0 ; k<size() ; ++k)
         if(m_indices(k)!=k)
@@ -167,51 +164,36 @@
     inline Transpositions() {}
 
     /** Copy constructor. */
     template<typename OtherDerived>
     inline Transpositions(const TranspositionsBase<OtherDerived>& other)
       : m_indices(other.indices()) {}
 
-    #ifndef EIGEN_PARSED_BY_DOXYGEN
-    /** Standard copy constructor. Defined only to prevent a default copy constructor
-      * from hiding the other templated constructor */
-    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}
-    #endif
-
     /** Generic constructor from expression of the transposition indices. */
     template<typename Other>
     explicit inline Transpositions(const MatrixBase<Other>& indices) : m_indices(indices)
     {}
 
     /** Copies the \a other transpositions into \c *this */
     template<typename OtherDerived>
     Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)
     {
       return Base::operator=(other);
     }
 
-    #ifndef EIGEN_PARSED_BY_DOXYGEN
-    /** This is a special case of the templated operator=. Its purpose is to
-      * prevent a default operator= from hiding the templated operator=.
-      */
-    Transpositions& operator=(const Transpositions& other)
-    {
-      m_indices = other.m_indices;
-      return *this;
-    }
-    #endif
-
     /** Constructs an uninitialized permutation matrix of given size.
       */
     inline Transpositions(Index size) : m_indices(size)
     {}
 
     /** const version of indices(). */
+    EIGEN_DEVICE_FUNC
     const IndicesType& indices() const { return m_indices; }
     /** \returns a reference to the stored array representing the transpositions. */
+    EIGEN_DEVICE_FUNC
     IndicesType& indices() { return m_indices; }
 
   protected:
 
     IndicesType m_indices;
 };
 
@@ -261,17 +243,19 @@
     {
       m_indices = other.m_indices;
       return *this;
     }
     #endif
 
     /** const version of indices(). */
+    EIGEN_DEVICE_FUNC
     const IndicesType& indices() const { return m_indices; }
-    
+
     /** \returns a reference to the stored array representing the transpositions. */
+    EIGEN_DEVICE_FUNC
     IndicesType& indices() { return m_indices; }
 
   protected:
 
     IndicesType m_indices;
 };
 
@@ -302,29 +286,20 @@
     /** Copies the \a other transpositions into \c *this */
     template<typename OtherDerived>
     TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)
     {
       return Base::operator=(other);
     }
 
-    #ifndef EIGEN_PARSED_BY_DOXYGEN
-    /** This is a special case of the templated operator=. Its purpose is to
-      * prevent a default operator= from hiding the templated operator=.
-      */
-    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)
-    {
-      m_indices = other.m_indices;
-      return *this;
-    }
-    #endif
-
     /** const version of indices(). */
+    EIGEN_DEVICE_FUNC
     const IndicesType& indices() const { return m_indices; }
 
     /** \returns a reference to the stored array representing the transpositions. */
+    EIGEN_DEVICE_FUNC
     IndicesType& indices() { return m_indices; }
 
   protected:
 
     typename IndicesType::Nested m_indices;
 };
 
@@ -370,17 +345,20 @@
 {
     typedef TranspositionsDerived TranspositionType;
     typedef typename TranspositionType::IndicesType IndicesType;
   public:
 
     explicit Transpose(const TranspositionType& t) : m_transpositions(t) {}
 
-    Index size() const { return m_transpositions.size(); }
-    Index rows() const { return m_transpositions.size(); }
-    Index cols() const { return m_transpositions.size(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index size() const EIGEN_NOEXCEPT { return m_transpositions.size(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return m_transpositions.size(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return m_transpositions.size(); }
 
     /** \returns the \a matrix with the inverse transpositions applied to the columns.
       */
     template<typename OtherDerived> friend
     const Product<OtherDerived, Transpose, AliasFreeProduct>
     operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trt)
     {
@@ -391,15 +369,16 @@
       */
     template<typename OtherDerived>
     const Product<Transpose, OtherDerived, AliasFreeProduct>
     operator*(const MatrixBase<OtherDerived>& matrix) const
     {
       return Product<Transpose, OtherDerived, AliasFreeProduct>(*this, matrix.derived());
     }
-    
+
+    EIGEN_DEVICE_FUNC
     const TranspositionType& nestedExpression() const { return m_transpositions; }
 
   protected:
     const TranspositionType& m_transpositions;
 };
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/TriangularMatrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/TriangularMatrix.h`

 * *Files 2% similar despite different names*

```diff
@@ -7,20 +7,20 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_TRIANGULARMATRIX_H
 #define EIGEN_TRIANGULARMATRIX_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
-  
+
 template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval;
-  
+
 }
 
 /** \class TriangularBase
   * \ingroup Core_Module
   *
   * \brief Base class for triangular part in a matrix
   */
@@ -30,45 +30,46 @@
 
     enum {
       Mode = internal::traits<Derived>::Mode,
       RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,
       ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,
       MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,
-      
+
       SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,
                                                    internal::traits<Derived>::ColsAtCompileTime>::ret),
       /**< This is equal to the number of coefficients, i.e. the number of
           * rows times the number of columns, or to \a Dynamic if this is not
           * known at compile-time. \sa RowsAtCompileTime, ColsAtCompileTime */
-      
+
       MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,
                                                    internal::traits<Derived>::MaxColsAtCompileTime>::ret)
-        
+
     };
     typedef typename internal::traits<Derived>::Scalar Scalar;
     typedef typename internal::traits<Derived>::StorageKind StorageKind;
     typedef typename internal::traits<Derived>::StorageIndex StorageIndex;
     typedef typename internal::traits<Derived>::FullMatrixType DenseMatrixType;
     typedef DenseMatrixType DenseType;
     typedef Derived const& Nested;
 
     EIGEN_DEVICE_FUNC
-    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }
+    inline TriangularBase() { eigen_assert(!((int(Mode) & int(UnitDiag)) && (int(Mode) & int(ZeroDiag)))); }
+
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return derived().rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return derived().cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index outerStride() const EIGEN_NOEXCEPT { return derived().outerStride(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index innerStride() const EIGEN_NOEXCEPT { return derived().innerStride(); }
 
-    EIGEN_DEVICE_FUNC
-    inline Index rows() const { return derived().rows(); }
-    EIGEN_DEVICE_FUNC
-    inline Index cols() const { return derived().cols(); }
-    EIGEN_DEVICE_FUNC
-    inline Index outerStride() const { return derived().outerStride(); }
-    EIGEN_DEVICE_FUNC
-    inline Index innerStride() const { return derived().innerStride(); }
-    
     // dummy resize function
+    EIGEN_DEVICE_FUNC
     void resize(Index rows, Index cols)
     {
       EIGEN_UNUSED_VARIABLE(rows);
       EIGEN_UNUSED_VARIABLE(cols);
       eigen_assert(rows==this->rows() && cols==this->cols());
     }
 
@@ -151,15 +152,15 @@
   * \ingroup Core_Module
   *
   * \brief Expression of a triangular part in a matrix
   *
   * \param MatrixType the type of the object in which we are taking the triangular part
   * \param Mode the kind of triangular matrix expression to construct. Can be #Upper,
   *             #Lower, #UnitUpper, #UnitLower, #StrictlyUpper, or #StrictlyLower.
-  *             This is in fact a bit field; it must have either #Upper or #Lower, 
+  *             This is in fact a bit field; it must have either #Upper or #Lower,
   *             and additionally it may have #UnitDiag or #ZeroDiag or neither.
   *
   * This class represents a triangular part of a matrix, not necessarily square. Strictly speaking, for rectangular
   * matrices one should speak of "trapezoid" parts. This class is the return type
   * of MatrixBase::triangularView() and SparseMatrixBase::triangularView(), and most of the time this is the only way it is used.
   *
   * \sa MatrixBase::triangularView()
@@ -193,15 +194,16 @@
     typedef _MatrixType MatrixType;
 
   protected:
     typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;
     typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;
 
     typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;
-    
+    typedef TriangularView<typename internal::add_const<MatrixType>::type, _Mode> ConstTriangularView;
+
   public:
 
     typedef typename internal::traits<TriangularView>::StorageKind StorageKind;
     typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned NestedExpression;
 
     enum {
       Mode = _Mode,
@@ -212,40 +214,50 @@
                     | (Mode & (ZeroDiag)),
       IsVectorAtCompileTime = false
     };
 
     EIGEN_DEVICE_FUNC
     explicit inline TriangularView(MatrixType& matrix) : m_matrix(matrix)
     {}
-    
-    using Base::operator=;
-    TriangularView& operator=(const TriangularView &other)
-    { return Base::operator=(other); }
+
+    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(TriangularView)
 
     /** \copydoc EigenBase::rows() */
-    EIGEN_DEVICE_FUNC
-    inline Index rows() const { return m_matrix.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }
     /** \copydoc EigenBase::cols() */
-    EIGEN_DEVICE_FUNC
-    inline Index cols() const { return m_matrix.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
 
     /** \returns a const reference to the nested expression */
     EIGEN_DEVICE_FUNC
     const NestedExpression& nestedExpression() const { return m_matrix; }
 
     /** \returns a reference to the nested expression */
     EIGEN_DEVICE_FUNC
     NestedExpression& nestedExpression() { return m_matrix; }
-    
+
     typedef TriangularView<const MatrixConjugateReturnType,Mode> ConjugateReturnType;
     /** \sa MatrixBase::conjugate() const */
     EIGEN_DEVICE_FUNC
     inline const ConjugateReturnType conjugate() const
     { return ConjugateReturnType(m_matrix.conjugate()); }
 
+    /** \returns an expression of the complex conjugate of \c *this if Cond==true,
+     *           returns \c *this otherwise.
+     */
+    template<bool Cond>
+    EIGEN_DEVICE_FUNC
+    inline typename internal::conditional<Cond,ConjugateReturnType,ConstTriangularView>::type
+    conjugateIf() const
+    {
+      typedef typename internal::conditional<Cond,ConjugateReturnType,ConstTriangularView>::type ReturnType;
+      return ReturnType(m_matrix.template conjugateIf<Cond>());
+    }
+
     typedef TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> AdjointReturnType;
     /** \sa MatrixBase::adjoint() const */
     EIGEN_DEVICE_FUNC
     inline const AdjointReturnType adjoint() const
     { return AdjointReturnType(m_matrix.adjoint()); }
 
     typedef TriangularView<typename MatrixType::TransposeReturnType,TransposeMode> TransposeReturnType;
@@ -253,29 +265,29 @@
     EIGEN_DEVICE_FUNC
     inline TransposeReturnType transpose()
     {
       EIGEN_STATIC_ASSERT_LVALUE(MatrixType)
       typename MatrixType::TransposeReturnType tmp(m_matrix);
       return TransposeReturnType(tmp);
     }
-    
+
     typedef TriangularView<const typename MatrixType::ConstTransposeReturnType,TransposeMode> ConstTransposeReturnType;
     /** \sa MatrixBase::transpose() const */
     EIGEN_DEVICE_FUNC
     inline const ConstTransposeReturnType transpose() const
     {
       return ConstTransposeReturnType(m_matrix.transpose());
     }
 
     template<typename Other>
     EIGEN_DEVICE_FUNC
-    inline const Solve<TriangularView, Other> 
+    inline const Solve<TriangularView, Other>
     solve(const MatrixBase<Other>& other) const
     { return Solve<TriangularView, Other>(*this, other.derived()); }
-    
+
   // workaround MSVC ICE
   #if EIGEN_COMP_MSVC
     template<int Side, typename Other>
     EIGEN_DEVICE_FUNC
     inline const internal::triangular_solve_retval<Side,TriangularView, Other>
     solve(const MatrixBase<Other>& other) const
     { return Base::template solve<Side>(other); }
@@ -311,15 +323,15 @@
       if (Mode & UnitDiag)
         return 1;
       else if (Mode & ZeroDiag)
         return 0;
       else
         return m_matrix.diagonal().prod();
     }
-      
+
   protected:
 
     MatrixTypeNested m_matrix;
 };
 
 /** \ingroup Core_Module
   *
@@ -373,15 +385,15 @@
     /** \sa MatrixBase::operator-=() */
     template<typename Other>
     EIGEN_DEVICE_FUNC
     TriangularViewType&  operator-=(const DenseBase<Other>& other) {
       internal::call_assignment_no_alias(derived(), other.derived(), internal::sub_assign_op<Scalar,typename Other::Scalar>());
       return derived();
     }
-    
+
     /** \sa MatrixBase::operator*=() */
     EIGEN_DEVICE_FUNC
     TriangularViewType&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = derived().nestedExpression() * other; }
     /** \sa DenseBase::operator/=() */
     EIGEN_DEVICE_FUNC
     TriangularViewType&  operator/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = derived().nestedExpression() / other; }
 
@@ -431,22 +443,22 @@
     TriangularViewType& operator=(const MatrixBase<OtherDerived>& other);
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
     EIGEN_DEVICE_FUNC
     TriangularViewType& operator=(const TriangularViewImpl& other)
     { return *this = other.derived().nestedExpression(); }
 
-    /** \deprecated */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC
+    /** \deprecated */
+    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC
     void lazyAssign(const TriangularBase<OtherDerived>& other);
 
-    /** \deprecated */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC
+    /** \deprecated */
+    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC
     void lazyAssign(const MatrixBase<OtherDerived>& other);
 #endif
 
     /** Efficient triangular matrix times vector/matrix product */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     const Product<TriangularViewType,OtherDerived>
@@ -466,15 +478,15 @@
 
     /** \returns the product of the inverse of \c *this with \a other, \a *this being triangular.
       *
       * This function computes the inverse-matrix matrix product inverse(\c *this) * \a other if
       * \a Side==OnTheLeft (the default), or the right-inverse-multiply  \a other * inverse(\c *this) if
       * \a Side==OnTheRight.
       *
-      * Note that the template parameter \c Side can be ommitted, in which case \c Side==OnTheLeft
+      * Note that the template parameter \c Side can be omitted, in which case \c Side==OnTheLeft
       *
       * The matrix \c *this must be triangular and invertible (i.e., all the coefficients of the
       * diagonal must be non zero). It works as a forward (resp. backward) substitution if \c *this
       * is an upper (resp. lower) triangular matrix.
       *
       * Example: \include Triangular_solve.cpp
       * Output: \verbinclude Triangular_solve.out
@@ -484,24 +496,23 @@
       *
       * For users coming from BLAS, this function (and more specifically solveInPlace()) offer
       * all the operations supported by the \c *TRSV and \c *TRSM BLAS routines.
       *
       * \sa TriangularView::solveInPlace()
       */
     template<int Side, typename Other>
-    EIGEN_DEVICE_FUNC
     inline const internal::triangular_solve_retval<Side,TriangularViewType, Other>
     solve(const MatrixBase<Other>& other) const;
 
     /** "in-place" version of TriangularView::solve() where the result is written in \a other
       *
       * \warning The parameter is only marked 'const' to make the C++ compiler accept a temporary expression here.
       * This function will const_cast it, so constness isn't honored here.
       *
-      * Note that the template parameter \c Side can be ommitted, in which case \c Side==OnTheLeft
+      * Note that the template parameter \c Side can be omitted, in which case \c Side==OnTheLeft
       *
       * See TriangularView:solve() for the details.
       */
     template<int Side, typename OtherDerived>
     EIGEN_DEVICE_FUNC
     void solveInPlace(const MatrixBase<OtherDerived>& other) const;
 
@@ -519,18 +530,18 @@
     void swap(TriangularBase<OtherDerived> const & other)
 #endif
     {
       EIGEN_STATIC_ASSERT_LVALUE(OtherDerived);
       call_assignment(derived(), other.const_cast_derived(), internal::swap_assign_op<Scalar>());
     }
 
-    /** \deprecated
-      * Shortcut for \code (*this).swap(other.triangularView<(*this)::Mode>()) \endcode */
+    /** Shortcut for \code (*this).swap(other.triangularView<(*this)::Mode>()) \endcode */
     template<typename OtherDerived>
-    EIGEN_DEVICE_FUNC
+    /** \deprecated */
+    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC
     void swap(MatrixBase<OtherDerived> const & other)
     {
       EIGEN_STATIC_ASSERT_LVALUE(OtherDerived);
       call_assignment(derived(), other.const_cast_derived(), internal::swap_assign_op<Scalar>());
     }
 
     template<typename RhsType, typename DstType>
@@ -540,69 +551,73 @@
         dst = rhs;
       this->solveInPlace(dst);
     }
 
     template<typename ProductType>
     EIGEN_DEVICE_FUNC
     EIGEN_STRONG_INLINE TriangularViewType& _assignProduct(const ProductType& prod, const Scalar& alpha, bool beta);
+  protected:
+    EIGEN_DEFAULT_COPY_CONSTRUCTOR(TriangularViewImpl)
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(TriangularViewImpl)
+
 };
 
 /***************************************************************************
 * Implementation of triangular evaluation/assignment
 ***************************************************************************/
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 // FIXME should we keep that possibility
 template<typename MatrixType, unsigned int Mode>
 template<typename OtherDerived>
-inline TriangularView<MatrixType, Mode>&
+EIGEN_DEVICE_FUNC inline TriangularView<MatrixType, Mode>&
 TriangularViewImpl<MatrixType, Mode, Dense>::operator=(const MatrixBase<OtherDerived>& other)
 {
   internal::call_assignment_no_alias(derived(), other.derived(), internal::assign_op<Scalar,typename OtherDerived::Scalar>());
   return derived();
 }
 
 // FIXME should we keep that possibility
 template<typename MatrixType, unsigned int Mode>
 template<typename OtherDerived>
-void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const MatrixBase<OtherDerived>& other)
+EIGEN_DEVICE_FUNC void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const MatrixBase<OtherDerived>& other)
 {
   internal::call_assignment_no_alias(derived(), other.template triangularView<Mode>());
 }
 
 
 
 template<typename MatrixType, unsigned int Mode>
 template<typename OtherDerived>
-inline TriangularView<MatrixType, Mode>&
+EIGEN_DEVICE_FUNC inline TriangularView<MatrixType, Mode>&
 TriangularViewImpl<MatrixType, Mode, Dense>::operator=(const TriangularBase<OtherDerived>& other)
 {
   eigen_assert(Mode == int(OtherDerived::Mode));
   internal::call_assignment(derived(), other.derived());
   return derived();
 }
 
 template<typename MatrixType, unsigned int Mode>
 template<typename OtherDerived>
-void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const TriangularBase<OtherDerived>& other)
+EIGEN_DEVICE_FUNC void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const TriangularBase<OtherDerived>& other)
 {
   eigen_assert(Mode == int(OtherDerived::Mode));
   internal::call_assignment_no_alias(derived(), other.derived());
 }
 #endif
 
 /***************************************************************************
 * Implementation of TriangularBase methods
 ***************************************************************************/
 
 /** Assigns a triangular or selfadjoint matrix to a dense matrix.
   * If the matrix is triangular, the opposite part is set to zero. */
 template<typename Derived>
 template<typename DenseDerived>
-void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const
+EIGEN_DEVICE_FUNC void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const
 {
   evalToLazy(other.derived());
 }
 
 /***************************************************************************
 * Implementation of TriangularView methods
 ***************************************************************************/
@@ -620,23 +635,25 @@
   * Example: \include MatrixBase_triangularView.cpp
   * Output: \verbinclude MatrixBase_triangularView.out
   *
   * \sa class TriangularView
   */
 template<typename Derived>
 template<unsigned int Mode>
+EIGEN_DEVICE_FUNC
 typename MatrixBase<Derived>::template TriangularViewReturnType<Mode>::Type
 MatrixBase<Derived>::triangularView()
 {
   return typename TriangularViewReturnType<Mode>::Type(derived());
 }
 
 /** This is the const version of MatrixBase::triangularView() */
 template<typename Derived>
 template<unsigned int Mode>
+EIGEN_DEVICE_FUNC
 typename MatrixBase<Derived>::template ConstTriangularViewReturnType<Mode>::Type
 MatrixBase<Derived>::triangularView() const
 {
   return typename ConstTriangularViewReturnType<Mode>::Type(derived());
 }
 
 /** \returns true if *this is approximately equal to an upper triangular matrix,
@@ -694,15 +711,15 @@
 ****************************************************************************
 * Evaluators and Assignment of triangular expressions
 ***************************************************************************
 ***************************************************************************/
 
 namespace internal {
 
-  
+
 // TODO currently a triangular expression has the form TriangularView<.,.>
 //      in the future triangular-ness should be defined by the expression traits
 //      such that Transpose<TriangularView<.,.> > is valid. (currently TriangularBase::transpose() is overloaded to make it work)
 template<typename MatrixType, unsigned int Mode>
 struct evaluator_traits<TriangularView<MatrixType,Mode> >
 {
   typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;
@@ -711,26 +728,27 @@
 
 template<typename MatrixType, unsigned int Mode>
 struct unary_evaluator<TriangularView<MatrixType,Mode>, IndexBased>
  : evaluator<typename internal::remove_all<MatrixType>::type>
 {
   typedef TriangularView<MatrixType,Mode> XprType;
   typedef evaluator<typename internal::remove_all<MatrixType>::type> Base;
+  EIGEN_DEVICE_FUNC
   unary_evaluator(const XprType &xpr) : Base(xpr.nestedExpression()) {}
 };
 
 // Additional assignment kinds:
 struct Triangular2Triangular    {};
 struct Triangular2Dense         {};
 struct Dense2Triangular         {};
 
 
 template<typename Kernel, unsigned int Mode, int UnrollCount, bool ClearOpposite> struct triangular_assignment_loop;
 
- 
+
 /** \internal Specialization of the dense assignment kernel for triangular matrices.
   * The main difference is that the triangular, diagonal, and opposite parts are processed through three different functions.
   * \tparam UpLo must be either Lower or Upper
   * \tparam Mode must be either 0, UnitDiag, ZeroDiag, or SelfAdjoint
   */
 template<int UpLo, int Mode, int SetOpposite, typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT, typename Functor, int Version = Specialized>
 class triangular_dense_assignment_kernel : public generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version>
@@ -739,44 +757,44 @@
   typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version> Base;
   typedef typename Base::DstXprType DstXprType;
   typedef typename Base::SrcXprType SrcXprType;
   using Base::m_dst;
   using Base::m_src;
   using Base::m_functor;
 public:
-  
+
   typedef typename Base::DstEvaluatorType DstEvaluatorType;
   typedef typename Base::SrcEvaluatorType SrcEvaluatorType;
   typedef typename Base::Scalar Scalar;
   typedef typename Base::AssignmentTraits AssignmentTraits;
-  
-  
+
+
   EIGEN_DEVICE_FUNC triangular_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)
     : Base(dst, src, func, dstExpr)
   {}
-  
+
 #ifdef EIGEN_INTERNAL_DEBUGGING
   EIGEN_DEVICE_FUNC void assignCoeff(Index row, Index col)
   {
     eigen_internal_assert(row!=col);
     Base::assignCoeff(row,col);
   }
 #else
   using Base::assignCoeff;
 #endif
-  
+
   EIGEN_DEVICE_FUNC void assignDiagonalCoeff(Index id)
   {
          if(Mode==UnitDiag && SetOpposite) m_functor.assignCoeff(m_dst.coeffRef(id,id), Scalar(1));
     else if(Mode==ZeroDiag && SetOpposite) m_functor.assignCoeff(m_dst.coeffRef(id,id), Scalar(0));
     else if(Mode==0)                       Base::assignCoeff(id,id);
   }
-  
+
   EIGEN_DEVICE_FUNC void assignOppositeCoeff(Index row, Index col)
-  { 
+  {
     eigen_internal_assert(row!=col);
     if(SetOpposite)
       m_functor.assignCoeff(m_dst.coeffRef(row,col), Scalar(0));
   }
 };
 
 template<int Mode, bool SetOpposite, typename DstXprType, typename SrcXprType, typename Functor>
@@ -789,25 +807,25 @@
   SrcEvaluatorType srcEvaluator(src);
 
   Index dstRows = src.rows();
   Index dstCols = src.cols();
   if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
     dst.resize(dstRows, dstCols);
   DstEvaluatorType dstEvaluator(dst);
-    
+
   typedef triangular_dense_assignment_kernel< Mode&(Lower|Upper),Mode&(UnitDiag|ZeroDiag|SelfAdjoint),SetOpposite,
                                               DstEvaluatorType,SrcEvaluatorType,Functor> Kernel;
   Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());
-  
+
   enum {
       unroll = DstXprType::SizeAtCompileTime != Dynamic
             && SrcEvaluatorType::CoeffReadCost < HugeCost
-            && DstXprType::SizeAtCompileTime * (DstEvaluatorType::CoeffReadCost+SrcEvaluatorType::CoeffReadCost) / 2 <= EIGEN_UNROLLING_LIMIT
+            && DstXprType::SizeAtCompileTime * (int(DstEvaluatorType::CoeffReadCost) + int(SrcEvaluatorType::CoeffReadCost)) / 2 <= EIGEN_UNROLLING_LIMIT
     };
-  
+
   triangular_assignment_loop<Kernel, Mode, unroll ? int(DstXprType::SizeAtCompileTime) : Dynamic, SetOpposite>::run(kernel);
 }
 
 template<int Mode, bool SetOpposite, typename DstXprType, typename SrcXprType>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 void call_triangular_assignment_loop(DstXprType& dst, const SrcXprType& src)
 {
@@ -821,57 +839,57 @@
 
 template< typename DstXprType, typename SrcXprType, typename Functor>
 struct Assignment<DstXprType, SrcXprType, Functor, Triangular2Triangular>
 {
   EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)
   {
     eigen_assert(int(DstXprType::Mode) == int(SrcXprType::Mode));
-    
-    call_triangular_assignment_loop<DstXprType::Mode, false>(dst, src, func);  
+
+    call_triangular_assignment_loop<DstXprType::Mode, false>(dst, src, func);
   }
 };
 
 template< typename DstXprType, typename SrcXprType, typename Functor>
 struct Assignment<DstXprType, SrcXprType, Functor, Triangular2Dense>
 {
   EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)
   {
-    call_triangular_assignment_loop<SrcXprType::Mode, (SrcXprType::Mode&SelfAdjoint)==0>(dst, src, func);  
+    call_triangular_assignment_loop<SrcXprType::Mode, (int(SrcXprType::Mode) & int(SelfAdjoint)) == 0>(dst, src, func);
   }
 };
 
 template< typename DstXprType, typename SrcXprType, typename Functor>
 struct Assignment<DstXprType, SrcXprType, Functor, Dense2Triangular>
 {
   EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)
   {
-    call_triangular_assignment_loop<DstXprType::Mode, false>(dst, src, func);  
+    call_triangular_assignment_loop<DstXprType::Mode, false>(dst, src, func);
   }
 };
 
 
 template<typename Kernel, unsigned int Mode, int UnrollCount, bool SetOpposite>
 struct triangular_assignment_loop
 {
   // FIXME: this is not very clean, perhaps this information should be provided by the kernel?
   typedef typename Kernel::DstEvaluatorType DstEvaluatorType;
   typedef typename DstEvaluatorType::XprType DstXprType;
-  
+
   enum {
     col = (UnrollCount-1) / DstXprType::RowsAtCompileTime,
     row = (UnrollCount-1) % DstXprType::RowsAtCompileTime
   };
-  
+
   typedef typename Kernel::Scalar Scalar;
 
   EIGEN_DEVICE_FUNC
   static inline void run(Kernel &kernel)
   {
     triangular_assignment_loop<Kernel, Mode, UnrollCount-1, SetOpposite>::run(kernel);
-    
+
     if(row==col)
       kernel.assignDiagonalCoeff(row);
     else if( ((Mode&Lower) && row>col) || ((Mode&Upper) && row<col) )
       kernel.assignCoeff(row,col);
     else if(SetOpposite)
       kernel.assignOppositeCoeff(row,col);
   }
@@ -906,18 +924,18 @@
       {
         for(; i < maxi; ++i)
           if(Mode&Upper) kernel.assignCoeff(i, j);
           else           kernel.assignOppositeCoeff(i, j);
       }
       else
         i = maxi;
-      
+
       if(i<kernel.rows()) // then i==j
         kernel.assignDiagonalCoeff(i++);
-      
+
       if (((Mode&Upper) && SetOpposite) || (Mode&Lower))
       {
         for(; i < kernel.rows(); ++i)
           if(Mode&Lower) kernel.assignCoeff(i, j);
           else           kernel.assignOppositeCoeff(i, j);
       }
     }
@@ -926,57 +944,57 @@
 
 } // end namespace internal
 
 /** Assigns a triangular or selfadjoint matrix to a dense matrix.
   * If the matrix is triangular, the opposite part is set to zero. */
 template<typename Derived>
 template<typename DenseDerived>
-void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const
+EIGEN_DEVICE_FUNC void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const
 {
   other.derived().resize(this->rows(), this->cols());
-  internal::call_triangular_assignment_loop<Derived::Mode,(Derived::Mode&SelfAdjoint)==0 /* SetOpposite */>(other.derived(), derived().nestedExpression());
+  internal::call_triangular_assignment_loop<Derived::Mode, (int(Derived::Mode) & int(SelfAdjoint)) == 0 /* SetOpposite */>(other.derived(), derived().nestedExpression());
 }
 
 namespace internal {
-  
+
 // Triangular = Product
 template< typename DstXprType, typename Lhs, typename Rhs, typename Scalar>
 struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>
 {
   typedef Product<Lhs,Rhs,DefaultProduct> SrcXprType;
   static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,typename SrcXprType::Scalar> &)
   {
     Index dstRows = src.rows();
     Index dstCols = src.cols();
     if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
       dst.resize(dstRows, dstCols);
 
-    dst._assignProduct(src, 1, 0);
+    dst._assignProduct(src, Scalar(1), false);
   }
 };
 
 // Triangular += Product
 template< typename DstXprType, typename Lhs, typename Rhs, typename Scalar>
 struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::add_assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>
 {
   typedef Product<Lhs,Rhs,DefaultProduct> SrcXprType;
   static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,typename SrcXprType::Scalar> &)
   {
-    dst._assignProduct(src, 1, 1);
+    dst._assignProduct(src, Scalar(1), true);
   }
 };
 
 // Triangular -= Product
 template< typename DstXprType, typename Lhs, typename Rhs, typename Scalar>
 struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::sub_assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>
 {
   typedef Product<Lhs,Rhs,DefaultProduct> SrcXprType;
   static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,typename SrcXprType::Scalar> &)
   {
-    dst._assignProduct(src, -1, 1);
+    dst._assignProduct(src, Scalar(-1), true);
   }
 };
 
 } // end namespace internal
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/VectorBlock.h` & `chronogram-0.2.0/include/Eigen/src/Core/VectorBlock.h`

 * *Files 2% similar despite different names*

```diff
@@ -31,15 +31,15 @@
   * \tparam VectorType the type of the object in which we are taking a sub-vector
   * \tparam Size size of the sub-vector we are taking at compile time (optional)
   *
   * This class represents an expression of either a fixed-size or dynamic-size sub-vector.
   * It is the return type of DenseBase::segment(Index,Index) and DenseBase::segment<int>(Index) and
   * most of the time this is the only way it is used.
   *
-  * However, if you want to directly maniputate sub-vector expressions,
+  * However, if you want to directly manipulate sub-vector expressions,
   * for instance if you want to write a function returning such an expression, you
   * will need to use this class.
   *
   * Here is an example illustrating the dynamic case:
   * \include class_VectorBlock.cpp
   * Output: \verbinclude class_VectorBlock.out
   *
@@ -67,27 +67,27 @@
   public:
     EIGEN_DENSE_PUBLIC_INTERFACE(VectorBlock)
 
     using Base::operator=;
 
     /** Dynamic-size constructor
       */
-    EIGEN_DEVICE_FUNC
-    inline VectorBlock(VectorType& vector, Index start, Index size)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    VectorBlock(VectorType& vector, Index start, Index size)
       : Base(vector,
              IsColVector ? start : 0, IsColVector ? 0 : start,
              IsColVector ? size  : 1, IsColVector ? 1 : size)
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(VectorBlock);
     }
 
     /** Fixed-size constructor
       */
-    EIGEN_DEVICE_FUNC
-    inline VectorBlock(VectorType& vector, Index start)
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    VectorBlock(VectorType& vector, Index start)
       : Base(vector, IsColVector ? start : 0, IsColVector ? 0 : start)
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(VectorBlock);
     }
 };
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/VectorwiseOp.h` & `chronogram-0.2.0/include/Eigen/src/Core/VectorwiseOp.h`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
-// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>
+// Copyright (C) 2008-2019 Gael Guennebaud <gael.guennebaud@inria.fr>
 // Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_PARTIAL_REDUX_H
@@ -61,117 +61,147 @@
     typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;
     EIGEN_DENSE_PUBLIC_INTERFACE(PartialReduxExpr)
 
     EIGEN_DEVICE_FUNC
     explicit PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())
       : m_matrix(mat), m_functor(func) {}
 
-    EIGEN_DEVICE_FUNC
-    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }
-    EIGEN_DEVICE_FUNC
-    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return (Direction==Vertical   ? 1 : m_matrix.rows()); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return (Direction==Horizontal ? 1 : m_matrix.cols()); }
 
     EIGEN_DEVICE_FUNC
     typename MatrixType::Nested nestedExpression() const { return m_matrix; }
 
     EIGEN_DEVICE_FUNC
     const MemberOp& functor() const { return m_functor; }
 
   protected:
     typename MatrixType::Nested m_matrix;
     const MemberOp m_functor;
 };
 
-#define EIGEN_MEMBER_FUNCTOR(MEMBER,COST)                               \
-  template <typename ResultType>                                        \
-  struct member_##MEMBER {                                              \
-    EIGEN_EMPTY_STRUCT_CTOR(member_##MEMBER)                            \
-    typedef ResultType result_type;                                     \
-    template<typename Scalar, int Size> struct Cost                     \
-    { enum { value = COST }; };                                         \
-    template<typename XprType>                                          \
-    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE                               \
-    ResultType operator()(const XprType& mat) const                     \
-    { return mat.MEMBER(); } \
+template<typename A,typename B> struct partial_redux_dummy_func;
+
+#define EIGEN_MAKE_PARTIAL_REDUX_FUNCTOR(MEMBER,COST,VECTORIZABLE,BINARYOP)                \
+  template <typename ResultType,typename Scalar>                                                            \
+  struct member_##MEMBER {                                                                  \
+    EIGEN_EMPTY_STRUCT_CTOR(member_##MEMBER)                                                \
+    typedef ResultType result_type;                                                         \
+    typedef BINARYOP<Scalar,Scalar> BinaryOp;   \
+    template<int Size> struct Cost { enum { value = COST }; };             \
+    enum { Vectorizable = VECTORIZABLE };                                                   \
+    template<typename XprType>                                                              \
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE                                                   \
+    ResultType operator()(const XprType& mat) const                                         \
+    { return mat.MEMBER(); }                                                                \
+    BinaryOp binaryFunc() const { return BinaryOp(); }                                      \
   }
 
+#define EIGEN_MEMBER_FUNCTOR(MEMBER,COST) \
+  EIGEN_MAKE_PARTIAL_REDUX_FUNCTOR(MEMBER,COST,0,partial_redux_dummy_func)
+
 namespace internal {
 
-EIGEN_MEMBER_FUNCTOR(squaredNorm, Size * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);
 EIGEN_MEMBER_FUNCTOR(norm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);
 EIGEN_MEMBER_FUNCTOR(stableNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);
 EIGEN_MEMBER_FUNCTOR(blueNorm, (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost);
 EIGEN_MEMBER_FUNCTOR(hypotNorm, (Size-1) * functor_traits<scalar_hypot_op<Scalar> >::Cost );
-EIGEN_MEMBER_FUNCTOR(sum, (Size-1)*NumTraits<Scalar>::AddCost);
-EIGEN_MEMBER_FUNCTOR(mean, (Size-1)*NumTraits<Scalar>::AddCost + NumTraits<Scalar>::MulCost);
-EIGEN_MEMBER_FUNCTOR(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost);
-EIGEN_MEMBER_FUNCTOR(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost);
 EIGEN_MEMBER_FUNCTOR(all, (Size-1)*NumTraits<Scalar>::AddCost);
 EIGEN_MEMBER_FUNCTOR(any, (Size-1)*NumTraits<Scalar>::AddCost);
 EIGEN_MEMBER_FUNCTOR(count, (Size-1)*NumTraits<Scalar>::AddCost);
-EIGEN_MEMBER_FUNCTOR(prod, (Size-1)*NumTraits<Scalar>::MulCost);
 
-template <int p, typename ResultType>
+EIGEN_MAKE_PARTIAL_REDUX_FUNCTOR(sum, (Size-1)*NumTraits<Scalar>::AddCost, 1, internal::scalar_sum_op);
+EIGEN_MAKE_PARTIAL_REDUX_FUNCTOR(minCoeff, (Size-1)*NumTraits<Scalar>::AddCost, 1, internal::scalar_min_op);
+EIGEN_MAKE_PARTIAL_REDUX_FUNCTOR(maxCoeff, (Size-1)*NumTraits<Scalar>::AddCost, 1, internal::scalar_max_op);
+EIGEN_MAKE_PARTIAL_REDUX_FUNCTOR(prod, (Size-1)*NumTraits<Scalar>::MulCost, 1, internal::scalar_product_op);
+
+template <int p, typename ResultType,typename Scalar>
 struct member_lpnorm {
   typedef ResultType result_type;
-  template<typename Scalar, int Size> struct Cost
+  enum { Vectorizable = 0 };
+  template<int Size> struct Cost
   { enum { value = (Size+5) * NumTraits<Scalar>::MulCost + (Size-1)*NumTraits<Scalar>::AddCost }; };
   EIGEN_DEVICE_FUNC member_lpnorm() {}
   template<typename XprType>
   EIGEN_DEVICE_FUNC inline ResultType operator()(const XprType& mat) const
   { return mat.template lpNorm<p>(); }
 };
 
-template <typename BinaryOp, typename Scalar>
+template <typename BinaryOpT, typename Scalar>
 struct member_redux {
+  typedef BinaryOpT BinaryOp;
   typedef typename result_of<
                      BinaryOp(const Scalar&,const Scalar&)
                    >::type  result_type;
-  template<typename _Scalar, int Size> struct Cost
-  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };
+
+  enum { Vectorizable = functor_traits<BinaryOp>::PacketAccess };
+  template<int Size> struct Cost { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };
   EIGEN_DEVICE_FUNC explicit member_redux(const BinaryOp func) : m_functor(func) {}
   template<typename Derived>
   EIGEN_DEVICE_FUNC inline result_type operator()(const DenseBase<Derived>& mat) const
   { return mat.redux(m_functor); }
+  const BinaryOp& binaryFunc() const { return m_functor; }
   const BinaryOp m_functor;
 };
 }
 
 /** \class VectorwiseOp
   * \ingroup Core_Module
   *
-  * \brief Pseudo expression providing partial reduction operations
+  * \brief Pseudo expression providing broadcasting and partial reduction operations
   *
   * \tparam ExpressionType the type of the object on which to do partial reductions
-  * \tparam Direction indicates the direction of the redux (#Vertical or #Horizontal)
+  * \tparam Direction indicates whether to operate on columns (#Vertical) or rows (#Horizontal)
   *
-  * This class represents a pseudo expression with partial reduction features.
+  * This class represents a pseudo expression with broadcasting and partial reduction features.
   * It is the return type of DenseBase::colwise() and DenseBase::rowwise()
-  * and most of the time this is the only way it is used.
+  * and most of the time this is the only way it is explicitly used.
+  *
+  * To understand the logic of rowwise/colwise expression, let's consider a generic case `A.colwise().foo()`
+  * where `foo` is any method of `VectorwiseOp`. This expression is equivalent to applying `foo()` to each
+  * column of `A` and then re-assemble the outputs in a matrix expression:
+  * \code [A.col(0).foo(), A.col(1).foo(), ..., A.col(A.cols()-1).foo()] \endcode
   *
   * Example: \include MatrixBase_colwise.cpp
   * Output: \verbinclude MatrixBase_colwise.out
   *
+  * The begin() and end() methods are obviously exceptions to the previous rule as they
+  * return STL-compatible begin/end iterators to the rows or columns of the nested expression.
+  * Typical use cases include for-range-loop and calls to STL algorithms:
+  *
+  * Example: \include MatrixBase_colwise_iterator_cxx11.cpp
+  * Output: \verbinclude MatrixBase_colwise_iterator_cxx11.out
+  *
+  * For a partial reduction on an empty input, some rules apply.
+  * For the sake of clarity, let's consider a vertical reduction:
+  *   - If the number of columns is zero, then a 1x0 row-major vector expression is returned.
+  *   - Otherwise, if the number of rows is zero, then
+  *       - a row vector of zeros is returned for sum-like reductions (sum, squaredNorm, norm, etc.)
+  *       - a row vector of ones is returned for a product reduction (e.g., <code>MatrixXd(n,0).colwise().prod()</code>)
+  *       - an assert is triggered for all other reductions (minCoeff,maxCoeff,redux(bin_op))
+  *
   * \sa DenseBase::colwise(), DenseBase::rowwise(), class PartialReduxExpr
   */
 template<typename ExpressionType, int Direction> class VectorwiseOp
 {
   public:
 
     typedef typename ExpressionType::Scalar Scalar;
     typedef typename ExpressionType::RealScalar RealScalar;
     typedef Eigen::Index Index; ///< \deprecated since Eigen 3.3
     typedef typename internal::ref_selector<ExpressionType>::non_const_type ExpressionTypeNested;
     typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;
 
-    template<template<typename _Scalar> class Functor,
-                      typename Scalar_=Scalar> struct ReturnType
+    template<template<typename OutScalar,typename InputScalar> class Functor,
+                      typename ReturnScalar=Scalar> struct ReturnType
     {
       typedef PartialReduxExpr<ExpressionType,
-                               Functor<Scalar_>,
+                               Functor<ReturnScalar,Scalar>,
                                Direction
                               > Type;
     };
 
     template<typename BinaryOp> struct ReduxReturnType
     {
       typedef PartialReduxExpr<ExpressionType,
@@ -183,31 +213,14 @@
     enum {
       isVertical   = (Direction==Vertical) ? 1 : 0,
       isHorizontal = (Direction==Horizontal) ? 1 : 0
     };
 
   protected:
 
-    typedef typename internal::conditional<isVertical,
-                               typename ExpressionType::ColXpr,
-                               typename ExpressionType::RowXpr>::type SubVector;
-    /** \internal
-      * \returns the i-th subvector according to the \c Direction */
-    EIGEN_DEVICE_FUNC
-    SubVector subVector(Index i)
-    {
-      return SubVector(m_matrix.derived(),i);
-    }
-
-    /** \internal
-      * \returns the number of subvectors in the direction \c Direction */
-    EIGEN_DEVICE_FUNC
-    Index subVectors() const
-    { return isVertical?m_matrix.cols():m_matrix.rows(); }
-
     template<typename OtherDerived> struct ExtendedType {
       typedef Replicate<OtherDerived,
                         isVertical   ? 1 : ExpressionType::RowsAtCompileTime,
                         isHorizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;
     };
 
     /** \internal
@@ -254,96 +267,164 @@
     EIGEN_DEVICE_FUNC
     explicit inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}
 
     /** \internal */
     EIGEN_DEVICE_FUNC
     inline const ExpressionType& _expression() const { return m_matrix; }
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
+    /** STL-like <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator">RandomAccessIterator</a>
+      * iterator type over the columns or rows as returned by the begin() and end() methods.
+      */
+    random_access_iterator_type iterator;
+    /** This is the const version of iterator (aka read-only) */
+    random_access_iterator_type const_iterator;
+    #else
+    typedef internal::subvector_stl_iterator<ExpressionType,               DirectionType(Direction)> iterator;
+    typedef internal::subvector_stl_iterator<const ExpressionType,         DirectionType(Direction)> const_iterator;
+    typedef internal::subvector_stl_reverse_iterator<ExpressionType,       DirectionType(Direction)> reverse_iterator;
+    typedef internal::subvector_stl_reverse_iterator<const ExpressionType, DirectionType(Direction)> const_reverse_iterator;
+    #endif
+
+    /** returns an iterator to the first row (rowwise) or column (colwise) of the nested expression.
+      * \sa end(), cbegin()
+      */
+    iterator                 begin()       { return iterator      (m_matrix, 0); }
+    /** const version of begin() */
+    const_iterator           begin() const { return const_iterator(m_matrix, 0); }
+    /** const version of begin() */
+    const_iterator          cbegin() const { return const_iterator(m_matrix, 0); }
+
+    /** returns a reverse iterator to the last row (rowwise) or column (colwise) of the nested expression.
+      * \sa rend(), crbegin()
+      */
+    reverse_iterator        rbegin()       { return reverse_iterator       (m_matrix, m_matrix.template subVectors<DirectionType(Direction)>()-1); }
+	/** const version of rbegin() */
+    const_reverse_iterator  rbegin() const { return const_reverse_iterator (m_matrix, m_matrix.template subVectors<DirectionType(Direction)>()-1); }
+	/** const version of rbegin() */
+	const_reverse_iterator crbegin() const { return const_reverse_iterator (m_matrix, m_matrix.template subVectors<DirectionType(Direction)>()-1); }
+
+    /** returns an iterator to the row (resp. column) following the last row (resp. column) of the nested expression
+      * \sa begin(), cend()
+      */
+    iterator                 end()         { return iterator      (m_matrix, m_matrix.template subVectors<DirectionType(Direction)>()); }
+    /** const version of end() */
+    const_iterator           end()  const  { return const_iterator(m_matrix, m_matrix.template subVectors<DirectionType(Direction)>()); }
+    /** const version of end() */
+    const_iterator          cend()  const  { return const_iterator(m_matrix, m_matrix.template subVectors<DirectionType(Direction)>()); }
+
+    /** returns a reverse iterator to the row (resp. column) before the first row (resp. column) of the nested expression
+      * \sa begin(), cend()
+      */
+    reverse_iterator        rend()         { return reverse_iterator       (m_matrix, -1); }
+    /** const version of rend() */
+    const_reverse_iterator  rend()  const  { return const_reverse_iterator (m_matrix, -1); }
+    /** const version of rend() */
+    const_reverse_iterator crend()  const  { return const_reverse_iterator (m_matrix, -1); }
+
     /** \returns a row or column vector expression of \c *this reduxed by \a func
       *
       * The template parameter \a BinaryOp is the type of the functor
       * of the custom redux operator. Note that func must be an associative operator.
       *
+      * \warning the size along the reduction direction must be strictly positive,
+      *          otherwise an assertion is triggered.
+      *
       * \sa class VectorwiseOp, DenseBase::colwise(), DenseBase::rowwise()
       */
     template<typename BinaryOp>
     EIGEN_DEVICE_FUNC
     const typename ReduxReturnType<BinaryOp>::Type
     redux(const BinaryOp& func = BinaryOp()) const
-    { return typename ReduxReturnType<BinaryOp>::Type(_expression(), internal::member_redux<BinaryOp,Scalar>(func)); }
+    {
+      eigen_assert(redux_length()>0 && "you are using an empty matrix");
+      return typename ReduxReturnType<BinaryOp>::Type(_expression(), internal::member_redux<BinaryOp,Scalar>(func));
+    }
 
     typedef typename ReturnType<internal::member_minCoeff>::Type MinCoeffReturnType;
     typedef typename ReturnType<internal::member_maxCoeff>::Type MaxCoeffReturnType;
-    typedef typename ReturnType<internal::member_squaredNorm,RealScalar>::Type SquaredNormReturnType;
-    typedef typename ReturnType<internal::member_norm,RealScalar>::Type NormReturnType;
+    typedef PartialReduxExpr<const CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const ExpressionTypeNestedCleaned>,internal::member_sum<RealScalar,RealScalar>,Direction> SquaredNormReturnType;
+    typedef CwiseUnaryOp<internal::scalar_sqrt_op<RealScalar>, const SquaredNormReturnType> NormReturnType;
     typedef typename ReturnType<internal::member_blueNorm,RealScalar>::Type BlueNormReturnType;
     typedef typename ReturnType<internal::member_stableNorm,RealScalar>::Type StableNormReturnType;
     typedef typename ReturnType<internal::member_hypotNorm,RealScalar>::Type HypotNormReturnType;
     typedef typename ReturnType<internal::member_sum>::Type SumReturnType;
-    typedef typename ReturnType<internal::member_mean>::Type MeanReturnType;
+    typedef EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(SumReturnType,Scalar,quotient) MeanReturnType;
     typedef typename ReturnType<internal::member_all>::Type AllReturnType;
     typedef typename ReturnType<internal::member_any>::Type AnyReturnType;
-    typedef PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> CountReturnType;
+    typedef PartialReduxExpr<ExpressionType, internal::member_count<Index,Scalar>, Direction> CountReturnType;
     typedef typename ReturnType<internal::member_prod>::Type ProdReturnType;
     typedef Reverse<const ExpressionType, Direction> ConstReverseReturnType;
     typedef Reverse<ExpressionType, Direction> ReverseReturnType;
 
     template<int p> struct LpNormReturnType {
-      typedef PartialReduxExpr<ExpressionType, internal::member_lpnorm<p,RealScalar>,Direction> Type;
+      typedef PartialReduxExpr<ExpressionType, internal::member_lpnorm<p,RealScalar,Scalar>,Direction> Type;
     };
 
     /** \returns a row (or column) vector expression of the smallest coefficient
       * of each column (or row) of the referenced expression.
       *
+      * \warning the size along the reduction direction must be strictly positive,
+      *          otherwise an assertion is triggered.
+      *
       * \warning the result is undefined if \c *this contains NaN.
       *
       * Example: \include PartialRedux_minCoeff.cpp
       * Output: \verbinclude PartialRedux_minCoeff.out
       *
       * \sa DenseBase::minCoeff() */
     EIGEN_DEVICE_FUNC
     const MinCoeffReturnType minCoeff() const
-    { return MinCoeffReturnType(_expression()); }
+    {
+      eigen_assert(redux_length()>0 && "you are using an empty matrix");
+      return MinCoeffReturnType(_expression());
+    }
 
     /** \returns a row (or column) vector expression of the largest coefficient
       * of each column (or row) of the referenced expression.
       *
+      * \warning the size along the reduction direction must be strictly positive,
+      *          otherwise an assertion is triggered.
+      *
       * \warning the result is undefined if \c *this contains NaN.
       *
       * Example: \include PartialRedux_maxCoeff.cpp
       * Output: \verbinclude PartialRedux_maxCoeff.out
       *
       * \sa DenseBase::maxCoeff() */
     EIGEN_DEVICE_FUNC
     const MaxCoeffReturnType maxCoeff() const
-    { return MaxCoeffReturnType(_expression()); }
+    {
+      eigen_assert(redux_length()>0 && "you are using an empty matrix");
+      return MaxCoeffReturnType(_expression());
+    }
 
     /** \returns a row (or column) vector expression of the squared norm
       * of each column (or row) of the referenced expression.
       * This is a vector with real entries, even if the original matrix has complex entries.
       *
       * Example: \include PartialRedux_squaredNorm.cpp
       * Output: \verbinclude PartialRedux_squaredNorm.out
       *
       * \sa DenseBase::squaredNorm() */
     EIGEN_DEVICE_FUNC
     const SquaredNormReturnType squaredNorm() const
-    { return SquaredNormReturnType(_expression()); }
+    { return SquaredNormReturnType(m_matrix.cwiseAbs2()); }
 
     /** \returns a row (or column) vector expression of the norm
       * of each column (or row) of the referenced expression.
       * This is a vector with real entries, even if the original matrix has complex entries.
       *
       * Example: \include PartialRedux_norm.cpp
       * Output: \verbinclude PartialRedux_norm.out
       *
       * \sa DenseBase::norm() */
     EIGEN_DEVICE_FUNC
     const NormReturnType norm() const
-    { return NormReturnType(_expression()); }
+    { return NormReturnType(squaredNorm()); }
 
     /** \returns a row (or column) vector expression of the norm
       * of each column (or row) of the referenced expression.
       * This is a vector with real entries, even if the original matrix has complex entries.
       *
       * Example: \include PartialRedux_norm.cpp
       * Output: \verbinclude PartialRedux_norm.out
@@ -400,15 +481,15 @@
 
     /** \returns a row (or column) vector expression of the mean
     * of each column (or row) of the referenced expression.
     *
     * \sa DenseBase::mean() */
     EIGEN_DEVICE_FUNC
     const MeanReturnType mean() const
-    { return MeanReturnType(_expression()); }
+    { return sum() / Scalar(Direction==Vertical?m_matrix.rows():m_matrix.cols()); }
 
     /** \returns a row (or column) vector expression representing
       * whether \b all coefficients of each respective column (or row) are \c true.
       * This expression can be assigned to a vector with entries of type \c bool.
       *
       * \sa DenseBase::all() */
     EIGEN_DEVICE_FUNC
@@ -496,59 +577,59 @@
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     ExpressionType& operator=(const DenseBase<OtherDerived>& other)
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(OtherDerived)
       EIGEN_STATIC_ASSERT_SAME_XPR_KIND(ExpressionType, OtherDerived)
       //eigen_assert((m_matrix.isNull()) == (other.isNull())); FIXME
-      return const_cast<ExpressionType&>(m_matrix = extendedTo(other.derived()));
+      return m_matrix = extendedTo(other.derived());
     }
 
     /** Adds the vector \a other to each subvector of \c *this */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     ExpressionType& operator+=(const DenseBase<OtherDerived>& other)
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(OtherDerived)
       EIGEN_STATIC_ASSERT_SAME_XPR_KIND(ExpressionType, OtherDerived)
-      return const_cast<ExpressionType&>(m_matrix += extendedTo(other.derived()));
+      return m_matrix += extendedTo(other.derived());
     }
 
     /** Substracts the vector \a other to each subvector of \c *this */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     ExpressionType& operator-=(const DenseBase<OtherDerived>& other)
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(OtherDerived)
       EIGEN_STATIC_ASSERT_SAME_XPR_KIND(ExpressionType, OtherDerived)
-      return const_cast<ExpressionType&>(m_matrix -= extendedTo(other.derived()));
+      return m_matrix -= extendedTo(other.derived());
     }
 
     /** Multiples each subvector of \c *this by the vector \a other */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     ExpressionType& operator*=(const DenseBase<OtherDerived>& other)
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(OtherDerived)
       EIGEN_STATIC_ASSERT_ARRAYXPR(ExpressionType)
       EIGEN_STATIC_ASSERT_SAME_XPR_KIND(ExpressionType, OtherDerived)
       m_matrix *= extendedTo(other.derived());
-      return const_cast<ExpressionType&>(m_matrix);
+      return m_matrix;
     }
 
     /** Divides each subvector of \c *this by the vector \a other */
     template<typename OtherDerived>
     EIGEN_DEVICE_FUNC
     ExpressionType& operator/=(const DenseBase<OtherDerived>& other)
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(OtherDerived)
       EIGEN_STATIC_ASSERT_ARRAYXPR(ExpressionType)
       EIGEN_STATIC_ASSERT_SAME_XPR_KIND(ExpressionType, OtherDerived)
       m_matrix /= extendedTo(other.derived());
-      return const_cast<ExpressionType&>(m_matrix);
+      return m_matrix;
     }
 
     /** Returns the expression of the sum of the vector \a other to each subvector of \c *this */
     template<typename OtherDerived> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC
     CwiseBinaryOp<internal::scalar_sum_op<Scalar,typename OtherDerived::Scalar>,
                   const ExpressionTypeNestedCleaned,
                   const typename ExtendedType<OtherDerived>::Type>
@@ -605,15 +686,15 @@
     /** \returns an expression where each column (or row) of the referenced matrix are normalized.
       * The referenced matrix is \b not modified.
       * \sa MatrixBase::normalized(), normalize()
       */
     EIGEN_DEVICE_FUNC
     CwiseBinaryOp<internal::scalar_quotient_op<Scalar>,
                   const ExpressionTypeNestedCleaned,
-                  const typename OppositeExtendedType<typename ReturnType<internal::member_norm,RealScalar>::Type>::Type>
+                  const typename OppositeExtendedType<NormReturnType>::Type>
     normalized() const { return m_matrix.cwiseQuotient(extendedToOpposite(this->norm())); }
 
 
     /** Normalize in-place each row or columns of the referenced matrix.
       * \sa MatrixBase::normalize(), normalized()
       */
     EIGEN_DEVICE_FUNC void normalize() {
@@ -654,41 +735,49 @@
                   Direction==Vertical   ? HNormalized_SizeMinusOne : 1,
                   Direction==Horizontal ? HNormalized_SizeMinusOne : 1> >
             HNormalizedReturnType;
 
     EIGEN_DEVICE_FUNC
     const HNormalizedReturnType hnormalized() const;
 
+#   ifdef EIGEN_VECTORWISEOP_PLUGIN
+#     include EIGEN_VECTORWISEOP_PLUGIN
+#   endif
+
   protected:
+    Index redux_length() const
+    {
+      return Direction==Vertical ? m_matrix.rows() : m_matrix.cols();
+    }
     ExpressionTypeNested m_matrix;
 };
 
 //const colwise moved to DenseBase.h due to CUDA compiler bug
 
 
 /** \returns a writable VectorwiseOp wrapper of *this providing additional partial reduction operations
   *
   * \sa rowwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
   */
 template<typename Derived>
-inline typename DenseBase<Derived>::ColwiseReturnType
+EIGEN_DEVICE_FUNC inline typename DenseBase<Derived>::ColwiseReturnType
 DenseBase<Derived>::colwise()
 {
   return ColwiseReturnType(derived());
 }
 
 //const rowwise moved to DenseBase.h due to CUDA compiler bug
 
 
 /** \returns a writable VectorwiseOp wrapper of *this providing additional partial reduction operations
   *
   * \sa colwise(), class VectorwiseOp, \ref TutorialReductionsVisitorsBroadcasting
   */
 template<typename Derived>
-inline typename DenseBase<Derived>::RowwiseReturnType
+EIGEN_DEVICE_FUNC inline typename DenseBase<Derived>::RowwiseReturnType
 DenseBase<Derived>::rowwise()
 {
   return RowwiseReturnType(derived());
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/AVX/Complex.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/AVX/Complex.h`

 * *Files 12% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 struct Packet4cf
 {
   EIGEN_STRONG_INLINE Packet4cf() {}
   EIGEN_STRONG_INLINE explicit Packet4cf(const __m256& a) : v(a) {}
   __m256  v;
 };
 
+#ifndef EIGEN_VECTORIZE_AVX512
 template<> struct packet_traits<std::complex<float> >  : default_packet_traits
 {
   typedef Packet4cf type;
   typedef Packet2cf half;
   enum {
     Vectorizable = 1,
     AlignedOnScalar = 1,
@@ -33,23 +34,36 @@
     HasHalfPacket = 1,
 
     HasAdd    = 1,
     HasSub    = 1,
     HasMul    = 1,
     HasDiv    = 1,
     HasNegate = 1,
+    HasSqrt   = 1,
     HasAbs    = 0,
     HasAbs2   = 0,
     HasMin    = 0,
     HasMax    = 0,
     HasSetLinear = 0
   };
 };
+#endif
 
-template<> struct unpacket_traits<Packet4cf> { typedef std::complex<float> type; enum {size=4, alignment=Aligned32}; typedef Packet2cf half; };
+template<> struct unpacket_traits<Packet4cf> {
+  typedef std::complex<float> type;
+  typedef Packet2cf half;
+  typedef Packet8f as_real;
+  enum {
+    size=4,
+    alignment=Aligned32,
+    vectorizable=true,
+    masked_load_available=false,
+    masked_store_available=false
+  };
+};
 
 template<> EIGEN_STRONG_INLINE Packet4cf padd<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_add_ps(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet4cf psub<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_sub_ps(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet4cf pnegate(const Packet4cf& a)
 {
   return Packet4cf(pnegate(a.v));
 }
@@ -63,18 +77,25 @@
 {
   __m256 tmp1 = _mm256_mul_ps(_mm256_moveldup_ps(a.v), b.v);
   __m256 tmp2 = _mm256_mul_ps(_mm256_movehdup_ps(a.v), _mm256_permute_ps(b.v, _MM_SHUFFLE(2,3,0,1)));
   __m256 result = _mm256_addsub_ps(tmp1, tmp2);
   return Packet4cf(result);
 }
 
+template <>
+EIGEN_STRONG_INLINE Packet4cf pcmp_eq(const Packet4cf& a, const Packet4cf& b) {
+  __m256 eq = _mm256_cmp_ps(a.v, b.v, _CMP_EQ_OQ);
+  return Packet4cf(_mm256_and_ps(eq, _mm256_permute_ps(eq, 0xb1)));
+}
+
+template<> EIGEN_STRONG_INLINE Packet4cf ptrue<Packet4cf>(const Packet4cf& a) { return Packet4cf(ptrue(Packet8f(a.v))); }
 template<> EIGEN_STRONG_INLINE Packet4cf pand   <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_and_ps(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet4cf por    <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_or_ps(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet4cf pxor   <Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_xor_ps(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet4cf pandnot<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_andnot_ps(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet4cf pandnot<Packet4cf>(const Packet4cf& a, const Packet4cf& b) { return Packet4cf(_mm256_andnot_ps(b.v,a.v)); }
 
 template<> EIGEN_STRONG_INLINE Packet4cf pload <Packet4cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet4cf(pload<Packet8f>(&numext::real_ref(*from))); }
 template<> EIGEN_STRONG_INLINE Packet4cf ploadu<Packet4cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet4cf(ploadu<Packet8f>(&numext::real_ref(*from))); }
 
 
 template<> EIGEN_STRONG_INLINE Packet4cf pset1<Packet4cf>(const std::complex<float>& from)
 {
@@ -136,78 +157,20 @@
 
 template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet4cf>(const Packet4cf& a)
 {
   return predux(padd(Packet2cf(_mm256_extractf128_ps(a.v,0)),
                      Packet2cf(_mm256_extractf128_ps(a.v,1))));
 }
 
-template<> EIGEN_STRONG_INLINE Packet4cf preduxp<Packet4cf>(const Packet4cf* vecs)
-{
-  Packet8f t0 = _mm256_shuffle_ps(vecs[0].v, vecs[0].v, _MM_SHUFFLE(3, 1, 2 ,0));
-  Packet8f t1 = _mm256_shuffle_ps(vecs[1].v, vecs[1].v, _MM_SHUFFLE(3, 1, 2 ,0));
-  t0 = _mm256_hadd_ps(t0,t1);
-  Packet8f t2 = _mm256_shuffle_ps(vecs[2].v, vecs[2].v, _MM_SHUFFLE(3, 1, 2 ,0));
-  Packet8f t3 = _mm256_shuffle_ps(vecs[3].v, vecs[3].v, _MM_SHUFFLE(3, 1, 2 ,0));
-  t2 = _mm256_hadd_ps(t2,t3);
-  
-  t1 = _mm256_permute2f128_ps(t0,t2, 0 + (2<<4));
-  t3 = _mm256_permute2f128_ps(t0,t2, 1 + (3<<4));
-
-  return Packet4cf(_mm256_add_ps(t1,t3));
-}
-
 template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet4cf>(const Packet4cf& a)
 {
   return predux_mul(pmul(Packet2cf(_mm256_extractf128_ps(a.v, 0)),
                          Packet2cf(_mm256_extractf128_ps(a.v, 1))));
 }
 
-template<int Offset>
-struct palign_impl<Offset,Packet4cf>
-{
-  static EIGEN_STRONG_INLINE void run(Packet4cf& first, const Packet4cf& second)
-  {
-    if (Offset==0) return;
-    palign_impl<Offset*2,Packet8f>::run(first.v, second.v);
-  }
-};
-
-template<> struct conj_helper<Packet4cf, Packet4cf, false,true>
-{
-  EIGEN_STRONG_INLINE Packet4cf pmadd(const Packet4cf& x, const Packet4cf& y, const Packet4cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet4cf pmul(const Packet4cf& a, const Packet4cf& b) const
-  {
-    return internal::pmul(a, pconj(b));
-  }
-};
-
-template<> struct conj_helper<Packet4cf, Packet4cf, true,false>
-{
-  EIGEN_STRONG_INLINE Packet4cf pmadd(const Packet4cf& x, const Packet4cf& y, const Packet4cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet4cf pmul(const Packet4cf& a, const Packet4cf& b) const
-  {
-    return internal::pmul(pconj(a), b);
-  }
-};
-
-template<> struct conj_helper<Packet4cf, Packet4cf, true,true>
-{
-  EIGEN_STRONG_INLINE Packet4cf pmadd(const Packet4cf& x, const Packet4cf& y, const Packet4cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet4cf pmul(const Packet4cf& a, const Packet4cf& b) const
-  {
-    return pconj(internal::pmul(a, b));
-  }
-};
-
 EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet4cf,Packet8f)
 
 template<> EIGEN_STRONG_INLINE Packet4cf pdiv<Packet4cf>(const Packet4cf& a, const Packet4cf& b)
 {
   Packet4cf num = pmul(a, pconj(b));
   __m256 tmp = _mm256_mul_ps(b.v, b.v);
   __m256 tmp2    = _mm256_shuffle_ps(tmp,tmp,0xB1);
@@ -224,14 +187,15 @@
 struct Packet2cd
 {
   EIGEN_STRONG_INLINE Packet2cd() {}
   EIGEN_STRONG_INLINE explicit Packet2cd(const __m256d& a) : v(a) {}
   __m256d  v;
 };
 
+#ifndef EIGEN_VECTORIZE_AVX512
 template<> struct packet_traits<std::complex<double> >  : default_packet_traits
 {
   typedef Packet2cd type;
   typedef Packet1cd half;
   enum {
     Vectorizable = 1,
     AlignedOnScalar = 0,
@@ -239,23 +203,36 @@
     HasHalfPacket = 1,
 
     HasAdd    = 1,
     HasSub    = 1,
     HasMul    = 1,
     HasDiv    = 1,
     HasNegate = 1,
+    HasSqrt   = 1,
     HasAbs    = 0,
     HasAbs2   = 0,
     HasMin    = 0,
     HasMax    = 0,
     HasSetLinear = 0
   };
 };
+#endif
 
-template<> struct unpacket_traits<Packet2cd> { typedef std::complex<double> type; enum {size=2, alignment=Aligned32}; typedef Packet1cd half; };
+template<> struct unpacket_traits<Packet2cd> {
+  typedef std::complex<double> type;
+  typedef Packet1cd half;
+  typedef Packet4d as_real;
+  enum {
+    size=2,
+    alignment=Aligned32,
+    vectorizable=true,
+    masked_load_available=false,
+    masked_store_available=false
+  };
+};
 
 template<> EIGEN_STRONG_INLINE Packet2cd padd<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_add_pd(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cd psub<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_sub_pd(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cd pnegate(const Packet2cd& a) { return Packet2cd(pnegate(a.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cd pconj(const Packet2cd& a)
 {
   const __m256d mask = _mm256_castsi256_pd(_mm256_set_epi32(0x80000000,0x0,0x0,0x0,0x80000000,0x0,0x0,0x0));
@@ -268,18 +245,25 @@
   __m256d even = _mm256_mul_pd(tmp1, b.v);
   __m256d tmp2 = _mm256_shuffle_pd(a.v,a.v,0xF);
   __m256d tmp3 = _mm256_shuffle_pd(b.v,b.v,0x5);
   __m256d odd  = _mm256_mul_pd(tmp2, tmp3);
   return Packet2cd(_mm256_addsub_pd(even, odd));
 }
 
+template <>
+EIGEN_STRONG_INLINE Packet2cd pcmp_eq(const Packet2cd& a, const Packet2cd& b) {
+  __m256d eq = _mm256_cmp_pd(a.v, b.v, _CMP_EQ_OQ);
+  return Packet2cd(pand(eq, _mm256_permute_pd(eq, 0x5)));
+}
+
+template<> EIGEN_STRONG_INLINE Packet2cd ptrue<Packet2cd>(const Packet2cd& a) { return Packet2cd(ptrue(Packet4d(a.v))); }
 template<> EIGEN_STRONG_INLINE Packet2cd pand   <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_and_pd(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cd por    <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_or_pd(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cd pxor   <Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_xor_pd(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet2cd pandnot<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_andnot_pd(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet2cd pandnot<Packet2cd>(const Packet2cd& a, const Packet2cd& b) { return Packet2cd(_mm256_andnot_pd(b.v,a.v)); }
 
 template<> EIGEN_STRONG_INLINE Packet2cd pload <Packet2cd>(const std::complex<double>* from)
 { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cd(pload<Packet4d>((const double*)from)); }
 template<> EIGEN_STRONG_INLINE Packet2cd ploadu<Packet2cd>(const std::complex<double>* from)
 { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cd(ploadu<Packet4d>((const double*)from)); }
 
 template<> EIGEN_STRONG_INLINE Packet2cd pset1<Packet2cd>(const std::complex<double>& from)
@@ -323,71 +307,20 @@
 
 template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet2cd>(const Packet2cd& a)
 {
   return predux(padd(Packet1cd(_mm256_extractf128_pd(a.v,0)),
                      Packet1cd(_mm256_extractf128_pd(a.v,1))));
 }
 
-template<> EIGEN_STRONG_INLINE Packet2cd preduxp<Packet2cd>(const Packet2cd* vecs)
-{
-  Packet4d t0 = _mm256_permute2f128_pd(vecs[0].v,vecs[1].v, 0 + (2<<4));
-  Packet4d t1 = _mm256_permute2f128_pd(vecs[0].v,vecs[1].v, 1 + (3<<4));
-
-  return Packet2cd(_mm256_add_pd(t0,t1));
-}
-
 template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet2cd>(const Packet2cd& a)
 {
   return predux(pmul(Packet1cd(_mm256_extractf128_pd(a.v,0)),
                      Packet1cd(_mm256_extractf128_pd(a.v,1))));
 }
 
-template<int Offset>
-struct palign_impl<Offset,Packet2cd>
-{
-  static EIGEN_STRONG_INLINE void run(Packet2cd& first, const Packet2cd& second)
-  {
-    if (Offset==0) return;
-    palign_impl<Offset*2,Packet4d>::run(first.v, second.v);
-  }
-};
-
-template<> struct conj_helper<Packet2cd, Packet2cd, false,true>
-{
-  EIGEN_STRONG_INLINE Packet2cd pmadd(const Packet2cd& x, const Packet2cd& y, const Packet2cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cd pmul(const Packet2cd& a, const Packet2cd& b) const
-  {
-    return internal::pmul(a, pconj(b));
-  }
-};
-
-template<> struct conj_helper<Packet2cd, Packet2cd, true,false>
-{
-  EIGEN_STRONG_INLINE Packet2cd pmadd(const Packet2cd& x, const Packet2cd& y, const Packet2cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cd pmul(const Packet2cd& a, const Packet2cd& b) const
-  {
-    return internal::pmul(pconj(a), b);
-  }
-};
-
-template<> struct conj_helper<Packet2cd, Packet2cd, true,true>
-{
-  EIGEN_STRONG_INLINE Packet2cd pmadd(const Packet2cd& x, const Packet2cd& y, const Packet2cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cd pmul(const Packet2cd& a, const Packet2cd& b) const
-  {
-    return pconj(internal::pmul(a, b));
-  }
-};
-
 EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet2cd,Packet4d)
 
 template<> EIGEN_STRONG_INLINE Packet2cd pdiv<Packet2cd>(const Packet2cd& a, const Packet2cd& b)
 {
   Packet2cd num = pmul(a, pconj(b));
   __m256d tmp = _mm256_mul_pd(b.v, b.v);
   __m256d denom = _mm256_hadd_pd(tmp, tmp);
@@ -420,32 +353,20 @@
 EIGEN_DEVICE_FUNC inline void
 ptranspose(PacketBlock<Packet2cd,2>& kernel) {
   __m256d tmp = _mm256_permute2f128_pd(kernel.packet[0].v, kernel.packet[1].v, 0+(2<<4));
   kernel.packet[1].v = _mm256_permute2f128_pd(kernel.packet[0].v, kernel.packet[1].v, 1+(3<<4));
  kernel.packet[0].v = tmp;
 }
 
-template<> EIGEN_STRONG_INLINE Packet4cf pinsertfirst(const Packet4cf& a, std::complex<float> b)
-{
-  return Packet4cf(_mm256_blend_ps(a.v,pset1<Packet4cf>(b).v,1|2));
-}
-
-template<> EIGEN_STRONG_INLINE Packet2cd pinsertfirst(const Packet2cd& a, std::complex<double> b)
-{
-  return Packet2cd(_mm256_blend_pd(a.v,pset1<Packet2cd>(b).v,1|2));
+template<> EIGEN_STRONG_INLINE Packet2cd psqrt<Packet2cd>(const Packet2cd& a) {
+  return psqrt_complex<Packet2cd>(a);
 }
 
-template<> EIGEN_STRONG_INLINE Packet4cf pinsertlast(const Packet4cf& a, std::complex<float> b)
-{
-  return Packet4cf(_mm256_blend_ps(a.v,pset1<Packet4cf>(b).v,(1<<7)|(1<<6)));
-}
-
-template<> EIGEN_STRONG_INLINE Packet2cd pinsertlast(const Packet2cd& a, std::complex<double> b)
-{
-  return Packet2cd(_mm256_blend_pd(a.v,pset1<Packet2cd>(b).v,(1<<3)|(1<<2)));
+template<> EIGEN_STRONG_INLINE Packet4cf psqrt<Packet4cf>(const Packet4cf& a) {
+  return psqrt_complex<Packet4cf>(a);
 }
 
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_COMPLEX_AVX_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/AVX512/MathFunctions.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/AVX512/MathFunctions.h`

 * *Files 26% similar despite different names*

```diff
@@ -11,123 +11,63 @@
 #define THIRD_PARTY_EIGEN3_EIGEN_SRC_CORE_ARCH_AVX512_MATHFUNCTIONS_H_
 
 namespace Eigen {
 
 namespace internal {
 
 // Disable the code for older versions of gcc that don't support many of the required avx512 instrinsics.
-#if EIGEN_GNUC_AT_LEAST(5, 3)
+#if EIGEN_GNUC_AT_LEAST(5, 3) || EIGEN_COMP_CLANG  || EIGEN_COMP_MSVC >= 1923
 
 #define _EIGEN_DECLARE_CONST_Packet16f(NAME, X) \
   const Packet16f p16f_##NAME = pset1<Packet16f>(X)
 
 #define _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(NAME, X) \
-  const Packet16f p16f_##NAME = (__m512)pset1<Packet16i>(X)
+  const Packet16f p16f_##NAME =  preinterpret<Packet16f,Packet16i>(pset1<Packet16i>(X))
 
 #define _EIGEN_DECLARE_CONST_Packet8d(NAME, X) \
   const Packet8d p8d_##NAME = pset1<Packet8d>(X)
 
 #define _EIGEN_DECLARE_CONST_Packet8d_FROM_INT64(NAME, X) \
   const Packet8d p8d_##NAME = _mm512_castsi512_pd(_mm512_set1_epi64(X))
 
-// Natural logarithm
-// Computes log(x) as log(2^e * m) = C*e + log(m), where the constant C =log(2)
-// and m is in the range [sqrt(1/2),sqrt(2)). In this range, the logarithm can
-// be easily approximated by a polynomial centered on m=1 for stability.
-#if defined(EIGEN_VECTORIZE_AVX512DQ)
+#define _EIGEN_DECLARE_CONST_Packet16bf(NAME, X) \
+  const Packet16bf p16bf_##NAME = pset1<Packet16bf>(X)
+
+#define _EIGEN_DECLARE_CONST_Packet16bf_FROM_INT(NAME, X) \
+  const Packet16bf p16bf_##NAME =  preinterpret<Packet16bf,Packet16i>(pset1<Packet16i>(X))
+
 template <>
 EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet16f
 plog<Packet16f>(const Packet16f& _x) {
-  Packet16f x = _x;
-  _EIGEN_DECLARE_CONST_Packet16f(1, 1.0f);
-  _EIGEN_DECLARE_CONST_Packet16f(half, 0.5f);
-  _EIGEN_DECLARE_CONST_Packet16f(126f, 126.0f);
+  return plog_float(_x);
+}
 
-  _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(inv_mant_mask, ~0x7f800000);
+template <>
+EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet8d
+plog<Packet8d>(const Packet8d& _x) {
+  return plog_double(_x);
+}
 
-  // The smallest non denormalized float number.
-  _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(min_norm_pos, 0x00800000);
-  _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(minus_inf, 0xff800000);
-  _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(nan, 0x7fc00000);
-
-  // Polynomial coefficients.
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_SQRTHF, 0.707106781186547524f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p0, 7.0376836292E-2f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p1, -1.1514610310E-1f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p2, 1.1676998740E-1f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p3, -1.2420140846E-1f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p4, +1.4249322787E-1f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p5, -1.6668057665E-1f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p6, +2.0000714765E-1f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p7, -2.4999993993E-1f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_p8, +3.3333331174E-1f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_q1, -2.12194440e-4f);
-  _EIGEN_DECLARE_CONST_Packet16f(cephes_log_q2, 0.693359375f);
-
-  // invalid_mask is set to true when x is NaN
-  __mmask16 invalid_mask =
-      _mm512_cmp_ps_mask(x, _mm512_setzero_ps(), _CMP_NGE_UQ);
-  __mmask16 iszero_mask =
-      _mm512_cmp_ps_mask(x, _mm512_setzero_ps(), _CMP_EQ_UQ);
-
-  // Truncate input values to the minimum positive normal.
-  x = pmax(x, p16f_min_norm_pos);
-
-  // Extract the shifted exponents.
-  Packet16f emm0 = _mm512_cvtepi32_ps(_mm512_srli_epi32((__m512i)x, 23));
-  Packet16f e = _mm512_sub_ps(emm0, p16f_126f);
-
-  // Set the exponents to -1, i.e. x are in the range [0.5,1).
-  x = _mm512_and_ps(x, p16f_inv_mant_mask);
-  x = _mm512_or_ps(x, p16f_half);
-
-  // part2: Shift the inputs from the range [0.5,1) to [sqrt(1/2),sqrt(2))
-  // and shift by -1. The values are then centered around 0, which improves
-  // the stability of the polynomial evaluation.
-  //   if( x < SQRTHF ) {
-  //     e -= 1;
-  //     x = x + x - 1.0;
-  //   } else { x = x - 1.0; }
-  __mmask16 mask = _mm512_cmp_ps_mask(x, p16f_cephes_SQRTHF, _CMP_LT_OQ);
-  Packet16f tmp = _mm512_mask_blend_ps(mask, _mm512_setzero_ps(), x);
-  x = psub(x, p16f_1);
-  e = psub(e, _mm512_mask_blend_ps(mask, _mm512_setzero_ps(), p16f_1));
-  x = padd(x, tmp);
+F16_PACKET_FUNCTION(Packet16f, Packet16h, plog)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, plog)
 
-  Packet16f x2 = pmul(x, x);
-  Packet16f x3 = pmul(x2, x);
+template <>
+EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet16f
+plog2<Packet16f>(const Packet16f& _x) {
+  return plog2_float(_x);
+}
 
-  // Evaluate the polynomial approximant of degree 8 in three parts, probably
-  // to improve instruction-level parallelism.
-  Packet16f y, y1, y2;
-  y = pmadd(p16f_cephes_log_p0, x, p16f_cephes_log_p1);
-  y1 = pmadd(p16f_cephes_log_p3, x, p16f_cephes_log_p4);
-  y2 = pmadd(p16f_cephes_log_p6, x, p16f_cephes_log_p7);
-  y = pmadd(y, x, p16f_cephes_log_p2);
-  y1 = pmadd(y1, x, p16f_cephes_log_p5);
-  y2 = pmadd(y2, x, p16f_cephes_log_p8);
-  y = pmadd(y, x3, y1);
-  y = pmadd(y, x3, y2);
-  y = pmul(y, x3);
-
-  // Add the logarithm of the exponent back to the result of the interpolation.
-  y1 = pmul(e, p16f_cephes_log_q1);
-  tmp = pmul(x2, p16f_half);
-  y = padd(y, y1);
-  x = psub(x, tmp);
-  y2 = pmul(e, p16f_cephes_log_q2);
-  x = padd(x, y);
-  x = padd(x, y2);
-
-  // Filter out invalid inputs, i.e. negative arg will be NAN, 0 will be -INF.
-  return _mm512_mask_blend_ps(iszero_mask,
-                              _mm512_mask_blend_ps(invalid_mask, x, p16f_nan),
-                              p16f_minus_inf);
+template <>
+EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet8d
+plog2<Packet8d>(const Packet8d& _x) {
+  return plog2_double(_x);
 }
-#endif
+
+F16_PACKET_FUNCTION(Packet16f, Packet16h, plog2)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, plog2)
 
 // Exponential function. Works by writing "x = m*log(2) + r" where
 // "m = floor(x/log(2)+1/2)" and "r" is the remainder. The result is then
 // "exp(x) = 2^m*exp(r)" where exp(r) is in the range [-1,1).
 template <>
 EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet16f
 pexp<Packet16f>(const Packet16f& _x) {
@@ -155,237 +95,268 @@
   Packet16f m = _mm512_floor_ps(pmadd(x, p16f_cephes_LOG2EF, p16f_half));
 
   // Get r = x - m*ln(2). Note that we can do this without losing more than one
   // ulp precision due to the FMA instruction.
   _EIGEN_DECLARE_CONST_Packet16f(nln2, -0.6931471805599453f);
   Packet16f r = _mm512_fmadd_ps(m, p16f_nln2, x);
   Packet16f r2 = pmul(r, r);
+  Packet16f r3 = pmul(r2, r);
 
-  // TODO(gonnet): Split into odd/even polynomials and try to exploit
-  //               instruction-level parallelism.
-  Packet16f y = p16f_cephes_exp_p0;
-  y = pmadd(y, r, p16f_cephes_exp_p1);
-  y = pmadd(y, r, p16f_cephes_exp_p2);
-  y = pmadd(y, r, p16f_cephes_exp_p3);
-  y = pmadd(y, r, p16f_cephes_exp_p4);
-  y = pmadd(y, r, p16f_cephes_exp_p5);
-  y = pmadd(y, r2, r);
-  y = padd(y, p16f_1);
+  // Evaluate the polynomial approximant,improved by instruction-level parallelism.
+  Packet16f y, y1, y2;
+  y  = pmadd(p16f_cephes_exp_p0, r, p16f_cephes_exp_p1);
+  y1 = pmadd(p16f_cephes_exp_p3, r, p16f_cephes_exp_p4);
+  y2 = padd(r, p16f_1);
+  y  = pmadd(y, r, p16f_cephes_exp_p2);
+  y1 = pmadd(y1, r, p16f_cephes_exp_p5);
+  y  = pmadd(y, r3, y1);
+  y  = pmadd(y, r2, y2);
 
   // Build emm0 = 2^m.
   Packet16i emm0 = _mm512_cvttps_epi32(padd(m, p16f_127));
   emm0 = _mm512_slli_epi32(emm0, 23);
 
   // Return 2^m * exp(r).
   return pmax(pmul(y, _mm512_castsi512_ps(emm0)), _x);
 }
 
-/*template <>
+template <>
 EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet8d
 pexp<Packet8d>(const Packet8d& _x) {
-  Packet8d x = _x;
+  return pexp_double(_x);
+}
 
-  _EIGEN_DECLARE_CONST_Packet8d(1, 1.0);
-  _EIGEN_DECLARE_CONST_Packet8d(2, 2.0);
+F16_PACKET_FUNCTION(Packet16f, Packet16h, pexp)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, pexp)
 
-  _EIGEN_DECLARE_CONST_Packet8d(exp_hi, 709.437);
-  _EIGEN_DECLARE_CONST_Packet8d(exp_lo, -709.436139303);
+template <>
+EIGEN_STRONG_INLINE Packet16h pfrexp(const Packet16h& a, Packet16h& exponent) {
+  Packet16f fexponent;
+  const Packet16h out = float2half(pfrexp<Packet16f>(half2float(a), fexponent));
+  exponent = float2half(fexponent);
+  return out;
+}
 
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_LOG2EF, 1.4426950408889634073599);
-
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_p0, 1.26177193074810590878e-4);
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_p1, 3.02994407707441961300e-2);
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_p2, 9.99999999999999999910e-1);
-
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_q0, 3.00198505138664455042e-6);
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_q1, 2.52448340349684104192e-3);
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_q2, 2.27265548208155028766e-1);
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_q3, 2.00000000000000000009e0);
-
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_C1, 0.693145751953125);
-  _EIGEN_DECLARE_CONST_Packet8d(cephes_exp_C2, 1.42860682030941723212e-6);
-
-  // clamp x
-  x = pmax(pmin(x, p8d_exp_hi), p8d_exp_lo);
-
-  // Express exp(x) as exp(g + n*log(2)).
-  const Packet8d n =
-      _mm512_mul_round_pd(p8d_cephes_LOG2EF, x, _MM_FROUND_TO_NEAREST_INT);
-
-  // Get the remainder modulo log(2), i.e. the "g" described above. Subtract
-  // n*log(2) out in two steps, i.e. n*C1 + n*C2, C1+C2=log2 to get the last
-  // digits right.
-  const Packet8d nC1 = pmul(n, p8d_cephes_exp_C1);
-  const Packet8d nC2 = pmul(n, p8d_cephes_exp_C2);
-  x = psub(x, nC1);
-  x = psub(x, nC2);
-
-  const Packet8d x2 = pmul(x, x);
-
-  // Evaluate the numerator polynomial of the rational interpolant.
-  Packet8d px = p8d_cephes_exp_p0;
-  px = pmadd(px, x2, p8d_cephes_exp_p1);
-  px = pmadd(px, x2, p8d_cephes_exp_p2);
-  px = pmul(px, x);
-
-  // Evaluate the denominator polynomial of the rational interpolant.
-  Packet8d qx = p8d_cephes_exp_q0;
-  qx = pmadd(qx, x2, p8d_cephes_exp_q1);
-  qx = pmadd(qx, x2, p8d_cephes_exp_q2);
-  qx = pmadd(qx, x2, p8d_cephes_exp_q3);
-
-  // I don't really get this bit, copied from the SSE2 routines, so...
-  // TODO(gonnet): Figure out what is going on here, perhaps find a better
-  // rational interpolant?
-  x = _mm512_div_pd(px, psub(qx, px));
-  x = pmadd(p8d_2, x, p8d_1);
-
-  // Build e=2^n.
-  const Packet8d e = _mm512_castsi512_pd(_mm512_slli_epi64(
-      _mm512_add_epi64(_mm512_cvtpd_epi64(n), _mm512_set1_epi64(1023)), 52));
-
-  // Construct the result 2^n * exp(g) = e * x. The max is used to catch
-  // non-finite values in the input.
-  return pmax(pmul(x, e), _x);
-  }*/
+template <>
+EIGEN_STRONG_INLINE Packet16h pldexp(const Packet16h& a, const Packet16h& exponent) {
+  return float2half(pldexp<Packet16f>(half2float(a), half2float(exponent)));
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet16bf pfrexp(const Packet16bf& a, Packet16bf& exponent) {
+  Packet16f fexponent;
+  const Packet16bf out = F32ToBf16(pfrexp<Packet16f>(Bf16ToF32(a), fexponent));
+  exponent = F32ToBf16(fexponent);
+  return out;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet16bf pldexp(const Packet16bf& a, const Packet16bf& exponent) {
+  return F32ToBf16(pldexp<Packet16f>(Bf16ToF32(a), Bf16ToF32(exponent)));
+}
 
 // Functions for sqrt.
 // The EIGEN_FAST_MATH version uses the _mm_rsqrt_ps approximation and one step
 // of Newton's method, at a cost of 1-2 bits of precision as opposed to the
 // exact solution. The main advantage of this approach is not just speed, but
 // also the fact that it can be inlined and pipelined with other computations,
 // further reducing its effective latency.
 #if EIGEN_FAST_MATH
 template <>
 EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet16f
 psqrt<Packet16f>(const Packet16f& _x) {
-  _EIGEN_DECLARE_CONST_Packet16f(one_point_five, 1.5f);
-  _EIGEN_DECLARE_CONST_Packet16f(minus_half, -0.5f);
-  _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(flt_min, 0x00800000);
-
-  Packet16f neg_half = pmul(_x, p16f_minus_half);
+  Packet16f neg_half = pmul(_x, pset1<Packet16f>(-.5f));
+  __mmask16 denormal_mask = _mm512_kand(
+      _mm512_cmp_ps_mask(_x, pset1<Packet16f>((std::numeric_limits<float>::min)()),
+                        _CMP_LT_OQ),
+      _mm512_cmp_ps_mask(_x, _mm512_setzero_ps(), _CMP_GE_OQ));
 
-  // select only the inverse sqrt of positive normal inputs (denormals are
-  // flushed to zero and cause infs as well).
-  __mmask16 non_zero_mask = _mm512_cmp_ps_mask(_x, p16f_flt_min, _CMP_GE_OQ);
-  Packet16f x = _mm512_mask_blend_ps(non_zero_mask, _mm512_setzero_ps(), _mm512_rsqrt14_ps(_x));
+  Packet16f x = _mm512_rsqrt14_ps(_x);
 
   // Do a single step of Newton's iteration.
-  x = pmul(x, pmadd(neg_half, pmul(x, x), p16f_one_point_five));
+  x = pmul(x, pmadd(neg_half, pmul(x, x), pset1<Packet16f>(1.5f)));
 
-  // Multiply the original _x by it's reciprocal square root to extract the
-  // square root.
-  return pmul(_x, x);
+  // Flush results for denormals to zero.
+  return _mm512_mask_blend_ps(denormal_mask, pmul(_x,x), _mm512_setzero_ps());
 }
 
 template <>
 EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet8d
 psqrt<Packet8d>(const Packet8d& _x) {
-  _EIGEN_DECLARE_CONST_Packet8d(one_point_five, 1.5);
-  _EIGEN_DECLARE_CONST_Packet8d(minus_half, -0.5);
-  _EIGEN_DECLARE_CONST_Packet8d_FROM_INT64(dbl_min, 0x0010000000000000LL);
+  Packet8d neg_half = pmul(_x, pset1<Packet8d>(-.5));
+  __mmask16 denormal_mask = _mm512_kand(
+      _mm512_cmp_pd_mask(_x, pset1<Packet8d>((std::numeric_limits<double>::min)()),
+                        _CMP_LT_OQ),
+      _mm512_cmp_pd_mask(_x, _mm512_setzero_pd(), _CMP_GE_OQ));
 
-  Packet8d neg_half = pmul(_x, p8d_minus_half);
+  Packet8d x = _mm512_rsqrt14_pd(_x);
 
-  // select only the inverse sqrt of positive normal inputs (denormals are
-  // flushed to zero and cause infs as well).
-  __mmask8 non_zero_mask = _mm512_cmp_pd_mask(_x, p8d_dbl_min, _CMP_GE_OQ);
-  Packet8d x = _mm512_mask_blend_pd(non_zero_mask, _mm512_setzero_pd(), _mm512_rsqrt14_pd(_x));
-
-  // Do a first step of Newton's iteration.
-  x = pmul(x, pmadd(neg_half, pmul(x, x), p8d_one_point_five));
+  // Do a single step of Newton's iteration.
+  x = pmul(x, pmadd(neg_half, pmul(x, x), pset1<Packet8d>(1.5)));
 
   // Do a second step of Newton's iteration.
-  x = pmul(x, pmadd(neg_half, pmul(x, x), p8d_one_point_five));
+  x = pmul(x, pmadd(neg_half, pmul(x, x), pset1<Packet8d>(1.5)));
 
-  // Multiply the original _x by it's reciprocal square root to extract the
-  // square root.
-  return pmul(_x, x);
+  return _mm512_mask_blend_pd(denormal_mask, pmul(_x,x), _mm512_setzero_pd());
 }
 #else
 template <>
 EIGEN_STRONG_INLINE Packet16f psqrt<Packet16f>(const Packet16f& x) {
   return _mm512_sqrt_ps(x);
 }
+
 template <>
 EIGEN_STRONG_INLINE Packet8d psqrt<Packet8d>(const Packet8d& x) {
   return _mm512_sqrt_pd(x);
 }
 #endif
 
-// Functions for rsqrt.
-// Almost identical to the sqrt routine, just leave out the last multiplication
-// and fill in NaN/Inf where needed. Note that this function only exists as an
-// iterative version for doubles since there is no instruction for diretly
-// computing the reciprocal square root in AVX-512.
-#ifdef EIGEN_FAST_MATH
+F16_PACKET_FUNCTION(Packet16f, Packet16h, psqrt)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, psqrt)
+
+// prsqrt for float.
+#if defined(EIGEN_VECTORIZE_AVX512ER)
+
+template <>
+EIGEN_STRONG_INLINE Packet16f prsqrt<Packet16f>(const Packet16f& x) {
+  return _mm512_rsqrt28_ps(x);
+}
+#elif EIGEN_FAST_MATH
+
 template <>
 EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet16f
 prsqrt<Packet16f>(const Packet16f& _x) {
   _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(inf, 0x7f800000);
-  _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(nan, 0x7fc00000);
   _EIGEN_DECLARE_CONST_Packet16f(one_point_five, 1.5f);
   _EIGEN_DECLARE_CONST_Packet16f(minus_half, -0.5f);
-  _EIGEN_DECLARE_CONST_Packet16f_FROM_INT(flt_min, 0x00800000);
 
   Packet16f neg_half = pmul(_x, p16f_minus_half);
 
-  // select only the inverse sqrt of positive normal inputs (denormals are
-  // flushed to zero and cause infs as well).
-  __mmask16 le_zero_mask = _mm512_cmp_ps_mask(_x, p16f_flt_min, _CMP_LT_OQ);
-  Packet16f x = _mm512_mask_blend_ps(le_zero_mask, _mm512_rsqrt14_ps(_x), _mm512_setzero_ps());
-
-  // Fill in NaNs and Infs for the negative/zero entries.
-  __mmask16 neg_mask = _mm512_cmp_ps_mask(_x, _mm512_setzero_ps(), _CMP_LT_OQ);
-  Packet16f infs_and_nans = _mm512_mask_blend_ps(
-      neg_mask, _mm512_mask_blend_ps(le_zero_mask, _mm512_setzero_ps(), p16f_inf), p16f_nan);
-
-  // Do a single step of Newton's iteration.
-  x = pmul(x, pmadd(neg_half, pmul(x, x), p16f_one_point_five));
+  // Identity infinite, negative and denormal arguments.
+  __mmask16 inf_mask = _mm512_cmp_ps_mask(_x, p16f_inf, _CMP_EQ_OQ);
+  __mmask16 not_pos_mask = _mm512_cmp_ps_mask(_x, _mm512_setzero_ps(), _CMP_LE_OQ);
+  __mmask16 not_finite_pos_mask = not_pos_mask | inf_mask;
+
+  // Compute an approximate result using the rsqrt intrinsic, forcing +inf
+  // for denormals for consistency with AVX and SSE implementations.
+  Packet16f y_approx = _mm512_rsqrt14_ps(_x);
+
+  // Do a single step of Newton-Raphson iteration to improve the approximation.
+  // This uses the formula y_{n+1} = y_n * (1.5 - y_n * (0.5 * x) * y_n).
+  // It is essential to evaluate the inner term like this because forming
+  // y_n^2 may over- or underflow.
+  Packet16f y_newton = pmul(y_approx, pmadd(y_approx, pmul(neg_half, y_approx), p16f_one_point_five));
+
+  // Select the result of the Newton-Raphson step for positive finite arguments.
+  // For other arguments, choose the output of the intrinsic. This will
+  // return rsqrt(+inf) = 0, rsqrt(x) = NaN if x < 0, and rsqrt(0) = +inf.
+  return _mm512_mask_blend_ps(not_finite_pos_mask, y_newton, y_approx);
+}
+#else
 
-  // Insert NaNs and Infs in all the right places.
-  return _mm512_mask_blend_ps(le_zero_mask, x, infs_and_nans);
+template <>
+EIGEN_STRONG_INLINE Packet16f prsqrt<Packet16f>(const Packet16f& x) {
+  _EIGEN_DECLARE_CONST_Packet16f(one, 1.0f);
+  return _mm512_div_ps(p16f_one, _mm512_sqrt_ps(x));
 }
+#endif
+
+F16_PACKET_FUNCTION(Packet16f, Packet16h, prsqrt)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, prsqrt)
 
+// prsqrt for double.
+#if EIGEN_FAST_MATH
 template <>
 EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet8d
 prsqrt<Packet8d>(const Packet8d& _x) {
-  _EIGEN_DECLARE_CONST_Packet8d_FROM_INT64(inf, 0x7ff0000000000000LL);
-  _EIGEN_DECLARE_CONST_Packet8d_FROM_INT64(nan, 0x7ff1000000000000LL);
   _EIGEN_DECLARE_CONST_Packet8d(one_point_five, 1.5);
   _EIGEN_DECLARE_CONST_Packet8d(minus_half, -0.5);
-  _EIGEN_DECLARE_CONST_Packet8d_FROM_INT64(dbl_min, 0x0010000000000000LL);
+  _EIGEN_DECLARE_CONST_Packet8d_FROM_INT64(inf, 0x7ff0000000000000LL);
 
   Packet8d neg_half = pmul(_x, p8d_minus_half);
 
-  // select only the inverse sqrt of positive normal inputs (denormals are
-  // flushed to zero and cause infs as well).
-  __mmask8 le_zero_mask = _mm512_cmp_pd_mask(_x, p8d_dbl_min, _CMP_LT_OQ);
-  Packet8d x = _mm512_mask_blend_pd(le_zero_mask, _mm512_rsqrt14_pd(_x), _mm512_setzero_pd());
-
-  // Fill in NaNs and Infs for the negative/zero entries.
-  __mmask8 neg_mask = _mm512_cmp_pd_mask(_x, _mm512_setzero_pd(), _CMP_LT_OQ);
-  Packet8d infs_and_nans = _mm512_mask_blend_pd(
-      neg_mask, _mm512_mask_blend_pd(le_zero_mask, _mm512_setzero_pd(), p8d_inf), p8d_nan);
+  // Identity infinite, negative and denormal arguments.
+  __mmask8 inf_mask = _mm512_cmp_pd_mask(_x, p8d_inf, _CMP_EQ_OQ);
+  __mmask8 not_pos_mask = _mm512_cmp_pd_mask(_x, _mm512_setzero_pd(), _CMP_LE_OQ);
+  __mmask8 not_finite_pos_mask = not_pos_mask | inf_mask;
+
+  // Compute an approximate result using the rsqrt intrinsic, forcing +inf
+  // for denormals for consistency with AVX and SSE implementations.
+#if defined(EIGEN_VECTORIZE_AVX512ER)
+  Packet8d y_approx = _mm512_rsqrt28_pd(_x);
+#else
+  Packet8d y_approx = _mm512_rsqrt14_pd(_x);
+#endif
+  // Do one or two steps of Newton-Raphson's to improve the approximation, depending on the
+  // starting accuracy (either 2^-14 or 2^-28, depending on whether AVX512ER is available).
+  // The Newton-Raphson algorithm has quadratic convergence and roughly doubles the number
+  // of correct digits for each step.
+  // This uses the formula y_{n+1} = y_n * (1.5 - y_n * (0.5 * x) * y_n).
+  // It is essential to evaluate the inner term like this because forming
+  // y_n^2 may over- or underflow.
+  Packet8d y_newton = pmul(y_approx, pmadd(neg_half, pmul(y_approx, y_approx), p8d_one_point_five));
+#if !defined(EIGEN_VECTORIZE_AVX512ER)
+  y_newton = pmul(y_newton, pmadd(y_newton, pmul(neg_half, y_newton), p8d_one_point_five));
+#endif
+  // Select the result of the Newton-Raphson step for positive finite arguments.
+  // For other arguments, choose the output of the intrinsic. This will
+  // return rsqrt(+inf) = 0, rsqrt(x) = NaN if x < 0, and rsqrt(0) = +inf.
+  return _mm512_mask_blend_pd(not_finite_pos_mask, y_newton, y_approx);
+}
+#else
+template <>
+EIGEN_STRONG_INLINE Packet8d prsqrt<Packet8d>(const Packet8d& x) {
+  _EIGEN_DECLARE_CONST_Packet8d(one, 1.0f);
+  return _mm512_div_pd(p8d_one, _mm512_sqrt_pd(x));
+}
+#endif
 
-  // Do a first step of Newton's iteration.
-  x = pmul(x, pmadd(neg_half, pmul(x, x), p8d_one_point_five));
+template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
+Packet16f plog1p<Packet16f>(const Packet16f& _x) {
+  return generic_plog1p(_x);
+}
 
-  // Do a second step of Newton's iteration.
-  x = pmul(x, pmadd(neg_half, pmul(x, x), p8d_one_point_five));
+F16_PACKET_FUNCTION(Packet16f, Packet16h, plog1p)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, plog1p)
 
-  // Insert NaNs and Infs in all the right places.
-  return _mm512_mask_blend_pd(le_zero_mask, x, infs_and_nans);
+template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
+Packet16f pexpm1<Packet16f>(const Packet16f& _x) {
+  return generic_expm1(_x);
 }
-#elif defined(EIGEN_VECTORIZE_AVX512ER)
+
+F16_PACKET_FUNCTION(Packet16f, Packet16h, pexpm1)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, pexpm1)
+
+#endif
+
+
 template <>
-EIGEN_STRONG_INLINE Packet16f prsqrt<Packet16f>(const Packet16f& x) {
-  return _mm512_rsqrt28_ps(x);
+EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet16f
+psin<Packet16f>(const Packet16f& _x) {
+  return psin_float(_x);
 }
-#endif
-#endif
+
+template <>
+EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet16f
+pcos<Packet16f>(const Packet16f& _x) {
+  return pcos_float(_x);
+}
+
+template <>
+EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet16f
+ptanh<Packet16f>(const Packet16f& _x) {
+  return internal::generic_fast_tanh_float(_x);
+}
+
+F16_PACKET_FUNCTION(Packet16f, Packet16h, psin)
+F16_PACKET_FUNCTION(Packet16f, Packet16h, pcos)
+F16_PACKET_FUNCTION(Packet16f, Packet16h, ptanh)
+
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, psin)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, pcos)
+BF16_PACKET_FUNCTION(Packet16f, Packet16bf, ptanh)
 
 }  // end namespace internal
 
 }  // end namespace Eigen
 
 #endif  // THIRD_PARTY_EIGEN3_EIGEN_SRC_CORE_ARCH_AVX512_MATHFUNCTIONS_H_
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/AltiVec/Complex.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/AltiVec/Complex.h`

 * *Files 14% similar despite different names*

```diff
@@ -25,23 +25,70 @@
 static Packet2ul  p2ul_CONJ_XOR2 = (Packet2ul) vec_sld((Packet4ui) p2d_MZERO, (Packet4ui) p2l_ZERO, 8);//{ 0x8000000000000000, 0x0000000000000000 };
 #endif
 #endif
 
 //---------- float ----------
 struct Packet2cf
 {
-  EIGEN_STRONG_INLINE explicit Packet2cf() : v(p4f_ZERO) {}
+  EIGEN_STRONG_INLINE explicit Packet2cf() {}
   EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}
+
+  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b)
+  {
+    Packet4f v1, v2;
+
+    // Permute and multiply the real parts of a and b
+    v1 = vec_perm(a.v, a.v, p16uc_PSET32_WODD);
+    // Get the imaginary parts of a
+    v2 = vec_perm(a.v, a.v, p16uc_PSET32_WEVEN);
+    // multiply a_re * b
+    v1 = vec_madd(v1, b.v, p4f_ZERO);
+    // multiply a_im * b and get the conjugate result
+    v2 = vec_madd(v2, b.v, p4f_ZERO);
+    v2 = reinterpret_cast<Packet4f>(pxor(v2, reinterpret_cast<Packet4f>(p4ui_CONJ_XOR)));
+    // permute back to a proper order
+    v2 = vec_perm(v2, v2, p16uc_COMPLEX32_REV);
+
+    return Packet2cf(padd<Packet4f>(v1, v2));
+  }
+
+  EIGEN_STRONG_INLINE Packet2cf& operator*=(const Packet2cf& b) {
+    v = pmul(Packet2cf(*this), b).v;
+    return *this;
+  }
+  EIGEN_STRONG_INLINE Packet2cf operator*(const Packet2cf& b) const {
+    return Packet2cf(*this) *= b;
+  }
+
+  EIGEN_STRONG_INLINE Packet2cf& operator+=(const Packet2cf& b) {
+    v = padd(v, b.v);
+    return *this;
+  }
+  EIGEN_STRONG_INLINE Packet2cf operator+(const Packet2cf& b) const {
+    return Packet2cf(*this) += b;
+  }
+  EIGEN_STRONG_INLINE Packet2cf& operator-=(const Packet2cf& b) {
+    v = psub(v, b.v);
+    return *this;
+  }
+  EIGEN_STRONG_INLINE Packet2cf operator-(const Packet2cf& b) const {
+    return Packet2cf(*this) -= b;
+  }
+  EIGEN_STRONG_INLINE Packet2cf operator-(void) const {
+    return Packet2cf(-v);
+  }
+
   Packet4f  v;
 };
 
 template<> struct packet_traits<std::complex<float> >  : default_packet_traits
 {
   typedef Packet2cf type;
   typedef Packet2cf half;
+  typedef Packet4f as_real;
   enum {
     Vectorizable = 1,
     AlignedOnScalar = 1,
     size = 2,
     HasHalfPacket = 0,
 
     HasAdd    = 1,
@@ -56,15 +103,15 @@
 #ifdef __VSX__
     HasBlend  = 1,
 #endif
     HasSetLinear = 0
   };
 };
 
-template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };
+template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false}; typedef Packet2cf half; typedef Packet4f as_real; };
 
 template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)
 {
   Packet2cf res;
   if((std::ptrdiff_t(&from) % 16) == 0)
     res.v = pload<Packet4f>((const float *)&from);
   else
@@ -76,63 +123,63 @@
 template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>*        from) { return Packet2cf(pload<Packet4f>((const float *) from)); }
 template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>*       from) { return Packet2cf(ploadu<Packet4f>((const float*) from)); }
 template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from) { return pset1<Packet2cf>(*from); }
 
 template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { pstore((float*)to, from.v); }
 template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { pstoreu((float*)to, from.v); }
 
+EIGEN_STRONG_INLINE Packet2cf pload2(const std::complex<float>* from0, const std::complex<float>* from1)
+{
+  Packet4f res0, res1;
+#ifdef __VSX__
+  __asm__ ("lxsdx %x0,%y1" : "=wa" (res0) : "Z" (*from0));
+  __asm__ ("lxsdx %x0,%y1" : "=wa" (res1) : "Z" (*from1));
+#ifdef _BIG_ENDIAN
+  __asm__ ("xxpermdi %x0, %x1, %x2, 0" : "=wa" (res0) : "wa" (res0), "wa" (res1));
+#else
+  __asm__ ("xxpermdi %x0, %x2, %x1, 0" : "=wa" (res0) : "wa" (res0), "wa" (res1));
+#endif
+#else
+  *reinterpret_cast<std::complex<float> *>(&res0) = *from0;
+  *reinterpret_cast<std::complex<float> *>(&res1) = *from1;
+  res0 = vec_perm(res0, res1, p16uc_TRANSPOSE64_HI);
+#endif
+  return Packet2cf(res0);
+}
+
 template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)
 {
-  std::complex<float> EIGEN_ALIGN16 af[2];
+  EIGEN_ALIGN16 std::complex<float> af[2];
   af[0] = from[0*stride];
   af[1] = from[1*stride];
   return pload<Packet2cf>(af);
 }
 template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)
 {
-  std::complex<float> EIGEN_ALIGN16 af[2];
+  EIGEN_ALIGN16 std::complex<float> af[2];
   pstore<std::complex<float> >((std::complex<float> *) af, from);
   to[0*stride] = af[0];
   to[1*stride] = af[1];
 }
 
 template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(a.v + b.v); }
 template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(a.v - b.v); }
 template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf(pxor<Packet4f>(a.v, reinterpret_cast<Packet4f>(p4ui_CONJ_XOR))); }
 
-template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
-{
-  Packet4f v1, v2;
-
-  // Permute and multiply the real parts of a and b
-  v1 = vec_perm(a.v, a.v, p16uc_PSET32_WODD);
-  // Get the imaginary parts of a
-  v2 = vec_perm(a.v, a.v, p16uc_PSET32_WEVEN);
-  // multiply a_re * b 
-  v1 = vec_madd(v1, b.v, p4f_ZERO);
-  // multiply a_im * b and get the conjugate result
-  v2 = vec_madd(v2, b.v, p4f_ZERO);
-  v2 = reinterpret_cast<Packet4f>(pxor(v2, reinterpret_cast<Packet4f>(p4ui_CONJ_XOR)));
-  // permute back to a proper order
-  v2 = vec_perm(v2, v2, p16uc_COMPLEX32_REV);
-  
-  return Packet2cf(padd<Packet4f>(v1, v2));
-}
-
 template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pand<Packet4f>(a.v, b.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(por<Packet4f>(a.v, b.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pxor<Packet4f>(a.v, b.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pandnot<Packet4f>(a.v, b.v)); }
 
 template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> * addr)    { EIGEN_PPC_PREFETCH(addr); }
 
 template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)
 {
-  std::complex<float> EIGEN_ALIGN16 res[2];
+  EIGEN_ALIGN16 std::complex<float> res[2];
   pstore((float *)&res, a.v);
 
   return res[0];
 }
 
 template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)
 {
@@ -145,95 +192,30 @@
 {
   Packet4f b;
   b = vec_sld(a.v, a.v, 8);
   b = padd<Packet4f>(a.v, b);
   return pfirst<Packet2cf>(Packet2cf(b));
 }
 
-template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)
-{
-  Packet4f b1, b2;
-#ifdef _BIG_ENDIAN  
-  b1 = vec_sld(vecs[0].v, vecs[1].v, 8);
-  b2 = vec_sld(vecs[1].v, vecs[0].v, 8);
-#else
-  b1 = vec_sld(vecs[1].v, vecs[0].v, 8);
-  b2 = vec_sld(vecs[0].v, vecs[1].v, 8);
-#endif
-  b2 = vec_sld(b2, b2, 8);
-  b2 = padd<Packet4f>(b1, b2);
-
-  return Packet2cf(b2);
-}
-
 template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)
 {
   Packet4f b;
   Packet2cf prod;
   b = vec_sld(a.v, a.v, 8);
   prod = pmul<Packet2cf>(a, Packet2cf(b));
 
   return pfirst<Packet2cf>(prod);
 }
 
-template<int Offset>
-struct palign_impl<Offset,Packet2cf>
-{
-  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)
-  {
-    if (Offset==1)
-    {
-#ifdef _BIG_ENDIAN
-      first.v = vec_sld(first.v, second.v, 8);
-#else
-      first.v = vec_sld(second.v, first.v, 8);
-#endif
-    }
-  }
-};
-
-template<> struct conj_helper<Packet2cf, Packet2cf, false,true>
-{
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return internal::pmul(a, pconj(b));
-  }
-};
-
-template<> struct conj_helper<Packet2cf, Packet2cf, true,false>
-{
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return internal::pmul(pconj(a), b);
-  }
-};
-
-template<> struct conj_helper<Packet2cf, Packet2cf, true,true>
-{
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return pconj(internal::pmul(a, b));
-  }
-};
-
 EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet2cf,Packet4f)
 
 template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
 {
   // TODO optimize it for AltiVec
-  Packet2cf res = conj_helper<Packet2cf,Packet2cf,false,true>().pmul(a, b);
+  Packet2cf res = pmul(a, pconj(b));
   Packet4f s = pmul<Packet4f>(b.v, b.v);
   return Packet2cf(pdiv(res.v, padd<Packet4f>(s, vec_perm(s, s, p16uc_COMPLEX32_REV))));
 }
 
 template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)
 {
   return Packet2cf(vec_perm(x.v, x.v, p16uc_COMPLEX32_REV));
@@ -242,35 +224,91 @@
 EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet2cf,2>& kernel)
 {
   Packet4f tmp = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_HI);
   kernel.packet[1].v = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_LO);
   kernel.packet[0].v = tmp;
 }
 
+template<> EIGEN_STRONG_INLINE Packet2cf pcmp_eq(const Packet2cf& a, const Packet2cf& b) {
+  Packet4f eq = reinterpret_cast<Packet4f>(vec_cmpeq(a.v,b.v));
+  return Packet2cf(vec_and(eq, vec_perm(eq, eq, p16uc_COMPLEX32_REV)));
+}
+
 #ifdef __VSX__
 template<> EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {
   Packet2cf result;
   result.v = reinterpret_cast<Packet4f>(pblend<Packet2d>(ifPacket, reinterpret_cast<Packet2d>(thenPacket.v), reinterpret_cast<Packet2d>(elsePacket.v)));
   return result;
 }
 #endif
 
+template<> EIGEN_STRONG_INLINE Packet2cf psqrt<Packet2cf>(const Packet2cf& a)
+{
+  return psqrt_complex<Packet2cf>(a);
+}
+
 //---------- double ----------
 #ifdef __VSX__
 struct Packet1cd
 {
   EIGEN_STRONG_INLINE Packet1cd() {}
   EIGEN_STRONG_INLINE explicit Packet1cd(const Packet2d& a) : v(a) {}
+
+  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b)
+  {
+    Packet2d a_re, a_im, v1, v2;
+
+    // Permute and multiply the real parts of a and b
+    a_re = vec_perm(a.v, a.v, p16uc_PSET64_HI);
+    // Get the imaginary parts of a
+    a_im = vec_perm(a.v, a.v, p16uc_PSET64_LO);
+    // multiply a_re * b
+    v1 = vec_madd(a_re, b.v, p2d_ZERO);
+    // multiply a_im * b and get the conjugate result
+    v2 = vec_madd(a_im, b.v, p2d_ZERO);
+    v2 = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4ui>(v2), reinterpret_cast<Packet4ui>(v2), 8));
+    v2 = pxor(v2, reinterpret_cast<Packet2d>(p2ul_CONJ_XOR1));
+
+    return Packet1cd(padd<Packet2d>(v1, v2));
+  }
+
+  EIGEN_STRONG_INLINE Packet1cd& operator*=(const Packet1cd& b) {
+    v = pmul(Packet1cd(*this), b).v;
+    return *this;
+  }
+  EIGEN_STRONG_INLINE Packet1cd operator*(const Packet1cd& b) const {
+    return Packet1cd(*this) *= b;
+  }
+
+  EIGEN_STRONG_INLINE Packet1cd& operator+=(const Packet1cd& b) {
+    v = padd(v, b.v);
+    return *this;
+  }
+  EIGEN_STRONG_INLINE Packet1cd operator+(const Packet1cd& b) const {
+    return Packet1cd(*this) += b;
+  }
+  EIGEN_STRONG_INLINE Packet1cd& operator-=(const Packet1cd& b) {
+    v = psub(v, b.v);
+    return *this;
+  }
+  EIGEN_STRONG_INLINE Packet1cd operator-(const Packet1cd& b) const {
+    return Packet1cd(*this) -= b;
+  }
+  EIGEN_STRONG_INLINE Packet1cd operator-(void) const {
+    return Packet1cd(-v);
+  }
+
   Packet2d v;
 };
 
 template<> struct packet_traits<std::complex<double> >  : default_packet_traits
 {
   typedef Packet1cd type;
   typedef Packet1cd half;
+  typedef Packet2d as_real;
   enum {
     Vectorizable = 1,
     AlignedOnScalar = 0,
     size = 1,
     HasHalfPacket = 0,
 
     HasAdd    = 1,
@@ -282,135 +320,67 @@
     HasAbs2   = 0,
     HasMin    = 0,
     HasMax    = 0,
     HasSetLinear = 0
   };
 };
 
-template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };
+template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false}; typedef Packet1cd half; typedef Packet2d as_real; };
 
 template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from) { return Packet1cd(pload<Packet2d>((const double*)from)); }
 template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { return Packet1cd(ploadu<Packet2d>((const double*)from)); }
 template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { pstore((double*)to, from.v); }
 template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { pstoreu((double*)to, from.v); }
 
 template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)
 { /* here we really have to use unaligned loads :( */ return ploadu<Packet1cd>(&from); }
 
-template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride)
+template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index)
 {
-  std::complex<double> EIGEN_ALIGN16 af[2];
-  af[0] = from[0*stride];
-  af[1] = from[1*stride];
-  return pload<Packet1cd>(af);
+  return pload<Packet1cd>(from);
 }
-template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride)
+template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index)
 {
-  std::complex<double> EIGEN_ALIGN16 af[2];
-  pstore<std::complex<double> >(af, from);
-  to[0*stride] = af[0];
-  to[1*stride] = af[1];
+  pstore<std::complex<double> >(to, from);
 }
 
 template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v + b.v); }
 template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v - b.v); }
 template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }
 template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd(pxor(a.v, reinterpret_cast<Packet2d>(p2ul_CONJ_XOR2))); }
 
-template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
-{
-  Packet2d a_re, a_im, v1, v2;
-
-  // Permute and multiply the real parts of a and b
-  a_re = vec_perm(a.v, a.v, p16uc_PSET64_HI);
-  // Get the imaginary parts of a
-  a_im = vec_perm(a.v, a.v, p16uc_PSET64_LO);
-  // multiply a_re * b
-  v1 = vec_madd(a_re, b.v, p2d_ZERO);
-  // multiply a_im * b and get the conjugate result
-  v2 = vec_madd(a_im, b.v, p2d_ZERO);
-  v2 = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4ui>(v2), reinterpret_cast<Packet4ui>(v2), 8));
-  v2 = pxor(v2, reinterpret_cast<Packet2d>(p2ul_CONJ_XOR1));
-
-  return Packet1cd(padd<Packet2d>(v1, v2));
-}
-
 template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pand(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(por(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pxor(a.v,b.v)); }
 template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(pandnot(a.v, b.v)); }
 
 template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>*     from)  { return pset1<Packet1cd>(*from); }
 
 template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> * addr)    { EIGEN_PPC_PREFETCH(addr); }
 
 template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)
 {
-  std::complex<double> EIGEN_ALIGN16 res[2];
+  EIGEN_ALIGN16 std::complex<double> res[2];
   pstore<std::complex<double> >(res, a);
 
   return res[0];
 }
 
 template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }
 
 template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a) { return pfirst(a); }
-template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)        { return vecs[0]; }
 
 template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a) { return pfirst(a); }
 
-template<int Offset>
-struct palign_impl<Offset,Packet1cd>
-{
-  static EIGEN_STRONG_INLINE void run(Packet1cd& /*first*/, const Packet1cd& /*second*/)
-  {
-    // FIXME is it sure we never have to align a Packet1cd?
-    // Even though a std::complex<double> has 16 bytes, it is not necessarily aligned on a 16 bytes boundary...
-  }
-};
-
-template<> struct conj_helper<Packet1cd, Packet1cd, false,true>
-{
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return internal::pmul(a, pconj(b));
-  }
-};
-
-template<> struct conj_helper<Packet1cd, Packet1cd, true,false>
-{
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return internal::pmul(pconj(a), b);
-  }
-};
-
-template<> struct conj_helper<Packet1cd, Packet1cd, true,true>
-{
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return pconj(internal::pmul(a, b));
-  }
-};
-
 EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet1cd,Packet2d)
 
 template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
 {
   // TODO optimize it for AltiVec
-  Packet1cd res = conj_helper<Packet1cd,Packet1cd,false,true>().pmul(a,b);
+  Packet1cd res = pmul(a,pconj(b));
   Packet2d s = pmul<Packet2d>(b.v, b.v);
   return Packet1cd(pdiv(res.v, padd<Packet2d>(s, vec_perm(s, s, p16uc_REVERSE64))));
 }
 
 EIGEN_STRONG_INLINE Packet1cd pcplxflip/*<Packet1cd>*/(const Packet1cd& x)
 {
   return Packet1cd(preverse(Packet2d(x.v)));
@@ -418,13 +388,30 @@
 
 EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)
 {
   Packet2d tmp = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_HI);
   kernel.packet[1].v = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_LO);
   kernel.packet[0].v = tmp;
 }
+
+template<> EIGEN_STRONG_INLINE Packet1cd pcmp_eq(const Packet1cd& a, const Packet1cd& b) {
+  // Compare real and imaginary parts of a and b to get the mask vector:
+  // [re(a)==re(b), im(a)==im(b)]
+  Packet2d eq = reinterpret_cast<Packet2d>(vec_cmpeq(a.v,b.v));
+  // Swap real/imag elements in the mask in to get:
+  // [im(a)==im(b), re(a)==re(b)]
+  Packet2d eq_swapped = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4ui>(eq), reinterpret_cast<Packet4ui>(eq), 8));
+  // Return re(a)==re(b) & im(a)==im(b) by computing bitwise AND of eq and eq_swapped
+  return Packet1cd(vec_and(eq, eq_swapped));
+}
+
+template<> EIGEN_STRONG_INLINE Packet1cd psqrt<Packet1cd>(const Packet1cd& a)
+{
+  return psqrt_complex<Packet1cd>(a);
+}
+
 #endif // __VSX__
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_COMPLEX32_ALTIVEC_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/AltiVec/MathFunctions.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/ZVector/MathFunctions.h`

 * *Files 20% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 #ifndef EIGEN_MATH_FUNCTIONS_ALTIVEC_H
 #define EIGEN_MATH_FUNCTIONS_ALTIVEC_H
 
 namespace Eigen {
 
 namespace internal {
 
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
 static _EIGEN_DECLARE_CONST_Packet4f(1 , 1.0f);
 static _EIGEN_DECLARE_CONST_Packet4f(half, 0.5f);
 static _EIGEN_DECLARE_CONST_Packet4i(0x7f, 0x7f);
 static _EIGEN_DECLARE_CONST_Packet4i(23, 23);
 
 static _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(inv_mant_mask, ~0x7f800000);
 
@@ -57,16 +58,16 @@
 
 static _EIGEN_DECLARE_CONST_Packet4f(cephes_exp_p0, 1.9875691500E-4f);
 static _EIGEN_DECLARE_CONST_Packet4f(cephes_exp_p1, 1.3981999507E-3f);
 static _EIGEN_DECLARE_CONST_Packet4f(cephes_exp_p2, 8.3334519073E-3f);
 static _EIGEN_DECLARE_CONST_Packet4f(cephes_exp_p3, 4.1665795894E-2f);
 static _EIGEN_DECLARE_CONST_Packet4f(cephes_exp_p4, 1.6666665459E-1f);
 static _EIGEN_DECLARE_CONST_Packet4f(cephes_exp_p5, 5.0000001201E-1f);
+#endif
 
-#ifdef __VSX__
 static _EIGEN_DECLARE_CONST_Packet2d(1 , 1.0);
 static _EIGEN_DECLARE_CONST_Packet2d(2 , 2.0);
 static _EIGEN_DECLARE_CONST_Packet2d(half, 0.5);
 
 static _EIGEN_DECLARE_CONST_Packet2d(exp_hi,  709.437);
 static _EIGEN_DECLARE_CONST_Packet2d(exp_lo, -709.436139303);
 
@@ -80,85 +81,69 @@
 static _EIGEN_DECLARE_CONST_Packet2d(cephes_exp_q1, 2.52448340349684104192e-3);
 static _EIGEN_DECLARE_CONST_Packet2d(cephes_exp_q2, 2.27265548208155028766e-1);
 static _EIGEN_DECLARE_CONST_Packet2d(cephes_exp_q3, 2.00000000000000000009e0);
 
 static _EIGEN_DECLARE_CONST_Packet2d(cephes_exp_C1, 0.693145751953125);
 static _EIGEN_DECLARE_CONST_Packet2d(cephes_exp_C2, 1.42860682030941723212e-6);
 
-#ifdef __POWER8_VECTOR__
-static Packet2l p2l_1023 = { 1023, 1023 };
-static Packet2ul p2ul_52 = { 52, 52 };
-#endif
-
-#endif
-
 template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
-Packet4f plog<Packet4f>(const Packet4f& _x)
+Packet2d pexp<Packet2d>(const Packet2d& _x)
 {
-  Packet4f x = _x;
+  Packet2d x = _x;
 
-  Packet4i emm0;
+  Packet2d tmp, fx;
+  Packet2l emm0;
+
+  // clamp x
+  x = pmax(pmin(x, p2d_exp_hi), p2d_exp_lo);
+  /* express exp(x) as exp(g + n*log(2)) */
+  fx = pmadd(p2d_cephes_LOG2EF, x, p2d_half);
+
+  fx = vec_floor(fx);
 
-  /* isvalid_mask is 0 if x < 0 or x is NaN. */
-  Packet4ui isvalid_mask = reinterpret_cast<Packet4ui>(vec_cmpge(x, p4f_ZERO));
-  Packet4ui iszero_mask = reinterpret_cast<Packet4ui>(vec_cmpeq(x, p4f_ZERO));
-
-  x = pmax(x, p4f_min_norm_pos);  /* cut off denormalized stuff */
-  emm0 = vec_sr(reinterpret_cast<Packet4i>(x),
-                reinterpret_cast<Packet4ui>(p4i_23));
-
-  /* keep only the fractional part */
-  x = pand(x, p4f_inv_mant_mask);
-  x = por(x, p4f_half);
-
-  emm0 = psub(emm0, p4i_0x7f);
-  Packet4f e = padd(vec_ctf(emm0, 0), p4f_1);
-
-  /* part2:
-     if( x < SQRTHF ) {
-       e -= 1;
-       x = x + x - 1.0;
-     } else { x = x - 1.0; }
-  */
-  Packet4f mask = reinterpret_cast<Packet4f>(vec_cmplt(x, p4f_cephes_SQRTHF));
-  Packet4f tmp = pand(x, mask);
-  x = psub(x, p4f_1);
-  e = psub(e, pand(p4f_1, mask));
-  x = padd(x, tmp);
-
-  Packet4f x2 = pmul(x,x);
-  Packet4f x3 = pmul(x2,x);
-
-  Packet4f y, y1, y2;
-  y  = pmadd(p4f_cephes_log_p0, x, p4f_cephes_log_p1);
-  y1 = pmadd(p4f_cephes_log_p3, x, p4f_cephes_log_p4);
-  y2 = pmadd(p4f_cephes_log_p6, x, p4f_cephes_log_p7);
-  y  = pmadd(y , x, p4f_cephes_log_p2);
-  y1 = pmadd(y1, x, p4f_cephes_log_p5);
-  y2 = pmadd(y2, x, p4f_cephes_log_p8);
-  y = pmadd(y, x3, y1);
-  y = pmadd(y, x3, y2);
-  y = pmul(y, x3);
-
-  y1 = pmul(e, p4f_cephes_log_q1);
-  tmp = pmul(x2, p4f_half);
-  y = padd(y, y1);
+  tmp = pmul(fx, p2d_cephes_exp_C1);
+  Packet2d z = pmul(fx, p2d_cephes_exp_C2);
   x = psub(x, tmp);
-  y2 = pmul(e, p4f_cephes_log_q2);
-  x = padd(x, y);
-  x = padd(x, y2);
-  // negative arg will be NAN, 0 will be -INF
-  x = vec_sel(x, p4f_minus_inf, iszero_mask);
-  x = vec_sel(p4f_minus_nan, x, isvalid_mask);
-  return x;
+  x = psub(x, z);
+
+  Packet2d x2 = pmul(x,x);
+
+  Packet2d px = p2d_cephes_exp_p0;
+  px = pmadd(px, x2, p2d_cephes_exp_p1);
+  px = pmadd(px, x2, p2d_cephes_exp_p2);
+  px = pmul (px, x);
+
+  Packet2d qx = p2d_cephes_exp_q0;
+  qx = pmadd(qx, x2, p2d_cephes_exp_q1);
+  qx = pmadd(qx, x2, p2d_cephes_exp_q2);
+  qx = pmadd(qx, x2, p2d_cephes_exp_q3);
+
+  x = pdiv(px,psub(qx,px));
+  x = pmadd(p2d_2,x,p2d_1);
+
+  // build 2^n
+  emm0 = vec_ctsl(fx, 0);
+
+  static const Packet2l p2l_1023 = { 1023, 1023 };
+  static const Packet2ul p2ul_52 = { 52, 52 };
+
+  emm0 = emm0 + p2l_1023;
+  emm0 = emm0 << reinterpret_cast<Packet2l>(p2ul_52);
+
+  // Altivec's max & min operators just drop silent NaNs. Check NaNs in 
+  // inputs and return them unmodified.
+  Packet2ul isnumber_mask = reinterpret_cast<Packet2ul>(vec_cmpeq(_x, _x));
+  return vec_sel(_x, pmax(pmul(x, reinterpret_cast<Packet2d>(emm0)), _x),
+                 isnumber_mask);
 }
 
 template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
 Packet4f pexp<Packet4f>(const Packet4f& _x)
 {
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
   Packet4f x = _x;
 
   Packet4f tmp, fx;
   Packet4i emm0;
 
   // clamp x
   x = pmax(pmin(x, p4f_exp_hi), p4f_exp_lo);
@@ -181,142 +166,68 @@
   y = pmadd(y, x, p4f_cephes_exp_p3);
   y = pmadd(y, x, p4f_cephes_exp_p4);
   y = pmadd(y, x, p4f_cephes_exp_p5);
   y = pmadd(y, z, x);
   y = padd(y, p4f_1);
 
   // build 2^n
-  emm0 = vec_cts(fx, 0);
-  emm0 = vec_add(emm0, p4i_0x7f);
-  emm0 = vec_sl(emm0, reinterpret_cast<Packet4ui>(p4i_23));
-
-  // Altivec's max & min operators just drop silent NaNs. Check NaNs in 
-  // inputs and return them unmodified.
-  Packet4ui isnumber_mask = reinterpret_cast<Packet4ui>(vec_cmpeq(_x, _x));
-  return vec_sel(_x, pmax(pmul(y, reinterpret_cast<Packet4f>(emm0)), _x),
-                 isnumber_mask);
-}
+  emm0 = (Packet4i){ (int)fx[0], (int)fx[1], (int)fx[2], (int)fx[3] };
+  emm0 = emm0 + p4i_0x7f;
+  emm0 = emm0 << reinterpret_cast<Packet4i>(p4i_23);
 
-#ifndef EIGEN_COMP_CLANG
-template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
-Packet4f prsqrt<Packet4f>(const Packet4f& x)
-{
-  return  vec_rsqrt(x);
-}
+  return pmax(pmul(y, reinterpret_cast<Packet4f>(emm0)), _x);
+#else
+  Packet4f res;
+  res.v4f[0] = pexp<Packet2d>(_x.v4f[0]);
+  res.v4f[1] = pexp<Packet2d>(_x.v4f[1]);
+  return res;
 #endif
-
-#ifdef __VSX__
-#ifndef EIGEN_COMP_CLANG
-template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
-Packet2d prsqrt<Packet2d>(const Packet2d& x)
-{
-  return  vec_rsqrt(x);
 }
-#endif
 
 template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
-Packet4f psqrt<Packet4f>(const Packet4f& x)
+Packet2d psqrt<Packet2d>(const Packet2d& x)
 {
-  return  vec_sqrt(x);
+  return vec_sqrt(x);
 }
 
 template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
-Packet2d psqrt<Packet2d>(const Packet2d& x)
+Packet4f psqrt<Packet4f>(const Packet4f& x)
 {
-  return  vec_sqrt(x);
-}
-
-// VSX support varies between different compilers and even different
-// versions of the same compiler.  For gcc version >= 4.9.3, we can use
-// vec_cts to efficiently convert Packet2d to Packet2l.  Otherwise, use
-// a slow version that works with older compilers. 
-// Update: apparently vec_cts/vec_ctf intrinsics for 64-bit doubles
-// are buggy, https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70963
-static inline Packet2l ConvertToPacket2l(const Packet2d& x) {
-#if EIGEN_GNUC_AT_LEAST(5, 4) || \
-    (EIGEN_GNUC_AT(6, 1) && __GNUC_PATCHLEVEL__ >= 1)
-  return vec_cts(x, 0);    // TODO: check clang version.
+  Packet4f res;
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
+  res = vec_sqrt(x);
 #else
-  double tmp[2];
-  memcpy(tmp, &x, sizeof(tmp));
-  Packet2l l = { static_cast<long long>(tmp[0]),
-                 static_cast<long long>(tmp[1]) };
-  return l;
+  res.v4f[0] = psqrt<Packet2d>(x.v4f[0]);
+  res.v4f[1] = psqrt<Packet2d>(x.v4f[1]);
 #endif
+  return res;
 }
 
 template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
-Packet2d pexp<Packet2d>(const Packet2d& _x)
-{
-  Packet2d x = _x;
-
-  Packet2d tmp, fx;
-  Packet2l emm0;
-
-  // clamp x
-  x = pmax(pmin(x, p2d_exp_hi), p2d_exp_lo);
-
-  /* express exp(x) as exp(g + n*log(2)) */
-  fx = pmadd(x, p2d_cephes_LOG2EF, p2d_half);
-
-  fx = pfloor(fx);
-
-  tmp = pmul(fx, p2d_cephes_exp_C1);
-  Packet2d z = pmul(fx, p2d_cephes_exp_C2);
-  x = psub(x, tmp);
-  x = psub(x, z);
-
-  Packet2d x2 = pmul(x,x);
-
-  Packet2d px = p2d_cephes_exp_p0;
-  px = pmadd(px, x2, p2d_cephes_exp_p1);
-  px = pmadd(px, x2, p2d_cephes_exp_p2);
-  px = pmul (px, x);
-
-  Packet2d qx = p2d_cephes_exp_q0;
-  qx = pmadd(qx, x2, p2d_cephes_exp_q1);
-  qx = pmadd(qx, x2, p2d_cephes_exp_q2);
-  qx = pmadd(qx, x2, p2d_cephes_exp_q3);
-
-  x = pdiv(px,psub(qx,px));
-  x = pmadd(p2d_2,x,p2d_1);
-
-  // build 2^n
-  emm0 = ConvertToPacket2l(fx);
+Packet2d prsqrt<Packet2d>(const Packet2d& x) {
+  return pset1<Packet2d>(1.0) / psqrt<Packet2d>(x);
+}
 
-#ifdef __POWER8_VECTOR__ 
-  emm0 = vec_add(emm0, p2l_1023);
-  emm0 = vec_sl(emm0, p2ul_52);
-#else
-  // Code is a bit complex for POWER7.  There is actually a
-  // vec_xxsldi intrinsic but it is not supported by some gcc versions.
-  // So we shift (52-32) bits and do a word swap with zeros.
-  _EIGEN_DECLARE_CONST_Packet4i(1023, 1023);
-  _EIGEN_DECLARE_CONST_Packet4i(20, 20);    // 52 - 32
-
-  Packet4i emm04i = reinterpret_cast<Packet4i>(emm0);
-  emm04i = vec_add(emm04i, p4i_1023);
-  emm04i = vec_sl(emm04i, reinterpret_cast<Packet4ui>(p4i_20));
-  static const Packet16uc perm = {
-    0x14, 0x15, 0x16, 0x17, 0x00, 0x01, 0x02, 0x03, 
-    0x1c, 0x1d, 0x1e, 0x1f, 0x08, 0x09, 0x0a, 0x0b };
-#ifdef  _BIG_ENDIAN
-  emm0 = reinterpret_cast<Packet2l>(vec_perm(p4i_ZERO, emm04i, perm));
+template<> EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED
+Packet4f prsqrt<Packet4f>(const Packet4f& x) {
+  Packet4f res;
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
+  res = pset1<Packet4f>(1.0) / psqrt<Packet4f>(x);
 #else
-  emm0 = reinterpret_cast<Packet2l>(vec_perm(emm04i, p4i_ZERO, perm));
-#endif
-
+  res.v4f[0] = prsqrt<Packet2d>(x.v4f[0]);
+  res.v4f[1] = prsqrt<Packet2d>(x.v4f[1]);
 #endif
+  return res;
+}
 
-  // Altivec's max & min operators just drop silent NaNs. Check NaNs in 
-  // inputs and return them unmodified.
-  Packet2ul isnumber_mask = reinterpret_cast<Packet2ul>(vec_cmpeq(_x, _x));
-  return vec_sel(_x, pmax(pmul(x, reinterpret_cast<Packet2d>(emm0)), _x),
-                 isnumber_mask);
+// Hyperbolic Tangent function.
+template <>
+EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED Packet4f
+ptanh<Packet4f>(const Packet4f& x) {
+  return internal::generic_fast_tanh_float(x);
 }
-#endif
 
 }  // end namespace internal
 
 }  // end namespace Eigen
 
 #endif  // EIGEN_MATH_FUNCTIONS_ALTIVEC_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/AltiVec/PacketMath.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/ZVector/PacketMath.h`

 * *Files 15% similar despite different names*

```diff
@@ -1,1061 +1,1060 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
-// Copyright (C) 2008-2016 Konstantinos Margaritis <markos@freevec.org>
+// Copyright (C) 2016 Konstantinos Margaritis <markos@freevec.org>
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-#ifndef EIGEN_PACKET_MATH_ALTIVEC_H
-#define EIGEN_PACKET_MATH_ALTIVEC_H
+#ifndef EIGEN_PACKET_MATH_ZVECTOR_H
+#define EIGEN_PACKET_MATH_ZVECTOR_H
 
 namespace Eigen {
 
 namespace internal {
 
 #ifndef EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD
-#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD 4
+#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD 16
 #endif
 
 #ifndef EIGEN_HAS_SINGLE_INSTRUCTION_MADD
 #define EIGEN_HAS_SINGLE_INSTRUCTION_MADD
 #endif
 
-#ifndef EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD
-#define EIGEN_HAS_SINGLE_INSTRUCTION_CJMADD
-#endif
-
-// NOTE Altivec has 32 registers, but Eigen only accepts a value of 8 or 16
 #ifndef EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS
 #define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS  32
 #endif
 
-typedef __vector float          Packet4f;
-typedef __vector int            Packet4i;
-typedef __vector unsigned int   Packet4ui;
-typedef __vector __bool int     Packet4bi;
-typedef __vector short int      Packet8i;
-typedef __vector unsigned char  Packet16uc;
+typedef __vector int                 Packet4i;
+typedef __vector unsigned int        Packet4ui;
+typedef __vector __bool int          Packet4bi;
+typedef __vector short int           Packet8i;
+typedef __vector unsigned char       Packet16uc;
+typedef __vector double              Packet2d;
+typedef __vector unsigned long long  Packet2ul;
+typedef __vector long long           Packet2l;
+
+// Z14 has builtin support for float vectors
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
+typedef __vector float               Packet4f;
+#else
+typedef struct {
+	Packet2d  v4f[2];
+} Packet4f;
+#endif
+
+typedef union {
+  numext::int32_t   i[4];
+  numext::uint32_t ui[4];
+  numext::int64_t   l[2];
+  numext::uint64_t ul[2];
+  double    d[2];
+  float     f[4];
+  Packet4i  v4i;
+  Packet4ui v4ui;
+  Packet2l  v2l;
+  Packet2ul v2ul;
+  Packet2d  v2d;
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
+  Packet4f  v4f;
+#endif
+} Packet;
 
 // We don't want to write the same code all the time, but we need to reuse the constants
 // and it doesn't really work to declare them global, so we define macros instead
 
-#define _EIGEN_DECLARE_CONST_FAST_Packet4f(NAME,X) \
-  Packet4f p4f_##NAME = reinterpret_cast<Packet4f>(vec_splat_s32(X))
-
 #define _EIGEN_DECLARE_CONST_FAST_Packet4i(NAME,X) \
-  Packet4i p4i_##NAME = vec_splat_s32(X)
+  Packet4i p4i_##NAME = reinterpret_cast<Packet4i>(vec_splat_s32(X))
 
-#define _EIGEN_DECLARE_CONST_Packet4f(NAME,X) \
-  Packet4f p4f_##NAME = pset1<Packet4f>(X)
+#define _EIGEN_DECLARE_CONST_FAST_Packet2d(NAME,X) \
+  Packet2d p2d_##NAME = reinterpret_cast<Packet2d>(vec_splat_s64(X))
+
+#define _EIGEN_DECLARE_CONST_FAST_Packet2l(NAME,X) \
+  Packet2l p2l_##NAME = reinterpret_cast<Packet2l>(vec_splat_s64(X))
 
 #define _EIGEN_DECLARE_CONST_Packet4i(NAME,X) \
   Packet4i p4i_##NAME = pset1<Packet4i>(X)
 
 #define _EIGEN_DECLARE_CONST_Packet2d(NAME,X) \
   Packet2d p2d_##NAME = pset1<Packet2d>(X)
 
 #define _EIGEN_DECLARE_CONST_Packet2l(NAME,X) \
   Packet2l p2l_##NAME = pset1<Packet2l>(X)
 
-#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(NAME,X) \
-  const Packet4f p4f_##NAME = reinterpret_cast<Packet4f>(pset1<Packet4i>(X))
+// These constants are endian-agnostic
+static _EIGEN_DECLARE_CONST_FAST_Packet4i(ZERO, 0); //{ 0, 0, 0, 0,}
+static _EIGEN_DECLARE_CONST_FAST_Packet4i(ONE, 1); //{ 1, 1, 1, 1}
 
-#define DST_CHAN 1
-#define DST_CTRL(size, count, stride) (((size) << 24) | ((count) << 16) | (stride))
+static _EIGEN_DECLARE_CONST_FAST_Packet2d(ZERO, 0);
+static _EIGEN_DECLARE_CONST_FAST_Packet2l(ZERO, 0);
+static _EIGEN_DECLARE_CONST_FAST_Packet2l(ONE, 1);
 
+static Packet2d p2d_ONE = { 1.0, 1.0 };
+static Packet2d p2d_ZERO_ = { numext::bit_cast<double>0x8000000000000000ull),
+                              numext::bit_cast<double>0x8000000000000000ull) };
+
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
+#define _EIGEN_DECLARE_CONST_FAST_Packet4f(NAME,X) \
+  Packet4f p4f_##NAME = reinterpret_cast<Packet4f>(vec_splat_s32(X))
+
+#define _EIGEN_DECLARE_CONST_Packet4f(NAME,X) \
+  Packet4f p4f_##NAME = pset1<Packet4f>(X)
+
+#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(NAME,X) \
+  const Packet4f p4f_##NAME = reinterpret_cast<Packet4f>(pset1<Packet4i>(X))
 
-// These constants are endian-agnostic
 static _EIGEN_DECLARE_CONST_FAST_Packet4f(ZERO, 0); //{ 0.0, 0.0, 0.0, 0.0}
-static _EIGEN_DECLARE_CONST_FAST_Packet4i(ZERO, 0); //{ 0, 0, 0, 0,}
-static _EIGEN_DECLARE_CONST_FAST_Packet4i(ONE,1); //{ 1, 1, 1, 1}
-static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS16,-16); //{ -16, -16, -16, -16}
 static _EIGEN_DECLARE_CONST_FAST_Packet4i(MINUS1,-1); //{ -1, -1, -1, -1}
-static Packet4f p4f_MZERO = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1); //{ 0x80000000, 0x80000000, 0x80000000, 0x80000000}
-#ifndef __VSX__
-static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0); //{ 1.0, 1.0, 1.0, 1.0}
+static Packet4f p4f_MZERO = { 0x80000000, 0x80000000, 0x80000000, 0x80000000};
 #endif
 
-static Packet4f p4f_COUNTDOWN = { 0.0, 1.0, 2.0, 3.0 };
 static Packet4i p4i_COUNTDOWN = { 0, 1, 2, 3 };
+static Packet4f p4f_COUNTDOWN = { 0.0, 1.0, 2.0, 3.0 };
+static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet16uc>(p2d_ZERO), reinterpret_cast<Packet16uc>(p2d_ONE), 8));
 
-static Packet16uc p16uc_REVERSE32 = { 12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3 };
+static Packet16uc p16uc_PSET64_HI = { 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };
 static Packet16uc p16uc_DUPLICATE32_HI = { 0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7 };
 
 // Mask alignment
-#ifdef __PPC64__
 #define _EIGEN_MASK_ALIGNMENT	0xfffffffffffffff0
-#else
-#define _EIGEN_MASK_ALIGNMENT	0xfffffff0
-#endif
 
 #define _EIGEN_ALIGNED_PTR(x)	((std::ptrdiff_t)(x) & _EIGEN_MASK_ALIGNMENT)
 
 // Handle endianness properly while loading constants
 // Define global static constants:
-#ifdef _BIG_ENDIAN
-static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);
-#ifdef __VSX__
+
+static Packet16uc p16uc_FORWARD =   { 0,1,2,3, 4,5,6,7, 8,9,10,11, 12,13,14,15 };
+static Packet16uc p16uc_REVERSE32 = { 12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3 };
 static Packet16uc p16uc_REVERSE64 = { 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };
-#endif
+
 static Packet16uc p16uc_PSET32_WODD   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);//{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };
 static Packet16uc p16uc_PSET32_WEVEN  = vec_sld(p16uc_DUPLICATE32_HI, (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);//{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };
-static Packet16uc p16uc_HALF64_0_16 = vec_sld((Packet16uc)p4i_ZERO, vec_splat((Packet16uc) vec_abs(p4i_MINUS16), 3), 8);      //{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16};
-#else
-static Packet16uc p16uc_FORWARD = p16uc_REVERSE32;
-static Packet16uc p16uc_REVERSE64 = { 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };
-static Packet16uc p16uc_PSET32_WODD = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);//{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };
-static Packet16uc p16uc_PSET32_WEVEN = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);//{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };
-static Packet16uc p16uc_HALF64_0_16 = vec_sld(vec_splat((Packet16uc) vec_abs(p4i_MINUS16), 0), (Packet16uc)p4i_ZERO, 8);      //{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16};
-#endif // _BIG_ENDIAN
+/*static Packet16uc p16uc_HALF64_0_16 = vec_sld((Packet16uc)p4i_ZERO, vec_splat((Packet16uc) vec_abs(p4i_MINUS16), 3), 8);      //{ 0,0,0,0, 0,0,0,0, 16,16,16,16, 16,16,16,16};
 
-static Packet16uc p16uc_PSET64_HI = (Packet16uc) vec_mergeh((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     //{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };
+static Packet16uc p16uc_PSET64_HI = (Packet16uc) vec_mergeh((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     //{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };*/
 static Packet16uc p16uc_PSET64_LO = (Packet16uc) vec_mergel((Packet4ui)p16uc_PSET32_WODD, (Packet4ui)p16uc_PSET32_WEVEN);     //{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };
-static Packet16uc p16uc_TRANSPOSE64_HI = p16uc_PSET64_HI + p16uc_HALF64_0_16;                                         //{ 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23};
-static Packet16uc p16uc_TRANSPOSE64_LO = p16uc_PSET64_LO + p16uc_HALF64_0_16;                                         //{ 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31};
+/*static Packet16uc p16uc_TRANSPOSE64_HI = vec_add(p16uc_PSET64_HI, p16uc_HALF64_0_16);                                         //{ 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23};
+static Packet16uc p16uc_TRANSPOSE64_LO = vec_add(p16uc_PSET64_LO, p16uc_HALF64_0_16);                                         //{ 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31};*/
+static Packet16uc p16uc_TRANSPOSE64_HI = { 0,1,2,3, 4,5,6,7, 16,17,18,19, 20,21,22,23};
+static Packet16uc p16uc_TRANSPOSE64_LO = { 8,9,10,11, 12,13,14,15, 24,25,26,27, 28,29,30,31};
 
 static Packet16uc p16uc_COMPLEX32_REV = vec_sld(p16uc_REVERSE32, p16uc_REVERSE32, 8);                                         //{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };
 
-#ifdef _BIG_ENDIAN
 static Packet16uc p16uc_COMPLEX32_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);                                            //{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };
-#else
-static Packet16uc p16uc_COMPLEX32_REV2 = vec_sld(p16uc_PSET64_HI, p16uc_PSET64_LO, 8);                                            //{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };
-#endif // _BIG_ENDIAN
+
 
 #if EIGEN_HAS_BUILTIN(__builtin_prefetch) || EIGEN_COMP_GNUC
-  #define EIGEN_PPC_PREFETCH(ADDR) __builtin_prefetch(ADDR);
+  #define EIGEN_ZVECTOR_PREFETCH(ADDR) __builtin_prefetch(ADDR);
 #else
-  #define EIGEN_PPC_PREFETCH(ADDR) asm( "   dcbt [%[addr]]\n" :: [addr] "r" (ADDR) : "cc" );
+  #define EIGEN_ZVECTOR_PREFETCH(ADDR) asm( "   pfd [%[addr]]\n" :: [addr] "r" (ADDR) : "cc" );
 #endif
 
-template<> struct packet_traits<float>  : default_packet_traits
+template<> struct packet_traits<int>    : default_packet_traits
 {
-  typedef Packet4f type;
-  typedef Packet4f half;
+  typedef Packet4i type;
+  typedef Packet4i half;
   enum {
     Vectorizable = 1,
     AlignedOnScalar = 1,
-    size=4,
-    HasHalfPacket = 1,
+    size = 4,
+    HasHalfPacket = 0,
 
     HasAdd  = 1,
     HasSub  = 1,
     HasMul  = 1,
     HasDiv  = 1,
-    HasMin  = 1,
-    HasMax  = 1,
-    HasAbs  = 1,
-    HasSin  = 0,
-    HasCos  = 0,
-    HasLog  = 0,
-    HasExp  = 1,
-#ifdef __VSX__
+    HasBlend = 1
+  };
+};
+
+template <>
+struct packet_traits<float> : default_packet_traits {
+  typedef Packet4f type;
+  typedef Packet4f half;
+  enum {
+    Vectorizable = 1,
+    AlignedOnScalar = 1,
+    size = 4,
+    HasHalfPacket = 0,
+
+    HasAdd = 1,
+    HasSub = 1,
+    HasMul = 1,
+    HasDiv = 1,
+    HasMin = 1,
+    HasMax = 1,
+    HasAbs = 1,
+    HasSin = 0,
+    HasCos = 0,
+    HasLog = 0,
+    HasExp = 1,
     HasSqrt = 1,
-#if !EIGEN_COMP_CLANG
     HasRsqrt = 1,
-#else
-    HasRsqrt = 0,
-#endif
-#else
-    HasSqrt = 0,
-    HasRsqrt = 0,
-#endif
+    HasTanh = 1,
+    HasErf = 1,
     HasRound = 1,
     HasFloor = 1,
     HasCeil = 1,
     HasNegate = 1,
     HasBlend = 1
   };
 };
-template<> struct packet_traits<int>    : default_packet_traits
+
+template<> struct packet_traits<double> : default_packet_traits
 {
-  typedef Packet4i type;
-  typedef Packet4i half;
+  typedef Packet2d type;
+  typedef Packet2d half;
   enum {
     Vectorizable = 1,
     AlignedOnScalar = 1,
-    size = 4,
-    HasHalfPacket = 0,
+    size=2,
+    HasHalfPacket = 1,
 
     HasAdd  = 1,
     HasSub  = 1,
     HasMul  = 1,
-    HasDiv  = 0,
+    HasDiv  = 1,
+    HasMin  = 1,
+    HasMax  = 1,
+    HasAbs  = 1,
+    HasSin  = 0,
+    HasCos  = 0,
+    HasLog  = 0,
+    HasExp  = 1,
+    HasSqrt = 1,
+    HasRsqrt = 1,
+    HasRound = 1,
+    HasFloor = 1,
+    HasCeil = 1,
+    HasNegate = 1,
     HasBlend = 1
   };
 };
 
+template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false}; typedef Packet4i half; };
+template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false}; typedef Packet4f half; };
+template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false}; typedef Packet2d half; };
+
+/* Forward declaration */
+EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet4f,4>& kernel);
+ 
+inline std::ostream & operator <<(std::ostream & s, const Packet4i & v)
+{
+  Packet vt;
+  vt.v4i = v;
+  s << vt.i[0] << ", " << vt.i[1] << ", " << vt.i[2] << ", " << vt.i[3];
+  return s;
+}
 
-template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };
-template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };
-
-inline std::ostream & operator <<(std::ostream & s, const Packet16uc & v)
+inline std::ostream & operator <<(std::ostream & s, const Packet4ui & v)
 {
-  union {
-    Packet16uc   v;
-    unsigned char n[16];
-  } vt;
-  vt.v = v;
-  for (int i=0; i< 16; i++)
-    s << (int)vt.n[i] << ", ";
+  Packet vt;
+  vt.v4ui = v;
+  s << vt.ui[0] << ", " << vt.ui[1] << ", " << vt.ui[2] << ", " << vt.ui[3];
   return s;
 }
 
-inline std::ostream & operator <<(std::ostream & s, const Packet4f & v)
+inline std::ostream & operator <<(std::ostream & s, const Packet2l & v)
 {
-  union {
-    Packet4f   v;
-    float n[4];
-  } vt;
-  vt.v = v;
-  s << vt.n[0] << ", " << vt.n[1] << ", " << vt.n[2] << ", " << vt.n[3];
+  Packet vt;
+  vt.v2l = v;
+  s << vt.l[0] << ", " << vt.l[1];
   return s;
 }
 
-inline std::ostream & operator <<(std::ostream & s, const Packet4i & v)
+inline std::ostream & operator <<(std::ostream & s, const Packet2ul & v)
 {
-  union {
-    Packet4i   v;
-    int n[4];
-  } vt;
-  vt.v = v;
-  s << vt.n[0] << ", " << vt.n[1] << ", " << vt.n[2] << ", " << vt.n[3];
+  Packet vt;
+  vt.v2ul = v;
+  s << vt.ul[0] << ", " << vt.ul[1] ;
   return s;
 }
 
-inline std::ostream & operator <<(std::ostream & s, const Packet4ui & v)
+inline std::ostream & operator <<(std::ostream & s, const Packet2d & v)
 {
-  union {
-    Packet4ui   v;
-    unsigned int n[4];
-  } vt;
-  vt.v = v;
-  s << vt.n[0] << ", " << vt.n[1] << ", " << vt.n[2] << ", " << vt.n[3];
+  Packet vt;
+  vt.v2d = v;
+  s << vt.d[0] << ", " << vt.d[1];
   return s;
 }
 
-// Need to define them first or we get specialization after instantiation errors
-template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from)
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
+inline std::ostream & operator <<(std::ostream & s, const Packet4f & v)
 {
-  EIGEN_DEBUG_ALIGNED_LOAD
-#ifdef __VSX__
-  return vec_vsx_ld(0, from);
-#else
-  return vec_ld(0, from);
-#endif
+  Packet vt;
+  vt.v4f = v;
+  s << vt.f[0] << ", " << vt.f[1] << ", " << vt.f[2] << ", " << vt.f[3];
+  return s;
 }
+#endif
 
 template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from)
 {
+  // FIXME: No intrinsic yet
   EIGEN_DEBUG_ALIGNED_LOAD
-#ifdef __VSX__
-  return vec_vsx_ld(0, from);
-#else
-  return vec_ld(0, from);
-#endif
+  Packet *vfrom;
+  vfrom = (Packet *) from;
+  return vfrom->v4i;
 }
 
-template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from)
+template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from)
 {
-  EIGEN_DEBUG_ALIGNED_STORE
-#ifdef __VSX__
-  vec_vsx_st(from, 0, to);
-#else
-  vec_st(from, 0, to);
-#endif
+  // FIXME: No intrinsic yet
+  EIGEN_DEBUG_ALIGNED_LOAD
+  Packet *vfrom;
+  vfrom = (Packet *) from;
+  return vfrom->v2d;
 }
 
 template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from)
 {
+  // FIXME: No intrinsic yet
   EIGEN_DEBUG_ALIGNED_STORE
-#ifdef __VSX__
-  vec_vsx_st(from, 0, to);
-#else
-  vec_st(from, 0, to);
-#endif
+  Packet *vto;
+  vto = (Packet *) to;
+  vto->v4i = from;
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {
-  Packet4f v = {from, from, from, from};
-  return v;
+template<> EIGEN_STRONG_INLINE void pstore<double>(double*   to, const Packet2d& from)
+{
+  // FIXME: No intrinsic yet
+  EIGEN_DEBUG_ALIGNED_STORE
+  Packet *vto;
+  vto = (Packet *) to;
+  vto->v2d = from;
 }
 
-template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {
-  Packet4i v = {from, from, from, from};
-  return v;
-}
-template<> EIGEN_STRONG_INLINE void
-pbroadcast4<Packet4f>(const float *a,
-                      Packet4f& a0, Packet4f& a1, Packet4f& a2, Packet4f& a3)
+template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)
 {
-  a3 = pload<Packet4f>(a);
-  a0 = vec_splat(a3, 0);
-  a1 = vec_splat(a3, 1);
-  a2 = vec_splat(a3, 2);
-  a3 = vec_splat(a3, 3);
+  return vec_splats(from);
 }
+template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) {
+  return vec_splats(from);
+}
+
 template<> EIGEN_STRONG_INLINE void
 pbroadcast4<Packet4i>(const int *a,
                       Packet4i& a0, Packet4i& a1, Packet4i& a2, Packet4i& a3)
 {
   a3 = pload<Packet4i>(a);
   a0 = vec_splat(a3, 0);
   a1 = vec_splat(a3, 1);
   a2 = vec_splat(a3, 2);
   a3 = vec_splat(a3, 3);
 }
 
-template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)
+template<> EIGEN_STRONG_INLINE void
+pbroadcast4<Packet2d>(const double *a,
+                      Packet2d& a0, Packet2d& a1, Packet2d& a2, Packet2d& a3)
 {
-  float EIGEN_ALIGN16 af[4];
-  af[0] = from[0*stride];
-  af[1] = from[1*stride];
-  af[2] = from[2*stride];
-  af[3] = from[3*stride];
- return pload<Packet4f>(af);
+  a1 = pload<Packet2d>(a);
+  a0 = vec_splat(a1, 0);
+  a1 = vec_splat(a1, 1);
+  a3 = pload<Packet2d>(a+2);
+  a2 = vec_splat(a3, 0);
+  a3 = vec_splat(a3, 1);
 }
+
 template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)
 {
   int EIGEN_ALIGN16 ai[4];
   ai[0] = from[0*stride];
   ai[1] = from[1*stride];
   ai[2] = from[2*stride];
   ai[3] = from[3*stride];
  return pload<Packet4i>(ai);
 }
-template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)
+
+template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)
 {
-  float EIGEN_ALIGN16 af[4];
-  pstore<float>(af, from);
-  to[0*stride] = af[0];
-  to[1*stride] = af[1];
-  to[2*stride] = af[2];
-  to[3*stride] = af[3];
+  double EIGEN_ALIGN16 af[2];
+  af[0] = from[0*stride];
+  af[1] = from[1*stride];
+ return pload<Packet2d>(af);
 }
+
 template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)
 {
   int EIGEN_ALIGN16 ai[4];
   pstore<int>((int *)ai, from);
   to[0*stride] = ai[0];
   to[1*stride] = ai[1];
   to[2*stride] = ai[2];
   to[3*stride] = ai[3];
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a) { return pset1<Packet4f>(a) + p4f_COUNTDOWN; }
-template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a)   { return pset1<Packet4i>(a) + p4i_COUNTDOWN; }
-
-template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return a + b; }
-template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return a + b; }
-
-template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return a - b; }
-template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return a - b; }
-
-template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return p4f_ZERO - a; }
-template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return p4i_ZERO - a; }
+template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)
+{
+  double EIGEN_ALIGN16 af[2];
+  pstore<double>(af, from);
+  to[0*stride] = af[0];
+  to[1*stride] = af[1];
+}
 
-template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }
-template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }
+template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a + b); }
+template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a + b); }
 
-template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b, p4f_MZERO); }
-template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return a * b; }
+template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a - b); }
+template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a - b); }
 
-template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)
-{
-#ifndef __VSX__  // VSX actually provides a div instruction
-  Packet4f t, y_0, y_1;
+template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a * b); }
+template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a * b); }
 
-  // Altivec does not offer a divide instruction, we have to do a reciprocal approximation
-  y_0 = vec_re(b);
+template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& a, const Packet4i& b) { return (a / b); }
+template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return (a / b); }
 
-  // Do one Newton-Raphson iteration to get the needed accuracy
-  t   = vec_nmsub(y_0, b, p4f_ONE);
-  y_1 = vec_madd(y_0, t, y_0);
+template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return (-a); }
+template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) { return (-a); }
 
-  return vec_madd(a, y_1, p4f_MZERO);
-#else
-  return vec_div(a, b);
-#endif
-}
+template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }
+template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }
 
-template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& /*a*/, const Packet4i& /*b*/)
-{ eigen_assert(false && "packet integer division are not supported by AltiVec");
-  return pset1<Packet4i>(0);
-}
+template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd<Packet4i>(pmul<Packet4i>(a, b), c); }
+template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vec_madd(a, b, c); }
 
-// for some weird raisons, it has to be overloaded for packet of integers
-template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a,b,c); }
-template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return a*b + c; }
+template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a)    { return padd<Packet4i>(pset1<Packet4i>(a), p4i_COUNTDOWN); }
+template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return padd<Packet2d>(pset1<Packet2d>(a), p2d_COUNTDOWN); }
 
-template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b)
-{
-  #ifdef __VSX__
-  Packet4f ret;
-  __asm__ ("xvcmpgesp %x0,%x1,%x2\n\txxsel %x0,%x1,%x2,%x0" : "=&wa" (ret) : "wa" (a), "wa" (b));
-  return ret;
-  #else
-  return vec_min(a, b);
-  #endif
-}
 template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }
+template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_min(a, b); }
 
-template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b)
-{
-  #ifdef __VSX__
-  Packet4f ret;
-  __asm__ ("xvcmpgtsp %x0,%x2,%x1\n\txxsel %x0,%x1,%x2,%x0" : "=&wa" (ret) : "wa" (a), "wa" (b));
-  return ret;
-  #else
-  return vec_max(a, b);
-  #endif
-}
 template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }
+template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_max(a, b); }
 
-template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }
 template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }
+template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, b); }
 
-template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }
 template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }
+template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_or(a, b); }
 
-template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }
 template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }
+template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_xor(a, b); }
 
-template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }
-template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }
+template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return pand<Packet4i>(a, vec_nor(b, b)); }
+template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, vec_nor(b, b)); }
 
-template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a) { return vec_round(a); }
-template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const  Packet4f& a) { return vec_ceil(a); }
-template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a) { return vec_floor(a); }
+template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return vec_round(a); }
+template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const  Packet2d& a) { return vec_ceil(a); }
+template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return vec_floor(a); }
 
-#ifdef _BIG_ENDIAN
-template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
-{
-  EIGEN_DEBUG_ALIGNED_LOAD
-  Packet16uc MSQ, LSQ;
-  Packet16uc mask;
-  MSQ = vec_ld(0, (unsigned char *)from);          // most significant quadword
-  LSQ = vec_ld(15, (unsigned char *)from);         // least significant quadword
-  mask = vec_lvsl(0, from);                        // create the permute mask
-  return (Packet4f) vec_perm(MSQ, LSQ, mask);           // align the data
+template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int*       from) { return pload<Packet4i>(from); }
+template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double*    from) { return pload<Packet2d>(from); }
 
-}
-template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
-{
-  EIGEN_DEBUG_ALIGNED_LOAD
-  // Taken from http://developer.apple.com/hardwaredrivers/ve/alignment.html
-  Packet16uc MSQ, LSQ;
-  Packet16uc mask;
-  MSQ = vec_ld(0, (unsigned char *)from);          // most significant quadword
-  LSQ = vec_ld(15, (unsigned char *)from);         // least significant quadword
-  mask = vec_lvsl(0, from);                        // create the permute mask
-  return (Packet4i) vec_perm(MSQ, LSQ, mask);    // align the data
-}
-#else
-// We also need ot redefine little endian loading of Packet4i/Packet4f using VSX
-template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
-{
-  EIGEN_DEBUG_UNALIGNED_LOAD
-  return (Packet4i) vec_vsx_ld((long)from & 15, (const int*) _EIGEN_ALIGNED_PTR(from));
-}
-template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
-{
-  EIGEN_DEBUG_UNALIGNED_LOAD
-  return (Packet4f) vec_vsx_ld((long)from & 15, (const float*) _EIGEN_ALIGNED_PTR(from));
-}
-#endif
 
-template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
-{
-  Packet4f p;
-  if((std::ptrdiff_t(from) % 16) == 0)  p = pload<Packet4f>(from);
-  else                                  p = ploadu<Packet4f>(from);
-  return vec_perm(p, p, p16uc_DUPLICATE32_HI);
-}
 template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
 {
-  Packet4i p;
-  if((std::ptrdiff_t(from) % 16) == 0)  p = pload<Packet4i>(from);
-  else                                  p = ploadu<Packet4i>(from);
+  Packet4i p = pload<Packet4i>(from);
   return vec_perm(p, p, p16uc_DUPLICATE32_HI);
 }
 
-#ifdef _BIG_ENDIAN
-template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)
-{
-  EIGEN_DEBUG_UNALIGNED_STORE
-  // Taken from http://developer.apple.com/hardwaredrivers/ve/alignment.html
-  // Warning: not thread safe!
-  Packet16uc MSQ, LSQ, edges;
-  Packet16uc edgeAlign, align;
-
-  MSQ = vec_ld(0, (unsigned char *)to);                     // most significant quadword
-  LSQ = vec_ld(15, (unsigned char *)to);                    // least significant quadword
-  edgeAlign = vec_lvsl(0, to);                              // permute map to extract edges
-  edges=vec_perm(LSQ,MSQ,edgeAlign);                        // extract the edges
-  align = vec_lvsr( 0, to );                                // permute map to misalign data
-  MSQ = vec_perm(edges,(Packet16uc)from,align);             // misalign the data (MSQ)
-  LSQ = vec_perm((Packet16uc)from,edges,align);             // misalign the data (LSQ)
-  vec_st( LSQ, 15, (unsigned char *)to );                   // Store the LSQ part first
-  vec_st( MSQ, 0, (unsigned char *)to );                    // Store the MSQ part
-}
-template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)
-{
-  EIGEN_DEBUG_UNALIGNED_STORE
-  // Taken from http://developer.apple.com/hardwaredrivers/ve/alignment.html
-  // Warning: not thread safe!
-  Packet16uc MSQ, LSQ, edges;
-  Packet16uc edgeAlign, align;
-
-  MSQ = vec_ld(0, (unsigned char *)to);                     // most significant quadword
-  LSQ = vec_ld(15, (unsigned char *)to);                    // least significant quadword
-  edgeAlign = vec_lvsl(0, to);                              // permute map to extract edges
-  edges=vec_perm(LSQ, MSQ, edgeAlign);                      // extract the edges
-  align = vec_lvsr( 0, to );                                // permute map to misalign data
-  MSQ = vec_perm(edges, (Packet16uc) from, align);          // misalign the data (MSQ)
-  LSQ = vec_perm((Packet16uc) from, edges, align);          // misalign the data (LSQ)
-  vec_st( LSQ, 15, (unsigned char *)to );                   // Store the LSQ part first
-  vec_st( MSQ, 0, (unsigned char *)to );                    // Store the MSQ part
-}
-#else
-// We also need ot redefine little endian loading of Packet4i/Packet4f using VSX
-template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet4i& from)
-{
-  EIGEN_DEBUG_ALIGNED_STORE
-  vec_vsx_st(from, (long)to & 15, (int*) _EIGEN_ALIGNED_PTR(to));
-}
-template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet4f& from)
+template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*   from)
 {
-  EIGEN_DEBUG_ALIGNED_STORE
-  vec_vsx_st(from, (long)to & 15, (float*) _EIGEN_ALIGNED_PTR(to));
+  Packet2d p = pload<Packet2d>(from);
+  return vec_perm(p, p, p16uc_PSET64_HI);
 }
-#endif
 
-template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr)    { EIGEN_PPC_PREFETCH(addr); }
-template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr)    { EIGEN_PPC_PREFETCH(addr); }
+template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*        to, const Packet4i& from) { pstore<int>(to, from); }
+template<> EIGEN_STRONG_INLINE void pstoreu<double>(double*  to, const Packet2d& from) { pstore<double>(to, from); }
 
-template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x; vec_ste(a, 0, &x); return x; }
-template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x; vec_ste(a, 0, &x); return x; }
+template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { EIGEN_ZVECTOR_PREFETCH(addr); }
+template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { EIGEN_ZVECTOR_PREFETCH(addr); }
 
-template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)
-{
-  return reinterpret_cast<Packet4f>(vec_perm(reinterpret_cast<Packet16uc>(a), reinterpret_cast<Packet16uc>(a), p16uc_REVERSE32));
-}
-template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)
-{
-  return reinterpret_cast<Packet4i>(vec_perm(reinterpret_cast<Packet16uc>(a), reinterpret_cast<Packet16uc>(a), p16uc_REVERSE32)); }
+template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int    EIGEN_ALIGN16 x[4]; pstore(x, a); return x[0]; }
+template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double EIGEN_ALIGN16 x[2]; pstore(x, a); return x[0]; }
 
-template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }
-template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }
-
-template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)
+template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)
 {
-  Packet4f b, sum;
-  b   = vec_sld(a, a, 8);
-  sum = a + b;
-  b   = vec_sld(sum, sum, 4);
-  sum += b;
-  return pfirst(sum);
+  return reinterpret_cast<Packet4i>(vec_perm(reinterpret_cast<Packet16uc>(a), reinterpret_cast<Packet16uc>(a), p16uc_REVERSE32));
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)
+template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)
 {
-  Packet4f v[4], sum[4];
-
-  // It's easier and faster to transpose then add as columns
-  // Check: http://www.freevec.org/function/matrix_4x4_transpose_floats for explanation
-  // Do the transpose, first set of moves
-  v[0] = vec_mergeh(vecs[0], vecs[2]);
-  v[1] = vec_mergel(vecs[0], vecs[2]);
-  v[2] = vec_mergeh(vecs[1], vecs[3]);
-  v[3] = vec_mergel(vecs[1], vecs[3]);
-  // Get the resulting vectors
-  sum[0] = vec_mergeh(v[0], v[2]);
-  sum[1] = vec_mergel(v[0], v[2]);
-  sum[2] = vec_mergeh(v[1], v[3]);
-  sum[3] = vec_mergel(v[1], v[3]);
-
-  // Now do the summation:
-  // Lines 0+1
-  sum[0] = sum[0] + sum[1];
-  // Lines 2+3
-  sum[1] = sum[2] + sum[3];
-  // Add the results
-  sum[0] = sum[0] + sum[1];
-
-  return sum[0];
+  return reinterpret_cast<Packet2d>(vec_perm(reinterpret_cast<Packet16uc>(a), reinterpret_cast<Packet16uc>(a), p16uc_REVERSE64));
 }
 
+template<> EIGEN_STRONG_INLINE Packet4i pabs<Packet4i>(const Packet4i& a) { return vec_abs(a); }
+template<> EIGEN_STRONG_INLINE Packet2d pabs<Packet2d>(const Packet2d& a) { return vec_abs(a); }
+
 template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)
 {
-  Packet4i sum;
-  sum = vec_sums(a, p4i_ZERO);
-#ifdef _BIG_ENDIAN
-  sum = vec_sld(sum, p4i_ZERO, 12);
-#else
-  sum = vec_sld(p4i_ZERO, sum, 4);
-#endif
+  Packet4i b, sum;
+  b   = vec_sld(a, a, 8);
+  sum = padd<Packet4i>(a, b);
+  b   = vec_sld(sum, sum, 4);
+  sum = padd<Packet4i>(sum, b);
   return pfirst(sum);
 }
 
-template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)
+template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)
 {
-  Packet4i v[4], sum[4];
-
-  // It's easier and faster to transpose then add as columns
-  // Check: http://www.freevec.org/function/matrix_4x4_transpose_floats for explanation
-  // Do the transpose, first set of moves
-  v[0] = vec_mergeh(vecs[0], vecs[2]);
-  v[1] = vec_mergel(vecs[0], vecs[2]);
-  v[2] = vec_mergeh(vecs[1], vecs[3]);
-  v[3] = vec_mergel(vecs[1], vecs[3]);
-  // Get the resulting vectors
-  sum[0] = vec_mergeh(v[0], v[2]);
-  sum[1] = vec_mergel(v[0], v[2]);
-  sum[2] = vec_mergeh(v[1], v[3]);
-  sum[3] = vec_mergel(v[1], v[3]);
-
-  // Now do the summation:
-  // Lines 0+1
-  sum[0] = sum[0] + sum[1];
-  // Lines 2+3
-  sum[1] = sum[2] + sum[3];
-  // Add the results
-  sum[0] = sum[0] + sum[1];
-
-  return sum[0];
+  Packet2d b, sum;
+  b   = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4i>(a), reinterpret_cast<Packet4i>(a), 8));
+  sum = padd<Packet2d>(a, b);
+  return pfirst(sum);
 }
 
 // Other reduction functions:
 // mul
-template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)
-{
-  Packet4f prod;
-  prod = pmul(a, vec_sld(a, a, 8));
-  return pfirst(pmul(prod, vec_sld(prod, prod, 4)));
-}
-
 template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)
 {
   EIGEN_ALIGN16 int aux[4];
   pstore(aux, a);
   return aux[0] * aux[1] * aux[2] * aux[3];
 }
 
-// min
-template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)
+template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)
 {
-  Packet4f b, res;
-  b = vec_min(a, vec_sld(a, a, 8));
-  res = vec_min(b, vec_sld(b, b, 4));
-  return pfirst(res);
+  return pfirst(pmul(a, reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4i>(a), reinterpret_cast<Packet4i>(a), 8))));
 }
 
+// min
 template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)
 {
   Packet4i b, res;
-  b = vec_min(a, vec_sld(a, a, 8));
-  res = vec_min(b, vec_sld(b, b, 4));
+  b   = pmin<Packet4i>(a, vec_sld(a, a, 8));
+  res = pmin<Packet4i>(b, vec_sld(b, b, 4));
   return pfirst(res);
 }
 
-// max
-template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)
+template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)
 {
-  Packet4f b, res;
-  b = vec_max(a, vec_sld(a, a, 8));
-  res = vec_max(b, vec_sld(b, b, 4));
-  return pfirst(res);
+  return pfirst(pmin<Packet2d>(a, reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4i>(a), reinterpret_cast<Packet4i>(a), 8))));
 }
 
+// max
 template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)
 {
   Packet4i b, res;
-  b = vec_max(a, vec_sld(a, a, 8));
-  res = vec_max(b, vec_sld(b, b, 4));
+  b = pmax<Packet4i>(a, vec_sld(a, a, 8));
+  res = pmax<Packet4i>(b, vec_sld(b, b, 4));
   return pfirst(res);
 }
 
-template<int Offset>
-struct palign_impl<Offset,Packet4f>
-{
-  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)
-  {
-#ifdef _BIG_ENDIAN
-    switch (Offset % 4) {
-    case 1:
-      first = vec_sld(first, second, 4); break;
-    case 2:
-      first = vec_sld(first, second, 8); break;
-    case 3:
-      first = vec_sld(first, second, 12); break;
-    }
-#else
-    switch (Offset % 4) {
-    case 1:
-      first = vec_sld(second, first, 12); break;
-    case 2:
-      first = vec_sld(second, first, 8); break;
-    case 3:
-      first = vec_sld(second, first, 4); break;
-    }
-#endif
-  }
-};
-
-template<int Offset>
-struct palign_impl<Offset,Packet4i>
+// max
+template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)
 {
-  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)
-  {
-#ifdef _BIG_ENDIAN
-    switch (Offset % 4) {
-    case 1:
-      first = vec_sld(first, second, 4); break;
-    case 2:
-      first = vec_sld(first, second, 8); break;
-    case 3:
-      first = vec_sld(first, second, 12); break;
-    }
-#else
-    switch (Offset % 4) {
-    case 1:
-      first = vec_sld(second, first, 12); break;
-    case 2:
-      first = vec_sld(second, first, 8); break;
-    case 3:
-      first = vec_sld(second, first, 4); break;
-    }
-#endif
-  }
-};
+  return pfirst(pmax<Packet2d>(a, reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4i>(a), reinterpret_cast<Packet4i>(a), 8))));
+}
 
 EIGEN_DEVICE_FUNC inline void
-ptranspose(PacketBlock<Packet4f,4>& kernel) {
-  Packet4f t0, t1, t2, t3;
-  t0 = vec_mergeh(kernel.packet[0], kernel.packet[2]);
-  t1 = vec_mergel(kernel.packet[0], kernel.packet[2]);
-  t2 = vec_mergeh(kernel.packet[1], kernel.packet[3]);
-  t3 = vec_mergel(kernel.packet[1], kernel.packet[3]);
+ptranspose(PacketBlock<Packet4i,4>& kernel) {
+  Packet4i t0 = vec_mergeh(kernel.packet[0], kernel.packet[2]);
+  Packet4i t1 = vec_mergel(kernel.packet[0], kernel.packet[2]);
+  Packet4i t2 = vec_mergeh(kernel.packet[1], kernel.packet[3]);
+  Packet4i t3 = vec_mergel(kernel.packet[1], kernel.packet[3]);
   kernel.packet[0] = vec_mergeh(t0, t2);
   kernel.packet[1] = vec_mergel(t0, t2);
   kernel.packet[2] = vec_mergeh(t1, t3);
   kernel.packet[3] = vec_mergel(t1, t3);
 }
 
 EIGEN_DEVICE_FUNC inline void
-ptranspose(PacketBlock<Packet4i,4>& kernel) {
-  Packet4i t0, t1, t2, t3;
-  t0 = vec_mergeh(kernel.packet[0], kernel.packet[2]);
-  t1 = vec_mergel(kernel.packet[0], kernel.packet[2]);
-  t2 = vec_mergeh(kernel.packet[1], kernel.packet[3]);
-  t3 = vec_mergel(kernel.packet[1], kernel.packet[3]);
-  kernel.packet[0] = vec_mergeh(t0, t2);
-  kernel.packet[1] = vec_mergel(t0, t2);
-  kernel.packet[2] = vec_mergeh(t1, t3);
-  kernel.packet[3] = vec_mergel(t1, t3);
+ptranspose(PacketBlock<Packet2d,2>& kernel) {
+  Packet2d t0 = vec_perm(kernel.packet[0], kernel.packet[1], p16uc_TRANSPOSE64_HI);
+  Packet2d t1 = vec_perm(kernel.packet[0], kernel.packet[1], p16uc_TRANSPOSE64_LO);
+  kernel.packet[0] = t0;
+  kernel.packet[1] = t1;
 }
 
 template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {
   Packet4ui select = { ifPacket.select[0], ifPacket.select[1], ifPacket.select[2], ifPacket.select[3] };
-  Packet4ui mask = reinterpret_cast<Packet4ui>(vec_cmpeq(reinterpret_cast<Packet4ui>(select), reinterpret_cast<Packet4ui>(p4i_ONE)));
+  Packet4ui mask = vec_cmpeq(select, reinterpret_cast<Packet4ui>(p4i_ONE));
   return vec_sel(elsePacket, thenPacket, mask);
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {
-  Packet4ui select = { ifPacket.select[0], ifPacket.select[1], ifPacket.select[2], ifPacket.select[3] };
-  Packet4ui mask = reinterpret_cast<Packet4ui>(vec_cmpeq(reinterpret_cast<Packet4ui>(select), reinterpret_cast<Packet4ui>(p4i_ONE)));
+
+template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {
+  Packet2ul select = { ifPacket.select[0], ifPacket.select[1] };
+  Packet2ul mask = vec_cmpeq(select, reinterpret_cast<Packet2ul>(p2l_ONE));
   return vec_sel(elsePacket, thenPacket, mask);
 }
 
+/* z13 has no vector float support so we emulate that with double
+   z14 has proper vector float support.
+*/
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ < 12)
+/* Helper function to simulate a vec_splat_packet4f
+ */
+template<int element> EIGEN_STRONG_INLINE Packet4f vec_splat_packet4f(const Packet4f&   from)
+{
+  Packet4f splat;
+  switch (element) {
+  case 0:
+    splat.v4f[0] = vec_splat(from.v4f[0], 0);
+    splat.v4f[1] = splat.v4f[0];
+    break;
+  case 1:
+    splat.v4f[0] = vec_splat(from.v4f[0], 1);
+    splat.v4f[1] = splat.v4f[0];
+    break;
+  case 2:
+    splat.v4f[0] = vec_splat(from.v4f[1], 0);
+    splat.v4f[1] = splat.v4f[0];
+    break;
+  case 3:
+    splat.v4f[0] = vec_splat(from.v4f[1], 1);
+    splat.v4f[1] = splat.v4f[0];
+    break;
+  }
+  return splat;
+}
 
-//---------- double ----------
-#ifdef __VSX__
-typedef __vector double              Packet2d;
-typedef __vector unsigned long long  Packet2ul;
-typedef __vector long long           Packet2l;
-#if EIGEN_COMP_CLANG
-typedef Packet2ul                    Packet2bl;
-#else
-typedef __vector __bool long         Packet2bl;
-#endif
+template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from)
+{
+  // FIXME: No intrinsic yet
+  EIGEN_DEBUG_ALIGNED_LOAD
+  Packet4f vfrom;
+  vfrom.v4f[0] = vec_ld2f(&from[0]);
+  vfrom.v4f[1] = vec_ld2f(&from[2]);
+  return vfrom;
+}
 
-static Packet2l  p2l_ONE  = { 1, 1 };
-static Packet2l  p2l_ZERO = reinterpret_cast<Packet2l>(p4i_ZERO);
-static Packet2d  p2d_ONE  = { 1.0, 1.0 };
-static Packet2d  p2d_ZERO = reinterpret_cast<Packet2d>(p4f_ZERO);
-static Packet2d  p2d_MZERO = { -0.0, -0.0 };
+template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from)
+{
+  // FIXME: No intrinsic yet
+  EIGEN_DEBUG_ALIGNED_STORE
+  vec_st2f(from.v4f[0], &to[0]);
+  vec_st2f(from.v4f[1], &to[2]);
+}
 
-#ifdef _BIG_ENDIAN
-static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(p2d_ZERO), reinterpret_cast<Packet4f>(p2d_ONE), 8));
-#else
-static Packet2d p2d_COUNTDOWN = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(p2d_ONE), reinterpret_cast<Packet4f>(p2d_ZERO), 8));
-#endif
+template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&    from)
+{
+  Packet4f to;
+  to.v4f[0] = pset1<Packet2d>(static_cast<const double&>(from));
+  to.v4f[1] = to.v4f[0];
+  return to;
+}
 
-template<int index> Packet2d vec_splat_dbl(Packet2d& a);
+template<> EIGEN_STRONG_INLINE void
+pbroadcast4<Packet4f>(const float *a,
+                      Packet4f& a0, Packet4f& a1, Packet4f& a2, Packet4f& a3)
+{
+  a3 = pload<Packet4f>(a);
+  a0 = vec_splat_packet4f<0>(a3);
+  a1 = vec_splat_packet4f<1>(a3);
+  a2 = vec_splat_packet4f<2>(a3);
+  a3 = vec_splat_packet4f<3>(a3);
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d vec_splat_dbl<0>(Packet2d& a)
+template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)
 {
-  return reinterpret_cast<Packet2d>(vec_perm(a, a, p16uc_PSET64_HI));
+  float EIGEN_ALIGN16 ai[4];
+  ai[0] = from[0*stride];
+  ai[1] = from[1*stride];
+  ai[2] = from[2*stride];
+  ai[3] = from[3*stride];
+ return pload<Packet4f>(ai);
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d vec_splat_dbl<1>(Packet2d& a)
+template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)
 {
-  return reinterpret_cast<Packet2d>(vec_perm(a, a, p16uc_PSET64_LO));
+  float EIGEN_ALIGN16 ai[4];
+  pstore<float>((float *)ai, from);
+  to[0*stride] = ai[0];
+  to[1*stride] = ai[1];
+  to[2*stride] = ai[2];
+  to[3*stride] = ai[3];
 }
 
-template<> struct packet_traits<double> : default_packet_traits
+template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
-  typedef Packet2d type;
-  typedef Packet2d half;
-  enum {
-    Vectorizable = 1,
-    AlignedOnScalar = 1,
-    size=2,
-    HasHalfPacket = 1,
+  Packet4f c;
+  c.v4f[0] = a.v4f[0] + b.v4f[0];
+  c.v4f[1] = a.v4f[1] + b.v4f[1];
+  return c;
+}
 
-    HasAdd  = 1,
-    HasSub  = 1,
-    HasMul  = 1,
-    HasDiv  = 1,
-    HasMin  = 1,
-    HasMax  = 1,
-    HasAbs  = 1,
-    HasSin  = 0,
-    HasCos  = 0,
-    HasLog  = 0,
-    HasExp  = 1,
-    HasSqrt = 1,
-    HasRsqrt = 1,
-    HasRound = 1,
-    HasFloor = 1,
-    HasCeil = 1,
-    HasNegate = 1,
-    HasBlend = 1
-  };
-};
+template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b)
+{
+  Packet4f c;
+  c.v4f[0] = a.v4f[0] - b.v4f[0];
+  c.v4f[1] = a.v4f[1] - b.v4f[1];
+  return c;
+}
 
-template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };
+template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b)
+{
+  Packet4f c;
+  c.v4f[0] = a.v4f[0] * b.v4f[0];
+  c.v4f[1] = a.v4f[1] * b.v4f[1];
+  return c;
+}
 
-inline std::ostream & operator <<(std::ostream & s, const Packet2l & v)
+template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
-  union {
-    Packet2l   v;
-    int64_t n[2];
-  } vt;
-  vt.v = v;
-  s << vt.n[0] << ", " << vt.n[1];
-  return s;
+  Packet4f c;
+  c.v4f[0] = a.v4f[0] / b.v4f[0];
+  c.v4f[1] = a.v4f[1] / b.v4f[1];
+  return c;
 }
 
-inline std::ostream & operator <<(std::ostream & s, const Packet2d & v)
+template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)
 {
-  union {
-    Packet2d   v;
-    double n[2];
-  } vt;
-  vt.v = v;
-  s << vt.n[0] << ", " << vt.n[1];
-  return s;
+  Packet4f c;
+  c.v4f[0] = -a.v4f[0];
+  c.v4f[1] = -a.v4f[1];
+  return c;
 }
 
-// Need to define them first or we get specialization after instantiation errors
-template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from)
+template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c)
 {
-  EIGEN_DEBUG_ALIGNED_LOAD
-#ifdef __VSX__
-  return vec_vsx_ld(0, from);
-#else
-  return vec_ld(0, from);
-#endif
+  Packet4f res;
+  res.v4f[0] = vec_madd(a.v4f[0], b.v4f[0], c.v4f[0]);
+  res.v4f[1] = vec_madd(a.v4f[1], b.v4f[1], c.v4f[1]);
+  return res;
 }
 
-template<> EIGEN_STRONG_INLINE void pstore<double>(double*   to, const Packet2d& from)
+template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
-  EIGEN_DEBUG_ALIGNED_STORE
-#ifdef __VSX__
-  vec_vsx_st(from, 0, to);
-#else
-  vec_st(from, 0, to);
-#endif
+  Packet4f res;
+  res.v4f[0] = pmin(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = pmin(a.v4f[1], b.v4f[1]);
+  return res;
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double&  from) {
-  Packet2d v = {from, from};
-  return v;
+template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b)
+{
+  Packet4f res;
+  res.v4f[0] = pmax(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = pmax(a.v4f[1], b.v4f[1]);
+  return res;
 }
 
-template<> EIGEN_STRONG_INLINE void
-pbroadcast4<Packet2d>(const double *a,
-                      Packet2d& a0, Packet2d& a1, Packet2d& a2, Packet2d& a3)
+template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
-  a1 = pload<Packet2d>(a);
-  a0 = vec_splat_dbl<0>(a1);
-  a1 = vec_splat_dbl<1>(a1);
-  a3 = pload<Packet2d>(a+2);
-  a2 = vec_splat_dbl<0>(a3);
-  a3 = vec_splat_dbl<1>(a3);
+  Packet4f res;
+  res.v4f[0] = pand(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = pand(a.v4f[1], b.v4f[1]);
+  return res;
 }
 
-template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)
+template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
-  double EIGEN_ALIGN16 af[2];
-  af[0] = from[0*stride];
-  af[1] = from[1*stride];
- return pload<Packet2d>(af);
+  Packet4f res;
+  res.v4f[0] = por(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = por(a.v4f[1], b.v4f[1]);
+  return res;
 }
-template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)
+
+template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
-  double EIGEN_ALIGN16 af[2];
-  pstore<double>(af, from);
-  to[0*stride] = af[0];
-  to[1*stride] = af[1];
+  Packet4f res;
+  res.v4f[0] = pxor(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = pxor(a.v4f[1], b.v4f[1]);
+  return res;
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return pset1<Packet2d>(a) + p2d_COUNTDOWN; }
+template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)
+{
+  Packet4f res;
+  res.v4f[0] = pandnot(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = pandnot(a.v4f[1], b.v4f[1]);
+  return res;
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return a + b; }
+template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a)
+{
+  Packet4f res;
+  res.v4f[0] = vec_round(a.v4f[0]);
+  res.v4f[1] = vec_round(a.v4f[1]);
+  return res;
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return a - b; }
+template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const  Packet4f& a)
+{
+  Packet4f res;
+  res.v4f[0] = vec_ceil(a.v4f[0]);
+  res.v4f[1] = vec_ceil(a.v4f[1]);
+  return res;
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) { return p2d_ZERO - a; }
+template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a)
+{
+  Packet4f res;
+  res.v4f[0] = vec_floor(a.v4f[0]);
+  res.v4f[1] = vec_floor(a.v4f[1]);
+  return res;
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }
+template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*    from)
+{
+  Packet4f p = pload<Packet4f>(from);
+  p.v4f[1] = vec_splat(p.v4f[0], 1);
+  p.v4f[0] = vec_splat(p.v4f[0], 0);
+  return p;
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_madd(a,b,p2d_MZERO); }
-template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_div(a,b); }
+template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float  EIGEN_ALIGN16 x[2]; vec_st2f(a.v4f[0], &x[0]); return x[0]; }
 
-// for some weird raisons, it has to be overloaded for packet of integers
-template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return vec_madd(a, b, c); }
+template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)
+{
+  Packet4f rev;
+  rev.v4f[0] = preverse<Packet2d>(a.v4f[1]);
+  rev.v4f[1] = preverse<Packet2d>(a.v4f[0]);
+  return rev;
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b)
+template<> EIGEN_STRONG_INLINE Packet4f pabs<Packet4f>(const Packet4f& a)
+{
+  Packet4f res;
+  res.v4f[0] = pabs(a.v4f[0]);
+  res.v4f[1] = pabs(a.v4f[1]);
+  return res;
+}
+
+template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)
 {
-  Packet2d ret;
-  __asm__ ("xvcmpgedp %x0,%x1,%x2\n\txxsel %x0,%x1,%x2,%x0" : "=&wa" (ret) : "wa" (a), "wa" (b));
-  return ret;
- }
-
-template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b)
-{
-  Packet2d ret;
-  __asm__ ("xvcmpgtdp %x0,%x2,%x1\n\txxsel %x0,%x1,%x2,%x0" : "=&wa" (ret) : "wa" (a), "wa" (b));
-  return ret;
+  Packet2d sum;
+  sum = padd<Packet2d>(a.v4f[0], a.v4f[1]);
+  double first = predux<Packet2d>(sum);
+  return static_cast<float>(first);
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, b); }
+template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)
+{
+  // Return predux_mul<Packet2d> of the subvectors product
+  return static_cast<float>(pfirst(predux_mul(pmul(a.v4f[0], a.v4f[1]))));
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_or(a, b); }
+template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)
+{
+  Packet2d b, res;
+  b   = pmin<Packet2d>(a.v4f[0], a.v4f[1]);
+  res = pmin<Packet2d>(b, reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4i>(b), reinterpret_cast<Packet4i>(b), 8)));
+  return static_cast<float>(pfirst(res));
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_xor(a, b); }
+template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)
+{
+  Packet2d b, res;
+  b   = pmax<Packet2d>(a.v4f[0], a.v4f[1]);
+  res = pmax<Packet2d>(b, reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4i>(b), reinterpret_cast<Packet4i>(b), 8)));
+  return static_cast<float>(pfirst(res));
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return vec_and(a, vec_nor(b, b)); }
+/* Split the Packet4f PacketBlock into 4 Packet2d PacketBlocks and transpose each one
+ */
+EIGEN_DEVICE_FUNC inline void
+ptranspose(PacketBlock<Packet4f,4>& kernel) {
+  PacketBlock<Packet2d,2> t0,t1,t2,t3;
+  // copy top-left 2x2 Packet2d block
+  t0.packet[0] = kernel.packet[0].v4f[0];
+  t0.packet[1] = kernel.packet[1].v4f[0];
+
+  // copy top-right 2x2 Packet2d block
+  t1.packet[0] = kernel.packet[0].v4f[1];
+  t1.packet[1] = kernel.packet[1].v4f[1];
+
+  // copy bottom-left 2x2 Packet2d block
+  t2.packet[0] = kernel.packet[2].v4f[0];
+  t2.packet[1] = kernel.packet[3].v4f[0];
+
+  // copy bottom-right 2x2 Packet2d block
+  t3.packet[0] = kernel.packet[2].v4f[1];
+  t3.packet[1] = kernel.packet[3].v4f[1];
+
+  // Transpose all 2x2 blocks
+  ptranspose(t0);
+  ptranspose(t1);
+  ptranspose(t2);
+  ptranspose(t3);
+
+  // Copy back transposed blocks, but exchange t1 and t2 due to transposition
+  kernel.packet[0].v4f[0] = t0.packet[0];
+  kernel.packet[0].v4f[1] = t2.packet[0];
+  kernel.packet[1].v4f[0] = t0.packet[1];
+  kernel.packet[1].v4f[1] = t2.packet[1];
+  kernel.packet[2].v4f[0] = t1.packet[0];
+  kernel.packet[2].v4f[1] = t3.packet[0];
+  kernel.packet[3].v4f[0] = t1.packet[1];
+  kernel.packet[3].v4f[1] = t3.packet[1];
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return vec_round(a); }
-template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const  Packet2d& a) { return vec_ceil(a); }
-template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return vec_floor(a); }
+template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {
+  Packet2ul select_hi = { ifPacket.select[0], ifPacket.select[1] };
+  Packet2ul select_lo = { ifPacket.select[2], ifPacket.select[3] };
+  Packet2ul mask_hi = vec_cmpeq(select_hi, reinterpret_cast<Packet2ul>(p2l_ONE));
+  Packet2ul mask_lo = vec_cmpeq(select_lo, reinterpret_cast<Packet2ul>(p2l_ONE));
+  Packet4f result;
+  result.v4f[0] = vec_sel(elsePacket.v4f[0], thenPacket.v4f[0], mask_hi);
+  result.v4f[1] = vec_sel(elsePacket.v4f[1], thenPacket.v4f[1], mask_lo);
+  return result;
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
+template<> Packet4f EIGEN_STRONG_INLINE pcmp_le<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
-  EIGEN_DEBUG_ALIGNED_LOAD
-  return (Packet2d) vec_vsx_ld((long)from & 15, (const double*) _EIGEN_ALIGNED_PTR(from));
+  Packet4f res;
+  res.v4f[0] = pcmp_le(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = pcmp_le(a.v4f[1], b.v4f[1]);
+  return res;
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*   from)
+template<> Packet4f EIGEN_STRONG_INLINE pcmp_lt<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
-  Packet2d p;
-  if((std::ptrdiff_t(from) % 16) == 0)  p = pload<Packet2d>(from);
-  else                                  p = ploadu<Packet2d>(from);
-  return vec_splat_dbl<0>(p);
+  Packet4f res;
+  res.v4f[0] = pcmp_lt(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = pcmp_lt(a.v4f[1], b.v4f[1]);
+  return res;
 }
 
-template<> EIGEN_STRONG_INLINE void pstoreu<double>(double*  to, const Packet2d& from)
+template<> Packet4f EIGEN_STRONG_INLINE pcmp_eq<Packet4f>(const Packet4f& a, const Packet4f& b)
 {
+  Packet4f res;
+  res.v4f[0] = pcmp_eq(a.v4f[0], b.v4f[0]);
+  res.v4f[1] = pcmp_eq(a.v4f[1], b.v4f[1]);
+  return res;
+}
+
+#else
+template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from)
+{
+  // FIXME: No intrinsic yet
+  EIGEN_DEBUG_ALIGNED_LOAD
+  Packet *vfrom;
+  vfrom = (Packet *) from;
+  return vfrom->v4f;
+}
+
+template<> EIGEN_STRONG_INLINE void pstore<float>(float* to, const Packet4f& from)
+{
+  // FIXME: No intrinsic yet
   EIGEN_DEBUG_ALIGNED_STORE
-  vec_vsx_st((Packet4f)from, (long)to & 15, (float*) _EIGEN_ALIGNED_PTR(to));
+  Packet *vto;
+  vto = (Packet *) to;
+  vto->v4f = from;
 }
 
-template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { EIGEN_PPC_PREFETCH(addr); }
+template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float& from)
+{
+  return vec_splats(from);
+}
 
-template<> EIGEN_STRONG_INLINE double  pfirst<Packet2d>(const Packet2d& a) { double EIGEN_ALIGN16 x[2]; pstore<double>(x, a); return x[0]; }
+template<> EIGEN_STRONG_INLINE void
+pbroadcast4<Packet4f>(const float *a,
+                      Packet4f& a0, Packet4f& a1, Packet4f& a2, Packet4f& a3)
+{
+  a3 = pload<Packet4f>(a);
+  a0 = vec_splat(a3, 0);
+  a1 = vec_splat(a3, 1);
+  a2 = vec_splat(a3, 2);
+  a3 = vec_splat(a3, 3);
+}
 
-template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)
+template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)
 {
-  return reinterpret_cast<Packet2d>(vec_perm(reinterpret_cast<Packet16uc>(a), reinterpret_cast<Packet16uc>(a), p16uc_REVERSE64));
+  float EIGEN_ALIGN16 af[4];
+  af[0] = from[0*stride];
+  af[1] = from[1*stride];
+  af[2] = from[2*stride];
+  af[3] = from[3*stride];
+ return pload<Packet4f>(af);
 }
-template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a) { return vec_abs(a); }
 
-template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)
+template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)
 {
-  Packet2d b, sum;
-  b   = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(a), reinterpret_cast<Packet4f>(a), 8));
-  sum = a + b;
-  return pfirst<Packet2d>(sum);
+  float EIGEN_ALIGN16 af[4];
+  pstore<float>((float*)af, from);
+  to[0*stride] = af[0];
+  to[1*stride] = af[1];
+  to[2*stride] = af[2];
+  to[3*stride] = af[3];
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)
+template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return (a + b); }
+template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return (a - b); }
+template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return (a * b); }
+template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return (a / b); }
+template<> EIGEN_STRONG_INLINE Packet4f pnegate<Packet4f>(const Packet4f& a) { return (-a); }
+template<> EIGEN_STRONG_INLINE Packet4f pconj<Packet4f>  (const Packet4f& a) { return a; }
+template<> EIGEN_STRONG_INLINE Packet4f pmadd<Packet4f>  (const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a, b, c); }
+template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>   (const Packet4f& a, const Packet4f& b) { return vec_min(a, b); }
+template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>   (const Packet4f& a, const Packet4f& b) { return vec_max(a, b); }
+template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>   (const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }
+template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>    (const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }
+template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>   (const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }
+template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }
+template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f> (const Packet4f& a) { return vec_round(a); }
+template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>  (const Packet4f& a) { return vec_ceil(a); }
+template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f> (const Packet4f& a) { return vec_floor(a); }
+template<> EIGEN_STRONG_INLINE Packet4f pabs<Packet4f>   (const Packet4f& a) { return vec_abs(a); }
+template<> EIGEN_STRONG_INLINE float pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; pstore(x, a); return x[0]; }
+
+template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float* from)
 {
-  Packet2d v[2], sum;
-  v[0] = vecs[0] + reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(vecs[0]), reinterpret_cast<Packet4f>(vecs[0]), 8));
-  v[1] = vecs[1] + reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(vecs[1]), reinterpret_cast<Packet4f>(vecs[1]), 8));
+  Packet4f p = pload<Packet4f>(from);
+  return vec_perm(p, p, p16uc_DUPLICATE32_HI);
+}
 
-#ifdef _BIG_ENDIAN
-  sum = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(v[0]), reinterpret_cast<Packet4f>(v[1]), 8));
-#else
-  sum = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4f>(v[1]), reinterpret_cast<Packet4f>(v[0]), 8));
-#endif
+template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)
+{
+  return reinterpret_cast<Packet4f>(vec_perm(reinterpret_cast<Packet16uc>(a), reinterpret_cast<Packet16uc>(a), p16uc_REVERSE32));
+}
 
-  return sum;
+template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)
+{
+  Packet4f b, sum;
+  b   = vec_sld(a, a, 8);
+  sum = padd<Packet4f>(a, b);
+  b   = vec_sld(sum, sum, 4);
+  sum = padd<Packet4f>(sum, b);
+  return pfirst(sum);
 }
+
 // Other reduction functions:
 // mul
-template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)
+template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)
 {
-  return pfirst(pmul(a, reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4ui>(a), reinterpret_cast<Packet4ui>(a), 8))));
+  Packet4f prod;
+  prod = pmul(a, vec_sld(a, a, 8));
+  return pfirst(pmul(prod, vec_sld(prod, prod, 4)));
 }
 
 // min
-template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)
+template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)
 {
-  return pfirst(pmin(a, reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4ui>(a), reinterpret_cast<Packet4ui>(a), 8))));
+  Packet4f b, res;
+  b   = pmin<Packet4f>(a, vec_sld(a, a, 8));
+  res = pmin<Packet4f>(b, vec_sld(b, b, 4));
+  return pfirst(res);
 }
 
 // max
-template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)
+template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)
 {
-  return pfirst(pmax(a, reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4ui>(a), reinterpret_cast<Packet4ui>(a), 8))));
+  Packet4f b, res;
+  b = pmax<Packet4f>(a, vec_sld(a, a, 8));
+  res = pmax<Packet4f>(b, vec_sld(b, b, 4));
+  return pfirst(res);
 }
 
-template<int Offset>
-struct palign_impl<Offset,Packet2d>
-{
-  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)
-  {
-    if (Offset == 1)
-#ifdef _BIG_ENDIAN
-      first = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4ui>(first), reinterpret_cast<Packet4ui>(second), 8));
-#else
-      first = reinterpret_cast<Packet2d>(vec_sld(reinterpret_cast<Packet4ui>(second), reinterpret_cast<Packet4ui>(first), 8));
-#endif
-  }
-};
-
 EIGEN_DEVICE_FUNC inline void
-ptranspose(PacketBlock<Packet2d,2>& kernel) {
-  Packet2d t0, t1;
-  t0 = vec_perm(kernel.packet[0], kernel.packet[1], p16uc_TRANSPOSE64_HI);
-  t1 = vec_perm(kernel.packet[0], kernel.packet[1], p16uc_TRANSPOSE64_LO);
-  kernel.packet[0] = t0;
-  kernel.packet[1] = t1;
+ptranspose(PacketBlock<Packet4f,4>& kernel) {
+  Packet4f t0 = vec_mergeh(kernel.packet[0], kernel.packet[2]);
+  Packet4f t1 = vec_mergel(kernel.packet[0], kernel.packet[2]);
+  Packet4f t2 = vec_mergeh(kernel.packet[1], kernel.packet[3]);
+  Packet4f t3 = vec_mergel(kernel.packet[1], kernel.packet[3]);
+  kernel.packet[0] = vec_mergeh(t0, t2);
+  kernel.packet[1] = vec_mergel(t0, t2);
+  kernel.packet[2] = vec_mergeh(t1, t3);
+  kernel.packet[3] = vec_mergel(t1, t3);
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {
-  Packet2l select = { ifPacket.select[0], ifPacket.select[1] };
-  Packet2bl mask = reinterpret_cast<Packet2bl>( vec_cmpeq(reinterpret_cast<Packet2d>(select), reinterpret_cast<Packet2d>(p2l_ONE)) );
+template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {
+  Packet4ui select = { ifPacket.select[0], ifPacket.select[1], ifPacket.select[2], ifPacket.select[3] };
+  Packet4ui mask = vec_cmpeq(select, reinterpret_cast<Packet4ui>(p4i_ONE));
   return vec_sel(elsePacket, thenPacket, mask);
 }
-#endif // __VSX__
+
+#endif
+
+template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { EIGEN_ZVECTOR_PREFETCH(addr); }
+template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f> (const float* from) { return pload<Packet4f>(from); }
+template<> EIGEN_STRONG_INLINE void pstoreu<float>(float* to, const Packet4f& from) { pstore<float>(to, from); }
+template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>  (const float& a)  { return padd<Packet4f>(pset1<Packet4f>(a), p4f_COUNTDOWN); }
+
 } // end namespace internal
 
 } // end namespace Eigen
 
-#endif // EIGEN_PACKET_MATH_ALTIVEC_H
+#endif // EIGEN_PACKET_MATH_ZVECTOR_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/Half.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/Default/BFloat16.h`

 * *Files 26% similar despite different names*

```diff
@@ -1,674 +1,700 @@
-// This file is part of Eigen, a lightweight C++ template library
-// for linear algebra.
-//
-// This Source Code Form is subject to the terms of the Mozilla
-// Public License v. 2.0. If a copy of the MPL was not distributed
-// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
-//
-// The conversion routines are Copyright (c) Fabian Giesen, 2016.
-// The original license follows:
-//
-// Copyright (c) Fabian Giesen, 2016
-// All rights reserved.
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted.
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-// Standard 16-bit float type, mostly useful for GPUs. Defines a new
-// type Eigen::half (inheriting from CUDA's __half struct) with
-// operator overloads such that it behaves basically as an arithmetic
-// type. It will be quite slow on CPUs (so it is recommended to stay
-// in float32_bits for CPUs, except for simple parameter conversions, I/O
-// to disk and the likes), but fast on GPUs.
-
-
-#ifndef EIGEN_HALF_CUDA_H
-#define EIGEN_HALF_CUDA_H
-
-#if __cplusplus > 199711L
-#define EIGEN_EXPLICIT_CAST(tgt_type) explicit operator tgt_type()
-#else
-#define EIGEN_EXPLICIT_CAST(tgt_type) operator tgt_type()
-#endif
+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.
 
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef EIGEN_BFLOAT16_H
+#define EIGEN_BFLOAT16_H
+
+#define BF16_PACKET_FUNCTION(PACKET_F, PACKET_BF16, METHOD)         \
+  template <>                                                       \
+  EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS EIGEN_UNUSED  \
+  PACKET_BF16 METHOD<PACKET_BF16>(const PACKET_BF16& _x) {          \
+    return F32ToBf16(METHOD<PACKET_F>(Bf16ToF32(_x)));              \
+  }
 
 namespace Eigen {
 
-struct half;
+struct bfloat16;
 
-namespace half_impl {
+namespace bfloat16_impl {
 
-#if !defined(EIGEN_HAS_CUDA_FP16)
-// Make our own __half_raw definition that is similar to CUDA's.
-struct __half_raw {
-  EIGEN_DEVICE_FUNC __half_raw() : x(0) {}
-  explicit EIGEN_DEVICE_FUNC __half_raw(unsigned short raw) : x(raw) {}
-  unsigned short x;
+// Make our own __bfloat16_raw definition.
+struct __bfloat16_raw {
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR __bfloat16_raw() : value(0) {}
+  explicit EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR __bfloat16_raw(unsigned short raw) : value(raw) {}
+  unsigned short value;
 };
-#elif defined(EIGEN_CUDACC_VER) && EIGEN_CUDACC_VER < 90000
-// In CUDA < 9.0, __half is the equivalent of CUDA 9's __half_raw
-typedef __half __half_raw;
-#endif
 
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __half_raw raw_uint16_to_half(unsigned short x);
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __half_raw float_to_half_rtne(float ff);
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC float half_to_float(__half_raw h);
-
-struct half_base : public __half_raw {
-  EIGEN_DEVICE_FUNC half_base() {}
-  EIGEN_DEVICE_FUNC half_base(const half_base& h) : __half_raw(h) {}
-  EIGEN_DEVICE_FUNC half_base(const __half_raw& h) : __half_raw(h) {}
-#if defined(EIGEN_HAS_CUDA_FP16) && defined(EIGEN_CUDACC_VER) && EIGEN_CUDACC_VER >= 90000
-  EIGEN_DEVICE_FUNC half_base(const __half& h) : __half_raw(*(__half_raw*)&h) {}
-#endif
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR __bfloat16_raw raw_uint16_to_bfloat16(unsigned short value);
+template <bool AssumeArgumentIsNormalOrInfinityOrZero>
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __bfloat16_raw float_to_bfloat16_rtne(float ff);
+// Forward declarations of template specializations, to avoid Visual C++ 2019 errors, saying:
+// > error C2908: explicit specialization; 'float_to_bfloat16_rtne' has already been instantiated
+template <>
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __bfloat16_raw float_to_bfloat16_rtne<false>(float ff);
+template <>
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __bfloat16_raw float_to_bfloat16_rtne<true>(float ff);
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC float bfloat16_to_float(__bfloat16_raw h);
+
+struct bfloat16_base : public __bfloat16_raw {
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bfloat16_base() {}
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bfloat16_base(const __bfloat16_raw& h) : __bfloat16_raw(h) {}
 };
 
-} // namespace half_impl
+} // namespace bfloat16_impl
 
 // Class definition.
-struct half : public half_impl::half_base {
-  #if !defined(EIGEN_HAS_CUDA_FP16) || (defined(EIGEN_CUDACC_VER) && EIGEN_CUDACC_VER < 90000)
-    typedef half_impl::__half_raw __half_raw;
-  #endif
-
-  EIGEN_DEVICE_FUNC half() {}
-
-  EIGEN_DEVICE_FUNC half(const __half_raw& h) : half_impl::half_base(h) {}
-  EIGEN_DEVICE_FUNC half(const half& h) : half_impl::half_base(h) {}
-#if defined(EIGEN_HAS_CUDA_FP16) && defined(EIGEN_CUDACC_VER) && EIGEN_CUDACC_VER >= 90000
-  EIGEN_DEVICE_FUNC half(const __half& h) : half_impl::half_base(h) {}
-#endif
+struct bfloat16 : public bfloat16_impl::bfloat16_base {
+
+  typedef bfloat16_impl::__bfloat16_raw __bfloat16_raw;
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bfloat16() {}
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bfloat16(const __bfloat16_raw& h) : bfloat16_impl::bfloat16_base(h) {}
+
+  explicit EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bfloat16(bool b)
+      : bfloat16_impl::bfloat16_base(bfloat16_impl::raw_uint16_to_bfloat16(b ? 0x3f80 : 0)) {}
 
-  explicit EIGEN_DEVICE_FUNC half(bool b)
-      : half_impl::half_base(half_impl::raw_uint16_to_half(b ? 0x3c00 : 0)) {}
   template<class T>
-  explicit EIGEN_DEVICE_FUNC half(const T& val)
-      : half_impl::half_base(half_impl::float_to_half_rtne(static_cast<float>(val))) {}
-  explicit EIGEN_DEVICE_FUNC half(float f)
-      : half_impl::half_base(half_impl::float_to_half_rtne(f)) {}
+  explicit EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bfloat16(T val)
+      : bfloat16_impl::bfloat16_base(bfloat16_impl::float_to_bfloat16_rtne<internal::is_integral<T>::value>(static_cast<float>(val))) {}
 
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(bool) const {
-    // +0.0 and -0.0 become false, everything else becomes true.
-    return (x & 0x7fff) != 0;
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(signed char) const {
-    return static_cast<signed char>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned char) const {
-    return static_cast<unsigned char>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(short) const {
-    return static_cast<short>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned short) const {
-    return static_cast<unsigned short>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(int) const {
-    return static_cast<int>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned int) const {
-    return static_cast<unsigned int>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(long) const {
-    return static_cast<long>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned long) const {
-    return static_cast<unsigned long>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(long long) const {
-    return static_cast<long long>(half_impl::half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(unsigned long long) const {
-    return static_cast<unsigned long long>(half_to_float(*this));
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(float) const {
-    return half_impl::half_to_float(*this);
-  }
-  EIGEN_DEVICE_FUNC EIGEN_EXPLICIT_CAST(double) const {
-    return static_cast<double>(half_impl::half_to_float(*this));
-  }
+  explicit EIGEN_DEVICE_FUNC bfloat16(float f)
+      : bfloat16_impl::bfloat16_base(bfloat16_impl::float_to_bfloat16_rtne<false>(f)) {}
 
-  EIGEN_DEVICE_FUNC half& operator=(const half& other) {
-    x = other.x;
-    return *this;
+  // Following the convention of numpy, converting between complex and
+  // float will lead to loss of imag value.
+  template<typename RealScalar>
+  explicit EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR bfloat16(const std::complex<RealScalar>& val)
+      : bfloat16_impl::bfloat16_base(bfloat16_impl::float_to_bfloat16_rtne<false>(static_cast<float>(val.real()))) {}
+
+  EIGEN_DEVICE_FUNC operator float() const {  // NOLINT: Allow implicit conversion to float, because it is lossless.
+    return bfloat16_impl::bfloat16_to_float(*this);
   }
 };
-
-} // end namespace Eigen
+} // namespace Eigen
 
 namespace std {
 template<>
-struct numeric_limits<Eigen::half> {
+struct numeric_limits<Eigen::bfloat16> {
   static const bool is_specialized = true;
   static const bool is_signed = true;
   static const bool is_integer = false;
   static const bool is_exact = false;
   static const bool has_infinity = true;
   static const bool has_quiet_NaN = true;
   static const bool has_signaling_NaN = true;
-  static const float_denorm_style has_denorm = denorm_present;
+  static const float_denorm_style has_denorm = std::denorm_absent;
   static const bool has_denorm_loss = false;
-  static const std::float_round_style round_style = std::round_to_nearest;
+  static const std::float_round_style round_style = numeric_limits<float>::round_style;
   static const bool is_iec559 = false;
-  static const bool is_bounded = false;
+  static const bool is_bounded = true;
   static const bool is_modulo = false;
-  static const int digits = 11;
-  static const int digits10 = 3;      // according to http://half.sourceforge.net/structstd_1_1numeric__limits_3_01half__float_1_1half_01_4.html
-  static const int max_digits10 = 5;  // according to http://half.sourceforge.net/structstd_1_1numeric__limits_3_01half__float_1_1half_01_4.html
+  static const int digits = 8;
+  static const int digits10 = 2;
+  static const int max_digits10 = 4;
   static const int radix = 2;
-  static const int min_exponent = -13;
-  static const int min_exponent10 = -4;
-  static const int max_exponent = 16;
-  static const int max_exponent10 = 4;
-  static const bool traps = true;
-  static const bool tinyness_before = false;
-
-  static Eigen::half (min)() { return Eigen::half_impl::raw_uint16_to_half(0x400); }
-  static Eigen::half lowest() { return Eigen::half_impl::raw_uint16_to_half(0xfbff); }
-  static Eigen::half (max)() { return Eigen::half_impl::raw_uint16_to_half(0x7bff); }
-  static Eigen::half epsilon() { return Eigen::half_impl::raw_uint16_to_half(0x0800); }
-  static Eigen::half round_error() { return Eigen::half(0.5); }
-  static Eigen::half infinity() { return Eigen::half_impl::raw_uint16_to_half(0x7c00); }
-  static Eigen::half quiet_NaN() { return Eigen::half_impl::raw_uint16_to_half(0x7e00); }
-  static Eigen::half signaling_NaN() { return Eigen::half_impl::raw_uint16_to_half(0x7e00); }
-  static Eigen::half denorm_min() { return Eigen::half_impl::raw_uint16_to_half(0x1); }
+  static const int min_exponent = numeric_limits<float>::min_exponent;
+  static const int min_exponent10 = numeric_limits<float>::min_exponent10;
+  static const int max_exponent = numeric_limits<float>::max_exponent;
+  static const int max_exponent10 = numeric_limits<float>::max_exponent10;
+  static const bool traps = numeric_limits<float>::traps;
+  static const bool tinyness_before = numeric_limits<float>::tinyness_before;
+
+  static Eigen::bfloat16 (min)() { return Eigen::bfloat16_impl::raw_uint16_to_bfloat16(0x0080); }
+  static Eigen::bfloat16 lowest() { return Eigen::bfloat16_impl::raw_uint16_to_bfloat16(0xff7f); }
+  static Eigen::bfloat16 (max)() { return Eigen::bfloat16_impl::raw_uint16_to_bfloat16(0x7f7f); }
+  static Eigen::bfloat16 epsilon() { return Eigen::bfloat16_impl::raw_uint16_to_bfloat16(0x3c00); }
+  static Eigen::bfloat16 round_error() { return Eigen::bfloat16(0x3f00); }
+  static Eigen::bfloat16 infinity() { return Eigen::bfloat16_impl::raw_uint16_to_bfloat16(0x7f80); }
+  static Eigen::bfloat16 quiet_NaN() { return Eigen::bfloat16_impl::raw_uint16_to_bfloat16(0x7fc0); }
+  static Eigen::bfloat16 signaling_NaN() { return Eigen::bfloat16_impl::raw_uint16_to_bfloat16(0x7f81); }
+  static Eigen::bfloat16 denorm_min() { return Eigen::bfloat16_impl::raw_uint16_to_bfloat16(0x0001); }
 };
 
 // If std::numeric_limits<T> is specialized, should also specialize
 // std::numeric_limits<const T>, std::numeric_limits<volatile T>, and
 // std::numeric_limits<const volatile T>
 // https://stackoverflow.com/a/16519653/
 template<>
-struct numeric_limits<const Eigen::half> : numeric_limits<Eigen::half> {};
+struct numeric_limits<const Eigen::bfloat16> : numeric_limits<Eigen::bfloat16> {};
 template<>
-struct numeric_limits<volatile Eigen::half> : numeric_limits<Eigen::half> {};
+struct numeric_limits<volatile Eigen::bfloat16> : numeric_limits<Eigen::bfloat16> {};
 template<>
-struct numeric_limits<const volatile Eigen::half> : numeric_limits<Eigen::half> {};
-} // end namespace std
+struct numeric_limits<const volatile Eigen::bfloat16> : numeric_limits<Eigen::bfloat16> {};
+} // namespace std
 
 namespace Eigen {
 
-namespace half_impl {
+namespace bfloat16_impl {
 
-#if defined(EIGEN_HAS_CUDA_FP16) && defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 530
+// We need to distinguish clang as the CUDA compiler from clang as the host compiler,
+// invoked by NVCC (e.g. on MacOS). The former needs to see both host and device implementation
+// of the functions, while the latter can only deal with one of them.
+#if !defined(EIGEN_HAS_NATIVE_BF16) || (EIGEN_COMP_CLANG && !EIGEN_COMP_NVCC) // Emulate support for bfloat16 floats
 
-// Intrinsics for native fp16 support. Note that on current hardware,
-// these are no faster than float32_bits arithmetic (you need to use the half2
-// versions to get the ALU speed increased), but you do save the
-// conversion steps back and forth.
+#if EIGEN_COMP_CLANG && defined(EIGEN_CUDACC)
+// We need to provide emulated *host-side* BF16 operators for clang.
+#pragma push_macro("EIGEN_DEVICE_FUNC")
+#undef EIGEN_DEVICE_FUNC
+#if defined(EIGEN_HAS_CUDA_BF16) && defined(EIGEN_HAS_NATIVE_BF16)
+#define EIGEN_DEVICE_FUNC __host__
+#else // both host and device need emulated ops.
+#define EIGEN_DEVICE_FUNC __host__ __device__
+#endif
+#endif
 
-EIGEN_STRONG_INLINE __device__ half operator + (const half& a, const half& b) {
-  return __hadd(a, b);
+// Definitions for CPUs, mostly working through conversion
+// to/from fp32.
+
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator + (const bfloat16& a, const bfloat16& b) {
+  return bfloat16(float(a) + float(b));
 }
-EIGEN_STRONG_INLINE __device__ half operator * (const half& a, const half& b) {
-  return __hmul(a, b);
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator + (const bfloat16& a, const int& b) {
+  return bfloat16(float(a) + static_cast<float>(b));
 }
-EIGEN_STRONG_INLINE __device__ half operator - (const half& a, const half& b) {
-  return __hsub(a, b);
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator + (const int& a, const bfloat16& b) {
+  return bfloat16(static_cast<float>(a) + float(b));
 }
-EIGEN_STRONG_INLINE __device__ half operator / (const half& a, const half& b) {
-  float num = __half2float(a);
-  float denom = __half2float(b);
-  return __float2half(num / denom);
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator * (const bfloat16& a, const bfloat16& b) {
+  return bfloat16(float(a) * float(b));
 }
-EIGEN_STRONG_INLINE __device__ half operator - (const half& a) {
-  return __hneg(a);
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator - (const bfloat16& a, const bfloat16& b) {
+  return bfloat16(float(a) - float(b));
 }
-EIGEN_STRONG_INLINE __device__ half& operator += (half& a, const half& b) {
-  a = a + b;
-  return a;
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator / (const bfloat16& a, const bfloat16& b) {
+  return bfloat16(float(a) / float(b));
 }
-EIGEN_STRONG_INLINE __device__ half& operator *= (half& a, const half& b) {
-  a = a * b;
-  return a;
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator - (const bfloat16& a) {
+  bfloat16 result;
+  result.value = a.value ^ 0x8000;
+  return result;
 }
-EIGEN_STRONG_INLINE __device__ half& operator -= (half& a, const half& b) {
-  a = a - b;
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16& operator += (bfloat16& a, const bfloat16& b) {
+  a = bfloat16(float(a) + float(b));
   return a;
 }
-EIGEN_STRONG_INLINE __device__ half& operator /= (half& a, const half& b) {
-  a = a / b;
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16& operator *= (bfloat16& a, const bfloat16& b) {
+  a = bfloat16(float(a) * float(b));
   return a;
 }
-EIGEN_STRONG_INLINE __device__ bool operator == (const half& a, const half& b) {
-  return __heq(a, b);
-}
-EIGEN_STRONG_INLINE __device__ bool operator != (const half& a, const half& b) {
-  return __hne(a, b);
-}
-EIGEN_STRONG_INLINE __device__ bool operator < (const half& a, const half& b) {
-  return __hlt(a, b);
-}
-EIGEN_STRONG_INLINE __device__ bool operator <= (const half& a, const half& b) {
-  return __hle(a, b);
-}
-EIGEN_STRONG_INLINE __device__ bool operator > (const half& a, const half& b) {
-  return __hgt(a, b);
-}
-EIGEN_STRONG_INLINE __device__ bool operator >= (const half& a, const half& b) {
-  return __hge(a, b);
-}
-
-#else  // Emulate support for half floats
-
-// Definitions for CPUs and older CUDA, mostly working through conversion
-// to/from float32_bits.
-
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half operator + (const half& a, const half& b) {
-  return half(float(a) + float(b));
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half operator * (const half& a, const half& b) {
-  return half(float(a) * float(b));
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half operator - (const half& a, const half& b) {
-  return half(float(a) - float(b));
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half operator / (const half& a, const half& b) {
-  return half(float(a) / float(b));
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half operator - (const half& a) {
-  half result;
-  result.x = a.x ^ 0x8000;
-  return result;
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half& operator += (half& a, const half& b) {
-  a = half(float(a) + float(b));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16& operator -= (bfloat16& a, const bfloat16& b) {
+  a = bfloat16(float(a) - float(b));
   return a;
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half& operator *= (half& a, const half& b) {
-  a = half(float(a) * float(b));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16& operator /= (bfloat16& a, const bfloat16& b) {
+  a = bfloat16(float(a) / float(b));
   return a;
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half& operator -= (half& a, const half& b) {
-  a = half(float(a) - float(b));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator++(bfloat16& a) {
+  a += bfloat16(1);
   return a;
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half& operator /= (half& a, const half& b) {
-  a = half(float(a) / float(b));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator--(bfloat16& a) {
+  a -= bfloat16(1);
   return a;
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator == (const half& a, const half& b) {
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator++(bfloat16& a, int) {
+  bfloat16 original_value = a;
+  ++a;
+  return original_value;
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator--(bfloat16& a, int) {
+  bfloat16 original_value = a;
+  --a;
+  return original_value;
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator == (const bfloat16& a, const bfloat16& b) {
   return numext::equal_strict(float(a),float(b));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator != (const half& a, const half& b) {
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator != (const bfloat16& a, const bfloat16& b) {
   return numext::not_equal_strict(float(a), float(b));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator < (const half& a, const half& b) {
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator < (const bfloat16& a, const bfloat16& b) {
   return float(a) < float(b);
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator <= (const half& a, const half& b) {
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator <= (const bfloat16& a, const bfloat16& b) {
   return float(a) <= float(b);
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator > (const half& a, const half& b) {
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator > (const bfloat16& a, const bfloat16& b) {
   return float(a) > float(b);
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator >= (const half& a, const half& b) {
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool operator >= (const bfloat16& a, const bfloat16& b) {
   return float(a) >= float(b);
 }
 
-#endif  // Emulate support for half floats
+#if EIGEN_COMP_CLANG && defined(EIGEN_CUDACC)
+#pragma pop_macro("EIGEN_DEVICE_FUNC")
+#endif
+#endif  // Emulate support for bfloat16 floats
 
 // Division by an index. Do it in full float precision to avoid accuracy
-// issues in converting the denominator to half.
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half operator / (const half& a, Index b) {
-  return half(static_cast<float>(a) / static_cast<float>(b));
+// issues in converting the denominator to bfloat16.
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 operator / (const bfloat16& a, Index b) {
+  return bfloat16(static_cast<float>(a) / static_cast<float>(b));
 }
 
-// Conversion routines, including fallbacks for the host or older CUDA.
-// Note that newer Intel CPUs (Haswell or newer) have vectorized versions of
-// these in hardware. If we need more performance on older/other CPUs, they are
-// also possible to vectorize directly.
-
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __half_raw raw_uint16_to_half(unsigned short x) {
-  __half_raw h;
-  h.x = x;
-  return h;
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __bfloat16_raw truncate_to_bfloat16(const float v) {
+  __bfloat16_raw output;
+  if (Eigen::numext::isnan EIGEN_NOT_A_MACRO(v)) {
+    output.value = std::signbit(v) ? 0xFFC0: 0x7FC0;
+    return output;
+  }
+  const uint16_t* p = reinterpret_cast<const uint16_t*>(&v);
+#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+  output.value = p[0];
+#else
+  output.value = p[1];
+#endif
+  return output;
 }
 
-union float32_bits {
-  unsigned int u;
-  float f;
-};
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR __bfloat16_raw raw_uint16_to_bfloat16(numext::uint16_t value) {
+  return __bfloat16_raw(value);
+}
 
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __half_raw float_to_half_rtne(float ff) {
-#if defined(EIGEN_HAS_CUDA_FP16) && defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 300
-  __half tmp_ff = __float2half(ff);
-  return *(__half_raw*)&tmp_ff;
-
-#elif defined(EIGEN_HAS_FP16_C)
-  __half_raw h;
-  h.x = _cvtss_sh(ff, 0);
-  return h;
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR numext::uint16_t raw_bfloat16_as_uint16(const __bfloat16_raw& bf) {
+  return bf.value;
+}
 
+// float_to_bfloat16_rtne template specialization that does not make any
+// assumption about the value of its function argument (ff).
+template <>
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __bfloat16_raw float_to_bfloat16_rtne<false>(float ff) {
+#if (defined(EIGEN_HAS_CUDA_BF16) && defined(EIGEN_HAS_HIP_BF16))
+  // Nothing to do here
+#else
+  __bfloat16_raw output;
+
+  if (Eigen::numext::isnan EIGEN_NOT_A_MACRO(ff)) {
+    // If the value is a NaN, squash it to a qNaN with msb of fraction set,
+    // this makes sure after truncation we don't end up with an inf.
+    //
+    // qNaN magic: All exponent bits set + most significant bit of fraction
+    // set.
+    output.value = std::signbit(ff) ? 0xFFC0: 0x7FC0;
+  } else {
+    // Fast rounding algorithm that rounds a half value to nearest even. This
+    // reduces expected error when we convert a large number of floats. Here
+    // is how it works:
+    //
+    // Definitions:
+    // To convert a float 32 to bfloat16, a float 32 can be viewed as 32 bits
+    // with the following tags:
+    //
+    // Sign |  Exp (8 bits) | Frac (23 bits)
+    //  S     EEEEEEEE         FFFFFFLRTTTTTTTTTTTTTTT
+    //
+    //  S: Sign bit.
+    //  E: Exponent bits.
+    //  F: First 6 bits of fraction.
+    //  L: Least significant bit of resulting bfloat16 if we truncate away the
+    //  rest of the float32. This is also the 7th bit of fraction
+    //  R: Rounding bit, 8th bit of fraction.
+    //  T: Sticky bits, rest of fraction, 15 bits.
+    //
+    // To round half to nearest even, there are 3 cases where we want to round
+    // down (simply truncate the result of the bits away, which consists of
+    // rounding bit and sticky bits) and two cases where we want to round up
+    // (truncate then add one to the result).
+    //
+    // The fast converting algorithm simply adds lsb (L) to 0x7fff (15 bits of
+    // 1s) as the rounding bias, adds the rounding bias to the input, then
+    // truncates the last 16 bits away.
+    //
+    // To understand how it works, we can analyze this algorithm case by case:
+    //
+    // 1. L = 0, R = 0:
+    //   Expect: round down, this is less than half value.
+    //
+    //   Algorithm:
+    //   - Rounding bias: 0x7fff + 0 = 0x7fff
+    //   - Adding rounding bias to input may create any carry, depending on
+    //   whether there is any value set to 1 in T bits.
+    //   - R may be set to 1 if there is a carry.
+    //   - L remains 0.
+    //   - Note that this case also handles Inf and -Inf, where all fraction
+    //   bits, including L, R and Ts are all 0. The output remains Inf after
+    //   this algorithm.
+    //
+    // 2. L = 1, R = 0:
+    //   Expect: round down, this is less than half value.
+    //
+    //   Algorithm:
+    //   - Rounding bias: 0x7fff + 1 = 0x8000
+    //   - Adding rounding bias to input doesn't change sticky bits but
+    //   adds 1 to rounding bit.
+    //   - L remains 1.
+    //
+    // 3. L = 0, R = 1, all of T are 0:
+    //   Expect: round down, this is exactly at half, the result is already
+    //   even (L=0).
+    //
+    //   Algorithm:
+    //   - Rounding bias: 0x7fff + 0 = 0x7fff
+    //   - Adding rounding bias to input sets all sticky bits to 1, but
+    //   doesn't create a carry.
+    //   - R remains 1.
+    //   - L remains 0.
+    //
+    // 4. L = 1, R = 1:
+    //   Expect: round up, this is exactly at half, the result needs to be
+    //   round to the next even number.
+    //
+    //   Algorithm:
+    //   - Rounding bias: 0x7fff + 1 = 0x8000
+    //   - Adding rounding bias to input doesn't change sticky bits, but
+    //   creates a carry from rounding bit.
+    //   - The carry sets L to 0, creates another carry bit and propagate
+    //   forward to F bits.
+    //   - If all the F bits are 1, a carry then propagates to the exponent
+    //   bits, which then creates the minimum value with the next exponent
+    //   value. Note that we won't have the case where exponents are all 1,
+    //   since that's either a NaN (handled in the other if condition) or inf
+    //   (handled in case 1).
+    //
+    // 5. L = 0, R = 1, any of T is 1:
+    //   Expect: round up, this is greater than half.
+    //
+    //   Algorithm:
+    //   - Rounding bias: 0x7fff + 0 = 0x7fff
+    //   - Adding rounding bias to input creates a carry from sticky bits,
+    //   sets rounding bit to 0, then create another carry.
+    //   - The second carry sets L to 1.
+    //
+    // Examples:
+    //
+    //  Exact half value that is already even:
+    //    Input:
+    //    Sign |  Exp (8 bit)     | Frac (first 7 bit) | Frac (last 16 bit)
+    //     S     E E E E E E E E      F F F F F F L     RTTTTTTTTTTTTTTT
+    //     0     0 0 0 0 0 0 0 0      0 0 0 0 0 1 0     1000000000000000
+    //
+    //     This falls into case 3. We truncate the rest of 16 bits and no
+    //     carry is created into F and L:
+    //
+    //    Output:
+    //    Sign |  Exp (8 bit)     | Frac (first 7 bit)
+    //     S     E E E E E E E E      F F F F F F L
+    //     0     0 0 0 0 0 0 0 0      0 0 0 0 0 1 0
+    //
+    //  Exact half value, round to next even number:
+    //    Input:
+    //    Sign |  Exp (8 bit)     | Frac (first 7 bit) | Frac (last 16 bit)
+    //     S     E E E E E E E E      F F F F F F L     RTTTTTTTTTTTTTTT
+    //     0     0 0 0 0 0 0 0 0      0 0 0 0 0 0 1     1000000000000000
+    //
+    //     This falls into case 4. We create a carry from R and T,
+    //     which then propagates into L and F:
+    //
+    //    Output:
+    //    Sign |  Exp (8 bit)     | Frac (first 7 bit)
+    //     S     E E E E E E E E      F F F F F F L
+    //     0     0 0 0 0 0 0 0 0      0 0 0 0 0 1 0
+    //
+    //
+    //  Max denormal value round to min normal value:
+    //    Input:
+    //    Sign |  Exp (8 bit)     | Frac (first 7 bit) | Frac (last 16 bit)
+    //     S     E E E E E E E E      F F F F F F L     RTTTTTTTTTTTTTTT
+    //     0     0 0 0 0 0 0 0 0      1 1 1 1 1 1 1     1111111111111111
+    //
+    //     This falls into case 4. We create a carry from R and T,
+    //     propagate into L and F, which then propagates into exponent
+    //     bits:
+    //
+    //    Output:
+    //    Sign |  Exp (8 bit)     | Frac (first 7 bit)
+    //     S     E E E E E E E E      F F F F F F L
+    //     0     0 0 0 0 0 0 0 1      0 0 0 0 0 0 0
+    //
+    //  Max normal value round to Inf:
+    //    Input:
+    //    Sign |  Exp (8 bit)     | Frac (first 7 bit) | Frac (last 16 bit)
+    //     S     E E E E E E E E      F F F F F F L     RTTTTTTTTTTTTTTT
+    //     0     1 1 1 1 1 1 1 0      1 1 1 1 1 1 1     1111111111111111
+    //
+    //     This falls into case 4. We create a carry from R and T,
+    //     propagate into L and F, which then propagates into exponent
+    //     bits:
+    //
+    //    Sign |  Exp (8 bit)     | Frac (first 7 bit)
+    //     S     E E E E E E E E      F F F F F F L
+    //     0     1 1 1 1 1 1 1 1      0 0 0 0 0 0 0
+
+    // At this point, ff must be either a normal float, or +/-infinity.
+    output = float_to_bfloat16_rtne<true>(ff);
+  }
+  return output;
+#endif
+}
+
+// float_to_bfloat16_rtne template specialization that assumes that its function
+// argument (ff) is either a normal floating point number, or +/-infinity, or
+// zero. Used to improve the runtime performance of conversion from an integer
+// type to bfloat16.
+template <>
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC __bfloat16_raw float_to_bfloat16_rtne<true>(float ff) {
+#if (defined(EIGEN_HAS_CUDA_BF16) && defined(EIGEN_HAS_HIP_BF16))
+    // Nothing to do here
 #else
-  float32_bits f; f.f = ff;
-
-  const float32_bits f32infty = { 255 << 23 };
-  const float32_bits f16max = { (127 + 16) << 23 };
-  const float32_bits denorm_magic = { ((127 - 15) + (23 - 10) + 1) << 23 };
-  unsigned int sign_mask = 0x80000000u;
-  __half_raw o;
-  o.x = static_cast<unsigned short>(0x0u);
-
-  unsigned int sign = f.u & sign_mask;
-  f.u ^= sign;
-
-  // NOTE all the integer compares in this function can be safely
-  // compiled into signed compares since all operands are below
-  // 0x80000000. Important if you want fast straight SSE2 code
-  // (since there's no unsigned PCMPGTD).
-
-  if (f.u >= f16max.u) {  // result is Inf or NaN (all exponent bits set)
-    o.x = (f.u > f32infty.u) ? 0x7e00 : 0x7c00; // NaN->qNaN and Inf->Inf
-  } else {  // (De)normalized number or zero
-    if (f.u < (113 << 23)) {  // resulting FP16 is subnormal or zero
-      // use a magic value to align our 10 mantissa bits at the bottom of
-      // the float. as long as FP addition is round-to-nearest-even this
-      // just works.
-      f.f += denorm_magic.f;
-
-      // and one integer subtract of the bias later, we have our final float!
-      o.x = static_cast<unsigned short>(f.u - denorm_magic.u);
-    } else {
-      unsigned int mant_odd = (f.u >> 13) & 1; // resulting mantissa is odd
-
-      // update exponent, rounding bias part 1
-      f.u += ((unsigned int)(15 - 127) << 23) + 0xfff;
-      // rounding bias part 2
-      f.u += mant_odd;
-      // take the bits!
-      o.x = static_cast<unsigned short>(f.u >> 13);
-    }
-  }
+    numext::uint32_t input = numext::bit_cast<numext::uint32_t>(ff);
+    __bfloat16_raw output;
 
-  o.x |= static_cast<unsigned short>(sign >> 16);
-  return o;
+    // Least significant bit of resulting bfloat.
+    numext::uint32_t lsb = (input >> 16) & 1;
+    numext::uint32_t rounding_bias = 0x7fff + lsb;
+    input += rounding_bias;
+    output.value = static_cast<numext::uint16_t>(input >> 16);
+    return output;
 #endif
 }
 
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC float half_to_float(__half_raw h) {
-#if defined(EIGEN_HAS_CUDA_FP16) && defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 300
-  return __half2float(h);
-
-#elif defined(EIGEN_HAS_FP16_C)
-  return _cvtsh_ss(h.x);
-
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC float bfloat16_to_float(__bfloat16_raw h) {
+    float result = 0;
+    unsigned short* q = reinterpret_cast<unsigned short*>(&result);
+#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+    q[0] = h.value;
 #else
-  const float32_bits magic = { 113 << 23 };
-  const unsigned int shifted_exp = 0x7c00 << 13; // exponent mask after shift
-  float32_bits o;
-
-  o.u = (h.x & 0x7fff) << 13;             // exponent/mantissa bits
-  unsigned int exp = shifted_exp & o.u;   // just the exponent
-  o.u += (127 - 15) << 23;                // exponent adjust
-
-  // handle exponent special cases
-  if (exp == shifted_exp) {     // Inf/NaN?
-    o.u += (128 - 16) << 23;    // extra exp adjust
-  } else if (exp == 0) {        // Zero/Denormal?
-    o.u += 1 << 23;             // extra exp adjust
-    o.f -= magic.f;             // renormalize
-  }
-
-  o.u |= (h.x & 0x8000) << 16;    // sign bit
-  return o.f;
+    q[1] = h.value;
 #endif
+    return result;
 }
-
 // --- standard functions ---
 
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isinf)(const half& a) {
-  return (a.x & 0x7fff) == 0x7c00;
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isinf)(const bfloat16& a) {
+  EIGEN_USING_STD(isinf);
+  return (isinf)(float(a));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isnan)(const bfloat16& a) {
+  EIGEN_USING_STD(isnan);
+  return (isnan)(float(a));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isnan)(const half& a) {
-#if defined(EIGEN_HAS_CUDA_FP16) && defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 530
-  return __hisnan(a);
-#else
-  return (a.x & 0x7fff) > 0x7c00;
-#endif
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isfinite)(const half& a) {
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bool (isfinite)(const bfloat16& a) {
   return !(isinf EIGEN_NOT_A_MACRO (a)) && !(isnan EIGEN_NOT_A_MACRO (a));
 }
 
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half abs(const half& a) {
-  half result;
-  result.x = a.x & 0x7FFF;
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 abs(const bfloat16& a) {
+  bfloat16 result;
+  result.value = a.value & 0x7FFF;
   return result;
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half exp(const half& a) {
-#if EIGEN_CUDACC_VER >= 80000 && defined EIGEN_CUDA_ARCH && EIGEN_CUDA_ARCH >= 530
-  return half(hexp(a));
-#else
-   return half(::expf(float(a)));
-#endif
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 exp(const bfloat16& a) {
+   return bfloat16(::expf(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log(const half& a) {
-#if defined(EIGEN_HAS_CUDA_FP16) && EIGEN_CUDACC_VER >= 80000 && defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 530
-  return half(::hlog(a));
-#else
-  return half(::logf(float(a)));
-#endif
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 expm1(const bfloat16& a) {
+  return bfloat16(numext::expm1(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log1p(const half& a) {
-  return half(numext::log1p(float(a)));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 log(const bfloat16& a) {
+  return bfloat16(::logf(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half log10(const half& a) {
-  return half(::log10f(float(a)));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 log1p(const bfloat16& a) {
+  return bfloat16(numext::log1p(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half sqrt(const half& a) {
-#if EIGEN_CUDACC_VER >= 80000 && defined EIGEN_CUDA_ARCH && EIGEN_CUDA_ARCH >= 530
-  return half(hsqrt(a));
-#else
-    return half(::sqrtf(float(a)));
-#endif
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 log10(const bfloat16& a) {
+  return bfloat16(::log10f(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half pow(const half& a, const half& b) {
-  return half(::powf(float(a), float(b)));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 log2(const bfloat16& a) {
+  return bfloat16(static_cast<float>(EIGEN_LOG2E) * ::logf(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half sin(const half& a) {
-  return half(::sinf(float(a)));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 sqrt(const bfloat16& a) {
+    return bfloat16(::sqrtf(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half cos(const half& a) {
-  return half(::cosf(float(a)));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 pow(const bfloat16& a, const bfloat16& b) {
+  return bfloat16(::powf(float(a), float(b)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half tan(const half& a) {
-  return half(::tanf(float(a)));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 sin(const bfloat16& a) {
+  return bfloat16(::sinf(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half tanh(const half& a) {
-  return half(::tanhf(float(a)));
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 cos(const bfloat16& a) {
+  return bfloat16(::cosf(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half floor(const half& a) {
-#if EIGEN_CUDACC_VER >= 80000 && defined EIGEN_CUDA_ARCH && EIGEN_CUDA_ARCH >= 300
-  return half(hfloor(a));
-#else
-  return half(::floorf(float(a)));
-#endif
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 tan(const bfloat16& a) {
+  return bfloat16(::tanf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 asin(const bfloat16& a) {
+  return bfloat16(::asinf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 acos(const bfloat16& a) {
+  return bfloat16(::acosf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 atan(const bfloat16& a) {
+  return bfloat16(::atanf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 sinh(const bfloat16& a) {
+  return bfloat16(::sinhf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 cosh(const bfloat16& a) {
+  return bfloat16(::coshf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 tanh(const bfloat16& a) {
+  return bfloat16(::tanhf(float(a)));
+}
+#if EIGEN_HAS_CXX11_MATH
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 asinh(const bfloat16& a) {
+  return bfloat16(::asinhf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 acosh(const bfloat16& a) {
+  return bfloat16(::acoshf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 atanh(const bfloat16& a) {
+  return bfloat16(::atanhf(float(a)));
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half ceil(const half& a) {
-#if EIGEN_CUDACC_VER >= 80000 && defined EIGEN_CUDA_ARCH && EIGEN_CUDA_ARCH >= 300
-  return half(hceil(a));
-#else
-  return half(::ceilf(float(a)));
 #endif
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 floor(const bfloat16& a) {
+  return bfloat16(::floorf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 ceil(const bfloat16& a) {
+  return bfloat16(::ceilf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 rint(const bfloat16& a) {
+  return bfloat16(::rintf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 round(const bfloat16& a) {
+  return bfloat16(::roundf(float(a)));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 fmod(const bfloat16& a, const bfloat16& b) {
+  return bfloat16(::fmodf(float(a), float(b)));
 }
 
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half (min)(const half& a, const half& b) {
-#if defined(EIGEN_HAS_CUDA_FP16) && defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 530
-  return __hlt(b, a) ? b : a;
-#else
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 (min)(const bfloat16& a, const bfloat16& b) {
   const float f1 = static_cast<float>(a);
   const float f2 = static_cast<float>(b);
   return f2 < f1 ? b : a;
-#endif
 }
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC half (max)(const half& a, const half& b) {
-#if defined(EIGEN_HAS_CUDA_FP16) && defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 530
-  return __hlt(a, b) ? b : a;
-#else
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 (max)(const bfloat16& a, const bfloat16& b) {
   const float f1 = static_cast<float>(a);
   const float f2 = static_cast<float>(b);
   return f1 < f2 ? b : a;
-#endif
 }
 
-EIGEN_ALWAYS_INLINE std::ostream& operator << (std::ostream& os, const half& v) {
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 fmin(const bfloat16& a, const bfloat16& b) {
+  const float f1 = static_cast<float>(a);
+  const float f2 = static_cast<float>(b);
+  return bfloat16(::fminf(f1, f2));
+}
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC bfloat16 fmax(const bfloat16& a, const bfloat16& b) {
+  const float f1 = static_cast<float>(a);
+  const float f2 = static_cast<float>(b);
+  return bfloat16(::fmaxf(f1, f2));
+}
+
+#ifndef EIGEN_NO_IO
+EIGEN_ALWAYS_INLINE std::ostream& operator << (std::ostream& os, const bfloat16& v) {
   os << static_cast<float>(v);
   return os;
 }
+#endif
 
-} // end namespace half_impl
-
-// import Eigen::half_impl::half into Eigen namespace
-// using half_impl::half;
+} // namespace bfloat16_impl
 
 namespace internal {
 
 template<>
-struct random_default_impl<half, false, false>
+struct random_default_impl<bfloat16, false, false>
 {
-  static inline half run(const half& x, const half& y)
+  static inline bfloat16 run(const bfloat16& x, const bfloat16& y)
   {
-    return x + (y-x) * half(float(std::rand()) / float(RAND_MAX));
+    return x + (y-x) * bfloat16(float(std::rand()) / float(RAND_MAX));
   }
-  static inline half run()
+  static inline bfloat16 run()
   {
-    return run(half(-1.f), half(1.f));
+    return run(bfloat16(-1.f), bfloat16(1.f));
   }
 };
 
-template<> struct is_arithmetic<half> { enum { value = true }; };
+template<> struct is_arithmetic<bfloat16> { enum { value = true }; };
 
-} // end namespace internal
+} // namespace internal
 
-template<> struct NumTraits<Eigen::half>
-    : GenericNumTraits<Eigen::half>
+template<> struct NumTraits<Eigen::bfloat16>
+    : GenericNumTraits<Eigen::bfloat16>
 {
   enum {
     IsSigned = true,
     IsInteger = false,
     IsComplex = false,
     RequireInitialization = false
   };
 
-  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half epsilon() {
-    return half_impl::raw_uint16_to_half(0x0800);
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR static EIGEN_STRONG_INLINE Eigen::bfloat16 epsilon() {
+    return bfloat16_impl::raw_uint16_to_bfloat16(0x3c00);
   }
-  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half dummy_precision() { return Eigen::half(1e-2f); }
-  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half highest() {
-    return half_impl::raw_uint16_to_half(0x7bff);
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR static EIGEN_STRONG_INLINE Eigen::bfloat16 dummy_precision() {
+    return bfloat16_impl::raw_uint16_to_bfloat16(0x3D4D);  // bfloat16(5e-2f);
+
   }
-  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half lowest() {
-    return half_impl::raw_uint16_to_half(0xfbff);
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR static EIGEN_STRONG_INLINE Eigen::bfloat16 highest() {
+    return bfloat16_impl::raw_uint16_to_bfloat16(0x7F7F);
   }
-  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half infinity() {
-    return half_impl::raw_uint16_to_half(0x7c00);
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR static EIGEN_STRONG_INLINE Eigen::bfloat16 lowest() {
+    return bfloat16_impl::raw_uint16_to_bfloat16(0xFF7F);
   }
-  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Eigen::half quiet_NaN() {
-    return half_impl::raw_uint16_to_half(0x7c01);
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR static EIGEN_STRONG_INLINE Eigen::bfloat16 infinity() {
+    return bfloat16_impl::raw_uint16_to_bfloat16(0x7f80);
   }
-};
-
-} // end namespace Eigen
-
-// C-like standard mathematical functions and trancendentals.
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half fabsh(const Eigen::half& a) {
-  Eigen::half result;
-  result.x = a.x & 0x7FFF;
-  return result;
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half exph(const Eigen::half& a) {
-  return Eigen::half(::expf(float(a)));
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half logh(const Eigen::half& a) {
-#if EIGEN_CUDACC_VER >= 80000 && defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 530
-  return Eigen::half(::hlog(a));
-#else
-  return Eigen::half(::logf(float(a)));
-#endif
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half sqrth(const Eigen::half& a) {
-  return Eigen::half(::sqrtf(float(a)));
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half powh(const Eigen::half& a, const Eigen::half& b) {
-  return Eigen::half(::powf(float(a), float(b)));
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half floorh(const Eigen::half& a) {
-  return Eigen::half(::floorf(float(a)));
-}
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half ceilh(const Eigen::half& a) {
-  return Eigen::half(::ceilf(float(a)));
-}
-
-namespace std {
-
-#if __cplusplus > 199711L
-template <>
-struct hash<Eigen::half> {
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE std::size_t operator()(const Eigen::half& a) const {
-    return static_cast<std::size_t>(a.x);
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR static EIGEN_STRONG_INLINE Eigen::bfloat16 quiet_NaN() {
+    return bfloat16_impl::raw_uint16_to_bfloat16(0x7fc0);
   }
 };
-#endif
-
-} // end namespace std
-
-
-// Add the missing shfl_xor intrinsic
-#if defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 300
-__device__ EIGEN_STRONG_INLINE Eigen::half __shfl_xor(Eigen::half var, int laneMask, int width=warpSize) {
-  #if EIGEN_CUDACC_VER < 90000
-  return static_cast<Eigen::half>(__shfl_xor(static_cast<float>(var), laneMask, width));
-  #else
-  return static_cast<Eigen::half>(__shfl_xor_sync(0xFFFFFFFF, static_cast<float>(var), laneMask, width));
-  #endif
-}
-#endif
-
-// ldg() has an overload for __half_raw, but we also need one for Eigen::half.
-#if defined(EIGEN_CUDA_ARCH) && EIGEN_CUDA_ARCH >= 350
-EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::half __ldg(const Eigen::half* ptr) {
-  return Eigen::half_impl::raw_uint16_to_half(
-      __ldg(reinterpret_cast<const unsigned short*>(ptr)));
-}
-#endif
 
+} // namespace Eigen
 
-#if defined(EIGEN_CUDA_ARCH)
 namespace Eigen {
 namespace numext {
 
 template<>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
-bool (isnan)(const Eigen::half& h) {
-  return (half_impl::isnan)(h);
+bool (isnan)(const Eigen::bfloat16& h) {
+  return (bfloat16_impl::isnan)(h);
 }
 
 template<>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
-bool (isinf)(const Eigen::half& h) {
-  return (half_impl::isinf)(h);
+bool (isinf)(const Eigen::bfloat16& h) {
+  return (bfloat16_impl::isinf)(h);
 }
 
 template<>
 EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE
-bool (isfinite)(const Eigen::half& h) {
-  return (half_impl::isfinite)(h);
+bool (isfinite)(const Eigen::bfloat16& h) {
+  return (bfloat16_impl::isfinite)(h);
+}
+
+template <>
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC Eigen::bfloat16 bit_cast<Eigen::bfloat16, uint16_t>(const uint16_t& src) {
+  return Eigen::bfloat16(Eigen::bfloat16_impl::raw_uint16_to_bfloat16(src));
+}
+
+template <>
+EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC uint16_t bit_cast<uint16_t, Eigen::bfloat16>(const Eigen::bfloat16& src) {
+  return Eigen::bfloat16_impl::raw_bfloat16_as_uint16(src);
 }
 
-} // namespace Eigen
 }  // namespace numext
+}  // namespace Eigen
+
+#if EIGEN_HAS_STD_HASH
+namespace std {
+template <>
+struct hash<Eigen::bfloat16> {
+  EIGEN_STRONG_INLINE std::size_t operator()(const Eigen::bfloat16& a) const {
+    return static_cast<std::size_t>(Eigen::numext::bit_cast<Eigen::numext::uint16_t>(a));
+  }
+};
+} // namespace std
 #endif
 
-#endif // EIGEN_HALF_CUDA_H
+
+#endif // EIGEN_BFLOAT16_H
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/CUDA/MathFunctions.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/GPU/MathFunctions.h`

 * *Files 8% similar despite different names*

```diff
@@ -3,25 +3,25 @@
 //
 // Copyright (C) 2014 Benoit Steiner <benoit.steiner.goog@gmail.com>
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-#ifndef EIGEN_MATH_FUNCTIONS_CUDA_H
-#define EIGEN_MATH_FUNCTIONS_CUDA_H
+#ifndef EIGEN_MATH_FUNCTIONS_GPU_H
+#define EIGEN_MATH_FUNCTIONS_GPU_H
 
 namespace Eigen {
 
 namespace internal {
 
 // Make sure this is only available when targeting a GPU: we don't want to
 // introduce conflicts between these packet_traits definitions and the ones
 // we'll use on the host side (SSE, AVX, ...)
-#if defined(__CUDACC__) && defined(EIGEN_USE_GPU)
+#if defined(EIGEN_GPUCC) && defined(EIGEN_USE_GPU)
 template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 float4 plog<float4>(const float4& a)
 {
   return make_float4(logf(a.x), logf(a.y), logf(a.z), logf(a.w));
 }
 
 template<>  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
@@ -53,14 +53,26 @@
 double2 pexp<double2>(const double2& a)
 {
   using ::exp;
   return make_double2(exp(a.x), exp(a.y));
 }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+float4 pexpm1<float4>(const float4& a)
+{
+  return make_float4(expm1f(a.x), expm1f(a.y), expm1f(a.z), expm1f(a.w));
+}
+
+template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+double2 pexpm1<double2>(const double2& a)
+{
+  return make_double2(expm1(a.x), expm1(a.y));
+}
+
+template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 float4 psqrt<float4>(const float4& a)
 {
   return make_float4(sqrtf(a.x), sqrtf(a.y), sqrtf(a.z), sqrtf(a.w));
 }
 
 template<> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
 double2 psqrt<double2>(const double2& a)
@@ -84,8 +96,8 @@
 
 #endif
 
 } // end namespace internal
 
 } // end namespace Eigen
 
-#endif // EIGEN_MATH_FUNCTIONS_CUDA_H
+#endif // EIGEN_MATH_FUNCTIONS_GPU_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/Default/Settings.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/Default/Settings.h`

 * *Files 0% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 #define EIGEN_DEFAULT_SETTINGS_H
 
 /** Defines the maximal loop size to enable meta unrolling of loops.
   * Note that the value here is expressed in Eigen's own notion of "number of FLOPS",
   * it does not correspond to the number of iterations or the number of instructions
   */
 #ifndef EIGEN_UNROLLING_LIMIT
-#define EIGEN_UNROLLING_LIMIT 100
+#define EIGEN_UNROLLING_LIMIT 110
 #endif
 
 /** Defines the threshold between a "small" and a "large" matrix.
   * This threshold is mainly used to select the proper product implementation.
   */
 #ifndef EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD
 #define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD 8
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/NEON/Complex.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/NEON/Complex.h`

 * *Files 24% similar despite different names*

```diff
@@ -11,192 +11,314 @@
 #ifndef EIGEN_COMPLEX_NEON_H
 #define EIGEN_COMPLEX_NEON_H
 
 namespace Eigen {
 
 namespace internal {
 
-inline uint32x4_t p4ui_CONJ_XOR() {
+inline uint32x4_t p4ui_CONJ_XOR()
+{
 // See bug 1325, clang fails to call vld1q_u64.
-#if EIGEN_COMP_CLANG
+#if EIGEN_COMP_CLANG || EIGEN_COMP_CASTXML
   uint32x4_t ret = { 0x00000000, 0x80000000, 0x00000000, 0x80000000 };
   return ret;
 #else
   static const uint32_t conj_XOR_DATA[] = { 0x00000000, 0x80000000, 0x00000000, 0x80000000 };
   return vld1q_u32( conj_XOR_DATA );
 #endif
 }
 
-inline uint32x2_t p2ui_CONJ_XOR() {
+inline uint32x2_t p2ui_CONJ_XOR()
+{
   static const uint32_t conj_XOR_DATA[] = { 0x00000000, 0x80000000 };
   return vld1_u32( conj_XOR_DATA );
 }
 
 //---------- float ----------
+
+struct Packet1cf
+{
+  EIGEN_STRONG_INLINE Packet1cf() {}
+  EIGEN_STRONG_INLINE explicit Packet1cf(const Packet2f& a) : v(a) {}
+  Packet2f v;
+};
 struct Packet2cf
 {
   EIGEN_STRONG_INLINE Packet2cf() {}
   EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}
-  Packet4f  v;
+  Packet4f v;
 };
 
-template<> struct packet_traits<std::complex<float> >  : default_packet_traits
+template<> struct packet_traits<std::complex<float> > : default_packet_traits
 {
   typedef Packet2cf type;
-  typedef Packet2cf half;
-  enum {
+  typedef Packet1cf half;
+  enum
+  {
     Vectorizable = 1,
     AlignedOnScalar = 1,
     size = 2,
-    HasHalfPacket = 0,
+    HasHalfPacket = 1,
 
-    HasAdd    = 1,
-    HasSub    = 1,
-    HasMul    = 1,
-    HasDiv    = 1,
-    HasNegate = 1,
-    HasAbs    = 0,
-    HasAbs2   = 0,
-    HasMin    = 0,
-    HasMax    = 0,
+    HasAdd       = 1,
+    HasSub       = 1,
+    HasMul       = 1,
+    HasDiv       = 1,
+    HasNegate    = 1,
+    HasAbs       = 0,
+    HasAbs2      = 0,
+    HasMin       = 0,
+    HasMax       = 0,
     HasSetLinear = 0
   };
 };
 
-template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };
-
-template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)
+template<> struct unpacket_traits<Packet1cf>
 {
-  float32x2_t r64;
-  r64 = vld1_f32((const float *)&from);
+  typedef std::complex<float> type;
+  typedef Packet1cf half;
+  typedef Packet2f as_real;
+  enum
+  {
+    size = 1,
+    alignment = Aligned16,
+    vectorizable = true,
+    masked_load_available = false,
+    masked_store_available = false
+  };
+};
+template<> struct unpacket_traits<Packet2cf>
+{
+  typedef std::complex<float> type;
+  typedef Packet1cf half;
+  typedef Packet4f as_real;
+  enum
+  {
+    size = 2,
+    alignment = Aligned16,
+    vectorizable = true,
+    masked_load_available = false,
+    masked_store_available = false
+  };
+};
 
+template<> EIGEN_STRONG_INLINE Packet1cf pcast<float,Packet1cf>(const float& a)
+{ return Packet1cf(vset_lane_f32(a, vdup_n_f32(0.f), 0)); }
+template<> EIGEN_STRONG_INLINE Packet2cf pcast<Packet2f,Packet2cf>(const Packet2f& a)
+{ return Packet2cf(vreinterpretq_f32_u64(vmovl_u32(vreinterpret_u32_f32(a)))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf pset1<Packet1cf>(const std::complex<float>& from)
+{ return Packet1cf(vld1_f32(reinterpret_cast<const float*>(&from))); }
+template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>& from)
+{
+  const float32x2_t r64 = vld1_f32(reinterpret_cast<const float*>(&from));
   return Packet2cf(vcombine_f32(r64, r64));
 }
 
-template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet1cf padd<Packet1cf>(const Packet1cf& a, const Packet1cf& b)
+{ return Packet1cf(padd<Packet2f>(a.v, b.v)); }
+template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+{ return Packet2cf(padd<Packet4f>(a.v, b.v)); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf psub<Packet1cf>(const Packet1cf& a, const Packet1cf& b)
+{ return Packet1cf(psub<Packet2f>(a.v, b.v)); }
+template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+{ return Packet2cf(psub<Packet4f>(a.v, b.v)); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf pnegate(const Packet1cf& a) { return Packet1cf(pnegate<Packet2f>(a.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf pconj(const Packet1cf& a)
+{
+  const Packet2ui b = vreinterpret_u32_f32(a.v);
+  return Packet1cf(vreinterpret_f32_u32(veor_u32(b, p2ui_CONJ_XOR())));
+}
 template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)
 {
-  Packet4ui b = vreinterpretq_u32_f32(a.v);
+  const Packet4ui b = vreinterpretq_u32_f32(a.v);
   return Packet2cf(vreinterpretq_f32_u32(veorq_u32(b, p4ui_CONJ_XOR())));
 }
 
+template<> EIGEN_STRONG_INLINE Packet1cf pmul<Packet1cf>(const Packet1cf& a, const Packet1cf& b)
+{
+  Packet2f v1, v2;
+
+  // Get the real values of a | a1_re | a1_re |
+  v1 = vdup_lane_f32(a.v, 0);
+  // Get the imag values of a | a1_im | a1_im |
+  v2 = vdup_lane_f32(a.v, 1);
+  // Multiply the real a with b
+  v1 = vmul_f32(v1, b.v);
+  // Multiply the imag a with b
+  v2 = vmul_f32(v2, b.v);
+  // Conjugate v2
+  v2 = vreinterpret_f32_u32(veor_u32(vreinterpret_u32_f32(v2), p2ui_CONJ_XOR()));
+  // Swap real/imag elements in v2.
+  v2 = vrev64_f32(v2);
+  // Add and return the result
+  return Packet1cf(vadd_f32(v1, v2));
+}
 template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
 {
   Packet4f v1, v2;
 
   // Get the real values of a | a1_re | a1_re | a2_re | a2_re |
   v1 = vcombine_f32(vdup_lane_f32(vget_low_f32(a.v), 0), vdup_lane_f32(vget_high_f32(a.v), 0));
   // Get the imag values of a | a1_im | a1_im | a2_im | a2_im |
   v2 = vcombine_f32(vdup_lane_f32(vget_low_f32(a.v), 1), vdup_lane_f32(vget_high_f32(a.v), 1));
   // Multiply the real a with b
   v1 = vmulq_f32(v1, b.v);
   // Multiply the imag a with b
   v2 = vmulq_f32(v2, b.v);
-  // Conjugate v2 
+  // Conjugate v2
   v2 = vreinterpretq_f32_u32(veorq_u32(vreinterpretq_u32_f32(v2), p4ui_CONJ_XOR()));
   // Swap real/imag elements in v2.
   v2 = vrev64q_f32(v2);
   // Add and return the result
   return Packet2cf(vaddq_f32(v1, v2));
 }
 
-template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)
-{
-  return Packet2cf(vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(a.v),vreinterpretq_u32_f32(b.v))));
-}
-template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+template<> EIGEN_STRONG_INLINE Packet1cf pcmp_eq(const Packet1cf& a, const Packet1cf& b)
 {
-  return Packet2cf(vreinterpretq_f32_u32(vorrq_u32(vreinterpretq_u32_f32(a.v),vreinterpretq_u32_f32(b.v))));
-}
-template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)
-{
-  return Packet2cf(vreinterpretq_f32_u32(veorq_u32(vreinterpretq_u32_f32(a.v),vreinterpretq_u32_f32(b.v))));
-}
+  // Compare real and imaginary parts of a and b to get the mask vector:
+  // [re(a[0])==re(b[0]), im(a[0])==im(b[0])]
+  Packet2f eq = pcmp_eq<Packet2f>(a.v, b.v);
+  // Swap real/imag elements in the mask in to get:
+  // [im(a[0])==im(b[0]), re(a[0])==re(b[0])]
+  Packet2f eq_swapped = vrev64_f32(eq);
+  // Return re(a)==re(b) && im(a)==im(b) by computing bitwise AND of eq and eq_swapped
+  return Packet1cf(pand<Packet2f>(eq, eq_swapped));
+}
+template<> EIGEN_STRONG_INLINE Packet2cf pcmp_eq(const Packet2cf& a, const Packet2cf& b)
+{
+  // Compare real and imaginary parts of a and b to get the mask vector:
+  // [re(a[0])==re(b[0]), im(a[0])==im(b[0]), re(a[1])==re(b[1]), im(a[1])==im(b[1])]
+  Packet4f eq = pcmp_eq<Packet4f>(a.v, b.v);
+  // Swap real/imag elements in the mask in to get:
+  // [im(a[0])==im(b[0]), re(a[0])==re(b[0]), im(a[1])==im(b[1]), re(a[1])==re(b[1])]
+  Packet4f eq_swapped = vrev64q_f32(eq);
+  // Return re(a)==re(b) && im(a)==im(b) by computing bitwise AND of eq and eq_swapped
+  return Packet2cf(pand<Packet4f>(eq, eq_swapped));
+}
+
+template<> EIGEN_STRONG_INLINE Packet1cf pand<Packet1cf>(const Packet1cf& a, const Packet1cf& b)
+{ return Packet1cf(vreinterpret_f32_u32(vand_u32(vreinterpret_u32_f32(a.v), vreinterpret_u32_f32(b.v)))); }
+template<> EIGEN_STRONG_INLINE Packet2cf pand<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+{ return Packet2cf(vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(a.v), vreinterpretq_u32_f32(b.v)))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf por<Packet1cf>(const Packet1cf& a, const Packet1cf& b)
+{ return Packet1cf(vreinterpret_f32_u32(vorr_u32(vreinterpret_u32_f32(a.v), vreinterpret_u32_f32(b.v)))); }
+template<> EIGEN_STRONG_INLINE Packet2cf por<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+{ return Packet2cf(vreinterpretq_f32_u32(vorrq_u32(vreinterpretq_u32_f32(a.v), vreinterpretq_u32_f32(b.v)))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf pxor<Packet1cf>(const Packet1cf& a, const Packet1cf& b)
+{ return Packet1cf(vreinterpret_f32_u32(veor_u32(vreinterpret_u32_f32(a.v), vreinterpret_u32_f32(b.v)))); }
+template<> EIGEN_STRONG_INLINE Packet2cf pxor<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+{ return Packet2cf(vreinterpretq_f32_u32(veorq_u32(vreinterpretq_u32_f32(a.v), vreinterpretq_u32_f32(b.v)))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf pandnot<Packet1cf>(const Packet1cf& a, const Packet1cf& b)
+{ return Packet1cf(vreinterpret_f32_u32(vbic_u32(vreinterpret_u32_f32(a.v), vreinterpret_u32_f32(b.v)))); }
 template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+{ return Packet2cf(vreinterpretq_f32_u32(vbicq_u32(vreinterpretq_u32_f32(a.v), vreinterpretq_u32_f32(b.v)))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf pload<Packet1cf>(const std::complex<float>* from)
+{ EIGEN_DEBUG_ALIGNED_LOAD return Packet1cf(pload<Packet2f>((const float*)from)); }
+template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from)
+{ EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(reinterpret_cast<const float*>(from))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf ploadu<Packet1cf>(const std::complex<float>* from)
+{ EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cf(ploadu<Packet2f>((const float*)from)); }
+template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from)
+{ EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(reinterpret_cast<const float*>(from))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cf ploaddup<Packet1cf>(const std::complex<float>* from)
+{ return pset1<Packet1cf>(*from); }
+template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from)
+{ return pset1<Packet2cf>(*from); }
+
+template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *to, const Packet1cf& from)
+{ EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }
+template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *to, const Packet2cf& from)
+{ EIGEN_DEBUG_ALIGNED_STORE pstore(reinterpret_cast<float*>(to), from.v); }
+
+template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *to, const Packet1cf& from)
+{ EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }
+template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *to, const Packet2cf& from)
+{ EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<float*>(to), from.v); }
+
+template<> EIGEN_DEVICE_FUNC inline Packet1cf pgather<std::complex<float>, Packet1cf>(
+    const std::complex<float>* from, Index stride)
 {
-  return Packet2cf(vreinterpretq_f32_u32(vbicq_u32(vreinterpretq_u32_f32(a.v),vreinterpretq_u32_f32(b.v))));
+  const Packet2f tmp = vdup_n_f32(std::real(from[0*stride]));
+  return Packet1cf(vset_lane_f32(std::imag(from[0*stride]), tmp, 1));
 }
-
-template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }
-template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }
-
-template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }
-
-template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }
-template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }
-
-template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)
+template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(
+    const std::complex<float>* from, Index stride)
 {
-  Packet4f res = pset1<Packet4f>(0.f);
-  res = vsetq_lane_f32(std::real(from[0*stride]), res, 0);
+  Packet4f res = vdupq_n_f32(std::real(from[0*stride]));
   res = vsetq_lane_f32(std::imag(from[0*stride]), res, 1);
   res = vsetq_lane_f32(std::real(from[1*stride]), res, 2);
   res = vsetq_lane_f32(std::imag(from[1*stride]), res, 3);
   return Packet2cf(res);
 }
 
-template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)
+template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet1cf>(
+    std::complex<float>* to, const Packet1cf& from, Index stride)
+{ to[stride*0] = std::complex<float>(vget_lane_f32(from.v, 0), vget_lane_f32(from.v, 1)); }
+template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(
+    std::complex<float>* to, const Packet2cf& from, Index stride)
 {
   to[stride*0] = std::complex<float>(vgetq_lane_f32(from.v, 0), vgetq_lane_f32(from.v, 1));
   to[stride*1] = std::complex<float>(vgetq_lane_f32(from.v, 2), vgetq_lane_f32(from.v, 3));
 }
 
-template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { EIGEN_ARM_PREFETCH((const float *)addr); }
+template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *addr)
+{ EIGEN_ARM_PREFETCH(reinterpret_cast<const float*>(addr)); }
 
-template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)
+template<> EIGEN_STRONG_INLINE std::complex<float> pfirst<Packet1cf>(const Packet1cf& a)
 {
-  std::complex<float> EIGEN_ALIGN16 x[2];
-  vst1q_f32((float *)x, a.v);
+  EIGEN_ALIGN16 std::complex<float> x;
+  vst1_f32(reinterpret_cast<float*>(&x), a.v);
+  return x;
+}
+template<> EIGEN_STRONG_INLINE std::complex<float> pfirst<Packet2cf>(const Packet2cf& a)
+{
+  EIGEN_ALIGN16 std::complex<float> x[2];
+  vst1q_f32(reinterpret_cast<float*>(x), a.v);
   return x[0];
 }
 
+template<> EIGEN_STRONG_INLINE Packet1cf preverse(const Packet1cf& a) { return a; }
 template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)
-{
-  float32x2_t a_lo, a_hi;
-  Packet4f a_r128;
-
-  a_lo = vget_low_f32(a.v);
-  a_hi = vget_high_f32(a.v);
-  a_r128 = vcombine_f32(a_hi, a_lo);
-
-  return Packet2cf(a_r128);
-}
+{ return Packet2cf(vcombine_f32(vget_high_f32(a.v), vget_low_f32(a.v))); }
 
+template<> EIGEN_STRONG_INLINE Packet1cf pcplxflip<Packet1cf>(const Packet1cf& a)
+{ return Packet1cf(vrev64_f32(a.v)); }
 template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)
+{ return Packet2cf(vrev64q_f32(a.v)); }
+
+template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet1cf>(const Packet1cf& a)
 {
-  return Packet2cf(vrev64q_f32(a.v));
+  std::complex<float> s;
+  vst1_f32((float *)&s, a.v);
+  return s;
 }
-
 template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)
 {
-  float32x2_t a1, a2;
   std::complex<float> s;
-
-  a1 = vget_low_f32(a.v);
-  a2 = vget_high_f32(a.v);
-  a2 = vadd_f32(a1, a2);
-  vst1_f32((float *)&s, a2);
-
+  vst1_f32(reinterpret_cast<float*>(&s), vadd_f32(vget_low_f32(a.v), vget_high_f32(a.v)));
   return s;
 }
 
-template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)
+template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet1cf>(const Packet1cf& a)
 {
-  Packet4f sum1, sum2, sum;
-
-  // Add the first two 64-bit float32x2_t of vecs[0]
-  sum1 = vcombine_f32(vget_low_f32(vecs[0].v), vget_low_f32(vecs[1].v));
-  sum2 = vcombine_f32(vget_high_f32(vecs[0].v), vget_high_f32(vecs[1].v));
-  sum = vaddq_f32(sum1, sum2);
-
-  return Packet2cf(sum);
+  std::complex<float> s;
+  vst1_f32((float *)&s, a.v);
+  return s;
 }
-
 template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)
 {
   float32x2_t a1, a2, v1, v2, prod;
   std::complex<float> s;
 
   a1 = vget_low_f32(a.v);
   a2 = vget_high_f32(a.v);
@@ -204,98 +326,75 @@
   v1 = vdup_lane_f32(a1, 0);
   // Get the real values of a | a1_im | a1_im | a2_im | a2_im |
   v2 = vdup_lane_f32(a1, 1);
   // Multiply the real a with b
   v1 = vmul_f32(v1, a2);
   // Multiply the imag a with b
   v2 = vmul_f32(v2, a2);
-  // Conjugate v2 
+  // Conjugate v2
   v2 = vreinterpret_f32_u32(veor_u32(vreinterpret_u32_f32(v2), p2ui_CONJ_XOR()));
   // Swap real/imag elements in v2.
   v2 = vrev64_f32(v2);
   // Add v1, v2
   prod = vadd_f32(v1, v2);
 
-  vst1_f32((float *)&s, prod);
+  vst1_f32(reinterpret_cast<float*>(&s), prod);
 
   return s;
 }
 
-template<int Offset>
-struct palign_impl<Offset,Packet2cf>
-{
-  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)
-  {
-    if (Offset==1)
-    {
-      first.v = vextq_f32(first.v, second.v, 2);
-    }
-  }
-};
-
-template<> struct conj_helper<Packet2cf, Packet2cf, false,true>
-{
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return internal::pmul(a, pconj(b));
-  }
-};
-
-template<> struct conj_helper<Packet2cf, Packet2cf, true,false>
-{
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return internal::pmul(pconj(a), b);
-  }
-};
+EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet1cf,Packet2f)
+EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet2cf,Packet4f)
 
-template<> struct conj_helper<Packet2cf, Packet2cf, true,true>
+template<> EIGEN_STRONG_INLINE Packet1cf pdiv<Packet1cf>(const Packet1cf& a, const Packet1cf& b)
 {
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return pconj(internal::pmul(a, b));
-  }
-};
+  // TODO optimize it for NEON
+  Packet1cf res = pmul(a, pconj(b));
+  Packet2f s, rev_s;
 
-EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet2cf,Packet4f)
+  // this computes the norm
+  s = vmul_f32(b.v, b.v);
+  rev_s = vrev64_f32(s);
 
+  return Packet1cf(pdiv<Packet2f>(res.v, vadd_f32(s, rev_s)));
+}
 template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
 {
   // TODO optimize it for NEON
-  Packet2cf res = conj_helper<Packet2cf,Packet2cf,false,true>().pmul(a,b);
+  Packet2cf res = pmul(a,pconj(b));
   Packet4f s, rev_s;
 
   // this computes the norm
   s = vmulq_f32(b.v, b.v);
   rev_s = vrev64q_f32(s);
 
-  return Packet2cf(pdiv<Packet4f>(res.v, vaddq_f32(s,rev_s)));
+  return Packet2cf(pdiv<Packet4f>(res.v, vaddq_f32(s, rev_s)));
 }
 
-EIGEN_DEVICE_FUNC inline void
-ptranspose(PacketBlock<Packet2cf,2>& kernel) {
+EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet1cf, 1>& /*kernel*/) {}
+EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet2cf, 2>& kernel)
+{
   Packet4f tmp = vcombine_f32(vget_high_f32(kernel.packet[0].v), vget_high_f32(kernel.packet[1].v));
   kernel.packet[0].v = vcombine_f32(vget_low_f32(kernel.packet[0].v), vget_low_f32(kernel.packet[1].v));
   kernel.packet[1].v = tmp;
 }
 
+template<> EIGEN_STRONG_INLINE Packet1cf psqrt<Packet1cf>(const Packet1cf& a) {
+  return psqrt_complex<Packet1cf>(a);
+}
+
+template<> EIGEN_STRONG_INLINE Packet2cf psqrt<Packet2cf>(const Packet2cf& a) {
+  return psqrt_complex<Packet2cf>(a);
+}
+
 //---------- double ----------
 #if EIGEN_ARCH_ARM64 && !EIGEN_APPLE_DOUBLE_NEON_BUG
 
 // See bug 1325, clang fails to call vld1q_u64.
-#if EIGEN_COMP_CLANG
+#if EIGEN_COMP_CLANG || EIGEN_COMP_CASTXML
   static uint64x2_t p2ul_CONJ_XOR = {0x0, 0x8000000000000000};
 #else
   const uint64_t  p2ul_conj_XOR_DATA[] = { 0x0, 0x8000000000000000 };
   static uint64x2_t p2ul_CONJ_XOR = vld1q_u64( p2ul_conj_XOR_DATA );
 #endif
 
 struct Packet1cd
@@ -305,15 +404,16 @@
   Packet2d v;
 };
 
 template<> struct packet_traits<std::complex<double> >  : default_packet_traits
 {
   typedef Packet1cd type;
   typedef Packet1cd half;
-  enum {
+  enum
+  {
     Vectorizable = 1,
     AlignedOnScalar = 0,
     size = 1,
     HasHalfPacket = 0,
 
     HasAdd    = 1,
     HasSub    = 1,
@@ -324,167 +424,161 @@
     HasAbs2   = 0,
     HasMin    = 0,
     HasMax    = 0,
     HasSetLinear = 0
   };
 };
 
-template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };
+template<> struct unpacket_traits<Packet1cd>
+{
+  typedef std::complex<double> type;
+  typedef Packet1cd half;
+  typedef Packet2d as_real;
+  enum
+  {
+    size=1,
+    alignment=Aligned16,
+    vectorizable=true,
+    masked_load_available=false,
+    masked_store_available=false
+  };
+};
+
+template<> EIGEN_STRONG_INLINE Packet1cd pload<Packet1cd>(const std::complex<double>* from)
+{ EIGEN_DEBUG_ALIGNED_LOAD return Packet1cd(pload<Packet2d>(reinterpret_cast<const double*>(from))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)
+{ EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cd(ploadu<Packet2d>(reinterpret_cast<const double*>(from))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>& from)
+{
+  /* here we really have to use unaligned loads :( */
+  return ploadu<Packet1cd>(&from);
+}
 
-template<> EIGEN_STRONG_INLINE Packet1cd pload<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet1cd(pload<Packet2d>((const double*)from)); }
-template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cd(ploadu<Packet2d>((const double*)from)); }
+template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
+{ return Packet1cd(padd<Packet2d>(a.v, b.v)); }
 
-template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)
-{ /* here we really have to use unaligned loads :( */ return ploadu<Packet1cd>(&from); }
+template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
+{ return Packet1cd(psub<Packet2d>(a.v, b.v)); }
 
-template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(padd<Packet2d>(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(psub<Packet2d>(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate<Packet2d>(a.v)); }
-template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd(vreinterpretq_f64_u64(veorq_u64(vreinterpretq_u64_f64(a.v), p2ul_CONJ_XOR))); }
+template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a)
+{ return Packet1cd(pnegate<Packet2d>(a.v)); }
+
+template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)
+{ return Packet1cd(vreinterpretq_f64_u64(veorq_u64(vreinterpretq_u64_f64(a.v), p2ul_CONJ_XOR))); }
 
 template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
 {
   Packet2d v1, v2;
 
-  // Get the real values of a 
+  // Get the real values of a
   v1 = vdupq_lane_f64(vget_low_f64(a.v), 0);
   // Get the imag values of a
   v2 = vdupq_lane_f64(vget_high_f64(a.v), 0);
   // Multiply the real a with b
   v1 = vmulq_f64(v1, b.v);
   // Multiply the imag a with b
   v2 = vmulq_f64(v2, b.v);
-  // Conjugate v2 
+  // Conjugate v2
   v2 = vreinterpretq_f64_u64(veorq_u64(vreinterpretq_u64_f64(v2), p2ul_CONJ_XOR));
   // Swap real/imag elements in v2.
   v2 = preverse<Packet2d>(v2);
   // Add and return the result
   return Packet1cd(vaddq_f64(v1, v2));
 }
 
-template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b)
-{
-  return Packet1cd(vreinterpretq_f64_u64(vandq_u64(vreinterpretq_u64_f64(a.v),vreinterpretq_u64_f64(b.v))));
-}
-template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b)
-{
-  return Packet1cd(vreinterpretq_f64_u64(vorrq_u64(vreinterpretq_u64_f64(a.v),vreinterpretq_u64_f64(b.v))));
-}
-template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b)
+template<> EIGEN_STRONG_INLINE Packet1cd pcmp_eq(const Packet1cd& a, const Packet1cd& b)
 {
-  return Packet1cd(vreinterpretq_f64_u64(veorq_u64(vreinterpretq_u64_f64(a.v),vreinterpretq_u64_f64(b.v))));
+  // Compare real and imaginary parts of a and b to get the mask vector:
+  // [re(a)==re(b), im(a)==im(b)]
+  Packet2d eq = pcmp_eq<Packet2d>(a.v, b.v);
+  // Swap real/imag elements in the mask in to get:
+  // [im(a)==im(b), re(a)==re(b)]
+  Packet2d eq_swapped = vreinterpretq_f64_u32(vrev64q_u32(vreinterpretq_u32_f64(eq)));
+  // Return re(a)==re(b) & im(a)==im(b) by computing bitwise AND of eq and eq_swapped
+  return Packet1cd(pand<Packet2d>(eq, eq_swapped));
 }
+
+template<> EIGEN_STRONG_INLINE Packet1cd pand<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
+{ return Packet1cd(vreinterpretq_f64_u64(vandq_u64(vreinterpretq_u64_f64(a.v),vreinterpretq_u64_f64(b.v)))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cd por<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
+{ return Packet1cd(vreinterpretq_f64_u64(vorrq_u64(vreinterpretq_u64_f64(a.v),vreinterpretq_u64_f64(b.v)))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cd pxor<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
+{ return Packet1cd(vreinterpretq_f64_u64(veorq_u64(vreinterpretq_u64_f64(a.v),vreinterpretq_u64_f64(b.v)))); }
+
 template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
-{
-  return Packet1cd(vreinterpretq_f64_u64(vbicq_u64(vreinterpretq_u64_f64(a.v),vreinterpretq_u64_f64(b.v))));
-}
+{ return Packet1cd(vreinterpretq_f64_u64(vbicq_u64(vreinterpretq_u64_f64(a.v),vreinterpretq_u64_f64(b.v)))); }
+
+template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from)
+{ return pset1<Packet1cd>(*from); }
 
-template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }
+template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *to, const Packet1cd& from)
+{ EIGEN_DEBUG_ALIGNED_STORE pstore(reinterpret_cast<double*>(to), from.v); }
 
-template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }
-template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }
+template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *to, const Packet1cd& from)
+{ EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), from.v); }
 
-template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { EIGEN_ARM_PREFETCH((const double *)addr); }
+template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *addr)
+{ EIGEN_ARM_PREFETCH(reinterpret_cast<const double*>(addr)); }
 
-template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride)
+template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(
+    const std::complex<double>* from, Index stride)
 {
   Packet2d res = pset1<Packet2d>(0.0);
   res = vsetq_lane_f64(std::real(from[0*stride]), res, 0);
   res = vsetq_lane_f64(std::imag(from[0*stride]), res, 1);
   return Packet1cd(res);
 }
 
-template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride)
-{
-  to[stride*0] = std::complex<double>(vgetq_lane_f64(from.v, 0), vgetq_lane_f64(from.v, 1));
-}
+template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(
+    std::complex<double>* to, const Packet1cd& from, Index stride)
+{ to[stride*0] = std::complex<double>(vgetq_lane_f64(from.v, 0), vgetq_lane_f64(from.v, 1)); }
 
-
-template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)
+template<> EIGEN_STRONG_INLINE std::complex<double> pfirst<Packet1cd>(const Packet1cd& a)
 {
-  std::complex<double> EIGEN_ALIGN16 res;
+  EIGEN_ALIGN16 std::complex<double> res;
   pstore<std::complex<double> >(&res, a);
-
   return res;
 }
 
 template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }
 
 template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a) { return pfirst(a); }
 
-template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs) { return vecs[0]; }
-
 template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a) { return pfirst(a); }
 
-template<int Offset>
-struct palign_impl<Offset,Packet1cd>
-{
-  static EIGEN_STRONG_INLINE void run(Packet1cd& /*first*/, const Packet1cd& /*second*/)
-  {
-    // FIXME is it sure we never have to align a Packet1cd?
-    // Even though a std::complex<double> has 16 bytes, it is not necessarily aligned on a 16 bytes boundary...
-  }
-};
-
-template<> struct conj_helper<Packet1cd, Packet1cd, false,true>
-{
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return internal::pmul(a, pconj(b));
-  }
-};
-
-template<> struct conj_helper<Packet1cd, Packet1cd, true,false>
-{
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return internal::pmul(pconj(a), b);
-  }
-};
-
-template<> struct conj_helper<Packet1cd, Packet1cd, true,true>
-{
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return pconj(internal::pmul(a, b));
-  }
-};
-
 EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet1cd,Packet2d)
 
 template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
 {
   // TODO optimize it for NEON
-  Packet1cd res = conj_helper<Packet1cd,Packet1cd,false,true>().pmul(a,b);
+  Packet1cd res = pmul(a,pconj(b));
   Packet2d s = pmul<Packet2d>(b.v, b.v);
   Packet2d rev_s = preverse<Packet2d>(s);
 
   return Packet1cd(pdiv(res.v, padd<Packet2d>(s,rev_s)));
 }
 
 EIGEN_STRONG_INLINE Packet1cd pcplxflip/*<Packet1cd>*/(const Packet1cd& x)
-{
-  return Packet1cd(preverse(Packet2d(x.v)));
-}
+{ return Packet1cd(preverse(Packet2d(x.v))); }
 
 EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)
 {
   Packet2d tmp = vcombine_f64(vget_high_f64(kernel.packet[0].v), vget_high_f64(kernel.packet[1].v));
   kernel.packet[0].v = vcombine_f64(vget_low_f64(kernel.packet[0].v), vget_low_f64(kernel.packet[1].v));
   kernel.packet[1].v = tmp;
 }
+
+template<> EIGEN_STRONG_INLINE Packet1cd psqrt<Packet1cd>(const Packet1cd& a) {
+  return psqrt_complex<Packet1cd>(a);
+}
+
 #endif // EIGEN_ARCH_ARM64
 
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_COMPLEX_NEON_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/SSE/PacketMath.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/MSA/PacketMath.h`

 * *Files 27% similar despite different names*

```diff
@@ -1,895 +1,1233 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
-// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>
+// Copyright (C) 2018 Wave Computing, Inc.
+// Written by:
+//   Chris Larsen
+//   Alexey Frunze (afrunze@wavecomp.com)
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-#ifndef EIGEN_PACKET_MATH_SSE_H
-#define EIGEN_PACKET_MATH_SSE_H
+#ifndef EIGEN_PACKET_MATH_MSA_H
+#define EIGEN_PACKET_MATH_MSA_H
+
+#include <iostream>
+#include <string>
 
 namespace Eigen {
 
 namespace internal {
 
 #ifndef EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD
 #define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD 8
 #endif
 
-#ifndef EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS
-#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS (2*sizeof(void*))
-#endif
-
-#ifdef __FMA__
 #ifndef EIGEN_HAS_SINGLE_INSTRUCTION_MADD
-#define EIGEN_HAS_SINGLE_INSTRUCTION_MADD 1
+#define EIGEN_HAS_SINGLE_INSTRUCTION_MADD
 #endif
+
+#ifndef EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS
+#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS 32
 #endif
 
-#if ((defined EIGEN_VECTORIZE_AVX) && (EIGEN_COMP_GNUC_STRICT || EIGEN_COMP_MINGW) && (__GXX_ABI_VERSION < 1004)) || EIGEN_OS_QNX
-// With GCC's default ABI version, a __m128 or __m256 are the same types and therefore we cannot
-// have overloads for both types without linking error.
-// One solution is to increase ABI version using -fabi-version=4 (or greater).
-// Otherwise, we workaround this inconvenience by wrapping 128bit types into the following helper
-// structure:
-template<typename T>
-struct eigen_packet_wrapper
-{
-  EIGEN_ALWAYS_INLINE operator T&() { return m_val; }
-  EIGEN_ALWAYS_INLINE operator const T&() const { return m_val; }
-  EIGEN_ALWAYS_INLINE eigen_packet_wrapper() {}
-  EIGEN_ALWAYS_INLINE eigen_packet_wrapper(const T &v) : m_val(v) {}
-  EIGEN_ALWAYS_INLINE eigen_packet_wrapper& operator=(const T &v) {
-    m_val = v;
-    return *this;
-  }
-  
-  T m_val;
-};
-typedef eigen_packet_wrapper<__m128>  Packet4f;
-typedef eigen_packet_wrapper<__m128i> Packet4i;
-typedef eigen_packet_wrapper<__m128d> Packet2d;
+#if 0
+#define EIGEN_MSA_DEBUG                                                             \
+  static bool firstTime = true;                                                     \
+  do {                                                                              \
+    if (firstTime) {                                                                \
+      std::cout << __FILE__ << ':' << __LINE__ << ':' << __FUNCTION__ << std::endl; \
+      firstTime = false;                                                            \
+    }                                                                               \
+  } while (0)
 #else
-typedef __m128  Packet4f;
-typedef __m128i Packet4i;
-typedef __m128d Packet2d;
+#define EIGEN_MSA_DEBUG
 #endif
 
-template<> struct is_arithmetic<__m128>  { enum { value = true }; };
-template<> struct is_arithmetic<__m128i> { enum { value = true }; };
-template<> struct is_arithmetic<__m128d> { enum { value = true }; };
-
-#define vec4f_swizzle1(v,p,q,r,s) \
-  (_mm_castsi128_ps(_mm_shuffle_epi32( _mm_castps_si128(v), ((s)<<6|(r)<<4|(q)<<2|(p)))))
-
-#define vec4i_swizzle1(v,p,q,r,s) \
-  (_mm_shuffle_epi32( v, ((s)<<6|(r)<<4|(q)<<2|(p))))
-
-#define vec2d_swizzle1(v,p,q) \
-  (_mm_castsi128_pd(_mm_shuffle_epi32( _mm_castpd_si128(v), ((q*2+1)<<6|(q*2)<<4|(p*2+1)<<2|(p*2)))))
-  
-#define vec4f_swizzle2(a,b,p,q,r,s) \
-  (_mm_shuffle_ps( (a), (b), ((s)<<6|(r)<<4|(q)<<2|(p))))
+#define EIGEN_MSA_SHF_I8(a, b, c, d) (((d) << 6) | ((c) << 4) | ((b) << 2) | (a))
 
-#define vec4i_swizzle2(a,b,p,q,r,s) \
-  (_mm_castps_si128( (_mm_shuffle_ps( _mm_castsi128_ps(a), _mm_castsi128_ps(b), ((s)<<6|(r)<<4|(q)<<2|(p))))))
+typedef v4f32 Packet4f;
+typedef v4i32 Packet4i;
+typedef v4u32 Packet4ui;
 
-#define _EIGEN_DECLARE_CONST_Packet4f(NAME,X) \
-  const Packet4f p4f_##NAME = pset1<Packet4f>(X)
+#define _EIGEN_DECLARE_CONST_Packet4f(NAME, X) const Packet4f p4f_##NAME = { X, X, X, X }
+#define _EIGEN_DECLARE_CONST_Packet4i(NAME, X) const Packet4i p4i_##NAME = { X, X, X, X }
+#define _EIGEN_DECLARE_CONST_Packet4ui(NAME, X) const Packet4ui p4ui_##NAME = { X, X, X, X }
 
-#define _EIGEN_DECLARE_CONST_Packet2d(NAME,X) \
-  const Packet2d p2d_##NAME = pset1<Packet2d>(X)
-
-#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(NAME,X) \
-  const Packet4f p4f_##NAME = _mm_castsi128_ps(pset1<Packet4i>(X))
+inline std::ostream& operator<<(std::ostream& os, const Packet4f& value) {
+  os << "[ " << value[0] << ", " << value[1] << ", " << value[2] << ", " << value[3] << " ]";
+  return os;
+}
 
-#define _EIGEN_DECLARE_CONST_Packet4i(NAME,X) \
-  const Packet4i p4i_##NAME = pset1<Packet4i>(X)
+inline std::ostream& operator<<(std::ostream& os, const Packet4i& value) {
+  os << "[ " << value[0] << ", " << value[1] << ", " << value[2] << ", " << value[3] << " ]";
+  return os;
+}
 
+inline std::ostream& operator<<(std::ostream& os, const Packet4ui& value) {
+  os << "[ " << value[0] << ", " << value[1] << ", " << value[2] << ", " << value[3] << " ]";
+  return os;
+}
 
-// Use the packet_traits defined in AVX/PacketMath.h instead if we're going
-// to leverage AVX instructions.
-#ifndef EIGEN_VECTORIZE_AVX
-template<> struct packet_traits<float>  : default_packet_traits
-{
+template <>
+struct packet_traits<float> : default_packet_traits {
   typedef Packet4f type;
-  typedef Packet4f half;
+  typedef Packet4f half;  // Packet2f intrinsics not implemented yet
   enum {
     Vectorizable = 1,
     AlignedOnScalar = 1,
-    size=4,
-    HasHalfPacket = 0,
-
-    HasDiv  = 1,
-    HasSin  = EIGEN_FAST_MATH,
-    HasCos  = EIGEN_FAST_MATH,
-    HasLog  = 1,
-    HasExp  = 1,
+    size = 4,
+    HasHalfPacket = 0,  // Packet2f intrinsics not implemented yet
+    // FIXME check the Has*
+    HasDiv = 1,
+    HasSin = EIGEN_FAST_MATH,
+    HasCos = EIGEN_FAST_MATH,
+    HasTanh = EIGEN_FAST_MATH,
+    HasErf = EIGEN_FAST_MATH,
+    HasLog = 1,
+    HasExp = 1,
     HasSqrt = 1,
     HasRsqrt = 1,
-    HasTanh  = EIGEN_FAST_MATH,
-    HasBlend = 1
-
-#ifdef EIGEN_VECTORIZE_SSE4_1
-    ,
     HasRound = 1,
     HasFloor = 1,
-    HasCeil = 1
-#endif
-  };
-};
-template<> struct packet_traits<double> : default_packet_traits
-{
-  typedef Packet2d type;
-  typedef Packet2d half;
-  enum {
-    Vectorizable = 1,
-    AlignedOnScalar = 1,
-    size=2,
-    HasHalfPacket = 0,
-
-    HasDiv  = 1,
-    HasExp  = 1,
-    HasSqrt = 1,
-    HasRsqrt = 1,
+    HasCeil = 1,
     HasBlend = 1
-
-#ifdef EIGEN_VECTORIZE_SSE4_1
-    ,
-    HasRound = 1,
-    HasFloor = 1,
-    HasCeil = 1
-#endif
   };
 };
-#endif
-template<> struct packet_traits<int>    : default_packet_traits
-{
+
+template <>
+struct packet_traits<int32_t> : default_packet_traits {
   typedef Packet4i type;
-  typedef Packet4i half;
+  typedef Packet4i half;  // Packet2i intrinsics not implemented yet
   enum {
     Vectorizable = 1,
     AlignedOnScalar = 1,
-    size=4,
-
+    size = 4,
+    HasHalfPacket = 0,  // Packet2i intrinsics not implemented yet
+    // FIXME check the Has*
+    HasDiv = 1,
     HasBlend = 1
   };
 };
 
-template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4, alignment=Aligned16}; typedef Packet4f half; };
-template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2, alignment=Aligned16}; typedef Packet2d half; };
-template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4, alignment=Aligned16}; typedef Packet4i half; };
-
-#ifndef EIGEN_VECTORIZE_AVX
-template<> struct scalar_div_cost<float,true> { enum { value = 7 }; };
-template<> struct scalar_div_cost<double,true> { enum { value = 8 }; };
-#endif
-
-#if EIGEN_COMP_MSVC==1500
-// Workaround MSVC 9 internal compiler error.
-// TODO: It has been detected with win64 builds (amd64), so let's check whether it also happens in 32bits+SSE mode
-// TODO: let's check whether there does not exist a better fix, like adding a pset0() function. (it crashed on pset1(0)).
-template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }
-template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }
-template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }
-#else
-template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps1(from); }
-template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }
-template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }
-#endif
-
-// GCC generates a shufps instruction for _mm_set1_ps/_mm_load1_ps instead of the more efficient pshufd instruction.
-// However, using inrinsics for pset1 makes gcc to generate crappy code in some cases (see bug 203)
-// Using inline assembly is also not an option because then gcc fails to reorder properly the instructions.
-// Therefore, we introduced the pload1 functions to be used in product kernels for which bug 203 does not apply.
-// Also note that with AVX, we want it to generate a vbroadcastss.
-#if EIGEN_COMP_GNUC_STRICT && (!defined __AVX__)
-template<> EIGEN_STRONG_INLINE Packet4f pload1<Packet4f>(const float *from) {
-  return vec4f_swizzle1(_mm_load_ss(from),0,0,0,0);
-}
-#endif
-  
-template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }
-template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }
-template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }
-
-template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }
-
-template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }
-
-template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)
-{
-  const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x80000000,0x80000000,0x80000000));
-  return _mm_xor_ps(a,mask);
-}
-template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)
-{
-  const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0x0,0x80000000,0x0,0x80000000));
-  return _mm_xor_pd(a,mask);
-}
-template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)
-{
-  return psub(Packet4i(_mm_setr_epi32(0,0,0,0)), a);
-}
-
-template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }
-template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }
-template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }
-
-template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_mullo_epi32(a,b);
-#else
-  // this version is slightly faster than 4 scalar products
-  return vec4i_swizzle1(
-            vec4i_swizzle2(
-              _mm_mul_epu32(a,b),
-              _mm_mul_epu32(vec4i_swizzle1(a,1,0,3,2),
-                            vec4i_swizzle1(b,1,0,3,2)),
-              0,2,0,2),
-            0,2,1,3);
-#endif
+template <>
+struct unpacket_traits<Packet4f> {
+  typedef float type;
+  enum { size = 4, alignment = Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false };
+  typedef Packet4f half;
+};
+
+template <>
+struct unpacket_traits<Packet4i> {
+  typedef int32_t type;
+  enum { size = 4, alignment = Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false };
+  typedef Packet4i half;
+};
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float& from) {
+  EIGEN_MSA_DEBUG;
+
+  Packet4f v = { from, from, from, from };
+  return v;
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }
-
-// for some weird raisons, it has to be overloaded for packet of integers
-template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }
-#ifdef __FMA__
-template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return _mm_fmadd_ps(a,b,c); }
-template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return _mm_fmadd_pd(a,b,c); }
-#endif
-
-template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_min_epi32(a,b);
-#else
-  // after some bench, this version *is* faster than a scalar implementation
-  Packet4i mask = _mm_cmplt_epi32(a,b);
-  return _mm_or_si128(_mm_and_si128(mask,a),_mm_andnot_si128(mask,b));
-#endif
+template <>
+EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int32_t& from) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fill_w(from);
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_max_epi32(a,b);
-#else
-  // after some bench, this version *is* faster than a scalar implementation
-  Packet4i mask = _mm_cmpgt_epi32(a,b);
-  return _mm_or_si128(_mm_and_si128(mask,a),_mm_andnot_si128(mask,b));
-#endif
+template <>
+EIGEN_STRONG_INLINE Packet4f pload1<Packet4f>(const float* from) {
+  EIGEN_MSA_DEBUG;
+
+  float f = *from;
+  Packet4f v = { f, f, f, f };
+  return v;
 }
 
-#ifdef EIGEN_VECTORIZE_SSE4_1
-template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a) { return _mm_round_ps(a, 0); }
-template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) { return _mm_round_pd(a, 0); }
-
-template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const Packet4f& a) { return _mm_ceil_ps(a); }
-template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const Packet2d& a) { return _mm_ceil_pd(a); }
-
-template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a) { return _mm_floor_ps(a); }
-template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return _mm_floor_pd(a); }
-#endif
-
-template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }
-
-template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }
-
-template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }
-
-template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }
-template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }
-template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }
-
-template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }
-template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }
-template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const __m128i*>(from)); }
-
-#if EIGEN_COMP_MSVC
-  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {
-    EIGEN_DEBUG_UNALIGNED_LOAD
-    #if (EIGEN_COMP_MSVC==1600)
-    // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps
-    // (i.e., it does not generate an unaligned load!!
-    __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));
-    res = _mm_loadh_pi(res, (const __m64*)(from+2));
-    return res;
-    #else
-    return _mm_loadu_ps(from);
-    #endif
-  }
-#else
-// NOTE: with the code below, MSVC's compiler crashes!
+template <>
+EIGEN_STRONG_INLINE Packet4i pload1<Packet4i>(const int32_t* from) {
+  EIGEN_MSA_DEBUG;
 
-template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)
-{
-  EIGEN_DEBUG_UNALIGNED_LOAD
-  return _mm_loadu_ps(from);
+  return __builtin_msa_fill_w(*from);
 }
-#endif
 
-template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)
-{
-  EIGEN_DEBUG_UNALIGNED_LOAD
-  return _mm_loadu_pd(from);
+template <>
+EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fadd_w(a, b);
 }
-template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)
-{
-  EIGEN_DEBUG_UNALIGNED_LOAD
-  return _mm_loadu_si128(reinterpret_cast<const __m128i*>(from));
+
+template <>
+EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_addv_w(a, b);
 }
 
+template <>
+EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a) {
+  EIGEN_MSA_DEBUG;
 
-template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)
-{
-  return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);
+  static const Packet4f countdown = { 0.0f, 1.0f, 2.0f, 3.0f };
+  return padd(pset1<Packet4f>(a), countdown);
 }
-template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)
-{ return pset1<Packet2d>(from[0]); }
-template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)
-{
-  Packet4i tmp;
-  tmp = _mm_loadl_epi64(reinterpret_cast<const __m128i*>(from));
-  return vec4i_swizzle1(tmp, 0, 0, 1, 1);
+
+template <>
+EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int32_t& a) {
+  EIGEN_MSA_DEBUG;
+
+  static const Packet4i countdown = { 0, 1, 2, 3 };
+  return padd(pset1<Packet4i>(a), countdown);
 }
 
-template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }
-template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }
-template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<__m128i*>(to), from); }
+template <>
+EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
 
-template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_pd(to, from); }
-template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_ps(to, from); }
-template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_si128(reinterpret_cast<__m128i*>(to), from); }
+  return __builtin_msa_fsub_w(a, b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
 
-template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)
-{
- return _mm_set_ps(from[3*stride], from[2*stride], from[1*stride], from[0*stride]);
+  return __builtin_msa_subv_w(a, b);
 }
-template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)
-{
- return _mm_set_pd(from[1*stride], from[0*stride]);
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4f)__builtin_msa_bnegi_w((v4u32)a, 31);
 }
-template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)
-{
- return _mm_set_epi32(from[3*stride], from[2*stride], from[1*stride], from[0*stride]);
- }
 
-template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)
-{
-  to[stride*0] = _mm_cvtss_f32(from);
-  to[stride*1] = _mm_cvtss_f32(_mm_shuffle_ps(from, from, 1));
-  to[stride*2] = _mm_cvtss_f32(_mm_shuffle_ps(from, from, 2));
-  to[stride*3] = _mm_cvtss_f32(_mm_shuffle_ps(from, from, 3));
+template <>
+EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_addvi_w((v4i32)__builtin_msa_nori_b((v16u8)a, 0), 1);
 }
-template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)
-{
-  to[stride*0] = _mm_cvtsd_f64(from);
-  to[stride*1] = _mm_cvtsd_f64(_mm_shuffle_pd(from, from, 1));
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  return a;
 }
-template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)
-{
-  to[stride*0] = _mm_cvtsi128_si32(from);
-  to[stride*1] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 1));
-  to[stride*2] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 2));
-  to[stride*3] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 3));
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  return a;
 }
 
-// some compilers might be tempted to perform multiple moves instead of using a vector path.
-template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)
-{
-  Packet4f pa = _mm_set_ss(a);
-  pstore(to, Packet4f(vec4f_swizzle1(pa,0,0,0,0)));
+template <>
+EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fmul_w(a, b);
 }
-// some compilers might be tempted to perform multiple moves instead of using a vector path.
-template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)
-{
-  Packet2d pa = _mm_set_sd(a);
-  pstore(to, Packet2d(vec2d_swizzle1(pa,0,0)));
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_mulv_w(a, b);
 }
 
-#if EIGEN_COMP_PGI
-typedef const void * SsePrefetchPtrType;
+template <>
+EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fdiv_w(a, b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_div_s_w(a, b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fmadd_w(c, a, b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) {
+  EIGEN_MSA_DEBUG;
+
+  // Use "asm" construct to avoid __builtin_msa_maddv_w GNU C bug.
+  Packet4i value = c;
+  __asm__("maddv.w %w[value], %w[a], %w[b]\n"
+          // Outputs
+          : [value] "+f"(value)
+          // Inputs
+          : [a] "f"(a), [b] "f"(b));
+  return value;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4f)__builtin_msa_and_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4i)__builtin_msa_and_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4f)__builtin_msa_or_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4i)__builtin_msa_or_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4f)__builtin_msa_xor_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4i)__builtin_msa_xor_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+  return pand(a, (Packet4f)__builtin_msa_xori_b((v16u8)b, 255));
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return pand(a, (Packet4i)__builtin_msa_xori_b((v16u8)b, 255));
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+#if EIGEN_FAST_MATH
+  // This prefers numbers to NaNs.
+  return __builtin_msa_fmin_w(a, b);
 #else
-typedef const char * SsePrefetchPtrType;
+  // This prefers NaNs to numbers.
+  Packet4i aNaN = __builtin_msa_fcun_w(a, a);
+  Packet4i aMinOrNaN = por(__builtin_msa_fclt_w(a, b), aNaN);
+  return (Packet4f)__builtin_msa_bsel_v((v16u8)aMinOrNaN, (v16u8)b, (v16u8)a);
 #endif
+}
 
-#ifndef EIGEN_VECTORIZE_AVX
-template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }
-template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }
-template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }
-#endif
-
-#if EIGEN_COMP_MSVC_STRICT && EIGEN_OS_WIN64
-// The temporary variable fixes an internal compilation error in vs <= 2008 and a wrong-result bug in vs 2010
-// Direct of the struct members fixed bug #62.
-template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }
-template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }
-template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }
-#elif EIGEN_COMP_MSVC_STRICT
-// The temporary variable fixes an internal compilation error in vs <= 2008 and a wrong-result bug in vs 2010
-template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }
-template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }
-template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }
-#else
-template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }
-template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }
-template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }
-#endif
-
-template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)
-{ return _mm_shuffle_ps(a,a,0x1B); }
-template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)
-{ return _mm_shuffle_pd(a,a,0x1); }
-template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)
-{ return _mm_shuffle_epi32(a,0x1B); }
-
-template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)
-{
-  const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF));
-  return _mm_and_ps(a,mask);
-}
-template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)
-{
-  const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0x7FFFFFFF));
-  return _mm_and_pd(a,mask);
-}
-template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)
-{
-  #ifdef EIGEN_VECTORIZE_SSSE3
-  return _mm_abs_epi32(a);
-  #else
-  Packet4i aux = _mm_srai_epi32(a,31);
-  return _mm_sub_epi32(_mm_xor_si128(a,aux),aux);
-  #endif
-}
-
-// with AVX, the default implementations based on pload1 are faster
-#ifndef __AVX__
-template<> EIGEN_STRONG_INLINE void
-pbroadcast4<Packet4f>(const float *a,
-                      Packet4f& a0, Packet4f& a1, Packet4f& a2, Packet4f& a3)
-{
-  a3 = pload<Packet4f>(a);
-  a0 = vec4f_swizzle1(a3, 0,0,0,0);
-  a1 = vec4f_swizzle1(a3, 1,1,1,1);
-  a2 = vec4f_swizzle1(a3, 2,2,2,2);
-  a3 = vec4f_swizzle1(a3, 3,3,3,3);
-}
-template<> EIGEN_STRONG_INLINE void
-pbroadcast4<Packet2d>(const double *a,
-                      Packet2d& a0, Packet2d& a1, Packet2d& a2, Packet2d& a3)
-{
-#ifdef EIGEN_VECTORIZE_SSE3
-  a0 = _mm_loaddup_pd(a+0);
-  a1 = _mm_loaddup_pd(a+1);
-  a2 = _mm_loaddup_pd(a+2);
-  a3 = _mm_loaddup_pd(a+3);
+template <>
+EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_min_s_w(a, b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) {
+  EIGEN_MSA_DEBUG;
+
+#if EIGEN_FAST_MATH
+  // This prefers numbers to NaNs.
+  return __builtin_msa_fmax_w(a, b);
 #else
-  a1 = pload<Packet2d>(a);
-  a0 = vec2d_swizzle1(a1, 0,0);
-  a1 = vec2d_swizzle1(a1, 1,1);
-  a3 = pload<Packet2d>(a+2);
-  a2 = vec2d_swizzle1(a3, 0,0);
-  a3 = vec2d_swizzle1(a3, 1,1);
+  // This prefers NaNs to numbers.
+  Packet4i aNaN = __builtin_msa_fcun_w(a, a);
+  Packet4i aMaxOrNaN = por(__builtin_msa_fclt_w(b, a), aNaN);
+  return (Packet4f)__builtin_msa_bsel_v((v16u8)aMaxOrNaN, (v16u8)b, (v16u8)a);
 #endif
 }
-#endif
 
-EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)
-{
-  vecs[1] = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(vecs[0]), 0x55));
-  vecs[2] = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(vecs[0]), 0xAA));
-  vecs[3] = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(vecs[0]), 0xFF));
-  vecs[0] = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(vecs[0]), 0x00));
+template <>
+EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_max_s_w(a, b);
 }
 
-#ifdef EIGEN_VECTORIZE_SSE3
-template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)
-{
-  return _mm_hadd_ps(_mm_hadd_ps(vecs[0], vecs[1]),_mm_hadd_ps(vecs[2], vecs[3]));
+template <>
+EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_ALIGNED_LOAD return (Packet4f)__builtin_msa_ld_w(const_cast<float*>(from), 0);
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)
-{
-  return _mm_hadd_pd(vecs[0], vecs[1]);
+template <>
+EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int32_t* from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_ALIGNED_LOAD return __builtin_msa_ld_w(const_cast<int32_t*>(from), 0);
 }
 
-#else
-template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)
-{
-  Packet4f tmp0, tmp1, tmp2;
-  tmp0 = _mm_unpacklo_ps(vecs[0], vecs[1]);
-  tmp1 = _mm_unpackhi_ps(vecs[0], vecs[1]);
-  tmp2 = _mm_unpackhi_ps(vecs[2], vecs[3]);
-  tmp0 = _mm_add_ps(tmp0, tmp1);
-  tmp1 = _mm_unpacklo_ps(vecs[2], vecs[3]);
-  tmp1 = _mm_add_ps(tmp1, tmp2);
-  tmp2 = _mm_movehl_ps(tmp1, tmp0);
-  tmp0 = _mm_movelh_ps(tmp0, tmp1);
-  return _mm_add_ps(tmp0, tmp2);
-}
-
-template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)
-{
-  return _mm_add_pd(_mm_unpacklo_pd(vecs[0], vecs[1]), _mm_unpackhi_pd(vecs[0], vecs[1]));
-}
-#endif  // SSE3
-
-template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)
-{
-  // Disable SSE3 _mm_hadd_pd that is extremely slow on all existing Intel's architectures
-  // (from Nehalem to Haswell)
-// #ifdef EIGEN_VECTORIZE_SSE3
-//   Packet4f tmp = _mm_add_ps(a, vec4f_swizzle1(a,2,3,2,3));
-//   return pfirst<Packet4f>(_mm_hadd_ps(tmp, tmp));
-// #else
-  Packet4f tmp = _mm_add_ps(a, _mm_movehl_ps(a,a));
-  return pfirst<Packet4f>(_mm_add_ss(tmp, _mm_shuffle_ps(tmp,tmp, 1)));
-// #endif
-}
-
-template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)
-{
-  // Disable SSE3 _mm_hadd_pd that is extremely slow on all existing Intel's architectures
-  // (from Nehalem to Haswell)
-// #ifdef EIGEN_VECTORIZE_SSE3
-//   return pfirst<Packet2d>(_mm_hadd_pd(a, a));
-// #else
-  return pfirst<Packet2d>(_mm_add_sd(a, _mm_unpackhi_pd(a,a)));
-// #endif
-}
-
-#ifdef EIGEN_VECTORIZE_SSSE3
-template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)
-{
-  return _mm_hadd_epi32(_mm_hadd_epi32(vecs[0], vecs[1]),_mm_hadd_epi32(vecs[2], vecs[3]));
-}
-template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)
-{
-  Packet4i tmp0 = _mm_hadd_epi32(a,a);
-  return pfirst<Packet4i>(_mm_hadd_epi32(tmp0,tmp0));
+template <>
+EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_UNALIGNED_LOAD return (Packet4f)__builtin_msa_ld_w(const_cast<float*>(from), 0);
 }
-#else
-template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)
-{
-  Packet4i tmp = _mm_add_epi32(a, _mm_unpackhi_epi64(a,a));
-  return pfirst(tmp) + pfirst<Packet4i>(_mm_shuffle_epi32(tmp, 1));
-}
-
-template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)
-{
-  Packet4i tmp0, tmp1, tmp2;
-  tmp0 = _mm_unpacklo_epi32(vecs[0], vecs[1]);
-  tmp1 = _mm_unpackhi_epi32(vecs[0], vecs[1]);
-  tmp2 = _mm_unpackhi_epi32(vecs[2], vecs[3]);
-  tmp0 = _mm_add_epi32(tmp0, tmp1);
-  tmp1 = _mm_unpacklo_epi32(vecs[2], vecs[3]);
-  tmp1 = _mm_add_epi32(tmp1, tmp2);
-  tmp2 = _mm_unpacklo_epi64(tmp0, tmp1);
-  tmp0 = _mm_unpackhi_epi64(tmp0, tmp1);
-  return _mm_add_epi32(tmp0, tmp2);
+
+template <>
+EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int32_t* from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_UNALIGNED_LOAD return (Packet4i)__builtin_msa_ld_w(const_cast<int32_t*>(from), 0);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float* from) {
+  EIGEN_MSA_DEBUG;
+
+  float f0 = from[0], f1 = from[1];
+  Packet4f v0 = { f0, f0, f0, f0 };
+  Packet4f v1 = { f1, f1, f1, f1 };
+  return (Packet4f)__builtin_msa_ilvr_d((v2i64)v1, (v2i64)v0);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int32_t* from) {
+  EIGEN_MSA_DEBUG;
+
+  int32_t i0 = from[0], i1 = from[1];
+  Packet4i v0 = { i0, i0, i0, i0 };
+  Packet4i v1 = { i1, i1, i1, i1 };
+  return (Packet4i)__builtin_msa_ilvr_d((v2i64)v1, (v2i64)v0);
+}
+
+template <>
+EIGEN_STRONG_INLINE void pstore<float>(float* to, const Packet4f& from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_ALIGNED_STORE __builtin_msa_st_w((Packet4i)from, to, 0);
+}
+
+template <>
+EIGEN_STRONG_INLINE void pstore<int32_t>(int32_t* to, const Packet4i& from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_ALIGNED_STORE __builtin_msa_st_w(from, to, 0);
+}
+
+template <>
+EIGEN_STRONG_INLINE void pstoreu<float>(float* to, const Packet4f& from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_UNALIGNED_STORE __builtin_msa_st_w((Packet4i)from, to, 0);
+}
+
+template <>
+EIGEN_STRONG_INLINE void pstoreu<int32_t>(int32_t* to, const Packet4i& from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_UNALIGNED_STORE __builtin_msa_st_w(from, to, 0);
+}
+
+template <>
+EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride) {
+  EIGEN_MSA_DEBUG;
+
+  float f = *from;
+  Packet4f v = { f, f, f, f };
+  v[1] = from[stride];
+  v[2] = from[2 * stride];
+  v[3] = from[3 * stride];
+  return v;
 }
-#endif
-// Other reduction functions:
 
+template <>
+EIGEN_DEVICE_FUNC inline Packet4i pgather<int32_t, Packet4i>(const int32_t* from, Index stride) {
+  EIGEN_MSA_DEBUG;
+
+  int32_t i = *from;
+  Packet4i v = { i, i, i, i };
+  v[1] = from[stride];
+  v[2] = from[2 * stride];
+  v[3] = from[3 * stride];
+  return v;
+}
+
+template <>
+EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from,
+                                                        Index stride) {
+  EIGEN_MSA_DEBUG;
+
+  *to = from[0];
+  to += stride;
+  *to = from[1];
+  to += stride;
+  *to = from[2];
+  to += stride;
+  *to = from[3];
+}
+
+template <>
+EIGEN_DEVICE_FUNC inline void pscatter<int32_t, Packet4i>(int32_t* to, const Packet4i& from,
+                                                          Index stride) {
+  EIGEN_MSA_DEBUG;
+
+  *to = from[0];
+  to += stride;
+  *to = from[1];
+  to += stride;
+  *to = from[2];
+  to += stride;
+  *to = from[3];
+}
+
+template <>
+EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) {
+  EIGEN_MSA_DEBUG;
+
+  __builtin_prefetch(addr);
+}
+
+template <>
+EIGEN_STRONG_INLINE void prefetch<int32_t>(const int32_t* addr) {
+  EIGEN_MSA_DEBUG;
+
+  __builtin_prefetch(addr);
+}
+
+template <>
+EIGEN_STRONG_INLINE float pfirst<Packet4f>(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  return a[0];
+}
+
+template <>
+EIGEN_STRONG_INLINE int32_t pfirst<Packet4i>(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  return a[0];
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4f)__builtin_msa_shf_w((v4i32)a, EIGEN_MSA_SHF_I8(3, 2, 1, 0));
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_shf_w(a, EIGEN_MSA_SHF_I8(3, 2, 1, 0));
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet4f)__builtin_msa_bclri_w((v4u32)a, 31);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet4i zero = __builtin_msa_ldi_w(0);
+  return __builtin_msa_add_a_w(zero, a);
+}
+
+template <>
+EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet4f s = padd(a, (Packet4f)__builtin_msa_shf_w((v4i32)a, EIGEN_MSA_SHF_I8(2, 3, 0, 1)));
+  s = padd(s, (Packet4f)__builtin_msa_shf_w((v4i32)s, EIGEN_MSA_SHF_I8(1, 0, 3, 2)));
+  return s[0];
+}
+
+
+template <>
+EIGEN_STRONG_INLINE int32_t predux<Packet4i>(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet4i s = padd(a, __builtin_msa_shf_w(a, EIGEN_MSA_SHF_I8(2, 3, 0, 1)));
+  s = padd(s, __builtin_msa_shf_w(s, EIGEN_MSA_SHF_I8(1, 0, 3, 2)));
+  return s[0];
+}
+
+// Other reduction functions:
 // mul
-template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)
-{
-  Packet4f tmp = _mm_mul_ps(a, _mm_movehl_ps(a,a));
-  return pfirst<Packet4f>(_mm_mul_ss(tmp, _mm_shuffle_ps(tmp,tmp, 1)));
-}
-template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)
-{
-  return pfirst<Packet2d>(_mm_mul_sd(a, _mm_unpackhi_pd(a,a)));
-}
-template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)
-{
-  // after some experiments, it is seems this is the fastest way to implement it
-  // for GCC (eg., reusing pmul is very slow !)
-  // TODO try to call _mm_mul_epu32 directly
-  EIGEN_ALIGN16 int aux[4];
-  pstore(aux, a);
-  return  (aux[0] * aux[1]) * (aux[2] * aux[3]);;
+template <>
+EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet4f p = pmul(a, (Packet4f)__builtin_msa_shf_w((v4i32)a, EIGEN_MSA_SHF_I8(2, 3, 0, 1)));
+  p = pmul(p, (Packet4f)__builtin_msa_shf_w((v4i32)p, EIGEN_MSA_SHF_I8(1, 0, 3, 2)));
+  return p[0];
+}
+
+template <>
+EIGEN_STRONG_INLINE int32_t predux_mul<Packet4i>(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet4i p = pmul(a, __builtin_msa_shf_w(a, EIGEN_MSA_SHF_I8(2, 3, 0, 1)));
+  p = pmul(p, __builtin_msa_shf_w(p, EIGEN_MSA_SHF_I8(1, 0, 3, 2)));
+  return p[0];
 }
 
 // min
-template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)
-{
-  Packet4f tmp = _mm_min_ps(a, _mm_movehl_ps(a,a));
-  return pfirst<Packet4f>(_mm_min_ss(tmp, _mm_shuffle_ps(tmp,tmp, 1)));
-}
-template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)
-{
-  return pfirst<Packet2d>(_mm_min_sd(a, _mm_unpackhi_pd(a,a)));
-}
-template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  Packet4i tmp = _mm_min_epi32(a, _mm_shuffle_epi32(a, _MM_SHUFFLE(0,0,3,2)));
-  return pfirst<Packet4i>(_mm_min_epi32(tmp,_mm_shuffle_epi32(tmp, 1)));
-#else
-  // after some experiments, it is seems this is the fastest way to implement it
-  // for GCC (eg., it does not like using std::min after the pstore !!)
-  EIGEN_ALIGN16 int aux[4];
-  pstore(aux, a);
-  int aux0 = aux[0]<aux[1] ? aux[0] : aux[1];
-  int aux2 = aux[2]<aux[3] ? aux[2] : aux[3];
-  return aux0<aux2 ? aux0 : aux2;
-#endif // EIGEN_VECTORIZE_SSE4_1
+template <>
+EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  // Swap 64-bit halves of a.
+  Packet4f swapped = (Packet4f)__builtin_msa_shf_w((Packet4i)a, EIGEN_MSA_SHF_I8(2, 3, 0, 1));
+#if !EIGEN_FAST_MATH
+  // Detect presence of NaNs from pairs a[0]-a[2] and a[1]-a[3] as two 32-bit
+  // masks of all zeroes/ones in low 64 bits.
+  v16u8 unord = (v16u8)__builtin_msa_fcun_w(a, swapped);
+  // Combine the two masks into one: 64 ones if no NaNs, otherwise 64 zeroes.
+  unord = (v16u8)__builtin_msa_ceqi_d((v2i64)unord, 0);
+#endif
+  // Continue with min computation.
+  Packet4f v = __builtin_msa_fmin_w(a, swapped);
+  v = __builtin_msa_fmin_w(
+      v, (Packet4f)__builtin_msa_shf_w((Packet4i)v, EIGEN_MSA_SHF_I8(1, 0, 3, 2)));
+#if !EIGEN_FAST_MATH
+  // Based on the mask select between v and 4 qNaNs.
+  v16u8 qnans = (v16u8)__builtin_msa_fill_w(0x7FC00000);
+  v = (Packet4f)__builtin_msa_bsel_v(unord, qnans, (v16u8)v);
+#endif
+  return v[0];
+}
+
+template <>
+EIGEN_STRONG_INLINE int32_t predux_min<Packet4i>(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet4i m = pmin(a, __builtin_msa_shf_w(a, EIGEN_MSA_SHF_I8(2, 3, 0, 1)));
+  m = pmin(m, __builtin_msa_shf_w(m, EIGEN_MSA_SHF_I8(1, 0, 3, 2)));
+  return m[0];
 }
 
 // max
-template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)
-{
-  Packet4f tmp = _mm_max_ps(a, _mm_movehl_ps(a,a));
-  return pfirst<Packet4f>(_mm_max_ss(tmp, _mm_shuffle_ps(tmp,tmp, 1)));
-}
-template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)
-{
-  return pfirst<Packet2d>(_mm_max_sd(a, _mm_unpackhi_pd(a,a)));
-}
-template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  Packet4i tmp = _mm_max_epi32(a, _mm_shuffle_epi32(a, _MM_SHUFFLE(0,0,3,2)));
-  return pfirst<Packet4i>(_mm_max_epi32(tmp,_mm_shuffle_epi32(tmp, 1)));
-#else
-  // after some experiments, it is seems this is the fastest way to implement it
-  // for GCC (eg., it does not like using std::min after the pstore !!)
-  EIGEN_ALIGN16 int aux[4];
-  pstore(aux, a);
-  int aux0 = aux[0]>aux[1] ? aux[0] : aux[1];
-  int aux2 = aux[2]>aux[3] ? aux[2] : aux[3];
-  return aux0>aux2 ? aux0 : aux2;
-#endif // EIGEN_VECTORIZE_SSE4_1
-}
-
-#if EIGEN_COMP_GNUC
-// template <> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f&  a, const Packet4f&  b, const Packet4f&  c)
-// {
-//   Packet4f res = b;
-//   asm("mulps %[a], %[b] \n\taddps %[c], %[b]" : [b] "+x" (res) : [a] "x" (a), [c] "x" (c));
-//   return res;
-// }
-// EIGEN_STRONG_INLINE Packet4i _mm_alignr_epi8(const Packet4i&  a, const Packet4i&  b, const int i)
-// {
-//   Packet4i res = a;
-//   asm("palignr %[i], %[a], %[b] " : [b] "+x" (res) : [a] "x" (a), [i] "i" (i));
-//   return res;
-// }
-#endif
-
-#ifdef EIGEN_VECTORIZE_SSSE3
-// SSSE3 versions
-template<int Offset>
-struct palign_impl<Offset,Packet4f>
-{
-  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)
-  {
-    if (Offset!=0)
-      first = _mm_castsi128_ps(_mm_alignr_epi8(_mm_castps_si128(second), _mm_castps_si128(first), Offset*4));
-  }
-};
+template <>
+EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  // Swap 64-bit halves of a.
+  Packet4f swapped = (Packet4f)__builtin_msa_shf_w((Packet4i)a, EIGEN_MSA_SHF_I8(2, 3, 0, 1));
+#if !EIGEN_FAST_MATH
+  // Detect presence of NaNs from pairs a[0]-a[2] and a[1]-a[3] as two 32-bit
+  // masks of all zeroes/ones in low 64 bits.
+  v16u8 unord = (v16u8)__builtin_msa_fcun_w(a, swapped);
+  // Combine the two masks into one: 64 ones if no NaNs, otherwise 64 zeroes.
+  unord = (v16u8)__builtin_msa_ceqi_d((v2i64)unord, 0);
+#endif
+  // Continue with max computation.
+  Packet4f v = __builtin_msa_fmax_w(a, swapped);
+  v = __builtin_msa_fmax_w(
+      v, (Packet4f)__builtin_msa_shf_w((Packet4i)v, EIGEN_MSA_SHF_I8(1, 0, 3, 2)));
+#if !EIGEN_FAST_MATH
+  // Based on the mask select between v and 4 qNaNs.
+  v16u8 qnans = (v16u8)__builtin_msa_fill_w(0x7FC00000);
+  v = (Packet4f)__builtin_msa_bsel_v(unord, qnans, (v16u8)v);
+#endif
+  return v[0];
+}
+
+template <>
+EIGEN_STRONG_INLINE int32_t predux_max<Packet4i>(const Packet4i& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet4i m = pmax(a, __builtin_msa_shf_w(a, EIGEN_MSA_SHF_I8(2, 3, 0, 1)));
+  m = pmax(m, __builtin_msa_shf_w(m, EIGEN_MSA_SHF_I8(1, 0, 3, 2)));
+  return m[0];
+}
+
+inline std::ostream& operator<<(std::ostream& os, const PacketBlock<Packet4f, 4>& value) {
+  os << "[ " << value.packet[0] << "," << std::endl
+     << "  " << value.packet[1] << "," << std::endl
+     << "  " << value.packet[2] << "," << std::endl
+     << "  " << value.packet[3] << " ]";
+  return os;
+}
+
+EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet4f, 4>& kernel) {
+  EIGEN_MSA_DEBUG;
+
+  v4i32 tmp1, tmp2, tmp3, tmp4;
+
+  tmp1 = __builtin_msa_ilvr_w((v4i32)kernel.packet[1], (v4i32)kernel.packet[0]);
+  tmp2 = __builtin_msa_ilvr_w((v4i32)kernel.packet[3], (v4i32)kernel.packet[2]);
+  tmp3 = __builtin_msa_ilvl_w((v4i32)kernel.packet[1], (v4i32)kernel.packet[0]);
+  tmp4 = __builtin_msa_ilvl_w((v4i32)kernel.packet[3], (v4i32)kernel.packet[2]);
+
+  kernel.packet[0] = (Packet4f)__builtin_msa_ilvr_d((v2i64)tmp2, (v2i64)tmp1);
+  kernel.packet[1] = (Packet4f)__builtin_msa_ilvod_d((v2i64)tmp2, (v2i64)tmp1);
+  kernel.packet[2] = (Packet4f)__builtin_msa_ilvr_d((v2i64)tmp4, (v2i64)tmp3);
+  kernel.packet[3] = (Packet4f)__builtin_msa_ilvod_d((v2i64)tmp4, (v2i64)tmp3);
+}
+
+inline std::ostream& operator<<(std::ostream& os, const PacketBlock<Packet4i, 4>& value) {
+  os << "[ " << value.packet[0] << "," << std::endl
+     << "  " << value.packet[1] << "," << std::endl
+     << "  " << value.packet[2] << "," << std::endl
+     << "  " << value.packet[3] << " ]";
+  return os;
+}
+
+EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet4i, 4>& kernel) {
+  EIGEN_MSA_DEBUG;
+
+  v4i32 tmp1, tmp2, tmp3, tmp4;
+
+  tmp1 = __builtin_msa_ilvr_w(kernel.packet[1], kernel.packet[0]);
+  tmp2 = __builtin_msa_ilvr_w(kernel.packet[3], kernel.packet[2]);
+  tmp3 = __builtin_msa_ilvl_w(kernel.packet[1], kernel.packet[0]);
+  tmp4 = __builtin_msa_ilvl_w(kernel.packet[3], kernel.packet[2]);
+
+  kernel.packet[0] = (Packet4i)__builtin_msa_ilvr_d((v2i64)tmp2, (v2i64)tmp1);
+  kernel.packet[1] = (Packet4i)__builtin_msa_ilvod_d((v2i64)tmp2, (v2i64)tmp1);
+  kernel.packet[2] = (Packet4i)__builtin_msa_ilvr_d((v2i64)tmp4, (v2i64)tmp3);
+  kernel.packet[3] = (Packet4i)__builtin_msa_ilvod_d((v2i64)tmp4, (v2i64)tmp3);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f psqrt(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fsqrt_w(a);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f prsqrt(const Packet4f& a) {
+  EIGEN_MSA_DEBUG;
+
+#if EIGEN_FAST_MATH
+  return __builtin_msa_frsqrt_w(a);
+#else
+  Packet4f ones = __builtin_msa_ffint_s_w(__builtin_msa_ldi_w(1));
+  return pdiv(ones, psqrt(a));
+#endif
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a) {
+  Packet4f v = a;
+  int32_t old_mode, new_mode;
+  asm volatile(
+      "cfcmsa  %[old_mode], $1\n"
+      "ori     %[new_mode], %[old_mode], 3\n"  // 3 = round towards -INFINITY.
+      "ctcmsa  $1, %[new_mode]\n"
+      "frint.w %w[v], %w[v]\n"
+      "ctcmsa  $1, %[old_mode]\n"
+      :  // outputs
+      [old_mode] "=r"(old_mode), [new_mode] "=r"(new_mode),
+      [v] "+f"(v)
+      :  // inputs
+      :  // clobbers
+  );
+  return v;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const Packet4f& a) {
+  Packet4f v = a;
+  int32_t old_mode, new_mode;
+  asm volatile(
+      "cfcmsa  %[old_mode], $1\n"
+      "ori     %[new_mode], %[old_mode], 3\n"
+      "xori    %[new_mode], %[new_mode], 1\n"  // 2 = round towards +INFINITY.
+      "ctcmsa  $1, %[new_mode]\n"
+      "frint.w %w[v], %w[v]\n"
+      "ctcmsa  $1, %[old_mode]\n"
+      :  // outputs
+      [old_mode] "=r"(old_mode), [new_mode] "=r"(new_mode),
+      [v] "+f"(v)
+      :  // inputs
+      :  // clobbers
+  );
+  return v;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a) {
+  Packet4f v = a;
+  int32_t old_mode, new_mode;
+  asm volatile(
+      "cfcmsa  %[old_mode], $1\n"
+      "ori     %[new_mode], %[old_mode], 3\n"
+      "xori    %[new_mode], %[new_mode], 3\n"  // 0 = round to nearest, ties to even.
+      "ctcmsa  $1, %[new_mode]\n"
+      "frint.w %w[v], %w[v]\n"
+      "ctcmsa  $1, %[old_mode]\n"
+      :  // outputs
+      [old_mode] "=r"(old_mode), [new_mode] "=r"(new_mode),
+      [v] "+f"(v)
+      :  // inputs
+      :  // clobbers
+  );
+  return v;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket,
+                                    const Packet4f& elsePacket) {
+  Packet4ui select = { ifPacket.select[0], ifPacket.select[1], ifPacket.select[2],
+                       ifPacket.select[3] };
+  Packet4i mask = __builtin_msa_ceqi_w((Packet4i)select, 0);
+  return (Packet4f)__builtin_msa_bsel_v((v16u8)mask, (v16u8)thenPacket, (v16u8)elsePacket);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket,
+                                    const Packet4i& elsePacket) {
+  Packet4ui select = { ifPacket.select[0], ifPacket.select[1], ifPacket.select[2],
+                       ifPacket.select[3] };
+  Packet4i mask = __builtin_msa_ceqi_w((Packet4i)select, 0);
+  return (Packet4i)__builtin_msa_bsel_v((v16u8)mask, (v16u8)thenPacket, (v16u8)elsePacket);
+}
+
+//---------- double ----------
+
+typedef v2f64 Packet2d;
+typedef v2i64 Packet2l;
+typedef v2u64 Packet2ul;
+
+#define _EIGEN_DECLARE_CONST_Packet2d(NAME, X) const Packet2d p2d_##NAME = { X, X }
+#define _EIGEN_DECLARE_CONST_Packet2l(NAME, X) const Packet2l p2l_##NAME = { X, X }
+#define _EIGEN_DECLARE_CONST_Packet2ul(NAME, X) const Packet2ul p2ul_##NAME = { X, X }
+
+inline std::ostream& operator<<(std::ostream& os, const Packet2d& value) {
+  os << "[ " << value[0] << ", " << value[1] << " ]";
+  return os;
+}
+
+inline std::ostream& operator<<(std::ostream& os, const Packet2l& value) {
+  os << "[ " << value[0] << ", " << value[1] << " ]";
+  return os;
+}
+
+inline std::ostream& operator<<(std::ostream& os, const Packet2ul& value) {
+  os << "[ " << value[0] << ", " << value[1] << " ]";
+  return os;
+}
 
-template<int Offset>
-struct palign_impl<Offset,Packet4i>
-{
-  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)
-  {
-    if (Offset!=0)
-      first = _mm_alignr_epi8(second,first, Offset*4);
-  }
+template <>
+struct packet_traits<double> : default_packet_traits {
+  typedef Packet2d type;
+  typedef Packet2d half;
+  enum {
+    Vectorizable = 1,
+    AlignedOnScalar = 1,
+    size = 2,
+    HasHalfPacket = 0,
+    // FIXME check the Has*
+    HasDiv = 1,
+    HasExp = 1,
+    HasSqrt = 1,
+    HasRsqrt = 1,
+    HasRound = 1,
+    HasFloor = 1,
+    HasCeil = 1,
+    HasBlend = 1
+  };
 };
 
-template<int Offset>
-struct palign_impl<Offset,Packet2d>
-{
-  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)
-  {
-    if (Offset==1)
-      first = _mm_castsi128_pd(_mm_alignr_epi8(_mm_castpd_si128(second), _mm_castpd_si128(first), 8));
-  }
-};
-#else
-// SSE2 versions
-template<int Offset>
-struct palign_impl<Offset,Packet4f>
-{
-  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)
-  {
-    if (Offset==1)
-    {
-      first = _mm_move_ss(first,second);
-      first = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(first),0x39));
-    }
-    else if (Offset==2)
-    {
-      first = _mm_movehl_ps(first,first);
-      first = _mm_movelh_ps(first,second);
-    }
-    else if (Offset==3)
-    {
-      first = _mm_move_ss(first,second);
-      first = _mm_shuffle_ps(first,second,0x93);
-    }
-  }
+template <>
+struct unpacket_traits<Packet2d> {
+  typedef double type;
+  enum { size = 2, alignment = Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false };
+  typedef Packet2d half;
 };
 
-template<int Offset>
-struct palign_impl<Offset,Packet4i>
-{
-  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)
-  {
-    if (Offset==1)
-    {
-      first = _mm_castps_si128(_mm_move_ss(_mm_castsi128_ps(first),_mm_castsi128_ps(second)));
-      first = _mm_shuffle_epi32(first,0x39);
-    }
-    else if (Offset==2)
-    {
-      first = _mm_castps_si128(_mm_movehl_ps(_mm_castsi128_ps(first),_mm_castsi128_ps(first)));
-      first = _mm_castps_si128(_mm_movelh_ps(_mm_castsi128_ps(first),_mm_castsi128_ps(second)));
-    }
-    else if (Offset==3)
-    {
-      first = _mm_castps_si128(_mm_move_ss(_mm_castsi128_ps(first),_mm_castsi128_ps(second)));
-      first = _mm_castps_si128(_mm_shuffle_ps(_mm_castsi128_ps(first),_mm_castsi128_ps(second),0x93));
-    }
-  }
-};
+template <>
+EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) {
+  EIGEN_MSA_DEBUG;
 
-template<int Offset>
-struct palign_impl<Offset,Packet2d>
-{
-  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)
-  {
-    if (Offset==1)
-    {
-      first = _mm_castps_pd(_mm_movehl_ps(_mm_castpd_ps(first),_mm_castpd_ps(first)));
-      first = _mm_castps_pd(_mm_movelh_ps(_mm_castpd_ps(first),_mm_castpd_ps(second)));
-    }
-  }
-};
-#endif
+  Packet2d value = { from, from };
+  return value;
+}
 
-EIGEN_DEVICE_FUNC inline void
-ptranspose(PacketBlock<Packet4f,4>& kernel) {
-  _MM_TRANSPOSE4_PS(kernel.packet[0], kernel.packet[1], kernel.packet[2], kernel.packet[3]);
-}
-
-EIGEN_DEVICE_FUNC inline void
-ptranspose(PacketBlock<Packet2d,2>& kernel) {
-  __m128d tmp = _mm_unpackhi_pd(kernel.packet[0], kernel.packet[1]);
-  kernel.packet[0] = _mm_unpacklo_pd(kernel.packet[0], kernel.packet[1]);
-  kernel.packet[1] = tmp;
-}
-
-EIGEN_DEVICE_FUNC inline void
-ptranspose(PacketBlock<Packet4i,4>& kernel) {
-  __m128i T0 = _mm_unpacklo_epi32(kernel.packet[0], kernel.packet[1]);
-  __m128i T1 = _mm_unpacklo_epi32(kernel.packet[2], kernel.packet[3]);
-  __m128i T2 = _mm_unpackhi_epi32(kernel.packet[0], kernel.packet[1]);
-  __m128i T3 = _mm_unpackhi_epi32(kernel.packet[2], kernel.packet[3]);
-
-  kernel.packet[0] = _mm_unpacklo_epi64(T0, T1);
-  kernel.packet[1] = _mm_unpackhi_epi64(T0, T1);
-  kernel.packet[2] = _mm_unpacklo_epi64(T2, T3);
-  kernel.packet[3] = _mm_unpackhi_epi64(T2, T3);
-}
-
-template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {
-  const __m128i zero = _mm_setzero_si128();
-  const __m128i select = _mm_set_epi32(ifPacket.select[3], ifPacket.select[2], ifPacket.select[1], ifPacket.select[0]);
-  __m128i false_mask = _mm_cmpeq_epi32(select, zero);
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_blendv_epi8(thenPacket, elsePacket, false_mask);
-#else
-  return _mm_or_si128(_mm_andnot_si128(false_mask, thenPacket), _mm_and_si128(false_mask, elsePacket));
-#endif
+template <>
+EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fadd_d(a, b);
 }
-template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {
-  const __m128 zero = _mm_setzero_ps();
-  const __m128 select = _mm_set_ps(ifPacket.select[3], ifPacket.select[2], ifPacket.select[1], ifPacket.select[0]);
-  __m128 false_mask = _mm_cmpeq_ps(select, zero);
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_blendv_ps(thenPacket, elsePacket, false_mask);
-#else
-  return _mm_or_ps(_mm_andnot_ps(false_mask, thenPacket), _mm_and_ps(false_mask, elsePacket));
-#endif
+
+template <>
+EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) {
+  EIGEN_MSA_DEBUG;
+
+  static const Packet2d countdown = { 0.0, 1.0 };
+  return padd(pset1<Packet2d>(a), countdown);
 }
-template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {
-  const __m128d zero = _mm_setzero_pd();
-  const __m128d select = _mm_set_pd(ifPacket.select[1], ifPacket.select[0]);
-  __m128d false_mask = _mm_cmpeq_pd(select, zero);
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_blendv_pd(thenPacket, elsePacket, false_mask);
-#else
-  return _mm_or_pd(_mm_andnot_pd(false_mask, thenPacket), _mm_and_pd(false_mask, elsePacket));
-#endif
+
+template <>
+EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fsub_d(a, b);
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f pinsertfirst(const Packet4f& a, float b)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_blend_ps(a,pset1<Packet4f>(b),1);
-#else
-  return _mm_move_ss(a, _mm_load_ss(&b));
-#endif
+template <>
+EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet2d)__builtin_msa_bnegi_d((v2u64)a, 63);
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d pinsertfirst(const Packet2d& a, double b)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_blend_pd(a,pset1<Packet2d>(b),1);
-#else
-  return _mm_move_sd(a, _mm_load_sd(&b));
-#endif
+template <>
+EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+  return a;
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f pinsertlast(const Packet4f& a, float b)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_blend_ps(a,pset1<Packet4f>(b),(1<<3));
+template <>
+EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fmul_d(a, b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fdiv_d(a, b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fmadd_d(c, a, b);
+}
+
+// Logical Operations are not supported for float, so we have to reinterpret casts using MSA
+// intrinsics
+template <>
+EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet2d)__builtin_msa_and_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet2d)__builtin_msa_or_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet2d)__builtin_msa_xor_v((v16u8)a, (v16u8)b);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+  return pand(a, (Packet2d)__builtin_msa_xori_b((v16u8)b, 255));
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double* from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_UNALIGNED_LOAD return (Packet2d)__builtin_msa_ld_d(const_cast<double*>(from), 0);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+#if EIGEN_FAST_MATH
+  // This prefers numbers to NaNs.
+  return __builtin_msa_fmin_d(a, b);
 #else
-  const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x0,0x0,0x0,0xFFFFFFFF));
-  return _mm_or_ps(_mm_andnot_ps(mask, a), _mm_and_ps(mask, pset1<Packet4f>(b)));
+  // This prefers NaNs to numbers.
+  v2i64 aNaN = __builtin_msa_fcun_d(a, a);
+  v2i64 aMinOrNaN = por(__builtin_msa_fclt_d(a, b), aNaN);
+  return (Packet2d)__builtin_msa_bsel_v((v16u8)aMinOrNaN, (v16u8)b, (v16u8)a);
 #endif
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d pinsertlast(const Packet2d& a, double b)
-{
-#ifdef EIGEN_VECTORIZE_SSE4_1
-  return _mm_blend_pd(a,pset1<Packet2d>(b),(1<<1));
+template <>
+EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) {
+  EIGEN_MSA_DEBUG;
+
+#if EIGEN_FAST_MATH
+  // This prefers numbers to NaNs.
+  return __builtin_msa_fmax_d(a, b);
 #else
-  const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0x0,0x0,0xFFFFFFFF,0xFFFFFFFF));
-  return _mm_or_pd(_mm_andnot_pd(mask, a), _mm_and_pd(mask, pset1<Packet2d>(b)));
+  // This prefers NaNs to numbers.
+  v2i64 aNaN = __builtin_msa_fcun_d(a, a);
+  v2i64 aMaxOrNaN = por(__builtin_msa_fclt_d(b, a), aNaN);
+  return (Packet2d)__builtin_msa_bsel_v((v16u8)aMaxOrNaN, (v16u8)b, (v16u8)a);
 #endif
 }
 
-// Scalar path for pmadd with FMA to ensure consistency with vectorized path.
-#ifdef __FMA__
-template<> EIGEN_STRONG_INLINE float pmadd(const float& a, const float& b, const float& c) {
-  return ::fmaf(a,b,c);
+template <>
+EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_UNALIGNED_LOAD return (Packet2d)__builtin_msa_ld_d(const_cast<double*>(from), 0);
 }
-template<> EIGEN_STRONG_INLINE double pmadd(const double& a, const double& b, const double& c) {
-  return ::fma(a,b,c);
+
+template <>
+EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double* from) {
+  EIGEN_MSA_DEBUG;
+
+  Packet2d value = { *from, *from };
+  return value;
 }
-#endif
 
-} // end namespace internal
+template <>
+EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_ALIGNED_STORE __builtin_msa_st_d((v2i64)from, to, 0);
+}
+
+template <>
+EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) {
+  EIGEN_MSA_DEBUG;
+
+  EIGEN_DEBUG_UNALIGNED_STORE __builtin_msa_st_d((v2i64)from, to, 0);
+}
+
+template <>
+EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride) {
+  EIGEN_MSA_DEBUG;
+
+  Packet2d value;
+  value[0] = *from;
+  from += stride;
+  value[1] = *from;
+  return value;
+}
+
+template <>
+EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from,
+                                                         Index stride) {
+  EIGEN_MSA_DEBUG;
+
+  *to = from[0];
+  to += stride;
+  *to = from[1];
+}
+
+template <>
+EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) {
+  EIGEN_MSA_DEBUG;
+
+  __builtin_prefetch(addr);
+}
+
+template <>
+EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+  return a[0];
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+  return (Packet2d)__builtin_msa_shf_w((v4i32)a, EIGEN_MSA_SHF_I8(2, 3, 0, 1));
+}
 
-} // end namespace Eigen
+template <>
+EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
 
-#if EIGEN_COMP_PGI
-// PGI++ does not define the following intrinsics in C++ mode.
-static inline __m128  _mm_castpd_ps   (__m128d x) { return reinterpret_cast<__m128&>(x);  }
-static inline __m128i _mm_castpd_si128(__m128d x) { return reinterpret_cast<__m128i&>(x); }
-static inline __m128d _mm_castps_pd   (__m128  x) { return reinterpret_cast<__m128d&>(x); }
-static inline __m128i _mm_castps_si128(__m128  x) { return reinterpret_cast<__m128i&>(x); }
-static inline __m128  _mm_castsi128_ps(__m128i x) { return reinterpret_cast<__m128&>(x);  }
-static inline __m128d _mm_castsi128_pd(__m128i x) { return reinterpret_cast<__m128d&>(x); }
+  return (Packet2d)__builtin_msa_bclri_d((v2u64)a, 63);
+}
+
+template <>
+EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet2d s = padd(a, preverse(a));
+  return s[0];
+}
+
+// Other reduction functions:
+// mul
+template <>
+EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+  Packet2d p = pmul(a, preverse(a));
+  return p[0];
+}
+
+// min
+template <>
+EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+#if EIGEN_FAST_MATH
+  Packet2d swapped = (Packet2d)__builtin_msa_shf_w((Packet4i)a, EIGEN_MSA_SHF_I8(2, 3, 0, 1));
+  Packet2d v = __builtin_msa_fmin_d(a, swapped);
+  return v[0];
+#else
+  double a0 = a[0], a1 = a[1];
+  return ((numext::isnan)(a0) || a0 < a1) ? a0 : a1;
 #endif
+}
+
+// max
+template <>
+EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+#if EIGEN_FAST_MATH
+  Packet2d swapped = (Packet2d)__builtin_msa_shf_w((Packet4i)a, EIGEN_MSA_SHF_I8(2, 3, 0, 1));
+  Packet2d v = __builtin_msa_fmax_d(a, swapped);
+  return v[0];
+#else
+  double a0 = a[0], a1 = a[1];
+  return ((numext::isnan)(a0) || a0 > a1) ? a0 : a1;
+#endif
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d psqrt(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+  return __builtin_msa_fsqrt_d(a);
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d prsqrt(const Packet2d& a) {
+  EIGEN_MSA_DEBUG;
+
+#if EIGEN_FAST_MATH
+  return __builtin_msa_frsqrt_d(a);
+#else
+  Packet2d ones = __builtin_msa_ffint_s_d(__builtin_msa_ldi_d(1));
+  return pdiv(ones, psqrt(a));
+#endif
+}
+
+inline std::ostream& operator<<(std::ostream& os, const PacketBlock<Packet2d, 2>& value) {
+  os << "[ " << value.packet[0] << "," << std::endl << "  " << value.packet[1] << " ]";
+  return os;
+}
+
+EIGEN_DEVICE_FUNC inline void ptranspose(PacketBlock<Packet2d, 2>& kernel) {
+  EIGEN_MSA_DEBUG;
+
+  Packet2d trn1 = (Packet2d)__builtin_msa_ilvev_d((v2i64)kernel.packet[1], (v2i64)kernel.packet[0]);
+  Packet2d trn2 = (Packet2d)__builtin_msa_ilvod_d((v2i64)kernel.packet[1], (v2i64)kernel.packet[0]);
+  kernel.packet[0] = trn1;
+  kernel.packet[1] = trn2;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) {
+  Packet2d v = a;
+  int32_t old_mode, new_mode;
+  asm volatile(
+      "cfcmsa  %[old_mode], $1\n"
+      "ori     %[new_mode], %[old_mode], 3\n"  // 3 = round towards -INFINITY.
+      "ctcmsa  $1, %[new_mode]\n"
+      "frint.d %w[v], %w[v]\n"
+      "ctcmsa  $1, %[old_mode]\n"
+      :  // outputs
+      [old_mode] "=r"(old_mode), [new_mode] "=r"(new_mode),
+      [v] "+f"(v)
+      :  // inputs
+      :  // clobbers
+  );
+  return v;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const Packet2d& a) {
+  Packet2d v = a;
+  int32_t old_mode, new_mode;
+  asm volatile(
+      "cfcmsa  %[old_mode], $1\n"
+      "ori     %[new_mode], %[old_mode], 3\n"
+      "xori    %[new_mode], %[new_mode], 1\n"  // 2 = round towards +INFINITY.
+      "ctcmsa  $1, %[new_mode]\n"
+      "frint.d %w[v], %w[v]\n"
+      "ctcmsa  $1, %[old_mode]\n"
+      :  // outputs
+      [old_mode] "=r"(old_mode), [new_mode] "=r"(new_mode),
+      [v] "+f"(v)
+      :  // inputs
+      :  // clobbers
+  );
+  return v;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a) {
+  Packet2d v = a;
+  int32_t old_mode, new_mode;
+  asm volatile(
+      "cfcmsa  %[old_mode], $1\n"
+      "ori     %[new_mode], %[old_mode], 3\n"
+      "xori    %[new_mode], %[new_mode], 3\n"  // 0 = round to nearest, ties to even.
+      "ctcmsa  $1, %[new_mode]\n"
+      "frint.d %w[v], %w[v]\n"
+      "ctcmsa  $1, %[old_mode]\n"
+      :  // outputs
+      [old_mode] "=r"(old_mode), [new_mode] "=r"(new_mode),
+      [v] "+f"(v)
+      :  // inputs
+      :  // clobbers
+  );
+  return v;
+}
+
+template <>
+EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket,
+                                    const Packet2d& elsePacket) {
+  Packet2ul select = { ifPacket.select[0], ifPacket.select[1] };
+  Packet2l mask = __builtin_msa_ceqi_d((Packet2l)select, 0);
+  return (Packet2d)__builtin_msa_bsel_v((v16u8)mask, (v16u8)thenPacket, (v16u8)elsePacket);
+}
+
+}  // end namespace internal
+
+}  // end namespace Eigen
 
-#endif // EIGEN_PACKET_MATH_SSE_H
+#endif  // EIGEN_PACKET_MATH_MSA_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/SSE/TypeCasting.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/SVE/TypeCasting.h`

 * *Files 21% similar despite different names*

```diff
@@ -1,77 +1,49 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
-// Copyright (C) 2015 Benoit Steiner <benoit.steiner.goog@gmail.com>
+// Copyright (C) 2020, Arm Limited and Contributors
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-#ifndef EIGEN_TYPE_CASTING_SSE_H
-#define EIGEN_TYPE_CASTING_SSE_H
+#ifndef EIGEN_TYPE_CASTING_SVE_H
+#define EIGEN_TYPE_CASTING_SVE_H
 
 namespace Eigen {
-
 namespace internal {
 
-#ifndef EIGEN_VECTORIZE_AVX
-template <>
-struct type_casting_traits<float, int> {
-  enum {
-    VectorizedCast = 1,
-    SrcCoeffRatio = 1,
-    TgtCoeffRatio = 1
-  };
-};
-
 template <>
-struct type_casting_traits<int, float> {
-  enum {
-    VectorizedCast = 1,
-    SrcCoeffRatio = 1,
-    TgtCoeffRatio = 1
-  };
+struct type_casting_traits<float, numext::int32_t> {
+  enum { VectorizedCast = 1, SrcCoeffRatio = 1, TgtCoeffRatio = 1 };
 };
 
 template <>
-struct type_casting_traits<double, float> {
-  enum {
-    VectorizedCast = 1,
-    SrcCoeffRatio = 2,
-    TgtCoeffRatio = 1
-  };
+struct type_casting_traits<numext::int32_t, float> {
+  enum { VectorizedCast = 1, SrcCoeffRatio = 1, TgtCoeffRatio = 1 };
 };
 
 template <>
-struct type_casting_traits<float, double> {
-  enum {
-    VectorizedCast = 1,
-    SrcCoeffRatio = 1,
-    TgtCoeffRatio = 2
-  };
-};
-#endif
-
-template<> EIGEN_STRONG_INLINE Packet4i pcast<Packet4f, Packet4i>(const Packet4f& a) {
-  return _mm_cvttps_epi32(a);
+EIGEN_STRONG_INLINE PacketXf pcast<PacketXi, PacketXf>(const PacketXi& a) {
+  return svcvt_f32_s32_z(svptrue_b32(), a);
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f pcast<Packet4i, Packet4f>(const Packet4i& a) {
-  return _mm_cvtepi32_ps(a);
+template <>
+EIGEN_STRONG_INLINE PacketXi pcast<PacketXf, PacketXi>(const PacketXf& a) {
+  return svcvt_s32_f32_z(svptrue_b32(), a);
 }
 
-template<> EIGEN_STRONG_INLINE Packet4f pcast<Packet2d, Packet4f>(const Packet2d& a, const Packet2d& b) {
-  return _mm_shuffle_ps(_mm_cvtpd_ps(a), _mm_cvtpd_ps(b), (1 << 2) | (1 << 6));
+template <>
+EIGEN_STRONG_INLINE PacketXf preinterpret<PacketXf, PacketXi>(const PacketXi& a) {
+  return svreinterpret_f32_s32(a);
 }
 
-template<> EIGEN_STRONG_INLINE Packet2d pcast<Packet4f, Packet2d>(const Packet4f& a) {
-  // Simply discard the second half of the input
-  return _mm_cvtps_pd(a);
+template <>
+EIGEN_STRONG_INLINE PacketXi preinterpret<PacketXi, PacketXf>(const PacketXf& a) {
+  return svreinterpret_s32_f32(a);
 }
 
+}  // namespace internal
+}  // namespace Eigen
 
-} // end namespace internal
-
-} // end namespace Eigen
-
-#endif // EIGEN_TYPE_CASTING_SSE_H
+#endif // EIGEN_TYPE_CASTING_SVE_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/arch/ZVector/Complex.h` & `chronogram-0.2.0/include/Eigen/src/Core/arch/ZVector/Complex.h`

 * *Files 10% similar despite different names*

```diff
@@ -11,32 +11,40 @@
 #ifndef EIGEN_COMPLEX32_ALTIVEC_H
 #define EIGEN_COMPLEX32_ALTIVEC_H
 
 namespace Eigen {
 
 namespace internal {
 
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ >= 12)
+static Packet4ui  p4ui_CONJ_XOR = { 0x00000000, 0x80000000, 0x00000000, 0x80000000 }; //vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_MZERO);
+#endif
+
 static Packet2ul  p2ul_CONJ_XOR1 = (Packet2ul) vec_sld((Packet4ui) p2d_ZERO_, (Packet4ui) p2l_ZERO, 8);//{ 0x8000000000000000, 0x0000000000000000 };
 static Packet2ul  p2ul_CONJ_XOR2 = (Packet2ul) vec_sld((Packet4ui) p2l_ZERO,  (Packet4ui) p2d_ZERO_, 8);//{ 0x8000000000000000, 0x0000000000000000 };
 
 struct Packet1cd
 {
   EIGEN_STRONG_INLINE Packet1cd() {}
   EIGEN_STRONG_INLINE explicit Packet1cd(const Packet2d& a) : v(a) {}
   Packet2d v;
 };
 
 struct Packet2cf
 {
   EIGEN_STRONG_INLINE Packet2cf() {}
   EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ < 12)
   union {
     Packet4f v;
     Packet1cd cd[2];
   };
+#else
+  Packet4f v;
+#endif
 };
 
 template<> struct packet_traits<std::complex<float> >  : default_packet_traits
 {
   typedef Packet2cf type;
   typedef Packet2cf half;
   enum {
@@ -79,77 +87,41 @@
     HasAbs2   = 0,
     HasMin    = 0,
     HasMax    = 0,
     HasSetLinear = 0
   };
 };
 
-template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16}; typedef Packet2cf half; };
-template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16}; typedef Packet1cd half; };
+template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float>  type; enum {size=2, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false}; typedef Packet2cf half; };
+template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false}; typedef Packet1cd half; };
 
 /* Forward declaration */
 EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet2cf,2>& kernel);
 
-template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from)  { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }
+/* complex<double> first */
 template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet1cd(pload<Packet2d>((const double*)from)); }
-template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from)  { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }
 template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cd(ploadu<Packet2d>((const double*)from)); }
-template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *     to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }
 template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }
-template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *     to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }
 template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }
 
 template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)
 { /* here we really have to use unaligned loads :( */ return ploadu<Packet1cd>(&from); }
 
-template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)
-{
-  Packet2cf res;
-  res.cd[0] = Packet1cd(vec_ld2f((const float *)&from));
-  res.cd[1] = res.cd[0];
-  return res;
-}
-template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)
-{
-  std::complex<float> EIGEN_ALIGN16 af[2];
-  af[0] = from[0*stride];
-  af[1] = from[1*stride];
-  return pload<Packet2cf>(af);
-}
 template<> EIGEN_DEVICE_FUNC inline Packet1cd pgather<std::complex<double>, Packet1cd>(const std::complex<double>* from, Index stride EIGEN_UNUSED)
 {
   return pload<Packet1cd>(from);
 }
-template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)
-{
-  std::complex<float> EIGEN_ALIGN16 af[2];
-  pstore<std::complex<float> >((std::complex<float> *) af, from);
-  to[0*stride] = af[0];
-  to[1*stride] = af[1];
-}
 template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<double>, Packet1cd>(std::complex<double>* to, const Packet1cd& from, Index stride EIGEN_UNUSED)
 {
   pstore<std::complex<double> >(to, from);
 }
-
-template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v, b.v)); }
 template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v + b.v); }
-template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v, b.v)); }
 template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(a.v - b.v); }
 template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }
-template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(Packet4f(a.v))); }
 template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a) { return Packet1cd((Packet2d)vec_xor((Packet2d)a.v, (Packet2d)p2ul_CONJ_XOR2)); }
-template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)
-{
-  Packet2cf res;
-  res.v.v4f[0] = pconj(Packet1cd(reinterpret_cast<Packet2d>(a.v.v4f[0]))).v;
-  res.v.v4f[1] = pconj(Packet1cd(reinterpret_cast<Packet2d>(a.v.v4f[1]))).v;
-  return res;
-}
-
 template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
 {
   Packet2d a_re, a_im, v1, v2;
 
   // Permute and multiply the real parts of a and b
   a_re = vec_perm(a.v, a.v, p16uc_PSET64_HI);
   // Get the imaginary parts of a
@@ -159,239 +131,296 @@
   // multiply a_im * b and get the conjugate result
   v2 = vec_madd(a_im, b.v, p2d_ZERO);
   v2 = (Packet2d) vec_sld((Packet4ui)v2, (Packet4ui)v2, 8);
   v2 = (Packet2d) vec_xor((Packet2d)v2, (Packet2d) p2ul_CONJ_XOR1);
 
   return Packet1cd(v1 + v2);
 }
-template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
-{
-  Packet2cf res;
-  res.v.v4f[0] = pmul(Packet1cd(reinterpret_cast<Packet2d>(a.v.v4f[0])), Packet1cd(reinterpret_cast<Packet2d>(b.v.v4f[0]))).v;
-  res.v.v4f[1] = pmul(Packet1cd(reinterpret_cast<Packet2d>(a.v.v4f[1])), Packet1cd(reinterpret_cast<Packet2d>(b.v.v4f[1]))).v;
-  return res;
-}
-
-template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_and(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pand<Packet4f>(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_or(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(por<Packet4f>(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_xor(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pxor<Packet4f>(a.v,b.v)); }
-template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_and(a.v, vec_nor(b.v,b.v))); }
-template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pandnot<Packet4f>(a.v,b.v)); }
-
+template<> EIGEN_STRONG_INLINE Packet1cd pand    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_and(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet1cd por     <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_or(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet1cd pxor    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_xor(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet1cd pandnot <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(vec_and(a.v, vec_nor(b.v,b.v))); }
 template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>*     from) {  return pset1<Packet1cd>(*from); }
-template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*      from) {  return pset1<Packet2cf>(*from); }
+template<> EIGEN_STRONG_INLINE Packet1cd pcmp_eq(const Packet1cd& a, const Packet1cd& b) {
+  Packet2d eq = vec_cmpeq (a.v, b.v);
+  Packet2d tmp = { eq[1], eq[0] };
+  return (Packet1cd)pand<Packet2d>(eq, tmp);
+}
 
-template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *     addr) { EIGEN_ZVECTOR_PREFETCH(addr); }
 template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { EIGEN_ZVECTOR_PREFETCH(addr); }
 
 template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)
 {
   std::complex<double> EIGEN_ALIGN16 res;
   pstore<std::complex<double> >(&res, a);
 
   return res;
 }
-template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)
-{
-  std::complex<float> EIGEN_ALIGN16 res[2];
-  pstore<std::complex<float> >(res, a);
-
-  return res[0];
-}
 
 template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }
-template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)
+template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)
 {
-  Packet2cf res;
-  res.cd[0] = a.cd[1];
-  res.cd[1] = a.cd[0];
-  return res;
+  return pfirst(a);
 }
-
-template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)
+template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)
 {
   return pfirst(a);
 }
-template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)
+EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet1cd,Packet2d)
+
+template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
 {
-  std::complex<float> res;
-  Packet1cd b = padd<Packet1cd>(a.cd[0], a.cd[1]);
-  vec_st2f(b.v, (float*)&res);
-  return res;
+  // TODO optimize it for AltiVec
+  Packet1cd res = pmul(a,pconj(b));
+  Packet2d s = vec_madd(b.v, b.v, p2d_ZERO_);
+  return Packet1cd(pdiv(res.v, s + vec_perm(s, s, p16uc_REVERSE64)));
 }
 
-template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)
+EIGEN_STRONG_INLINE Packet1cd pcplxflip/*<Packet1cd>*/(const Packet1cd& x)
 {
-  return vecs[0];
+  return Packet1cd(preverse(Packet2d(x.v)));
 }
-template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)
+
+EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)
 {
-  PacketBlock<Packet2cf,2> transpose;
-  transpose.packet[0] = vecs[0];
-  transpose.packet[1] = vecs[1];
-  ptranspose(transpose);
+  Packet2d tmp = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_HI);
+  kernel.packet[1].v = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_LO);
+  kernel.packet[0].v = tmp;
+}
 
-  return padd<Packet2cf>(transpose.packet[0], transpose.packet[1]);
-} 
+/* complex<float> follows */
+template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from)  { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }
+template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from)  { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }
+template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *     to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }
+template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *     to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }
 
-template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)
+template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)
 {
-  return pfirst(a);
+  std::complex<float> EIGEN_ALIGN16 res[2];
+  pstore<std::complex<float> >(res, a);
+
+  return res[0];
 }
-template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)
+
+
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ < 12)
+template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)
 {
-  std::complex<float> res;
-  Packet1cd b = pmul<Packet1cd>(a.cd[0], a.cd[1]);
-  vec_st2f(b.v, (float*)&res);
+  Packet2cf res;
+  res.cd[0] = Packet1cd(vec_ld2f((const float *)&from));
+  res.cd[1] = res.cd[0];
   return res;
 }
-
-template<int Offset>
-struct palign_impl<Offset,Packet1cd>
+#else
+template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)
 {
-  static EIGEN_STRONG_INLINE void run(Packet1cd& /*first*/, const Packet1cd& /*second*/)
-  {
-    // FIXME is it sure we never have to align a Packet1cd?
-    // Even though a std::complex<double> has 16 bytes, it is not necessarily aligned on a 16 bytes boundary...
-  }
-};
+  Packet2cf res;
+  if((std::ptrdiff_t(&from) % 16) == 0)
+    res.v = pload<Packet4f>((const float *)&from);
+  else
+    res.v = ploadu<Packet4f>((const float *)&from);
+  res.v = vec_perm(res.v, res.v, p16uc_PSET64_HI);
+  return res;
+}
+#endif
 
-template<int Offset>
-struct palign_impl<Offset,Packet2cf>
+template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)
 {
-  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)
-  {
-    if (Offset == 1) {
-      first.cd[0] = first.cd[1];
-      first.cd[1] = second.cd[0];
-    }
-  }
-};
-
-template<> struct conj_helper<Packet1cd, Packet1cd, false,true>
+  std::complex<float> EIGEN_ALIGN16 af[2];
+  af[0] = from[0*stride];
+  af[1] = from[1*stride];
+  return pload<Packet2cf>(af);
+}
+template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)
 {
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
+  std::complex<float> EIGEN_ALIGN16 af[2];
+  pstore<std::complex<float> >((std::complex<float> *) af, from);
+  to[0*stride] = af[0];
+  to[1*stride] = af[1];
+}
 
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return internal::pmul(a, pconj(b));
-  }
-};
+template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v, b.v)); }
+template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v, b.v)); }
+template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(Packet4f(a.v))); }
 
-template<> struct conj_helper<Packet1cd, Packet1cd, true,false>
-{
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
+template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pand<Packet4f>(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(por<Packet4f>(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pxor<Packet4f>(a.v,b.v)); }
+template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(pandnot<Packet4f>(a.v,b.v)); }
 
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return internal::pmul(pconj(a), b);
-  }
-};
+template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*      from) {  return pset1<Packet2cf>(*from); }
 
-template<> struct conj_helper<Packet1cd, Packet1cd, true,true>
-{
-  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const
-  { return padd(pmul(x,y),c); }
+template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *     addr) { EIGEN_ZVECTOR_PREFETCH(addr); }
 
-  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const
-  {
-    return pconj(internal::pmul(a, b));
-  }
-};
 
-template<> struct conj_helper<Packet2cf, Packet2cf, false,true>
-{
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
+#if !defined(__ARCH__) || (defined(__ARCH__) && __ARCH__ < 12)
 
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return internal::pmul(a, pconj(b));
-  }
-};
+template<> EIGEN_STRONG_INLINE Packet2cf pcmp_eq(const Packet2cf& a, const Packet2cf& b) {
+  Packet4f eq = pcmp_eq<Packet4f> (a.v, b.v);
+  Packet2cf res;
+  Packet2d tmp1 = { eq.v4f[0][1], eq.v4f[0][0] };
+  Packet2d tmp2 = { eq.v4f[1][1], eq.v4f[1][0] };
+  res.v.v4f[0] = pand<Packet2d>(eq.v4f[0], tmp1);
+  res.v.v4f[1] = pand<Packet2d>(eq.v4f[1], tmp2);
+  return res;
+}
 
-template<> struct conj_helper<Packet2cf, Packet2cf, true,false>
+template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)
 {
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
-
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return internal::pmul(pconj(a), b);
-  }
-};
+  Packet2cf res;
+  res.v.v4f[0] = pconj(Packet1cd(reinterpret_cast<Packet2d>(a.v.v4f[0]))).v;
+  res.v.v4f[1] = pconj(Packet1cd(reinterpret_cast<Packet2d>(a.v.v4f[1]))).v;
+  return res;
+}
 
-template<> struct conj_helper<Packet2cf, Packet2cf, true,true>
+template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
 {
-  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const
-  { return padd(pmul(x,y),c); }
+  Packet2cf res;
+  res.v.v4f[0] = pmul(Packet1cd(reinterpret_cast<Packet2d>(a.v.v4f[0])), Packet1cd(reinterpret_cast<Packet2d>(b.v.v4f[0]))).v;
+  res.v.v4f[1] = pmul(Packet1cd(reinterpret_cast<Packet2d>(a.v.v4f[1])), Packet1cd(reinterpret_cast<Packet2d>(b.v.v4f[1]))).v;
+  return res;
+}
 
-  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const
-  {
-    return pconj(internal::pmul(a, b));
-  }
-};
+template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)
+{
+  Packet2cf res;
+  res.cd[0] = a.cd[1];
+  res.cd[1] = a.cd[0];
+  return res;
+}
 
-EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet2cf,Packet4f)
-EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet1cd,Packet2d)
+template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)
+{
+  std::complex<float> res;
+  Packet1cd b = padd<Packet1cd>(a.cd[0], a.cd[1]);
+  vec_st2f(b.v, (float*)&res);
+  return res;
+}
 
-template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)
+template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)
 {
-  // TODO optimize it for AltiVec
-  Packet1cd res = conj_helper<Packet1cd,Packet1cd,false,true>().pmul(a,b);
-  Packet2d s = vec_madd(b.v, b.v, p2d_ZERO_);
-  return Packet1cd(pdiv(res.v, s + vec_perm(s, s, p16uc_REVERSE64)));
+  std::complex<float> res;
+  Packet1cd b = pmul<Packet1cd>(a.cd[0], a.cd[1]);
+  vec_st2f(b.v, (float*)&res);
+  return res;
 }
 
+EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet2cf,Packet4f)
+
 template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
 {
   // TODO optimize it for AltiVec
   Packet2cf res;
   res.cd[0] = pdiv<Packet1cd>(a.cd[0], b.cd[0]);
   res.cd[1] = pdiv<Packet1cd>(a.cd[1], b.cd[1]);
   return res;
 }
 
-EIGEN_STRONG_INLINE Packet1cd pcplxflip/*<Packet1cd>*/(const Packet1cd& x)
-{
-  return Packet1cd(preverse(Packet2d(x.v)));
-}
-
 EIGEN_STRONG_INLINE Packet2cf pcplxflip/*<Packet2cf>*/(const Packet2cf& x)
 {
   Packet2cf res;
   res.cd[0] = pcplxflip(x.cd[0]);
   res.cd[1] = pcplxflip(x.cd[1]);
   return res;
 }
 
-EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet1cd,2>& kernel)
-{
-  Packet2d tmp = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_HI);
-  kernel.packet[1].v = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_LO);
-  kernel.packet[0].v = tmp;
-}
-
 EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet2cf,2>& kernel)
 {
   Packet1cd tmp = kernel.packet[0].cd[1];
   kernel.packet[0].cd[1] = kernel.packet[1].cd[0];
   kernel.packet[1].cd[0] = tmp;
 }
 
 template<> EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {
   Packet2cf result;
   const Selector<4> ifPacket4 = { ifPacket.select[0], ifPacket.select[0], ifPacket.select[1], ifPacket.select[1] };
   result.v = pblend<Packet4f>(ifPacket4, thenPacket.v, elsePacket.v);
   return result;
 }
+#else
+template<> EIGEN_STRONG_INLINE Packet2cf pcmp_eq(const Packet2cf& a, const Packet2cf& b) {
+  Packet4f eq = vec_cmpeq (a.v, b.v);
+  Packet4f tmp = { eq[1], eq[0], eq[3], eq[2] };
+  return (Packet2cf)pand<Packet4f>(eq, tmp);
+}
+template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf(pxor<Packet4f>(a.v, reinterpret_cast<Packet4f>(p4ui_CONJ_XOR))); }
+template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+{
+  Packet4f a_re, a_im, prod, prod_im;
+
+  // Permute and multiply the real parts of a and b
+  a_re = vec_perm(a.v, a.v, p16uc_PSET32_WODD);
+  
+  // Get the imaginary parts of a
+  a_im = vec_perm(a.v, a.v, p16uc_PSET32_WEVEN);
+
+  // multiply a_im * b and get the conjugate result
+  prod_im = a_im * b.v;
+  prod_im = pxor<Packet4f>(prod_im, reinterpret_cast<Packet4f>(p4ui_CONJ_XOR));
+  // permute back to a proper order
+  prod_im = vec_perm(prod_im, prod_im, p16uc_COMPLEX32_REV);
+
+  // multiply a_re * b, add prod_im
+  prod = pmadd<Packet4f>(a_re, b.v, prod_im);
+ 
+  return Packet2cf(prod);
+}
+
+template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)
+{
+  Packet4f rev_a;
+  rev_a = vec_perm(a.v, a.v, p16uc_COMPLEX32_REV2);
+  return Packet2cf(rev_a);
+}
+
+template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)
+{
+  Packet4f b;
+  b = vec_sld(a.v, a.v, 8);
+  b = padd<Packet4f>(a.v, b);
+  return pfirst<Packet2cf>(Packet2cf(b));
+}
+
+template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)
+{
+  Packet4f b;
+  Packet2cf prod;
+  b = vec_sld(a.v, a.v, 8);
+  prod = pmul<Packet2cf>(a, Packet2cf(b));
+
+  return pfirst<Packet2cf>(prod);
+}
+
+EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet2cf,Packet4f)
+
+template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)
+{
+  // TODO optimize it for AltiVec
+  Packet2cf res = pmul(a, pconj(b));
+  Packet4f s = pmul<Packet4f>(b.v, b.v);
+  return Packet2cf(pdiv(res.v, padd<Packet4f>(s, vec_perm(s, s, p16uc_COMPLEX32_REV))));
+}
+
+template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)
+{
+  return Packet2cf(vec_perm(x.v, x.v, p16uc_COMPLEX32_REV));
+}
+
+EIGEN_STRONG_INLINE void ptranspose(PacketBlock<Packet2cf,2>& kernel)
+{
+  Packet4f tmp = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_HI);
+  kernel.packet[1].v = vec_perm(kernel.packet[0].v, kernel.packet[1].v, p16uc_TRANSPOSE64_LO);
+  kernel.packet[0].v = tmp;
+}
+
+template<> EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {
+  Packet2cf result;
+  result.v = reinterpret_cast<Packet4f>(pblend<Packet2d>(ifPacket, reinterpret_cast<Packet2d>(thenPacket.v), reinterpret_cast<Packet2d>(elsePacket.v)));
+  return result;
+}
+#endif
 
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_COMPLEX32_ALTIVEC_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/functors/AssignmentFunctors.h` & `chronogram-0.2.0/include/Eigen/src/Core/functors/AssignmentFunctors.h`

 * *Files 2% similar despite different names*

```diff
@@ -140,28 +140,37 @@
   *
   */
 template<typename Scalar> struct swap_assign_op {
 
   EIGEN_EMPTY_STRUCT_CTOR(swap_assign_op)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Scalar& a, const Scalar& b) const
   {
-#ifdef __CUDACC__
+#ifdef EIGEN_GPUCC
     // FIXME is there some kind of cuda::swap?
     Scalar t=b; const_cast<Scalar&>(b)=a; a=t;
 #else
     using std::swap;
     swap(a,const_cast<Scalar&>(b));
 #endif
   }
 };
 template<typename Scalar>
 struct functor_traits<swap_assign_op<Scalar> > {
   enum {
     Cost = 3 * NumTraits<Scalar>::ReadCost,
-    PacketAccess = packet_traits<Scalar>::Vectorizable
+    PacketAccess = 
+    #if defined(EIGEN_VECTORIZE_AVX) && EIGEN_COMP_CLANG && (EIGEN_COMP_CLANG<800 || defined(__apple_build_version__))
+    // This is a partial workaround for a bug in clang generating bad code
+    // when mixing 256/512 bits loads and 128 bits moves.
+    // See http://eigen.tuxfamily.org/bz/show_bug.cgi?id=1684
+    //     https://bugs.llvm.org/show_bug.cgi?id=40815
+    0
+    #else
+    packet_traits<Scalar>::Vectorizable
+    #endif
   };
 };
 
 } // namespace internal
 
 } // namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/functors/BinaryFunctors.h` & `chronogram-0.2.0/include/Eigen/src/Core/functors/BinaryFunctors.h`

 * *Files 4% similar despite different names*

```diff
@@ -35,40 +35,34 @@
 #ifndef EIGEN_SCALAR_BINARY_OP_PLUGIN
   EIGEN_EMPTY_STRUCT_CTOR(scalar_sum_op)
 #else
   scalar_sum_op() {
     EIGEN_SCALAR_BINARY_OP_PLUGIN
   }
 #endif
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a + b; }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a + b; }
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet packetOp(const Packet& a, const Packet& b) const
   { return internal::padd(a,b); }
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type predux(const Packet& a) const
   { return internal::predux(a); }
 };
 template<typename LhsScalar,typename RhsScalar>
 struct functor_traits<scalar_sum_op<LhsScalar,RhsScalar> > {
   enum {
-    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2, // rough estimate!
+    Cost = (int(NumTraits<LhsScalar>::AddCost) + int(NumTraits<RhsScalar>::AddCost)) / 2, // rough estimate!
     PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasAdd && packet_traits<RhsScalar>::HasAdd
     // TODO vectorize mixed sum
   };
 };
 
-/** \internal
-  * \brief Template specialization to deprecate the summation of boolean expressions.
-  * This is required to solve Bug 426.
-  * \sa DenseBase::count(), DenseBase::any(), ArrayBase::cast(), MatrixBase::cast()
-  */
-template<> struct scalar_sum_op<bool,bool> : scalar_sum_op<int,int> {
-  EIGEN_DEPRECATED
-  scalar_sum_op() {}
-};
+
+template<>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool scalar_sum_op<bool,bool>::operator() (const bool& a, const bool& b) const { return a || b; }
 
 
 /** \internal
   * \brief Template functor to compute the product of two scalars
   *
   * \sa class CwiseBinaryOp, Cwise::operator*(), class VectorwiseOp, MatrixBase::redux()
   */
@@ -79,31 +73,35 @@
 #ifndef EIGEN_SCALAR_BINARY_OP_PLUGIN
   EIGEN_EMPTY_STRUCT_CTOR(scalar_product_op)
 #else
   scalar_product_op() {
     EIGEN_SCALAR_BINARY_OP_PLUGIN
   }
 #endif
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet packetOp(const Packet& a, const Packet& b) const
   { return internal::pmul(a,b); }
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type predux(const Packet& a) const
   { return internal::predux_mul(a); }
 };
 template<typename LhsScalar,typename RhsScalar>
 struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {
   enum {
-    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)/2, // rough estimate!
+    Cost = (int(NumTraits<LhsScalar>::MulCost) + int(NumTraits<RhsScalar>::MulCost))/2, // rough estimate!
     PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul
     // TODO vectorize mixed product
   };
 };
 
+template<>
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool scalar_product_op<bool,bool>::operator() (const bool& a, const bool& b) const { return a && b; }
+
+
 /** \internal
   * \brief Template functor to compute the conjugate product of two scalars
   *
   * This is a short cut for conj(x) * y which is needed for optimization purpose; in Eigen2 support mode, this becomes x * conj(y)
   */
 template<typename LhsScalar,typename RhsScalar>
 struct scalar_conj_product_op  : binary_op_base<LhsScalar,RhsScalar>
@@ -112,19 +110,19 @@
   enum {
     Conj = NumTraits<LhsScalar>::IsComplex
   };
   
   typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_conj_product_op>::ReturnType result_type;
   
   EIGEN_EMPTY_STRUCT_CTOR(scalar_conj_product_op)
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const LhsScalar& a, const RhsScalar& b) const
   { return conj_helper<LhsScalar,RhsScalar,Conj,false>().pmul(a,b); }
   
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet packetOp(const Packet& a, const Packet& b) const
   { return conj_helper<Packet,Packet,Conj,false>().pmul(a,b); }
 };
 template<typename LhsScalar,typename RhsScalar>
 struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {
   enum {
     Cost = NumTraits<LhsScalar>::MulCost,
     PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul
@@ -132,55 +130,69 @@
 };
 
 /** \internal
   * \brief Template functor to compute the min of two scalars
   *
   * \sa class CwiseBinaryOp, MatrixBase::cwiseMin, class VectorwiseOp, MatrixBase::minCoeff()
   */
-template<typename LhsScalar,typename RhsScalar>
+template<typename LhsScalar,typename RhsScalar, int NaNPropagation>
 struct scalar_min_op : binary_op_base<LhsScalar,RhsScalar>
 {
   typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_min_op>::ReturnType result_type;
   EIGEN_EMPTY_STRUCT_CTOR(scalar_min_op)
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return numext::mini(a, b); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const LhsScalar& a, const RhsScalar& b) const {
+    return internal::pmin<NaNPropagation>(a, b);
+  }
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
-  { return internal::pmin(a,b); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet packetOp(const Packet& a, const Packet& b) const
+  {
+    return internal::pmin<NaNPropagation>(a,b);
+  }
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const
-  { return internal::predux_min(a); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type predux(const Packet& a) const
+  {
+    return internal::predux_min<NaNPropagation>(a);
+  }
 };
-template<typename LhsScalar,typename RhsScalar>
-struct functor_traits<scalar_min_op<LhsScalar,RhsScalar> > {
+
+template<typename LhsScalar,typename RhsScalar, int NaNPropagation>
+struct functor_traits<scalar_min_op<LhsScalar,RhsScalar, NaNPropagation> > {
   enum {
     Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2,
     PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMin
   };
 };
 
 /** \internal
   * \brief Template functor to compute the max of two scalars
   *
   * \sa class CwiseBinaryOp, MatrixBase::cwiseMax, class VectorwiseOp, MatrixBase::maxCoeff()
   */
-template<typename LhsScalar,typename RhsScalar>
-struct scalar_max_op  : binary_op_base<LhsScalar,RhsScalar>
+template<typename LhsScalar,typename RhsScalar, int NaNPropagation>
+struct scalar_max_op : binary_op_base<LhsScalar,RhsScalar>
 {
   typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_max_op>::ReturnType result_type;
   EIGEN_EMPTY_STRUCT_CTOR(scalar_max_op)
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return numext::maxi(a, b); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const LhsScalar& a, const RhsScalar& b) const {
+    return internal::pmax<NaNPropagation>(a,b);
+  }
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
-  { return internal::pmax(a,b); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet packetOp(const Packet& a, const Packet& b) const
+  {
+    return internal::pmax<NaNPropagation>(a,b);
+  }
   template<typename Packet>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const
-  { return internal::predux_max(a); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type predux(const Packet& a) const
+  {
+    return internal::predux_max<NaNPropagation>(a);
+  }
 };
-template<typename LhsScalar,typename RhsScalar>
-struct functor_traits<scalar_max_op<LhsScalar,RhsScalar> > {
+
+template<typename LhsScalar,typename RhsScalar, int NaNPropagation>
+struct functor_traits<scalar_max_op<LhsScalar,RhsScalar, NaNPropagation> > {
   enum {
     Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2,
     PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMax
   };
 };
 
 /** \internal
@@ -249,15 +261,14 @@
 struct scalar_cmp_op<LhsScalar,RhsScalar, cmp_NEQ> : binary_op_base<LhsScalar,RhsScalar>
 {
   typedef bool result_type;
   EIGEN_EMPTY_STRUCT_CTOR(scalar_cmp_op)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator()(const LhsScalar& a, const RhsScalar& b) const {return a!=b;}
 };
 
-
 /** \internal
   * \brief Template functor to compute the hypot of two \b positive \b and \b real scalars
   *
   * \sa MatrixBase::stableNorm(), class Redux
   */
 template<typename Scalar>
 struct scalar_hypot_op<Scalar,Scalar> : binary_op_base<Scalar,Scalar>
@@ -283,38 +294,54 @@
            2 * scalar_div_cost<Scalar,false>::value,
     PacketAccess = false
   };
 };
 
 /** \internal
   * \brief Template functor to compute the pow of two scalars
+  * See the specification of pow in https://en.cppreference.com/w/cpp/numeric/math/pow
   */
 template<typename Scalar, typename Exponent>
 struct scalar_pow_op  : binary_op_base<Scalar,Exponent>
 {
   typedef typename ScalarBinaryOpTraits<Scalar,Exponent,scalar_pow_op>::ReturnType result_type;
 #ifndef EIGEN_SCALAR_BINARY_OP_PLUGIN
   EIGEN_EMPTY_STRUCT_CTOR(scalar_pow_op)
 #else
   scalar_pow_op() {
     typedef Scalar LhsScalar;
     typedef Exponent RhsScalar;
     EIGEN_SCALAR_BINARY_OP_PLUGIN
   }
 #endif
+
   EIGEN_DEVICE_FUNC
   inline result_type operator() (const Scalar& a, const Exponent& b) const { return numext::pow(a, b); }
+
+  template<typename Packet>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
+  {
+    return generic_pow(a,b);
+  }
 };
+
 template<typename Scalar, typename Exponent>
 struct functor_traits<scalar_pow_op<Scalar,Exponent> > {
-  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };
+  enum {
+    Cost = 5 * NumTraits<Scalar>::MulCost,
+    PacketAccess = (!NumTraits<Scalar>::IsComplex && !NumTraits<Scalar>::IsInteger &&
+                    packet_traits<Scalar>::HasExp && packet_traits<Scalar>::HasLog &&
+                    packet_traits<Scalar>::HasRound && packet_traits<Scalar>::HasCmp &&
+                    // Temporarly disable packet access for half/bfloat16 until
+                    // accuracy is improved.
+                    !is_same<Scalar, half>::value && !is_same<Scalar, bfloat16>::value
+                    )
+  };
 };
 
-
-
 //---------- non associative binary functors ----------
 
 /** \internal
   * \brief Template functor to compute the difference of two scalars
   *
   * \sa class CwiseBinaryOp, MatrixBase::operator-
   */
@@ -333,15 +360,15 @@
   template<typename Packet>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
   { return internal::psub(a,b); }
 };
 template<typename LhsScalar,typename RhsScalar>
 struct functor_traits<scalar_difference_op<LhsScalar,RhsScalar> > {
   enum {
-    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2,
+    Cost = (int(NumTraits<LhsScalar>::AddCost) + int(NumTraits<RhsScalar>::AddCost)) / 2,
     PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasSub && packet_traits<RhsScalar>::HasSub
   };
 };
 
 /** \internal
   * \brief Template functor to compute the quotient of two scalars
   *
@@ -378,51 +405,90 @@
   * \brief Template functor to compute the and of two booleans
   *
   * \sa class CwiseBinaryOp, ArrayBase::operator&&
   */
 struct scalar_boolean_and_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_boolean_and_op)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }
+  template<typename Packet>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
+  { return internal::pand(a,b); }
 };
 template<> struct functor_traits<scalar_boolean_and_op> {
   enum {
     Cost = NumTraits<bool>::AddCost,
-    PacketAccess = false
+    PacketAccess = true
   };
 };
 
 /** \internal
   * \brief Template functor to compute the or of two booleans
   *
   * \sa class CwiseBinaryOp, ArrayBase::operator||
   */
 struct scalar_boolean_or_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_boolean_or_op)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }
+  template<typename Packet>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
+  { return internal::por(a,b); }
 };
 template<> struct functor_traits<scalar_boolean_or_op> {
   enum {
     Cost = NumTraits<bool>::AddCost,
-    PacketAccess = false
+    PacketAccess = true
   };
 };
 
 /** \internal
  * \brief Template functor to compute the xor of two booleans
  *
  * \sa class CwiseBinaryOp, ArrayBase::operator^
  */
 struct scalar_boolean_xor_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_boolean_xor_op)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a ^ b; }
+  template<typename Packet>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
+  { return internal::pxor(a,b); }
 };
 template<> struct functor_traits<scalar_boolean_xor_op> {
   enum {
     Cost = NumTraits<bool>::AddCost,
-    PacketAccess = false
+    PacketAccess = true
+  };
+};
+
+/** \internal
+  * \brief Template functor to compute the absolute difference of two scalars
+  *
+  * \sa class CwiseBinaryOp, MatrixBase::absolute_difference
+  */
+template<typename LhsScalar,typename RhsScalar>
+struct scalar_absolute_difference_op : binary_op_base<LhsScalar,RhsScalar>
+{
+  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar,scalar_absolute_difference_op>::ReturnType result_type;
+#ifndef EIGEN_SCALAR_BINARY_OP_PLUGIN
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_absolute_difference_op)
+#else
+  scalar_absolute_difference_op() {
+    EIGEN_SCALAR_BINARY_OP_PLUGIN
+  }
+#endif
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const
+  { return numext::absdiff(a,b); }
+  template<typename Packet>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const
+  { return internal::pabsdiff(a,b); }
+};
+template<typename LhsScalar,typename RhsScalar>
+struct functor_traits<scalar_absolute_difference_op<LhsScalar,RhsScalar> > {
+  enum {
+    Cost = (NumTraits<LhsScalar>::AddCost+NumTraits<RhsScalar>::AddCost)/2,
+    PacketAccess = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasAbsDiff
   };
 };
 
 
 
 //---------- binary functors bound to a constant, thus appearing as a unary functor ----------
 
@@ -432,15 +498,15 @@
 //  - they are portable across C++ versions (the std::binder* are deprecated in C++11)
 template<typename BinaryOp> struct bind1st_op : BinaryOp {
 
   typedef typename BinaryOp::first_argument_type  first_argument_type;
   typedef typename BinaryOp::second_argument_type second_argument_type;
   typedef typename BinaryOp::result_type          result_type;
 
-  bind1st_op(const first_argument_type &val) : m_value(val) {}
+  EIGEN_DEVICE_FUNC explicit bind1st_op(const first_argument_type &val) : m_value(val) {}
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const second_argument_type& b) const { return BinaryOp::operator()(m_value,b); }
 
   template<typename Packet>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& b) const
   { return BinaryOp::packetOp(internal::pset1<Packet>(m_value), b); }
 
@@ -451,15 +517,15 @@
 
 template<typename BinaryOp> struct bind2nd_op : BinaryOp {
 
   typedef typename BinaryOp::first_argument_type  first_argument_type;
   typedef typename BinaryOp::second_argument_type second_argument_type;
   typedef typename BinaryOp::result_type          result_type;
 
-  bind2nd_op(const second_argument_type &val) : m_value(val) {}
+  EIGEN_DEVICE_FUNC explicit bind2nd_op(const second_argument_type &val) : m_value(val) {}
 
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const first_argument_type& a) const { return BinaryOp::operator()(a,m_value); }
 
   template<typename Packet>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const
   { return BinaryOp::packetOp(a,internal::pset1<Packet>(m_value)); }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/functors/NullaryFunctors.h` & `chronogram-0.2.0/include/Eigen/src/Core/functors/NullaryFunctors.h`

 * *Files 10% similar despite different names*

```diff
@@ -33,67 +33,68 @@
   template<typename IndexType>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType row, IndexType col) const { return row==col ? Scalar(1) : Scalar(0); }
 };
 template<typename Scalar>
 struct functor_traits<scalar_identity_op<Scalar> >
 { enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };
 
-template <typename Scalar, typename Packet, bool IsInteger> struct linspaced_op_impl;
+template <typename Scalar, bool IsInteger> struct linspaced_op_impl;
 
-template <typename Scalar, typename Packet>
-struct linspaced_op_impl<Scalar,Packet,/*IsInteger*/false>
+template <typename Scalar>
+struct linspaced_op_impl<Scalar,/*IsInteger*/false>
 {
-  linspaced_op_impl(const Scalar& low, const Scalar& high, Index num_steps) :
-    m_low(low), m_high(high), m_size1(num_steps==1 ? 1 : num_steps-1), m_step(num_steps==1 ? Scalar() : (high-low)/Scalar(num_steps-1)),
+  typedef typename NumTraits<Scalar>::Real RealScalar;
+
+  EIGEN_DEVICE_FUNC linspaced_op_impl(const Scalar& low, const Scalar& high, Index num_steps) :
+    m_low(low), m_high(high), m_size1(num_steps==1 ? 1 : num_steps-1), m_step(num_steps==1 ? Scalar() : Scalar((high-low)/RealScalar(num_steps-1))),
     m_flip(numext::abs(high)<numext::abs(low))
   {}
 
   template<typename IndexType>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType i) const {
-    typedef typename NumTraits<Scalar>::Real RealScalar;
     if(m_flip)
-      return (i==0)? m_low : (m_high - RealScalar(m_size1-i)*m_step);
+      return (i==0)? m_low : Scalar(m_high - RealScalar(m_size1-i)*m_step);
     else
-      return (i==m_size1)? m_high : (m_low + RealScalar(i)*m_step);
+      return (i==m_size1)? m_high : Scalar(m_low + RealScalar(i)*m_step);
   }
 
-  template<typename IndexType>
+  template<typename Packet, typename IndexType>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const
   {
     // Principle:
     // [low, ..., low] + ( [step, ..., step] * ( [i, ..., i] + [0, ..., size] ) )
     if(m_flip)
     {
       Packet pi = plset<Packet>(Scalar(i-m_size1));
       Packet res = padd(pset1<Packet>(m_high), pmul(pset1<Packet>(m_step), pi));
-      if(i==0)
-        res = pinsertfirst(res, m_low);
-      return res;
+      if (EIGEN_PREDICT_TRUE(i != 0)) return res;
+      Packet mask = pcmp_lt(pset1<Packet>(0), plset<Packet>(0));
+      return pselect<Packet>(mask, res, pset1<Packet>(m_low));
     }
     else
     {
       Packet pi = plset<Packet>(Scalar(i));
       Packet res = padd(pset1<Packet>(m_low), pmul(pset1<Packet>(m_step), pi));
-      if(i==m_size1-unpacket_traits<Packet>::size+1)
-        res = pinsertlast(res, m_high);
-      return res;
+      if(EIGEN_PREDICT_TRUE(i != m_size1-unpacket_traits<Packet>::size+1)) return res;
+      Packet mask = pcmp_lt(plset<Packet>(0), pset1<Packet>(unpacket_traits<Packet>::size-1));
+      return pselect<Packet>(mask, res, pset1<Packet>(m_high));
     }
   }
 
   const Scalar m_low;
   const Scalar m_high;
   const Index m_size1;
   const Scalar m_step;
   const bool m_flip;
 };
 
-template <typename Scalar, typename Packet>
-struct linspaced_op_impl<Scalar,Packet,/*IsInteger*/true>
+template <typename Scalar>
+struct linspaced_op_impl<Scalar,/*IsInteger*/true>
 {
-  linspaced_op_impl(const Scalar& low, const Scalar& high, Index num_steps) :
+  EIGEN_DEVICE_FUNC linspaced_op_impl(const Scalar& low, const Scalar& high, Index num_steps) :
     m_low(low),
     m_multiplier((high-low)/convert_index<Scalar>(num_steps<=1 ? 1 : num_steps-1)),
     m_divisor(convert_index<Scalar>((high>=low?num_steps:-num_steps)+(high-low))/((numext::abs(high-low)+1)==0?1:(numext::abs(high-low)+1))),
     m_use_divisor(num_steps>1 && (numext::abs(high-low)+1)<num_steps)
   {}
 
   template<typename IndexType>
@@ -111,40 +112,40 @@
 };
 
 // ----- Linspace functor ----------------------------------------------------------------
 
 // Forward declaration (we default to random access which does not really give
 // us a speed gain when using packet access but it allows to use the functor in
 // nested expressions).
-template <typename Scalar, typename PacketType> struct linspaced_op;
-template <typename Scalar, typename PacketType> struct functor_traits< linspaced_op<Scalar,PacketType> >
+template <typename Scalar> struct linspaced_op;
+template <typename Scalar> struct functor_traits< linspaced_op<Scalar> >
 {
   enum
   {
     Cost = 1,
     PacketAccess =   (!NumTraits<Scalar>::IsInteger) && packet_traits<Scalar>::HasSetLinear && packet_traits<Scalar>::HasBlend,
                   /*&& ((!NumTraits<Scalar>::IsInteger) || packet_traits<Scalar>::HasDiv),*/ // <- vectorization for integer is currently disabled
     IsRepeatable = true
   };
 };
-template <typename Scalar, typename PacketType> struct linspaced_op
+template <typename Scalar> struct linspaced_op
 {
-  linspaced_op(const Scalar& low, const Scalar& high, Index num_steps)
+  EIGEN_DEVICE_FUNC linspaced_op(const Scalar& low, const Scalar& high, Index num_steps)
     : impl((num_steps==1 ? high : low),high,num_steps)
   {}
 
   template<typename IndexType>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType i) const { return impl(i); }
 
   template<typename Packet,typename IndexType>
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const { return impl.packetOp(i); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const { return impl.template packetOp<Packet>(i); }
 
   // This proxy object handles the actual required temporaries and the different
   // implementations (integer vs. floating point).
-  const linspaced_op_impl<Scalar,PacketType,NumTraits<Scalar>::IsInteger> impl;
+  const linspaced_op_impl<Scalar,NumTraits<Scalar>::IsInteger> impl;
 };
 
 // Linear access is automatically determined from the operator() prototypes available for the given functor.
 // If it exposes an operator()(i,j), then we assume the i and j coefficients are required independently
 // and linear access is not possible. In all other cases, linear access is enabled.
 // Users should not have to deal with this structure.
 template<typename Functor> struct functor_has_linear_access { enum { ret = !has_binary_operator<Functor>::value }; };
@@ -162,20 +163,20 @@
 template<typename Scalar,typename IndexType>
 struct has_nullary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };
 template<typename Scalar,typename IndexType>
 struct has_unary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };
 template<typename Scalar,typename IndexType>
 struct has_binary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 1}; };
 
-template<typename Scalar, typename PacketType,typename IndexType>
-struct has_nullary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };
-template<typename Scalar, typename PacketType,typename IndexType>
-struct has_unary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 1}; };
-template<typename Scalar, typename PacketType,typename IndexType>
-struct has_binary_operator<linspaced_op<Scalar,PacketType>,IndexType> { enum { value = 0}; };
+template<typename Scalar,typename IndexType>
+struct has_nullary_operator<linspaced_op<Scalar>,IndexType> { enum { value = 0}; };
+template<typename Scalar,typename IndexType>
+struct has_unary_operator<linspaced_op<Scalar>,IndexType> { enum { value = 1}; };
+template<typename Scalar,typename IndexType>
+struct has_binary_operator<linspaced_op<Scalar>,IndexType> { enum { value = 0}; };
 
 template<typename Scalar,typename IndexType>
 struct has_nullary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 1}; };
 template<typename Scalar,typename IndexType>
 struct has_unary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };
 template<typename Scalar,typename IndexType>
 struct has_binary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/functors/StlFunctors.h` & `chronogram-0.2.0/include/Eigen/src/Core/functors/StlFunctors.h`

 * *Files 11% similar despite different names*

```diff
@@ -8,14 +8,36 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_STL_FUNCTORS_H
 #define EIGEN_STL_FUNCTORS_H
 
 namespace Eigen {
 
+// Portable replacements for certain functors.
+namespace numext {
+
+template<typename T = void>
+struct equal_to {
+  typedef bool result_type;
+  EIGEN_DEVICE_FUNC bool operator()(const T& lhs, const T& rhs) const {
+    return lhs == rhs;
+  }
+};
+
+template<typename T = void>
+struct not_equal_to {
+  typedef bool result_type;
+  EIGEN_DEVICE_FUNC bool operator()(const T& lhs, const T& rhs) const {
+    return lhs != rhs;
+  }
+};
+
+}
+
+
 namespace internal {
 
 // default functor traits for STL functors:
 
 template<typename T>
 struct functor_traits<std::multiplies<T> >
 { enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };
@@ -65,29 +87,37 @@
 { enum { Cost = 1, PacketAccess = false }; };
 
 template<typename T>
 struct functor_traits<std::equal_to<T> >
 { enum { Cost = 1, PacketAccess = false }; };
 
 template<typename T>
+struct functor_traits<numext::equal_to<T> >
+  : functor_traits<std::equal_to<T> > {};
+
+template<typename T>
 struct functor_traits<std::not_equal_to<T> >
 { enum { Cost = 1, PacketAccess = false }; };
 
-#if (__cplusplus < 201103L) && (EIGEN_COMP_MSVC <= 1900)
+template<typename T>
+struct functor_traits<numext::not_equal_to<T> >
+  : functor_traits<std::not_equal_to<T> > {};
+
+#if (EIGEN_COMP_CXXVER < 11)
 // std::binder* are deprecated since c++11 and will be removed in c++17
 template<typename T>
 struct functor_traits<std::binder2nd<T> >
 { enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };
 
 template<typename T>
 struct functor_traits<std::binder1st<T> >
 { enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };
 #endif
 
-#if (__cplusplus < 201703L) && (EIGEN_COMP_MSVC < 1910)
+#if (EIGEN_COMP_CXXVER < 17)
 // std::unary_negate is deprecated since c++17 and will be removed in c++20
 template<typename T>
 struct functor_traits<std::unary_negate<T> >
 { enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };
 
 // std::binary_negate is deprecated since c++17 and will be removed in c++20
 template<typename T>
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/functors/TernaryFunctors.h` & `chronogram-0.2.0/include/Eigen/src/Core/functors/TernaryFunctors.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/functors/UnaryFunctors.h` & `chronogram-0.2.0/include/Eigen/src/Core/functors/UnaryFunctors.h`

 * *Files 19% similar despite different names*

```diff
@@ -105,36 +105,44 @@
   * \brief Template functor to compute the conjugate of a complex value
   *
   * \sa class CwiseUnaryOp, MatrixBase::conjugate()
   */
 template<typename Scalar> struct scalar_conjugate_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_conjugate_op)
   EIGEN_DEVICE_FUNC
-  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { using numext::conj; return conj(a); }
+  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::conj(a); }
   template<typename Packet>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }
 };
 template<typename Scalar>
 struct functor_traits<scalar_conjugate_op<Scalar> >
 {
   enum {
-    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,
+    Cost = 0,
+    // Yes the cost is zero even for complexes because in most cases for which
+    // the cost is used, conjugation turns to be a no-op. Some examples:
+    //   cost(a*conj(b)) == cost(a*b)
+    //   cost(a+conj(b)) == cost(a+b)
+    //   <etc.
+    // If we don't set it to zero, then:
+    //   A.conjugate().lazyProduct(B.conjugate())
+    // will bake its operands. We definitely don't want that!
     PacketAccess = packet_traits<Scalar>::HasConj
   };
 };
 
 /** \internal
   * \brief Template functor to compute the phase angle of a complex
   *
   * \sa class CwiseUnaryOp, Cwise::arg
   */
 template<typename Scalar> struct scalar_arg_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_arg_op)
   typedef typename NumTraits<Scalar>::Real result_type;
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { using numext::arg; return arg(a); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::arg(a); }
   template<typename Packet>
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const
   { return internal::parg(a); }
 };
 template<typename Scalar>
 struct functor_traits<scalar_arg_op<Scalar> >
 {
@@ -155,14 +163,52 @@
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }
 };
 template<typename Scalar, typename NewType>
 struct functor_traits<scalar_cast_op<Scalar,NewType> >
 { enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };
 
 /** \internal
+  * \brief Template functor to arithmetically shift a scalar right by a number of bits
+  *
+  * \sa class CwiseUnaryOp, MatrixBase::shift_right()
+  */
+template<typename Scalar, int N>
+struct scalar_shift_right_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_shift_right_op)
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const
+  { return a >> N; }
+  template<typename Packet>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const
+  { return internal::parithmetic_shift_right<N>(a); }
+};
+template<typename Scalar, int N>
+struct functor_traits<scalar_shift_right_op<Scalar,N> >
+{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasShift }; };
+
+/** \internal
+  * \brief Template functor to logically shift a scalar left by a number of bits
+  *
+  * \sa class CwiseUnaryOp, MatrixBase::shift_left()
+  */
+template<typename Scalar, int N>
+struct scalar_shift_left_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_shift_left_op)
+
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const
+  { return a << N; }
+  template<typename Packet>
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const
+  { return internal::plogical_shift_left<N>(a); }
+};
+template<typename Scalar, int N>
+struct functor_traits<scalar_shift_left_op<Scalar,N> >
+{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasShift }; };
+
+/** \internal
   * \brief Template functor to extract the real part of a complex
   *
   * \sa class CwiseUnaryOp, MatrixBase::real()
   */
 template<typename Scalar>
 struct scalar_real_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_real_op)
@@ -260,14 +306,34 @@
         scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value))
 #endif
   };
 };
 
 /** \internal
   *
+  * \brief Template functor to compute the exponential of a scalar - 1.
+  *
+  * \sa class CwiseUnaryOp, ArrayBase::expm1()
+  */
+template<typename Scalar> struct scalar_expm1_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_expm1_op)
+  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::expm1(a); }
+  template <typename Packet>
+  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pexpm1(a); }
+};
+template <typename Scalar>
+struct functor_traits<scalar_expm1_op<Scalar> > {
+  enum {
+    PacketAccess = packet_traits<Scalar>::HasExpm1,
+    Cost = functor_traits<scalar_exp_op<Scalar> >::Cost // TODO measure cost of expm1
+  };
+};
+
+/** \internal
+  *
   * \brief Template functor to compute the logarithm of a scalar
   *
   * \sa class CwiseUnaryOp, ArrayBase::log()
   */
 template<typename Scalar> struct scalar_log_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_log_op)
   EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log(a); }
@@ -317,23 +383,39 @@
   *
   * \brief Template functor to compute the base-10 logarithm of a scalar
   *
   * \sa class CwiseUnaryOp, Cwise::log10()
   */
 template<typename Scalar> struct scalar_log10_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_log10_op)
-  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { EIGEN_USING_STD_MATH(log10) return log10(a); }
+  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { EIGEN_USING_STD(log10) return log10(a); }
   template <typename Packet>
   EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog10(a); }
 };
 template<typename Scalar>
 struct functor_traits<scalar_log10_op<Scalar> >
 { enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog10 }; };
 
 /** \internal
+  *
+  * \brief Template functor to compute the base-2 logarithm of a scalar
+  *
+  * \sa class CwiseUnaryOp, Cwise::log2()
+  */
+template<typename Scalar> struct scalar_log2_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_log2_op)
+  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return Scalar(EIGEN_LOG2E) * numext::log(a); }
+  template <typename Packet>
+  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog2(a); }
+};
+template<typename Scalar>
+struct functor_traits<scalar_log2_op<Scalar> >
+{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };
+
+/** \internal
   * \brief Template functor to compute the square root of a scalar
   * \sa class CwiseUnaryOp, Cwise::sqrt()
   */
 template<typename Scalar> struct scalar_sqrt_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_sqrt_op)
   EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sqrt(a); }
   template <typename Packet>
@@ -352,21 +434,33 @@
     // The following numbers are based on min VSQRT throughput on Haswell.
     Cost = (sizeof(Scalar) == 8 ? 28 : 14),
 #endif
     PacketAccess = packet_traits<Scalar>::HasSqrt
   };
 };
 
+// Boolean specialization to eliminate -Wimplicit-conversion-floating-point-to-bool warnings.
+template<> struct scalar_sqrt_op<bool> {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_sqrt_op)
+  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a) const { return a; }
+  template <typename Packet>
+  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return a; }
+};
+template <>
+struct functor_traits<scalar_sqrt_op<bool> > {
+  enum { Cost = 1, PacketAccess = packet_traits<bool>::Vectorizable };
+};
+
 /** \internal
   * \brief Template functor to compute the reciprocal square root of a scalar
   * \sa class CwiseUnaryOp, Cwise::rsqrt()
   */
 template<typename Scalar> struct scalar_rsqrt_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_rsqrt_op)
-  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return Scalar(1)/numext::sqrt(a); }
+  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::rsqrt(a); }
   template <typename Packet>
   EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::prsqrt(a); }
 };
 
 template<typename Scalar>
 struct functor_traits<scalar_rsqrt_op<Scalar> >
 { enum {
@@ -524,14 +618,31 @@
                 : (6 * NumTraits<Scalar>::AddCost +
                    3 * NumTraits<Scalar>::MulCost +
                    2 * scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value +
                    functor_traits<scalar_exp_op<Scalar> >::Cost))
   };
 };
 
+#if EIGEN_HAS_CXX11_MATH
+/** \internal
+  * \brief Template functor to compute the atanh of a scalar
+  * \sa class CwiseUnaryOp, ArrayBase::atanh()
+  */
+template <typename Scalar>
+struct scalar_atanh_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_atanh_op)
+  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::atanh(a); }
+};
+
+template <typename Scalar>
+struct functor_traits<scalar_atanh_op<Scalar> > {
+  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };
+};
+#endif
+
 /** \internal
   * \brief Template functor to compute the sinh of a scalar
   * \sa class CwiseUnaryOp, ArrayBase::sinh()
   */
 template<typename Scalar> struct scalar_sinh_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_sinh_op)
   EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sinh(a); }
@@ -543,14 +654,31 @@
 {
   enum {
     Cost = 5 * NumTraits<Scalar>::MulCost,
     PacketAccess = packet_traits<Scalar>::HasSinh
   };
 };
 
+#if EIGEN_HAS_CXX11_MATH
+/** \internal
+  * \brief Template functor to compute the asinh of a scalar
+  * \sa class CwiseUnaryOp, ArrayBase::asinh()
+  */
+template <typename Scalar>
+struct scalar_asinh_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_asinh_op)
+  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::asinh(a); }
+};
+
+template <typename Scalar>
+struct functor_traits<scalar_asinh_op<Scalar> > {
+  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };
+};
+#endif
+
 /** \internal
   * \brief Template functor to compute the cosh of a scalar
   * \sa class CwiseUnaryOp, ArrayBase::cosh()
   */
 template<typename Scalar> struct scalar_cosh_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_cosh_op)
   EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::cosh(a); }
@@ -562,29 +690,50 @@
 {
   enum {
     Cost = 5 * NumTraits<Scalar>::MulCost,
     PacketAccess = packet_traits<Scalar>::HasCosh
   };
 };
 
+#if EIGEN_HAS_CXX11_MATH
+/** \internal
+  * \brief Template functor to compute the acosh of a scalar
+  * \sa class CwiseUnaryOp, ArrayBase::acosh()
+  */
+template <typename Scalar>
+struct scalar_acosh_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_acosh_op)
+  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::acosh(a); }
+};
+
+template <typename Scalar>
+struct functor_traits<scalar_acosh_op<Scalar> > {
+  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };
+};
+#endif
+
 /** \internal
   * \brief Template functor to compute the inverse of a scalar
   * \sa class CwiseUnaryOp, Cwise::inverse()
   */
 template<typename Scalar>
 struct scalar_inverse_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_inverse_op)
   EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return Scalar(1)/a; }
   template<typename Packet>
   EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const
   { return internal::pdiv(pset1<Packet>(Scalar(1)),a); }
 };
-template<typename Scalar>
-struct functor_traits<scalar_inverse_op<Scalar> >
-{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };
+template <typename Scalar>
+struct functor_traits<scalar_inverse_op<Scalar> > {
+  enum {
+    PacketAccess = packet_traits<Scalar>::HasDiv,
+    Cost = scalar_div_cost<Scalar, PacketAccess>::value
+  };
+};
 
 /** \internal
   * \brief Template functor to compute the square of a scalar
   * \sa class CwiseUnaryOp, Cwise::square()
   */
 template<typename Scalar>
 struct scalar_square_op {
@@ -594,14 +743,27 @@
   EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const
   { return internal::pmul(a,a); }
 };
 template<typename Scalar>
 struct functor_traits<scalar_square_op<Scalar> >
 { enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };
 
+// Boolean specialization to avoid -Wint-in-bool-context warnings on GCC.
+template<>
+struct scalar_square_op<bool> {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_square_op)
+  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a) const { return a; }
+  template<typename Packet>
+  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const
+  { return a; }
+};
+template<>
+struct functor_traits<scalar_square_op<bool> >
+{ enum { Cost = 0, PacketAccess = packet_traits<bool>::Vectorizable }; };
+
 /** \internal
   * \brief Template functor to compute the cube of a scalar
   * \sa class CwiseUnaryOp, Cwise::cube()
   */
 template<typename Scalar>
 struct scalar_cube_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_cube_op)
@@ -610,14 +772,27 @@
   EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const
   { return internal::pmul(a,pmul(a,a)); }
 };
 template<typename Scalar>
 struct functor_traits<scalar_cube_op<Scalar> >
 { enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };
 
+// Boolean specialization to avoid -Wint-in-bool-context warnings on GCC.
+template<>
+struct scalar_cube_op<bool> {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_cube_op)
+  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a) const { return a; }
+  template<typename Packet>
+  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const
+  { return a; }
+};
+template<>
+struct functor_traits<scalar_cube_op<bool> >
+{ enum { Cost = 0, PacketAccess = packet_traits<bool>::Vectorizable }; };
+
 /** \internal
   * \brief Template functor to compute the rounded value of a scalar
   * \sa class CwiseUnaryOp, ArrayBase::round()
   */
 template<typename Scalar> struct scalar_round_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_round_op)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::round(a); }
@@ -649,14 +824,33 @@
   enum {
     Cost = NumTraits<Scalar>::MulCost,
     PacketAccess = packet_traits<Scalar>::HasFloor
   };
 };
 
 /** \internal
+  * \brief Template functor to compute the rounded (with current rounding mode)  value of a scalar
+  * \sa class CwiseUnaryOp, ArrayBase::rint()
+  */
+template<typename Scalar> struct scalar_rint_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_rint_op)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::rint(a); }
+  template <typename Packet>
+  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::print(a); }
+};
+template<typename Scalar>
+struct functor_traits<scalar_rint_op<Scalar> >
+{
+  enum {
+    Cost = NumTraits<Scalar>::MulCost,
+    PacketAccess = packet_traits<Scalar>::HasRint
+  };
+};
+
+/** \internal
   * \brief Template functor to compute the ceil of a scalar
   * \sa class CwiseUnaryOp, ArrayBase::ceil()
   */
 template<typename Scalar> struct scalar_ceil_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_ceil_op)
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::ceil(a); }
   template <typename Packet>
@@ -674,15 +868,21 @@
 /** \internal
   * \brief Template functor to compute whether a scalar is NaN
   * \sa class CwiseUnaryOp, ArrayBase::isnan()
   */
 template<typename Scalar> struct scalar_isnan_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_isnan_op)
   typedef bool result_type;
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isnan)(a); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const {
+#if defined(SYCL_DEVICE_ONLY)
+    return numext::isnan(a);
+#else
+    return (numext::isnan)(a);
+#endif
+  }
 };
 template<typename Scalar>
 struct functor_traits<scalar_isnan_op<Scalar> >
 {
   enum {
     Cost = NumTraits<Scalar>::MulCost,
     PacketAccess = false
@@ -692,15 +892,21 @@
 /** \internal
   * \brief Template functor to check whether a scalar is +/-inf
   * \sa class CwiseUnaryOp, ArrayBase::isinf()
   */
 template<typename Scalar> struct scalar_isinf_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_isinf_op)
   typedef bool result_type;
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isinf)(a); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const {
+#if defined(SYCL_DEVICE_ONLY)
+    return numext::isinf(a);
+#else
+    return (numext::isinf)(a);
+#endif
+  }
 };
 template<typename Scalar>
 struct functor_traits<scalar_isinf_op<Scalar> >
 {
   enum {
     Cost = NumTraits<Scalar>::MulCost,
     PacketAccess = false
@@ -710,15 +916,21 @@
 /** \internal
   * \brief Template functor to check whether a scalar has a finite value
   * \sa class CwiseUnaryOp, ArrayBase::isfinite()
   */
 template<typename Scalar> struct scalar_isfinite_op {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_isfinite_op)
   typedef bool result_type;
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return (numext::isfinite)(a); }
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const {
+#if defined(SYCL_DEVICE_ONLY)
+    return numext::isfinite(a);
+#else
+    return (numext::isfinite)(a);
+#endif
+  }
 };
 template<typename Scalar>
 struct functor_traits<scalar_isfinite_op<Scalar> >
 {
   enum {
     Cost = NumTraits<Scalar>::MulCost,
     PacketAccess = false
@@ -742,51 +954,178 @@
   };
 };
 
 /** \internal
   * \brief Template functor to compute the signum of a scalar
   * \sa class CwiseUnaryOp, Cwise::sign()
   */
-template<typename Scalar,bool iscpx=(NumTraits<Scalar>::IsComplex!=0) > struct scalar_sign_op;
+template<typename Scalar,bool is_complex=(NumTraits<Scalar>::IsComplex!=0), bool is_integer=(NumTraits<Scalar>::IsInteger!=0) > struct scalar_sign_op;
 template<typename Scalar>
-struct scalar_sign_op<Scalar,false> {
+struct scalar_sign_op<Scalar, false, true> {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op)
   EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const
   {
       return Scalar( (a>Scalar(0)) - (a<Scalar(0)) );
   }
   //TODO
   //template <typename Packet>
   //EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psign(a); }
 };
+
 template<typename Scalar>
-struct scalar_sign_op<Scalar,true> {
+struct scalar_sign_op<Scalar, false, false> {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op)
+  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const
+  {
+    return (numext::isnan)(a) ? a : Scalar( (a>Scalar(0)) - (a<Scalar(0)) );
+  }
+  //TODO
+  //template <typename Packet>
+  //EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psign(a); }
+};
+
+template<typename Scalar, bool is_integer>
+struct scalar_sign_op<Scalar,true, is_integer> {
   EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op)
   EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const
   {
     typedef typename NumTraits<Scalar>::Real real_type;
     real_type aa = numext::abs(a);
     if (aa==real_type(0))
       return Scalar(0);
     aa = real_type(1)/aa;
-    return Scalar(real(a)*aa, imag(a)*aa );
+    return Scalar(a.real()*aa, a.imag()*aa );
   }
   //TODO
   //template <typename Packet>
   //EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psign(a); }
 };
 template<typename Scalar>
 struct functor_traits<scalar_sign_op<Scalar> >
 { enum {
-    Cost = 
+    Cost =
         NumTraits<Scalar>::IsComplex
         ? ( 8*NumTraits<Scalar>::MulCost  ) // roughly
         : ( 3*NumTraits<Scalar>::AddCost),
     PacketAccess = packet_traits<Scalar>::HasSign
   };
 };
 
+/** \internal
+  * \brief Template functor to compute the logistic function of a scalar
+  * \sa class CwiseUnaryOp, ArrayBase::logistic()
+  */
+template <typename T>
+struct scalar_logistic_op {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_logistic_op)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T operator()(const T& x) const {
+    return packetOp(x);
+  }
+
+  template <typename Packet> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  Packet packetOp(const Packet& x) const {
+    const Packet one = pset1<Packet>(T(1));
+    return pdiv(one, padd(one, pexp(pnegate(x))));
+  }
+};
+
+#ifndef EIGEN_GPU_COMPILE_PHASE
+/** \internal
+  * \brief Template specialization of the logistic function for float.
+  *
+  *  Uses just a 9/10-degree rational interpolant which
+  *  interpolates 1/(1+exp(-x)) - 0.5 up to a couple of ulps in the range
+  *  [-9, 18]. Below -9 we use the more accurate approximation
+  *  1/(1+exp(-x)) ~= exp(x), and above 18 the logistic function is 1 withing
+  *  one ulp. The shifted logistic is interpolated because it was easier to
+  *  make the fit converge.
+  *
+  */
+template <>
+struct scalar_logistic_op<float> {
+  EIGEN_EMPTY_STRUCT_CTOR(scalar_logistic_op)
+  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float operator()(const float& x) const {
+    return packetOp(x);
+  }
+
+  template <typename Packet> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  Packet packetOp(const Packet& _x) const {
+    const Packet cutoff_lower = pset1<Packet>(-9.f);
+    const Packet lt_mask = pcmp_lt<Packet>(_x, cutoff_lower);
+    const bool any_small = predux_any(lt_mask);
+
+    // The upper cut-off is the smallest x for which the rational approximation evaluates to 1.
+    // Choosing this value saves us a few instructions clamping the results at the end.
+#ifdef EIGEN_VECTORIZE_FMA
+    const Packet cutoff_upper = pset1<Packet>(15.7243833541870117f);
+#else
+    const Packet cutoff_upper = pset1<Packet>(15.6437711715698242f);
+#endif
+    const Packet x = pmin(_x, cutoff_upper);
+
+    // The monomial coefficients of the numerator polynomial (odd).
+    const Packet alpha_1 = pset1<Packet>(2.48287947061529e-01f);
+    const Packet alpha_3 = pset1<Packet>(8.51377133304701e-03f);
+    const Packet alpha_5 = pset1<Packet>(6.08574864600143e-05f);
+    const Packet alpha_7 = pset1<Packet>(1.15627324459942e-07f);
+    const Packet alpha_9 = pset1<Packet>(4.37031012579801e-11f);
+
+    // The monomial coefficients of the denominator polynomial (even).
+    const Packet beta_0 = pset1<Packet>(9.93151921023180e-01f);
+    const Packet beta_2 = pset1<Packet>(1.16817656904453e-01f);
+    const Packet beta_4 = pset1<Packet>(1.70198817374094e-03f);
+    const Packet beta_6 = pset1<Packet>(6.29106785017040e-06f);
+    const Packet beta_8 = pset1<Packet>(5.76102136993427e-09f);
+    const Packet beta_10 = pset1<Packet>(6.10247389755681e-13f);
+
+    // Since the polynomials are odd/even, we need x^2.
+    const Packet x2 = pmul(x, x);
+
+    // Evaluate the numerator polynomial p.
+    Packet p = pmadd(x2, alpha_9, alpha_7);
+    p = pmadd(x2, p, alpha_5);
+    p = pmadd(x2, p, alpha_3);
+    p = pmadd(x2, p, alpha_1);
+    p = pmul(x, p);
+
+    // Evaluate the denominator polynomial q.
+    Packet q = pmadd(x2, beta_10, beta_8);
+    q = pmadd(x2, q, beta_6);
+    q = pmadd(x2, q, beta_4);
+    q = pmadd(x2, q, beta_2);
+    q = pmadd(x2, q, beta_0);
+    // Divide the numerator by the denominator and shift it up.
+    const Packet logistic = padd(pdiv(p, q), pset1<Packet>(0.5f));
+    if (EIGEN_PREDICT_FALSE(any_small)) {
+      const Packet exponential = pexp(_x);
+      return pselect(lt_mask, exponential, logistic);
+    } else {
+      return logistic;
+    }
+  }
+};
+#endif  // #ifndef EIGEN_GPU_COMPILE_PHASE
+
+template <typename T>
+struct functor_traits<scalar_logistic_op<T> > {
+  enum {
+    // The cost estimate for float here here is for the common(?) case where
+    // all arguments are greater than -9.
+    Cost = scalar_div_cost<T, packet_traits<T>::HasDiv>::value +
+           (internal::is_same<T, float>::value
+                ? NumTraits<T>::AddCost * 15 + NumTraits<T>::MulCost * 11
+                : NumTraits<T>::AddCost * 2 +
+                      functor_traits<scalar_exp_op<T> >::Cost),
+    PacketAccess =
+        packet_traits<T>::HasAdd && packet_traits<T>::HasDiv &&
+        (internal::is_same<T, float>::value
+             ? packet_traits<T>::HasMul && packet_traits<T>::HasMax &&
+                   packet_traits<T>::HasMin
+             : packet_traits<T>::HasNegate && packet_traits<T>::HasExp)
+  };
+};
+
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_FUNCTORS_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/GeneralBlockPanelKernel.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/GeneralBlockPanelKernel.h`

 * *Files 23% similar despite different names*

```diff
@@ -24,5073 +24,6755 @@
 00000170: 6966 6e64 6566 2045 4947 454e 5f47 454e  ifndef EIGEN_GEN
 00000180: 4552 414c 5f42 4c4f 434b 5f50 414e 454c  ERAL_BLOCK_PANEL
 00000190: 5f48 0a23 6465 6669 6e65 2045 4947 454e  _H.#define EIGEN
 000001a0: 5f47 454e 4552 414c 5f42 4c4f 434b 5f50  _GENERAL_BLOCK_P
 000001b0: 414e 454c 5f48 0a0a 0a6e 616d 6573 7061  ANEL_H...namespa
 000001c0: 6365 2045 6967 656e 207b 0a0a 6e61 6d65  ce Eigen {..name
 000001d0: 7370 6163 6520 696e 7465 726e 616c 207b  space internal {
-000001e0: 0a0a 7465 6d70 6c61 7465 3c74 7970 656e  ..template<typen
-000001f0: 616d 6520 5f4c 6873 5363 616c 6172 2c20  ame _LhsScalar, 
-00000200: 7479 7065 6e61 6d65 205f 5268 7353 6361  typename _RhsSca
-00000210: 6c61 722c 2062 6f6f 6c20 5f43 6f6e 6a4c  lar, bool _ConjL
-00000220: 6873 3d66 616c 7365 2c20 626f 6f6c 205f  hs=false, bool _
-00000230: 436f 6e6a 5268 733d 6661 6c73 653e 0a63  ConjRhs=false>.c
-00000240: 6c61 7373 2067 6562 705f 7472 6169 7473  lass gebp_traits
-00000250: 3b0a 0a0a 2f2a 2a20 5c69 6e74 6572 6e61  ;.../** \interna
-00000260: 6c20 5c72 6574 7572 6e73 2062 2069 6620  l \returns b if 
-00000270: 613c 3d30 2c20 616e 6420 7265 7475 726e  a<=0, and return
-00000280: 7320 6120 6f74 6865 7277 6973 652e 202a  s a otherwise. *
-00000290: 2f0a 696e 6c69 6e65 2073 7464 3a3a 7074  /.inline std::pt
-000002a0: 7264 6966 665f 7420 6d61 6e61 6765 5f63  rdiff_t manage_c
-000002b0: 6163 6869 6e67 5f73 697a 6573 5f68 656c  aching_sizes_hel
-000002c0: 7065 7228 7374 643a 3a70 7472 6469 6666  per(std::ptrdiff
-000002d0: 5f74 2061 2c20 7374 643a 3a70 7472 6469  _t a, std::ptrdi
-000002e0: 6666 5f74 2062 290a 7b0a 2020 7265 7475  ff_t b).{.  retu
-000002f0: 726e 2061 3c3d 3020 3f20 6220 3a20 613b  rn a<=0 ? b : a;
-00000300: 0a7d 0a0a 2369 6620 4549 4745 4e5f 4152  .}..#if EIGEN_AR
-00000310: 4348 5f69 3338 365f 4f52 5f78 3836 5f36  CH_i386_OR_x86_6
-00000320: 340a 636f 6e73 7420 7374 643a 3a70 7472  4.const std::ptr
-00000330: 6469 6666 5f74 2064 6566 6175 6c74 4c31  diff_t defaultL1
-00000340: 4361 6368 6553 697a 6520 3d20 3332 2a31  CacheSize = 32*1
-00000350: 3032 343b 0a63 6f6e 7374 2073 7464 3a3a  024;.const std::
-00000360: 7074 7264 6966 665f 7420 6465 6661 756c  ptrdiff_t defaul
-00000370: 744c 3243 6163 6865 5369 7a65 203d 2032  tL2CacheSize = 2
-00000380: 3536 2a31 3032 343b 0a63 6f6e 7374 2073  56*1024;.const s
-00000390: 7464 3a3a 7074 7264 6966 665f 7420 6465  td::ptrdiff_t de
-000003a0: 6661 756c 744c 3343 6163 6865 5369 7a65  faultL3CacheSize
-000003b0: 203d 2032 2a31 3032 342a 3130 3234 3b0a   = 2*1024*1024;.
-000003c0: 2365 6c73 650a 636f 6e73 7420 7374 643a  #else.const std:
-000003d0: 3a70 7472 6469 6666 5f74 2064 6566 6175  :ptrdiff_t defau
-000003e0: 6c74 4c31 4361 6368 6553 697a 6520 3d20  ltL1CacheSize = 
-000003f0: 3136 2a31 3032 343b 0a63 6f6e 7374 2073  16*1024;.const s
-00000400: 7464 3a3a 7074 7264 6966 665f 7420 6465  td::ptrdiff_t de
-00000410: 6661 756c 744c 3243 6163 6865 5369 7a65  faultL2CacheSize
-00000420: 203d 2035 3132 2a31 3032 343b 0a63 6f6e   = 512*1024;.con
-00000430: 7374 2073 7464 3a3a 7074 7264 6966 665f  st std::ptrdiff_
-00000440: 7420 6465 6661 756c 744c 3343 6163 6865  t defaultL3Cache
-00000450: 5369 7a65 203d 2035 3132 2a31 3032 343b  Size = 512*1024;
-00000460: 0a23 656e 6469 660a 0a2f 2a2a 205c 696e  .#endif../** \in
-00000470: 7465 726e 616c 202a 2f0a 7374 7275 6374  ternal */.struct
-00000480: 2043 6163 6865 5369 7a65 7320 7b0a 2020   CacheSizes {.  
-00000490: 4361 6368 6553 697a 6573 2829 3a20 6d5f  CacheSizes(): m_
-000004a0: 6c31 282d 3129 2c6d 5f6c 3228 2d31 292c  l1(-1),m_l2(-1),
-000004b0: 6d5f 6c33 282d 3129 207b 0a20 2020 2069  m_l3(-1) {.    i
-000004c0: 6e74 206c 3143 6163 6865 5369 7a65 2c20  nt l1CacheSize, 
-000004d0: 6c32 4361 6368 6553 697a 652c 206c 3343  l2CacheSize, l3C
-000004e0: 6163 6865 5369 7a65 3b0a 2020 2020 7175  acheSize;.    qu
-000004f0: 6572 7943 6163 6865 5369 7a65 7328 6c31  eryCacheSizes(l1
-00000500: 4361 6368 6553 697a 652c 206c 3243 6163  CacheSize, l2Cac
-00000510: 6865 5369 7a65 2c20 6c33 4361 6368 6553  heSize, l3CacheS
-00000520: 697a 6529 3b0a 2020 2020 6d5f 6c31 203d  ize);.    m_l1 =
-00000530: 206d 616e 6167 655f 6361 6368 696e 675f   manage_caching_
-00000540: 7369 7a65 735f 6865 6c70 6572 286c 3143  sizes_helper(l1C
-00000550: 6163 6865 5369 7a65 2c20 6465 6661 756c  acheSize, defaul
-00000560: 744c 3143 6163 6865 5369 7a65 293b 0a20  tL1CacheSize);. 
-00000570: 2020 206d 5f6c 3220 3d20 6d61 6e61 6765     m_l2 = manage
-00000580: 5f63 6163 6869 6e67 5f73 697a 6573 5f68  _caching_sizes_h
-00000590: 656c 7065 7228 6c32 4361 6368 6553 697a  elper(l2CacheSiz
-000005a0: 652c 2064 6566 6175 6c74 4c32 4361 6368  e, defaultL2Cach
-000005b0: 6553 697a 6529 3b0a 2020 2020 6d5f 6c33  eSize);.    m_l3
-000005c0: 203d 206d 616e 6167 655f 6361 6368 696e   = manage_cachin
-000005d0: 675f 7369 7a65 735f 6865 6c70 6572 286c  g_sizes_helper(l
-000005e0: 3343 6163 6865 5369 7a65 2c20 6465 6661  3CacheSize, defa
-000005f0: 756c 744c 3343 6163 6865 5369 7a65 293b  ultL3CacheSize);
-00000600: 0a20 207d 0a0a 2020 7374 643a 3a70 7472  .  }..  std::ptr
-00000610: 6469 6666 5f74 206d 5f6c 313b 0a20 2073  diff_t m_l1;.  s
-00000620: 7464 3a3a 7074 7264 6966 665f 7420 6d5f  td::ptrdiff_t m_
-00000630: 6c32 3b0a 2020 7374 643a 3a70 7472 6469  l2;.  std::ptrdi
-00000640: 6666 5f74 206d 5f6c 333b 0a7d 3b0a 0a0a  ff_t m_l3;.};...
-00000650: 2f2a 2a20 5c69 6e74 6572 6e61 6c20 2a2f  /** \internal */
-00000660: 0a69 6e6c 696e 6520 766f 6964 206d 616e  .inline void man
-00000670: 6167 655f 6361 6368 696e 675f 7369 7a65  age_caching_size
-00000680: 7328 4163 7469 6f6e 2061 6374 696f 6e2c  s(Action action,
-00000690: 2073 7464 3a3a 7074 7264 6966 665f 742a   std::ptrdiff_t*
-000006a0: 206c 312c 2073 7464 3a3a 7074 7264 6966   l1, std::ptrdif
-000006b0: 665f 742a 206c 322c 2073 7464 3a3a 7074  f_t* l2, std::pt
-000006c0: 7264 6966 665f 742a 206c 3329 0a7b 0a20  rdiff_t* l3).{. 
-000006d0: 2073 7461 7469 6320 4361 6368 6553 697a   static CacheSiz
-000006e0: 6573 206d 5f63 6163 6865 5369 7a65 733b  es m_cacheSizes;
-000006f0: 0a0a 2020 6966 2861 6374 696f 6e3d 3d53  ..  if(action==S
-00000700: 6574 4163 7469 6f6e 290a 2020 7b0a 2020  etAction).  {.  
-00000710: 2020 2f2f 2073 6574 2074 6865 2063 7075    // set the cpu
-00000720: 2063 6163 6865 2073 697a 6520 616e 6420   cache size and 
-00000730: 6361 6368 6520 616c 6c20 626c 6f63 6b20  cache all block 
-00000740: 7369 7a65 7320 6672 6f6d 2061 2067 6c6f  sizes from a glo
-00000750: 6261 6c20 6361 6368 6520 7369 7a65 2069  bal cache size i
-00000760: 6e20 6279 7465 0a20 2020 2065 6967 656e  n byte.    eigen
-00000770: 5f69 6e74 6572 6e61 6c5f 6173 7365 7274  _internal_assert
-00000780: 286c 3121 3d30 2026 2620 6c32 213d 3029  (l1!=0 && l2!=0)
-00000790: 3b0a 2020 2020 6d5f 6361 6368 6553 697a  ;.    m_cacheSiz
-000007a0: 6573 2e6d 5f6c 3120 3d20 2a6c 313b 0a20  es.m_l1 = *l1;. 
-000007b0: 2020 206d 5f63 6163 6865 5369 7a65 732e     m_cacheSizes.
-000007c0: 6d5f 6c32 203d 202a 6c32 3b0a 2020 2020  m_l2 = *l2;.    
-000007d0: 6d5f 6361 6368 6553 697a 6573 2e6d 5f6c  m_cacheSizes.m_l
-000007e0: 3320 3d20 2a6c 333b 0a20 207d 0a20 2065  3 = *l3;.  }.  e
-000007f0: 6c73 6520 6966 2861 6374 696f 6e3d 3d47  lse if(action==G
-00000800: 6574 4163 7469 6f6e 290a 2020 7b0a 2020  etAction).  {.  
-00000810: 2020 6569 6765 6e5f 696e 7465 726e 616c    eigen_internal
-00000820: 5f61 7373 6572 7428 6c31 213d 3020 2626  _assert(l1!=0 &&
-00000830: 206c 3221 3d30 293b 0a20 2020 202a 6c31   l2!=0);.    *l1
-00000840: 203d 206d 5f63 6163 6865 5369 7a65 732e   = m_cacheSizes.
-00000850: 6d5f 6c31 3b0a 2020 2020 2a6c 3220 3d20  m_l1;.    *l2 = 
-00000860: 6d5f 6361 6368 6553 697a 6573 2e6d 5f6c  m_cacheSizes.m_l
-00000870: 323b 0a20 2020 202a 6c33 203d 206d 5f63  2;.    *l3 = m_c
-00000880: 6163 6865 5369 7a65 732e 6d5f 6c33 3b0a  acheSizes.m_l3;.
-00000890: 2020 7d0a 2020 656c 7365 0a20 207b 0a20    }.  else.  {. 
-000008a0: 2020 2065 6967 656e 5f69 6e74 6572 6e61     eigen_interna
-000008b0: 6c5f 6173 7365 7274 2866 616c 7365 293b  l_assert(false);
-000008c0: 0a20 207d 0a7d 0a0a 2f2a 2048 656c 7065  .  }.}../* Helpe
-000008d0: 7220 666f 7220 636f 6d70 7574 6550 726f  r for computePro
-000008e0: 6475 6374 426c 6f63 6b69 6e67 5369 7a65  ductBlockingSize
-000008f0: 732e 0a20 2a0a 202a 2047 6976 656e 2061  s.. *. * Given a
-00000900: 206d 2078 206b 2074 696d 6573 206b 2078   m x k times k x
-00000910: 206e 206d 6174 7269 7820 7072 6f64 7563   n matrix produc
-00000920: 7420 6f66 2073 6361 6c61 7220 7479 7065  t of scalar type
-00000930: 7320 5c63 204c 6873 5363 616c 6172 2061  s \c LhsScalar a
-00000940: 6e64 205c 6320 5268 7353 6361 6c61 722c  nd \c RhsScalar,
-00000950: 0a20 2a20 7468 6973 2066 756e 6374 696f  . * this functio
-00000960: 6e20 636f 6d70 7574 6573 2074 6865 2062  n computes the b
-00000970: 6c6f 636b 696e 6720 7369 7a65 2070 6172  locking size par
-00000980: 616d 6574 6572 7320 616c 6f6e 6720 7468  ameters along th
-00000990: 6520 7265 7370 6563 7469 7665 2064 696d  e respective dim
-000009a0: 656e 7369 6f6e 730a 202a 2066 6f72 206d  ensions. * for m
-000009b0: 6174 7269 7820 7072 6f64 7563 7473 2061  atrix products a
-000009c0: 6e64 2072 656c 6174 6564 2061 6c67 6f72  nd related algor
-000009d0: 6974 686d 732e 2054 6865 2062 6c6f 636b  ithms. The block
-000009e0: 696e 6720 7369 7a65 7320 6465 7065 6e64  ing sizes depend
-000009f0: 7320 6f6e 2076 6172 696f 7573 0a20 2a20  s on various. * 
-00000a00: 7061 7261 6d65 7465 7273 3a0a 202a 202d  parameters:. * -
-00000a10: 2074 6865 204c 3120 616e 6420 4c32 2063   the L1 and L2 c
-00000a20: 6163 6865 2073 697a 6573 2c0a 202a 202d  ache sizes,. * -
-00000a30: 2074 6865 2072 6567 6973 7465 7220 6c65   the register le
-00000a40: 7665 6c20 626c 6f63 6b69 6e67 2073 697a  vel blocking siz
-00000a50: 6573 2064 6566 696e 6564 2062 7920 6765  es defined by ge
-00000a60: 6270 5f74 7261 6974 732c 0a20 2a20 2d20  bp_traits,. * - 
-00000a70: 7468 6520 6e75 6d62 6572 206f 6620 7363  the number of sc
-00000a80: 616c 6172 7320 7468 6174 2066 6974 2069  alars that fit i
-00000a90: 6e74 6f20 6120 7061 636b 6574 2028 7768  nto a packet (wh
-00000aa0: 656e 2076 6563 746f 7269 7a61 7469 6f6e  en vectorization
-00000ab0: 2069 7320 656e 6162 6c65 6429 2e0a 202a   is enabled).. *
-00000ac0: 0a20 2a20 5c73 6120 7365 7443 7075 4361  . * \sa setCpuCa
-00000ad0: 6368 6553 697a 6573 202a 2f0a 0a74 656d  cheSizes */..tem
-00000ae0: 706c 6174 653c 7479 7065 6e61 6d65 204c  plate<typename L
-00000af0: 6873 5363 616c 6172 2c20 7479 7065 6e61  hsScalar, typena
-00000b00: 6d65 2052 6873 5363 616c 6172 2c20 696e  me RhsScalar, in
-00000b10: 7420 4b63 4661 6374 6f72 2c20 7479 7065  t KcFactor, type
-00000b20: 6e61 6d65 2049 6e64 6578 3e0a 766f 6964  name Index>.void
-00000b30: 2065 7661 6c75 6174 6550 726f 6475 6374   evaluateProduct
-00000b40: 426c 6f63 6b69 6e67 5369 7a65 7348 6575  BlockingSizesHeu
-00000b50: 7269 7374 6963 2849 6e64 6578 2620 6b2c  ristic(Index& k,
-00000b60: 2049 6e64 6578 2620 6d2c 2049 6e64 6578   Index& m, Index
-00000b70: 2620 6e2c 2049 6e64 6578 206e 756d 5f74  & n, Index num_t
-00000b80: 6872 6561 6473 203d 2031 290a 7b0a 2020  hreads = 1).{.  
-00000b90: 7479 7065 6465 6620 6765 6270 5f74 7261  typedef gebp_tra
-00000ba0: 6974 733c 4c68 7353 6361 6c61 722c 5268  its<LhsScalar,Rh
-00000bb0: 7353 6361 6c61 723e 2054 7261 6974 733b  sScalar> Traits;
-00000bc0: 0a0a 2020 2f2f 2045 7870 6c61 6e61 7469  ..  // Explanati
-00000bd0: 6f6e 733a 0a20 202f 2f20 4c65 7427 7320  ons:.  // Let's 
-00000be0: 7265 6361 6c6c 2074 6861 7420 7468 6520  recall that the 
-00000bf0: 7072 6f64 7563 7420 616c 676f 7269 7468  product algorith
-00000c00: 6d73 2066 6f72 6d20 6d63 2078 206b 6320  ms form mc x kc 
-00000c10: 7665 7274 6963 616c 2070 616e 656c 7320  vertical panels 
-00000c20: 4127 206f 6e20 7468 6520 6c68 7320 616e  A' on the lhs an
-00000c30: 640a 2020 2f2f 206b 6320 7820 6e63 2062  d.  // kc x nc b
-00000c40: 6c6f 636b 7320 4227 206f 6e20 7468 6520  locks B' on the 
-00000c50: 7268 732e 2042 2720 6861 7320 746f 2066  rhs. B' has to f
-00000c60: 6974 2069 6e74 6f20 4c32 2f4c 3320 6361  it into L2/L3 ca
-00000c70: 6368 652e 204d 6f72 656f 7665 722c 2041  che. Moreover, A
-00000c80: 2720 6973 2070 726f 6365 7373 6564 0a20  ' is processed. 
-00000c90: 202f 2f20 7065 7220 6d72 2078 206b 6320   // per mr x kc 
-00000ca0: 686f 7269 7a6f 6e74 616c 2073 6d61 6c6c  horizontal small
-00000cb0: 2070 616e 656c 7320 7768 6572 6520 6d72   panels where mr
-00000cc0: 2069 7320 7468 6520 626c 6f63 6b69 6e67   is the blocking
-00000cd0: 2073 697a 6520 616c 6f6e 6720 7468 6520   size along the 
-00000ce0: 6d20 6469 6d65 6e73 696f 6e0a 2020 2f2f  m dimension.  //
-00000cf0: 2061 7420 7468 6520 7265 6769 7374 6572   at the register
-00000d00: 206c 6576 656c 2e20 5468 6973 2073 6d61   level. This sma
-00000d10: 6c6c 2068 6f72 697a 6f6e 7461 6c20 7061  ll horizontal pa
-00000d20: 6e65 6c20 6861 7320 746f 2073 7461 7920  nel has to stay 
-00000d30: 7769 7468 696e 204c 3120 6361 6368 652e  within L1 cache.
-00000d40: 0a20 2073 7464 3a3a 7074 7264 6966 665f  .  std::ptrdiff_
-00000d50: 7420 6c31 2c20 6c32 2c20 6c33 3b0a 2020  t l1, l2, l3;.  
-00000d60: 6d61 6e61 6765 5f63 6163 6869 6e67 5f73  manage_caching_s
-00000d70: 697a 6573 2847 6574 4163 7469 6f6e 2c20  izes(GetAction, 
-00000d80: 266c 312c 2026 6c32 2c20 266c 3329 3b0a  &l1, &l2, &l3);.
-00000d90: 0a20 2069 6620 286e 756d 5f74 6872 6561  .  if (num_threa
-00000da0: 6473 203e 2031 2920 7b0a 2020 2020 7479  ds > 1) {.    ty
-00000db0: 7065 6465 6620 7479 7065 6e61 6d65 2054  pedef typename T
-00000dc0: 7261 6974 733a 3a52 6573 5363 616c 6172  raits::ResScalar
-00000dd0: 2052 6573 5363 616c 6172 3b0a 2020 2020   ResScalar;.    
-00000de0: 656e 756d 207b 0a20 2020 2020 206b 6469  enum {.      kdi
-00000df0: 7620 3d20 4b63 4661 6374 6f72 202a 2028  v = KcFactor * (
-00000e00: 5472 6169 7473 3a3a 6d72 202a 2073 697a  Traits::mr * siz
-00000e10: 656f 6628 4c68 7353 6361 6c61 7229 202b  eof(LhsScalar) +
-00000e20: 2054 7261 6974 733a 3a6e 7220 2a20 7369   Traits::nr * si
-00000e30: 7a65 6f66 2852 6873 5363 616c 6172 2929  zeof(RhsScalar))
-00000e40: 2c0a 2020 2020 2020 6b73 7562 203d 2054  ,.      ksub = T
-00000e50: 7261 6974 733a 3a6d 7220 2a20 5472 6169  raits::mr * Trai
-00000e60: 7473 3a3a 6e72 202a 2073 697a 656f 6628  ts::nr * sizeof(
-00000e70: 5265 7353 6361 6c61 7229 2c0a 2020 2020  ResScalar),.    
-00000e80: 2020 6b72 203d 2038 2c0a 2020 2020 2020    kr = 8,.      
-00000e90: 6d72 203d 2054 7261 6974 733a 3a6d 722c  mr = Traits::mr,
-00000ea0: 0a20 2020 2020 206e 7220 3d20 5472 6169  .      nr = Trai
-00000eb0: 7473 3a3a 6e72 0a20 2020 207d 3b0a 2020  ts::nr.    };.  
-00000ec0: 2020 2f2f 2049 6e63 7265 6173 696e 6720    // Increasing 
-00000ed0: 6b20 6769 7665 7320 7573 206d 6f72 6520  k gives us more 
-00000ee0: 7469 6d65 2074 6f20 7072 6566 6574 6368  time to prefetch
-00000ef0: 2074 6865 2063 6f6e 7465 6e74 206f 6620   the content of 
-00000f00: 7468 6520 2243 220a 2020 2020 2f2f 2072  the "C".    // r
-00000f10: 6567 6973 7465 7273 2e20 486f 7765 7665  egisters. Howeve
-00000f20: 7220 6f6e 6365 2074 6865 206c 6174 656e  r once the laten
-00000f30: 6379 2069 7320 6869 6464 656e 2074 6865  cy is hidden the
-00000f40: 7265 2069 7320 6e6f 2070 6f69 6e74 2069  re is no point i
-00000f50: 6e0a 2020 2020 2f2f 2069 6e63 7265 6173  n.    // increas
-00000f60: 696e 6720 7468 6520 7661 6c75 6520 6f66  ing the value of
-00000f70: 206b 2c20 736f 2077 6527 6c6c 2063 6170   k, so we'll cap
-00000f80: 2069 7420 6174 2033 3230 2028 7661 6c75   it at 320 (valu
-00000f90: 6520 6465 7465 726d 696e 6564 0a20 2020  e determined.   
-00000fa0: 202f 2f20 6578 7065 7269 6d65 6e74 616c   // experimental
-00000fb0: 6c79 292e 0a20 2020 2063 6f6e 7374 2049  ly)..    const I
-00000fc0: 6e64 6578 206b 5f63 6163 6865 203d 2028  ndex k_cache = (
-00000fd0: 6e75 6d65 7874 3a3a 6d69 6e69 3c49 6e64  numext::mini<Ind
-00000fe0: 6578 3e29 2828 6c31 2d6b 7375 6229 2f6b  ex>)((l1-ksub)/k
-00000ff0: 6469 762c 2033 3230 293b 0a20 2020 2069  div, 320);.    i
-00001000: 6620 286b 5f63 6163 6865 203c 206b 2920  f (k_cache < k) 
-00001010: 7b0a 2020 2020 2020 6b20 3d20 6b5f 6361  {.      k = k_ca
-00001020: 6368 6520 2d20 286b 5f63 6163 6865 2025  che - (k_cache %
-00001030: 206b 7229 3b0a 2020 2020 2020 6569 6765   kr);.      eige
-00001040: 6e5f 696e 7465 726e 616c 5f61 7373 6572  n_internal_asser
-00001050: 7428 6b20 3e20 3029 3b0a 2020 2020 7d0a  t(k > 0);.    }.
-00001060: 0a20 2020 2063 6f6e 7374 2049 6e64 6578  .    const Index
-00001070: 206e 5f63 6163 6865 203d 2028 6c32 2d6c   n_cache = (l2-l
-00001080: 3129 202f 2028 6e72 202a 2073 697a 656f  1) / (nr * sizeo
-00001090: 6628 5268 7353 6361 6c61 7229 202a 206b  f(RhsScalar) * k
-000010a0: 293b 0a20 2020 2063 6f6e 7374 2049 6e64  );.    const Ind
-000010b0: 6578 206e 5f70 6572 5f74 6872 6561 6420  ex n_per_thread 
-000010c0: 3d20 6e75 6d65 7874 3a3a 6469 765f 6365  = numext::div_ce
-000010d0: 696c 286e 2c20 6e75 6d5f 7468 7265 6164  il(n, num_thread
-000010e0: 7329 3b0a 2020 2020 6966 2028 6e5f 6361  s);.    if (n_ca
-000010f0: 6368 6520 3c3d 206e 5f70 6572 5f74 6872  che <= n_per_thr
-00001100: 6561 6429 207b 0a20 2020 2020 202f 2f20  ead) {.      // 
-00001110: 446f 6e27 7420 6578 6365 6564 2074 6865  Don't exceed the
-00001120: 2063 6170 6163 6974 7920 6f66 2074 6865   capacity of the
-00001130: 206c 3220 6361 6368 652e 0a20 2020 2020   l2 cache..     
-00001140: 2065 6967 656e 5f69 6e74 6572 6e61 6c5f   eigen_internal_
-00001150: 6173 7365 7274 286e 5f63 6163 6865 203e  assert(n_cache >
-00001160: 3d20 7374 6174 6963 5f63 6173 743c 496e  = static_cast<In
-00001170: 6465 783e 286e 7229 293b 0a20 2020 2020  dex>(nr));.     
-00001180: 206e 203d 206e 5f63 6163 6865 202d 2028   n = n_cache - (
-00001190: 6e5f 6361 6368 6520 2520 6e72 293b 0a20  n_cache % nr);. 
-000011a0: 2020 2020 2065 6967 656e 5f69 6e74 6572       eigen_inter
-000011b0: 6e61 6c5f 6173 7365 7274 286e 203e 2030  nal_assert(n > 0
-000011c0: 293b 0a20 2020 207d 2065 6c73 6520 7b0a  );.    } else {.
-000011d0: 2020 2020 2020 6e20 3d20 286e 756d 6578        n = (numex
-000011e0: 743a 3a6d 696e 693c 496e 6465 783e 2928  t::mini<Index>)(
-000011f0: 6e2c 2028 6e5f 7065 725f 7468 7265 6164  n, (n_per_thread
-00001200: 202b 206e 7220 2d20 3129 202d 2028 286e   + nr - 1) - ((n
-00001210: 5f70 6572 5f74 6872 6561 6420 2b20 6e72  _per_thread + nr
-00001220: 202d 2031 2920 2520 6e72 2929 3b0a 2020   - 1) % nr));.  
-00001230: 2020 7d0a 0a20 2020 2069 6620 286c 3320    }..    if (l3 
-00001240: 3e20 6c32 2920 7b0a 2020 2020 2020 2f2f  > l2) {.      //
-00001250: 206c 3320 6973 2073 6861 7265 6420 6265   l3 is shared be
-00001260: 7477 6565 6e20 616c 6c20 636f 7265 732c  tween all cores,
-00001270: 2073 6f20 7765 276c 6c20 6769 7665 2065   so we'll give e
-00001280: 6163 6820 7468 7265 6164 2069 7473 206f  ach thread its o
-00001290: 776e 2063 6875 6e6b 206f 6620 6c33 2e0a  wn chunk of l3..
-000012a0: 2020 2020 2020 636f 6e73 7420 496e 6465        const Inde
-000012b0: 7820 6d5f 6361 6368 6520 3d20 286c 332d  x m_cache = (l3-
-000012c0: 6c32 2920 2f20 2873 697a 656f 6628 4c68  l2) / (sizeof(Lh
-000012d0: 7353 6361 6c61 7229 202a 206b 202a 206e  sScalar) * k * n
-000012e0: 756d 5f74 6872 6561 6473 293b 0a20 2020  um_threads);.   
-000012f0: 2020 2063 6f6e 7374 2049 6e64 6578 206d     const Index m
-00001300: 5f70 6572 5f74 6872 6561 6420 3d20 6e75  _per_thread = nu
-00001310: 6d65 7874 3a3a 6469 765f 6365 696c 286d  mext::div_ceil(m
-00001320: 2c20 6e75 6d5f 7468 7265 6164 7329 3b0a  , num_threads);.
-00001330: 2020 2020 2020 6966 286d 5f63 6163 6865        if(m_cache
-00001340: 203c 206d 5f70 6572 5f74 6872 6561 6420   < m_per_thread 
-00001350: 2626 206d 5f63 6163 6865 203e 3d20 7374  && m_cache >= st
-00001360: 6174 6963 5f63 6173 743c 496e 6465 783e  atic_cast<Index>
-00001370: 286d 7229 2920 7b0a 2020 2020 2020 2020  (mr)) {.        
-00001380: 6d20 3d20 6d5f 6361 6368 6520 2d20 286d  m = m_cache - (m
-00001390: 5f63 6163 6865 2025 206d 7229 3b0a 2020  _cache % mr);.  
-000013a0: 2020 2020 2020 6569 6765 6e5f 696e 7465        eigen_inte
-000013b0: 726e 616c 5f61 7373 6572 7428 6d20 3e20  rnal_assert(m > 
-000013c0: 3029 3b0a 2020 2020 2020 7d20 656c 7365  0);.      } else
-000013d0: 207b 0a20 2020 2020 2020 206d 203d 2028   {.        m = (
-000013e0: 6e75 6d65 7874 3a3a 6d69 6e69 3c49 6e64  numext::mini<Ind
-000013f0: 6578 3e29 286d 2c20 286d 5f70 6572 5f74  ex>)(m, (m_per_t
-00001400: 6872 6561 6420 2b20 6d72 202d 2031 2920  hread + mr - 1) 
-00001410: 2d20 2828 6d5f 7065 725f 7468 7265 6164  - ((m_per_thread
-00001420: 202b 206d 7220 2d20 3129 2025 206d 7229   + mr - 1) % mr)
-00001430: 293b 0a20 2020 2020 207d 0a20 2020 207d  );.      }.    }
-00001440: 0a20 207d 0a20 2065 6c73 6520 7b0a 2020  .  }.  else {.  
-00001450: 2020 2f2f 2049 6e20 756e 6974 2074 6573    // In unit tes
-00001460: 7473 2077 6520 646f 206e 6f74 2077 616e  ts we do not wan
-00001470: 7420 746f 2075 7365 2065 7874 7261 206c  t to use extra l
-00001480: 6172 6765 206d 6174 7269 6365 732c 0a20  arge matrices,. 
-00001490: 2020 202f 2f20 736f 2077 6520 7265 6475     // so we redu
-000014a0: 6365 2074 6865 2063 6163 6865 2073 697a  ce the cache siz
-000014b0: 6520 746f 2063 6865 636b 2074 6865 2062  e to check the b
-000014c0: 6c6f 636b 696e 6720 7374 7261 7465 6779  locking strategy
-000014d0: 2069 7320 6e6f 7420 666c 6177 6564 0a23   is not flawed.#
-000014e0: 6966 6465 6620 4549 4745 4e5f 4445 4255  ifdef EIGEN_DEBU
-000014f0: 475f 534d 414c 4c5f 5052 4f44 5543 545f  G_SMALL_PRODUCT_
-00001500: 424c 4f43 4b53 0a20 2020 206c 3120 3d20  BLOCKS.    l1 = 
-00001510: 392a 3130 3234 3b0a 2020 2020 6c32 203d  9*1024;.    l2 =
-00001520: 2033 322a 3130 3234 3b0a 2020 2020 6c33   32*1024;.    l3
-00001530: 203d 2035 3132 2a31 3032 343b 0a23 656e   = 512*1024;.#en
-00001540: 6469 660a 0a20 2020 202f 2f20 4561 726c  dif..    // Earl
-00001550: 7920 7265 7475 726e 2066 6f72 2073 6d61  y return for sma
-00001560: 6c6c 2070 726f 626c 656d 7320 6265 6361  ll problems beca
-00001570: 7573 6520 7468 6520 636f 6d70 7574 6174  use the computat
-00001580: 696f 6e20 6265 6c6f 7720 6172 6520 7469  ion below are ti
-00001590: 6d65 2063 6f6e 7375 6d69 6e67 2066 6f72  me consuming for
-000015a0: 2073 6d61 6c6c 2070 726f 626c 656d 732e   small problems.
-000015b0: 0a20 2020 202f 2f20 5065 7268 6170 7320  .    // Perhaps 
-000015c0: 6974 2077 6f75 6c64 206d 616b 6520 6d6f  it would make mo
-000015d0: 7265 2073 656e 7365 2074 6f20 636f 6e73  re sense to cons
-000015e0: 6964 6572 206b 2a6e 2a6d 3f3f 0a20 2020  ider k*n*m??.   
-000015f0: 202f 2f20 4e6f 7465 2074 6861 7420 666f   // Note that fo
-00001600: 7220 7665 7279 2074 696e 7920 7072 6f62  r very tiny prob
-00001610: 6c65 6d2c 2074 6869 7320 6675 6e63 7469  lem, this functi
-00001620: 6f6e 2073 686f 756c 6420 6265 2062 7970  on should be byp
-00001630: 6173 7365 6420 616e 7977 6179 0a20 2020  assed anyway.   
-00001640: 202f 2f20 6265 6361 7573 6520 7765 2075   // because we u
-00001650: 7365 2074 6865 2063 6f65 6666 6963 6965  se the coefficie
-00001660: 6e74 2d62 6173 6564 2069 6d70 6c65 6d65  nt-based impleme
-00001670: 6e74 6174 696f 6e20 666f 7220 7468 656d  ntation for them
-00001680: 2e0a 2020 2020 6966 2828 6e75 6d65 7874  ..    if((numext
-00001690: 3a3a 6d61 7869 2928 6b2c 286e 756d 6578  ::maxi)(k,(numex
-000016a0: 743a 3a6d 6178 6929 286d 2c6e 2929 3c34  t::maxi)(m,n))<4
-000016b0: 3829 0a20 2020 2020 2072 6574 7572 6e3b  8).      return;
-000016c0: 0a0a 2020 2020 7479 7065 6465 6620 7479  ..    typedef ty
-000016d0: 7065 6e61 6d65 2054 7261 6974 733a 3a52  pename Traits::R
-000016e0: 6573 5363 616c 6172 2052 6573 5363 616c  esScalar ResScal
-000016f0: 6172 3b0a 2020 2020 656e 756d 207b 0a20  ar;.    enum {. 
-00001700: 2020 2020 206b 5f70 6565 6c69 6e67 203d       k_peeling =
-00001710: 2038 2c0a 2020 2020 2020 6b5f 6469 7620   8,.      k_div 
-00001720: 3d20 4b63 4661 6374 6f72 202a 2028 5472  = KcFactor * (Tr
-00001730: 6169 7473 3a3a 6d72 202a 2073 697a 656f  aits::mr * sizeo
-00001740: 6628 4c68 7353 6361 6c61 7229 202b 2054  f(LhsScalar) + T
-00001750: 7261 6974 733a 3a6e 7220 2a20 7369 7a65  raits::nr * size
-00001760: 6f66 2852 6873 5363 616c 6172 2929 2c0a  of(RhsScalar)),.
-00001770: 2020 2020 2020 6b5f 7375 6220 3d20 5472        k_sub = Tr
-00001780: 6169 7473 3a3a 6d72 202a 2054 7261 6974  aits::mr * Trait
-00001790: 733a 3a6e 7220 2a20 7369 7a65 6f66 2852  s::nr * sizeof(R
-000017a0: 6573 5363 616c 6172 290a 2020 2020 7d3b  esScalar).    };
-000017b0: 0a0a 2020 2020 2f2f 202d 2d2d 2d20 3173  ..    // ---- 1s
-000017c0: 7420 6c65 7665 6c20 6f66 2062 6c6f 636b  t level of block
-000017d0: 696e 6720 6f6e 204c 312c 2079 6965 6c64  ing on L1, yield
-000017e0: 7320 6b63 202d 2d2d 2d0a 0a20 2020 202f  s kc ----..    /
-000017f0: 2f20 426c 6f63 6b69 6e67 206f 6e20 7468  / Blocking on th
-00001800: 6520 7468 6972 6420 6469 6d65 6e73 696f  e third dimensio
-00001810: 6e20 2869 2e65 2e2c 206b 2920 6973 2063  n (i.e., k) is c
-00001820: 686f 7365 6e20 736f 2074 6861 7420 616e  hosen so that an
-00001830: 2068 6f72 697a 6f6e 7461 6c20 7061 6e65   horizontal pane
-00001840: 6c0a 2020 2020 2f2f 206f 6620 7369 7a65  l.    // of size
-00001850: 206d 7220 7820 6b63 206f 6620 7468 6520   mr x kc of the 
-00001860: 6c68 7320 706c 7573 2061 2076 6572 7469  lhs plus a verti
-00001870: 6361 6c20 7061 6e65 6c20 6f66 206b 6320  cal panel of kc 
-00001880: 7820 6e72 206f 6620 7468 6520 7268 7320  x nr of the rhs 
-00001890: 626f 7468 2066 6974 7320 7769 7468 696e  both fits within
-000018a0: 204c 3120 6361 6368 652e 0a20 2020 202f   L1 cache..    /
-000018b0: 2f20 5765 2061 6c73 6f20 696e 636c 7564  / We also includ
-000018c0: 6520 6120 7265 6769 7374 6572 2d6c 6576  e a register-lev
-000018d0: 656c 2062 6c6f 636b 206f 6620 7468 6520  el block of the 
-000018e0: 7265 7375 6c74 2028 6d78 2078 206e 7229  result (mx x nr)
-000018f0: 2e0a 2020 2020 2f2f 2028 496e 2061 6e20  ..    // (In an 
-00001900: 6964 6561 6c20 776f 726c 6420 6f6e 6c79  ideal world only
-00001910: 2074 6865 206c 6873 2070 616e 656c 2077   the lhs panel w
-00001920: 6f75 6c64 2073 7461 7920 696e 204c 3129  ould stay in L1)
-00001930: 0a20 2020 202f 2f20 4d6f 7265 6f76 6572  .    // Moreover
-00001940: 2c20 6b63 2068 6173 2074 6f20 6265 2061  , kc has to be a
-00001950: 206d 756c 7469 706c 6520 6f66 2038 2074   multiple of 8 t
-00001960: 6f20 6265 2063 6f6d 7061 7469 626c 6520  o be compatible 
-00001970: 7769 7468 206c 6f6f 7020 7065 656c 696e  with loop peelin
-00001980: 672c 206c 6561 6469 6e67 2074 6f20 6120  g, leading to a 
-00001990: 6d61 7869 6d75 6d20 626c 6f63 6b69 6e67  maximum blocking
-000019a0: 2073 697a 6520 6f66 3a0a 2020 2020 636f   size of:.    co
-000019b0: 6e73 7420 496e 6465 7820 6d61 785f 6b63  nst Index max_kc
-000019c0: 203d 206e 756d 6578 743a 3a6d 6178 693c   = numext::maxi<
-000019d0: 496e 6465 783e 2828 286c 312d 6b5f 7375  Index>(((l1-k_su
-000019e0: 6229 2f6b 5f64 6976 2920 2620 287e 286b  b)/k_div) & (~(k
-000019f0: 5f70 6565 6c69 6e67 2d31 2929 2c31 293b  _peeling-1)),1);
-00001a00: 0a20 2020 2063 6f6e 7374 2049 6e64 6578  .    const Index
-00001a10: 206f 6c64 5f6b 203d 206b 3b0a 2020 2020   old_k = k;.    
-00001a20: 6966 286b 3e6d 6178 5f6b 6329 0a20 2020  if(k>max_kc).   
-00001a30: 207b 0a20 2020 2020 202f 2f20 5765 2061   {.      // We a
-00001a40: 7265 2072 6561 6c6c 7920 626c 6f63 6b69  re really blocki
-00001a50: 6e67 206f 6e20 7468 6520 7468 6972 6420  ng on the third 
-00001a60: 6469 6d65 6e73 696f 6e3a 0a20 2020 2020  dimension:.     
-00001a70: 202f 2f20 2d3e 2072 6564 7563 6520 626c   // -> reduce bl
-00001a80: 6f63 6b69 6e67 2073 697a 6520 746f 206d  ocking size to m
-00001a90: 616b 6520 7375 7265 2074 6865 206c 6173  ake sure the las
-00001aa0: 7420 626c 6f63 6b20 6973 2061 7320 6c61  t block is as la
-00001ab0: 7267 6520 6173 2070 6f73 7369 626c 650a  rge as possible.
-00001ac0: 2020 2020 2020 2f2f 2020 2020 7768 696c        //    whil
-00001ad0: 6520 6b65 6570 696e 6720 7468 6520 7361  e keeping the sa
-00001ae0: 6d65 206e 756d 6265 7220 6f66 2073 7765  me number of swe
-00001af0: 6570 7320 6f76 6572 2074 6865 2072 6573  eps over the res
-00001b00: 756c 742e 0a20 2020 2020 206b 203d 2028  ult..      k = (
-00001b10: 6b25 6d61 785f 6b63 293d 3d30 203f 206d  k%max_kc)==0 ? m
-00001b20: 6178 5f6b 630a 2020 2020 2020 2020 2020  ax_kc.          
-00001b30: 2020 2020 2020 2020 2020 2020 2020 3a20                : 
-00001b40: 6d61 785f 6b63 202d 206b 5f70 6565 6c69  max_kc - k_peeli
-00001b50: 6e67 202a 2028 286d 6178 5f6b 632d 312d  ng * ((max_kc-1-
-00001b60: 286b 256d 6178 5f6b 6329 292f 286b 5f70  (k%max_kc))/(k_p
-00001b70: 6565 6c69 6e67 2a28 6b2f 6d61 785f 6b63  eeling*(k/max_kc
-00001b80: 2b31 2929 293b 0a0a 2020 2020 2020 6569  +1)));..      ei
-00001b90: 6765 6e5f 696e 7465 726e 616c 5f61 7373  gen_internal_ass
-00001ba0: 6572 7428 2828 6f6c 645f 6b2f 6b29 203d  ert(((old_k/k) =
-00001bb0: 3d20 286f 6c64 5f6b 2f6d 6178 5f6b 6329  = (old_k/max_kc)
-00001bc0: 2920 2626 2022 7468 6520 6e75 6d62 6572  ) && "the number
-00001bd0: 206f 6620 7377 6565 7073 2068 6173 2074   of sweeps has t
-00001be0: 6f20 7265 6d61 696e 2074 6865 2073 616d  o remain the sam
-00001bf0: 6522 293b 0a20 2020 207d 0a0a 2020 2020  e");.    }..    
-00001c00: 2f2f 202d 2d2d 2d20 326e 6420 6c65 7665  // ---- 2nd leve
-00001c10: 6c20 6f66 2062 6c6f 636b 696e 6720 6f6e  l of blocking on
-00001c20: 206d 6178 284c 322c 4c33 292c 2079 6965   max(L2,L3), yie
-00001c30: 6c64 7320 6e63 202d 2d2d 2d0a 0a20 2020  lds nc ----..   
-00001c40: 202f 2f20 544f 444f 2066 696e 6420 6120   // TODO find a 
-00001c50: 7265 6c69 6162 6c65 2077 6179 2074 6f20  reliable way to 
-00001c60: 6765 7420 7468 6520 6163 7475 616c 2061  get the actual a
-00001c70: 6d6f 756e 7420 6f66 2063 6163 6865 2070  mount of cache p
-00001c80: 6572 2063 6f72 6520 746f 2075 7365 2066  er core to use f
-00001c90: 6f72 2032 6e64 206c 6576 656c 2062 6c6f  or 2nd level blo
-00001ca0: 636b 696e 672c 2074 6861 7420 6973 3a0a  cking, that is:.
-00001cb0: 2020 2020 2f2f 2020 2020 2020 6163 7475      //      actu
-00001cc0: 616c 5f6c 3220 3d20 6d61 7828 6c32 2c20  al_l2 = max(l2, 
-00001cd0: 6c33 2f6e 625f 636f 7265 5f73 6861 7269  l3/nb_core_shari
-00001ce0: 6e67 5f6c 3329 0a20 2020 202f 2f20 5468  ng_l3).    // Th
-00001cf0: 6520 6e75 6d62 6572 2062 656c 6f77 2069  e number below i
-00001d00: 7320 7175 6974 6520 636f 6e73 6572 7661  s quite conserva
-00001d10: 7469 7665 3a20 6974 2069 7320 6265 7474  tive: it is bett
-00001d20: 6572 2074 6f20 756e 6465 7265 7374 696d  er to underestim
-00001d30: 6174 6520 7468 6520 6361 6368 6520 7369  ate the cache si
-00001d40: 7a65 2072 6174 6865 7220 7468 616e 206f  ze rather than o
-00001d50: 7665 7265 7374 696d 6174 696e 6720 6974  verestimating it
-00001d60: 290a 2020 2020 2f2f 2046 6f72 2069 6e73  ).    // For ins
-00001d70: 7461 6e63 652c 2069 7420 636f 7272 6573  tance, it corres
-00001d80: 706f 6e64 7320 746f 2036 4d42 206f 6620  ponds to 6MB of 
-00001d90: 4c33 2073 6861 7265 6420 616d 6f6e 6720  L3 shared among 
-00001da0: 3420 636f 7265 732e 0a20 2020 2023 6966  4 cores..    #if
-00001db0: 6465 6620 4549 4745 4e5f 4445 4255 475f  def EIGEN_DEBUG_
-00001dc0: 534d 414c 4c5f 5052 4f44 5543 545f 424c  SMALL_PRODUCT_BL
-00001dd0: 4f43 4b53 0a20 2020 2063 6f6e 7374 2049  OCKS.    const I
-00001de0: 6e64 6578 2061 6374 7561 6c5f 6c32 203d  ndex actual_l2 =
-00001df0: 206c 333b 0a20 2020 2023 656c 7365 0a20   l3;.    #else. 
-00001e00: 2020 2063 6f6e 7374 2049 6e64 6578 2061     const Index a
-00001e10: 6374 7561 6c5f 6c32 203d 2031 3537 3238  ctual_l2 = 15728
-00001e20: 3634 3b20 2f2f 203d 3d20 312e 3520 4d42  64; // == 1.5 MB
-00001e30: 0a20 2020 2023 656e 6469 660a 0a20 2020  .    #endif..   
-00001e40: 202f 2f20 4865 7265 2c20 6e63 2069 7320   // Here, nc is 
-00001e50: 6368 6f73 656e 2073 7563 6820 7468 6174  chosen such that
-00001e60: 2061 2062 6c6f 636b 206f 6620 6b63 2078   a block of kc x
-00001e70: 206e 6320 6f66 2074 6865 2072 6873 2066   nc of the rhs f
-00001e80: 6974 2077 6974 6869 6e20 6861 6c66 206f  it within half o
-00001e90: 6620 4c32 2e0a 2020 2020 2f2f 2054 6865  f L2..    // The
-00001ea0: 2073 6563 6f6e 6420 6861 6c66 2069 7320   second half is 
-00001eb0: 696d 706c 6963 6974 6c79 2072 6573 6572  implicitly reser
-00001ec0: 7665 6420 746f 2061 6363 6573 7320 7468  ved to access th
-00001ed0: 6520 7265 7375 6c74 2061 6e64 206c 6873  e result and lhs
-00001ee0: 2063 6f65 6666 6963 6965 6e74 732e 0a20   coefficients.. 
-00001ef0: 2020 202f 2f20 5768 656e 206b 3c6d 6178     // When k<max
-00001f00: 5f6b 632c 2074 6865 6e20 6e63 2063 616e  _kc, then nc can
-00001f10: 2061 7262 6974 7261 7269 6c79 2067 726f   arbitrarily gro
-00001f20: 7774 682e 2049 6e20 7072 6163 7469 6365  wth. In practice
-00001f30: 2c20 6974 2073 6565 6d73 2074 6f20 6265  , it seems to be
-00001f40: 2066 7275 6974 6675 6c0a 2020 2020 2f2f   fruitful.    //
-00001f50: 2074 6f20 6c69 6d69 7420 7468 6973 2067   to limit this g
-00001f60: 726f 7774 683a 2077 6520 626f 756e 6420  rowth: we bound 
-00001f70: 6e63 2074 6f20 6772 6f77 7468 2062 7920  nc to growth by 
-00001f80: 6120 6661 6374 6f72 2078 312e 352e 0a20  a factor x1.5.. 
-00001f90: 2020 202f 2f20 486f 7765 7665 722c 2069     // However, i
-00001fa0: 6620 7468 6520 656e 7469 7265 206c 6873  f the entire lhs
-00001fb0: 2062 6c6f 636b 2066 6974 2077 6974 6869   block fit withi
-00001fc0: 6e20 4c31 2c20 7468 656e 2077 6520 6172  n L1, then we ar
-00001fd0: 6520 6e6f 7420 676f 696e 6720 746f 2062  e not going to b
-00001fe0: 6c6f 636b 206f 6e20 7468 6520 726f 7773  lock on the rows
-00001ff0: 2061 7420 616c 6c2c 0a20 2020 202f 2f20   at all,.    // 
-00002000: 616e 6420 6974 2062 6563 6f6d 6573 2066  and it becomes f
-00002010: 7275 6974 6675 6c20 746f 206b 6565 7020  ruitful to keep 
-00002020: 7468 6520 7061 636b 6564 2072 6873 2062  the packed rhs b
-00002030: 6c6f 636b 7320 696e 204c 3120 6966 2074  locks in L1 if t
-00002040: 6865 7265 2069 7320 656e 6f75 6768 2072  here is enough r
-00002050: 656d 6169 6e69 6e67 2073 7061 6365 2e0a  emaining space..
-00002060: 2020 2020 496e 6465 7820 6d61 785f 6e63      Index max_nc
-00002070: 3b0a 2020 2020 636f 6e73 7420 496e 6465  ;.    const Inde
-00002080: 7820 6c68 735f 6279 7465 7320 3d20 6d20  x lhs_bytes = m 
-00002090: 2a20 6b20 2a20 7369 7a65 6f66 284c 6873  * k * sizeof(Lhs
-000020a0: 5363 616c 6172 293b 0a20 2020 2063 6f6e  Scalar);.    con
-000020b0: 7374 2049 6e64 6578 2072 656d 6169 6e69  st Index remaini
-000020c0: 6e67 5f6c 3120 3d20 6c31 2d20 6b5f 7375  ng_l1 = l1- k_su
-000020d0: 6220 2d20 6c68 735f 6279 7465 733b 0a20  b - lhs_bytes;. 
-000020e0: 2020 2069 6628 7265 6d61 696e 696e 675f     if(remaining_
-000020f0: 6c31 203e 3d20 496e 6465 7828 5472 6169  l1 >= Index(Trai
-00002100: 7473 3a3a 6e72 2a73 697a 656f 6628 5268  ts::nr*sizeof(Rh
-00002110: 7353 6361 6c61 7229 292a 6b29 0a20 2020  sScalar))*k).   
-00002120: 207b 0a20 2020 2020 202f 2f20 4c31 2062   {.      // L1 b
-00002130: 6c6f 636b 696e 670a 2020 2020 2020 6d61  locking.      ma
-00002140: 785f 6e63 203d 2072 656d 6169 6e69 6e67  x_nc = remaining
-00002150: 5f6c 3120 2f20 286b 2a73 697a 656f 6628  _l1 / (k*sizeof(
-00002160: 5268 7353 6361 6c61 7229 293b 0a20 2020  RhsScalar));.   
-00002170: 207d 0a20 2020 2065 6c73 650a 2020 2020   }.    else.    
-00002180: 7b0a 2020 2020 2020 2f2f 204c 3220 626c  {.      // L2 bl
-00002190: 6f63 6b69 6e67 0a20 2020 2020 206d 6178  ocking.      max
-000021a0: 5f6e 6320 3d20 2833 2a61 6374 7561 6c5f  _nc = (3*actual_
-000021b0: 6c32 292f 2832 2a32 2a6d 6178 5f6b 632a  l2)/(2*2*max_kc*
-000021c0: 7369 7a65 6f66 2852 6873 5363 616c 6172  sizeof(RhsScalar
-000021d0: 2929 3b0a 2020 2020 7d0a 2020 2020 2f2f  ));.    }.    //
-000021e0: 2057 4152 4e49 4e47 2042 656c 6f77 2c20   WARNING Below, 
-000021f0: 7765 2061 7373 756d 6520 7468 6174 2054  we assume that T
-00002200: 7261 6974 733a 3a6e 7220 6973 2061 2070  raits::nr is a p
-00002210: 6f77 6572 206f 6620 7477 6f2e 0a20 2020  ower of two..   
-00002220: 2049 6e64 6578 206e 6320 3d20 6e75 6d65   Index nc = nume
-00002230: 7874 3a3a 6d69 6e69 3c49 6e64 6578 3e28  xt::mini<Index>(
-00002240: 6163 7475 616c 5f6c 322f 2832 2a6b 2a73  actual_l2/(2*k*s
-00002250: 697a 656f 6628 5268 7353 6361 6c61 7229  izeof(RhsScalar)
-00002260: 292c 206d 6178 5f6e 6329 2026 2028 7e28  ), max_nc) & (~(
-00002270: 5472 6169 7473 3a3a 6e72 2d31 2929 3b0a  Traits::nr-1));.
-00002280: 2020 2020 6966 286e 3e6e 6329 0a20 2020      if(n>nc).   
-00002290: 207b 0a20 2020 2020 202f 2f20 5765 2061   {.      // We a
-000022a0: 7265 2072 6561 6c6c 7920 626c 6f63 6b69  re really blocki
-000022b0: 6e67 206f 7665 7220 7468 6520 636f 6c75  ng over the colu
-000022c0: 6d6e 733a 0a20 2020 2020 202f 2f20 2d3e  mns:.      // ->
-000022d0: 2072 6564 7563 6520 626c 6f63 6b69 6e67   reduce blocking
-000022e0: 2073 697a 6520 746f 206d 616b 6520 7375   size to make su
-000022f0: 7265 2074 6865 206c 6173 7420 626c 6f63  re the last bloc
-00002300: 6b20 6973 2061 7320 6c61 7267 6520 6173  k is as large as
-00002310: 2070 6f73 7369 626c 650a 2020 2020 2020   possible.      
-00002320: 2f2f 2020 2020 7768 696c 6520 6b65 6570  //    while keep
-00002330: 696e 6720 7468 6520 7361 6d65 206e 756d  ing the same num
-00002340: 6265 7220 6f66 2073 7765 6570 7320 6f76  ber of sweeps ov
-00002350: 6572 2074 6865 2070 6163 6b65 6420 6c68  er the packed lh
-00002360: 732e 0a20 2020 2020 202f 2f20 2020 2048  s..      //    H
-00002370: 6572 6520 7765 2061 6c6c 6f77 206f 6e65  ere we allow one
-00002380: 206d 6f72 6520 7377 6565 7020 6966 2074   more sweep if t
-00002390: 6869 7320 6769 7665 7320 7573 2061 2070  his gives us a p
-000023a0: 6572 6665 6374 206d 6174 6368 2c20 7468  erfect match, th
-000023b0: 7573 2074 6865 2063 6f6d 6d65 6e74 6564  us the commented
-000023c0: 2022 2d31 220a 2020 2020 2020 6e20 3d20   "-1".      n = 
-000023d0: 286e 256e 6329 3d3d 3020 3f20 6e63 0a20  (n%nc)==0 ? nc. 
-000023e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000023f0: 2020 203a 2028 6e63 202d 2054 7261 6974     : (nc - Trait
-00002400: 733a 3a6e 7220 2a20 2828 6e63 2f2a 2d31  s::nr * ((nc/*-1
-00002410: 2a2f 2d28 6e25 6e63 2929 2f28 5472 6169  */-(n%nc))/(Trai
-00002420: 7473 3a3a 6e72 2a28 6e2f 6e63 2b31 2929  ts::nr*(n/nc+1))
-00002430: 2929 3b0a 2020 2020 7d0a 2020 2020 656c  ));.    }.    el
-00002440: 7365 2069 6628 6f6c 645f 6b3d 3d6b 290a  se if(old_k==k).
-00002450: 2020 2020 7b0a 2020 2020 2020 2f2f 2053      {.      // S
-00002460: 6f20 6661 722c 206e 6f20 626c 6f63 6b69  o far, no blocki
-00002470: 6e67 2061 7420 616c 6c2c 2069 2e65 2e2c  ng at all, i.e.,
-00002480: 206b 633d 3d6b 2c20 616e 6420 6e63 3d3d   kc==k, and nc==
-00002490: 6e2e 0a20 2020 2020 202f 2f20 496e 2074  n..      // In t
-000024a0: 6869 7320 6361 7365 2c20 6c65 7427 7320  his case, let's 
-000024b0: 7065 7266 6f72 6d20 6120 626c 6f63 6b69  perform a blocki
-000024c0: 6e67 206f 7665 7220 7468 6520 726f 7773  ng over the rows
-000024d0: 2073 7563 6820 7468 6174 2074 6865 2070   such that the p
-000024e0: 6163 6b65 6420 6c68 7320 6461 7461 2069  acked lhs data i
-000024f0: 7320 6b65 7074 2069 6e20 6361 6368 6520  s kept in cache 
-00002500: 4c31 2f4c 320a 2020 2020 2020 2f2f 2054  L1/L2.      // T
-00002510: 4f44 4f3a 2070 6172 7420 6f66 2074 6869  ODO: part of thi
-00002520: 7320 626c 6f63 6b69 6e67 2073 7472 6174  s blocking strat
-00002530: 6567 7920 6973 206e 6f77 2069 6d70 6c65  egy is now imple
-00002540: 6d65 6e74 6564 2077 6974 6869 6e20 7468  mented within th
-00002550: 6520 6b65 726e 656c 2069 7473 656c 662c  e kernel itself,
-00002560: 2073 6f20 7468 6520 4c31 2d62 6173 6564   so the L1-based
-00002570: 2068 6575 7269 7374 6963 2068 6572 6520   heuristic here 
-00002580: 7368 6f75 6c64 2062 6520 6f62 736f 6c65  should be obsole
-00002590: 7465 2e0a 2020 2020 2020 496e 6465 7820  te..      Index 
-000025a0: 7072 6f62 6c65 6d5f 7369 7a65 203d 206b  problem_size = k
-000025b0: 2a6e 2a73 697a 656f 6628 4c68 7353 6361  *n*sizeof(LhsSca
-000025c0: 6c61 7229 3b0a 2020 2020 2020 496e 6465  lar);.      Inde
-000025d0: 7820 6163 7475 616c 5f6c 6d20 3d20 6163  x actual_lm = ac
-000025e0: 7475 616c 5f6c 323b 0a20 2020 2020 2049  tual_l2;.      I
-000025f0: 6e64 6578 206d 6178 5f6d 6320 3d20 6d3b  ndex max_mc = m;
-00002600: 0a20 2020 2020 2069 6628 7072 6f62 6c65  .      if(proble
-00002610: 6d5f 7369 7a65 3c3d 3130 3234 290a 2020  m_size<=1024).  
-00002620: 2020 2020 7b0a 2020 2020 2020 2020 2f2f      {.        //
-00002630: 2070 726f 626c 656d 2069 7320 736d 616c   problem is smal
-00002640: 6c20 656e 6f75 6768 2074 6f20 6b65 6570  l enough to keep
-00002650: 2069 6e20 4c31 0a20 2020 2020 2020 202f   in L1.        /
-00002660: 2f20 4c65 7427 7320 6368 6f6f 7365 206d  / Let's choose m
-00002670: 2073 7563 6820 7468 6174 206c 6873 2773   such that lhs's
-00002680: 2062 6c6f 636b 2066 6974 2069 6e20 312f   block fit in 1/
-00002690: 3320 6f66 204c 310a 2020 2020 2020 2020  3 of L1.        
-000026a0: 6163 7475 616c 5f6c 6d20 3d20 6c31 3b0a  actual_lm = l1;.
-000026b0: 2020 2020 2020 7d0a 2020 2020 2020 656c        }.      el
-000026c0: 7365 2069 6628 6c33 213d 3020 2626 2070  se if(l3!=0 && p
-000026d0: 726f 626c 656d 5f73 697a 653c 3d33 3237  roblem_size<=327
-000026e0: 3638 290a 2020 2020 2020 7b0a 2020 2020  68).      {.    
-000026f0: 2020 2020 2f2f 2077 6520 6861 7665 2062      // we have b
-00002700: 6f74 6820 4c32 2061 6e64 204c 332c 2061  oth L2 and L3, a
-00002710: 6e64 2070 726f 626c 656d 2069 7320 736d  nd problem is sm
-00002720: 616c 6c20 656e 6f75 6768 2074 6f20 6265  all enough to be
-00002730: 206b 6570 7420 696e 204c 320a 2020 2020   kept in L2.    
-00002740: 2020 2020 2f2f 204c 6574 2773 2063 686f      // Let's cho
-00002750: 6f73 6520 6d20 7375 6368 2074 6861 7420  ose m such that 
-00002760: 6c68 7327 7320 626c 6f63 6b20 6669 7420  lhs's block fit 
-00002770: 696e 2031 2f33 206f 6620 4c32 0a20 2020  in 1/3 of L2.   
-00002780: 2020 2020 2061 6374 7561 6c5f 6c6d 203d       actual_lm =
-00002790: 206c 323b 0a20 2020 2020 2020 206d 6178   l2;.        max
-000027a0: 5f6d 6320 3d20 286e 756d 6578 743a 3a6d  _mc = (numext::m
-000027b0: 696e 693c 496e 6465 783e 2928 3537 362c  ini<Index>)(576,
-000027c0: 6d61 785f 6d63 293b 0a20 2020 2020 207d  max_mc);.      }
-000027d0: 0a20 2020 2020 2049 6e64 6578 206d 6320  .      Index mc 
-000027e0: 3d20 286e 756d 6578 743a 3a6d 696e 693c  = (numext::mini<
-000027f0: 496e 6465 783e 2928 6163 7475 616c 5f6c  Index>)(actual_l
-00002800: 6d2f 2833 2a6b 2a73 697a 656f 6628 4c68  m/(3*k*sizeof(Lh
-00002810: 7353 6361 6c61 7229 292c 206d 6178 5f6d  sScalar)), max_m
-00002820: 6329 3b0a 2020 2020 2020 6966 2028 6d63  c);.      if (mc
-00002830: 203e 2054 7261 6974 733a 3a6d 7229 206d   > Traits::mr) m
-00002840: 6320 2d3d 206d 6320 2520 5472 6169 7473  c -= mc % Traits
-00002850: 3a3a 6d72 3b0a 2020 2020 2020 656c 7365  ::mr;.      else
-00002860: 2069 6620 286d 633d 3d30 2920 7265 7475   if (mc==0) retu
-00002870: 726e 3b0a 2020 2020 2020 6d20 3d20 286d  rn;.      m = (m
-00002880: 256d 6329 3d3d 3020 3f20 6d63 0a20 2020  %mc)==0 ? mc.   
-00002890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028a0: 203a 2028 6d63 202d 2054 7261 6974 733a   : (mc - Traits:
-000028b0: 3a6d 7220 2a20 2828 6d63 2f2a 2d31 2a2f  :mr * ((mc/*-1*/
-000028c0: 2d28 6d25 6d63 2929 2f28 5472 6169 7473  -(m%mc))/(Traits
-000028d0: 3a3a 6d72 2a28 6d2f 6d63 2b31 2929 2929  ::mr*(m/mc+1))))
-000028e0: 3b0a 2020 2020 7d0a 2020 7d0a 7d0a 0a74  ;.    }.  }.}..t
-000028f0: 656d 706c 6174 6520 3c74 7970 656e 616d  emplate <typenam
-00002900: 6520 496e 6465 783e 0a69 6e6c 696e 6520  e Index>.inline 
-00002910: 626f 6f6c 2075 7365 5370 6563 6966 6963  bool useSpecific
-00002920: 426c 6f63 6b69 6e67 5369 7a65 7328 496e  BlockingSizes(In
-00002930: 6465 7826 206b 2c20 496e 6465 7826 206d  dex& k, Index& m
-00002940: 2c20 496e 6465 7826 206e 290a 7b0a 2369  , Index& n).{.#i
-00002950: 6664 6566 2045 4947 454e 5f54 4553 545f  fdef EIGEN_TEST_
-00002960: 5350 4543 4946 4943 5f42 4c4f 434b 494e  SPECIFIC_BLOCKIN
-00002970: 475f 5349 5a45 530a 2020 6966 2028 4549  G_SIZES.  if (EI
-00002980: 4745 4e5f 5445 5354 5f53 5045 4349 4649  GEN_TEST_SPECIFI
-00002990: 435f 424c 4f43 4b49 4e47 5f53 495a 4553  C_BLOCKING_SIZES
-000029a0: 2920 7b0a 2020 2020 6b20 3d20 6e75 6d65  ) {.    k = nume
-000029b0: 7874 3a3a 6d69 6e69 3c49 6e64 6578 3e28  xt::mini<Index>(
-000029c0: 6b2c 2045 4947 454e 5f54 4553 545f 5350  k, EIGEN_TEST_SP
-000029d0: 4543 4946 4943 5f42 4c4f 434b 494e 475f  ECIFIC_BLOCKING_
-000029e0: 5349 5a45 5f4b 293b 0a20 2020 206d 203d  SIZE_K);.    m =
-000029f0: 206e 756d 6578 743a 3a6d 696e 693c 496e   numext::mini<In
-00002a00: 6465 783e 286d 2c20 4549 4745 4e5f 5445  dex>(m, EIGEN_TE
-00002a10: 5354 5f53 5045 4349 4649 435f 424c 4f43  ST_SPECIFIC_BLOC
-00002a20: 4b49 4e47 5f53 495a 455f 4d29 3b0a 2020  KING_SIZE_M);.  
-00002a30: 2020 6e20 3d20 6e75 6d65 7874 3a3a 6d69    n = numext::mi
-00002a40: 6e69 3c49 6e64 6578 3e28 6e2c 2045 4947  ni<Index>(n, EIG
-00002a50: 454e 5f54 4553 545f 5350 4543 4946 4943  EN_TEST_SPECIFIC
-00002a60: 5f42 4c4f 434b 494e 475f 5349 5a45 5f4e  _BLOCKING_SIZE_N
-00002a70: 293b 0a20 2020 2072 6574 7572 6e20 7472  );.    return tr
-00002a80: 7565 3b0a 2020 7d0a 2365 6c73 650a 2020  ue;.  }.#else.  
-00002a90: 4549 4745 4e5f 554e 5553 4544 5f56 4152  EIGEN_UNUSED_VAR
-00002aa0: 4941 424c 4528 6b29 0a20 2045 4947 454e  IABLE(k).  EIGEN
-00002ab0: 5f55 4e55 5345 445f 5641 5249 4142 4c45  _UNUSED_VARIABLE
-00002ac0: 286d 290a 2020 4549 4745 4e5f 554e 5553  (m).  EIGEN_UNUS
-00002ad0: 4544 5f56 4152 4941 424c 4528 6e29 0a23  ED_VARIABLE(n).#
-00002ae0: 656e 6469 660a 2020 7265 7475 726e 2066  endif.  return f
-00002af0: 616c 7365 3b0a 7d0a 0a2f 2a2a 205c 6272  alse;.}../** \br
-00002b00: 6965 6620 436f 6d70 7574 6573 2074 6865  ief Computes the
-00002b10: 2062 6c6f 636b 696e 6720 7061 7261 6d65   blocking parame
-00002b20: 7465 7273 2066 6f72 2061 206d 2078 206b  ters for a m x k
-00002b30: 2074 696d 6573 206b 2078 206e 206d 6174   times k x n mat
-00002b40: 7269 7820 7072 6f64 7563 740a 2020 2a0a  rix product.  *.
-00002b50: 2020 2a20 5c70 6172 616d 5b69 6e2c 6f75    * \param[in,ou
-00002b60: 745d 206b 2049 6e70 7574 3a20 7468 6520  t] k Input: the 
-00002b70: 7468 6972 6420 6469 6d65 6e73 696f 6e20  third dimension 
-00002b80: 6f66 2074 6865 2070 726f 6475 6374 2e20  of the product. 
-00002b90: 4f75 7470 7574 3a20 7468 6520 626c 6f63  Output: the bloc
-00002ba0: 6b69 6e67 2073 697a 6520 616c 6f6e 6720  king size along 
-00002bb0: 7468 6520 7361 6d65 2064 696d 656e 7369  the same dimensi
-00002bc0: 6f6e 2e0a 2020 2a20 5c70 6172 616d 5b69  on..  * \param[i
-00002bd0: 6e2c 6f75 745d 206d 2049 6e70 7574 3a20  n,out] m Input: 
-00002be0: 7468 6520 6e75 6d62 6572 206f 6620 726f  the number of ro
-00002bf0: 7773 206f 6620 7468 6520 6c65 6674 2068  ws of the left h
-00002c00: 616e 6420 7369 6465 2e20 4f75 7470 7574  and side. Output
-00002c10: 3a20 7468 6520 626c 6f63 6b69 6e67 2073  : the blocking s
-00002c20: 697a 6520 616c 6f6e 6720 7468 6520 7361  ize along the sa
-00002c30: 6d65 2064 696d 656e 7369 6f6e 2e0a 2020  me dimension..  
-00002c40: 2a20 5c70 6172 616d 5b69 6e2c 6f75 745d  * \param[in,out]
-00002c50: 206e 2049 6e70 7574 3a20 7468 6520 6e75   n Input: the nu
-00002c60: 6d62 6572 206f 6620 636f 6c75 6d6e 7320  mber of columns 
-00002c70: 6f66 2074 6865 2072 6967 6874 2068 616e  of the right han
-00002c80: 6420 7369 6465 2e20 4f75 7470 7574 3a20  d side. Output: 
-00002c90: 7468 6520 626c 6f63 6b69 6e67 2073 697a  the blocking siz
-00002ca0: 6520 616c 6f6e 6720 7468 6520 7361 6d65  e along the same
-00002cb0: 2064 696d 656e 7369 6f6e 2e0a 2020 2a0a   dimension..  *.
-00002cc0: 2020 2a20 4769 7665 6e20 6120 6d20 7820    * Given a m x 
-00002cd0: 6b20 7469 6d65 7320 6b20 7820 6e20 6d61  k times k x n ma
-00002ce0: 7472 6978 2070 726f 6475 6374 206f 6620  trix product of 
-00002cf0: 7363 616c 6172 2074 7970 6573 205c 6320  scalar types \c 
-00002d00: 4c68 7353 6361 6c61 7220 616e 6420 5c63  LhsScalar and \c
-00002d10: 2052 6873 5363 616c 6172 2c0a 2020 2a20   RhsScalar,.  * 
-00002d20: 7468 6973 2066 756e 6374 696f 6e20 636f  this function co
-00002d30: 6d70 7574 6573 2074 6865 2062 6c6f 636b  mputes the block
-00002d40: 696e 6720 7369 7a65 2070 6172 616d 6574  ing size paramet
-00002d50: 6572 7320 616c 6f6e 6720 7468 6520 7265  ers along the re
-00002d60: 7370 6563 7469 7665 2064 696d 656e 7369  spective dimensi
-00002d70: 6f6e 730a 2020 2a20 666f 7220 6d61 7472  ons.  * for matr
-00002d80: 6978 2070 726f 6475 6374 7320 616e 6420  ix products and 
-00002d90: 7265 6c61 7465 6420 616c 676f 7269 7468  related algorith
-00002da0: 6d73 2e0a 2020 2a0a 2020 2a20 5468 6520  ms..  *.  * The 
-00002db0: 626c 6f63 6b69 6e67 2073 697a 6520 7061  blocking size pa
-00002dc0: 7261 6d65 7465 7273 206d 6179 2062 6520  rameters may be 
-00002dd0: 6576 616c 7561 7465 643a 0a20 202a 2020  evaluated:.  *  
-00002de0: 202d 2065 6974 6865 7220 6279 2061 2068   - either by a h
-00002df0: 6575 7269 7374 6963 2062 6173 6564 206f  euristic based o
-00002e00: 6e20 6361 6368 6520 7369 7a65 733b 0a20  n cache sizes;. 
-00002e10: 202a 2020 202d 206f 7220 7573 696e 6720   *   - or using 
-00002e20: 6669 7865 6420 7072 6573 6372 6962 6564  fixed prescribed
-00002e30: 2076 616c 7565 7320 2866 6f72 2074 6573   values (for tes
-00002e40: 7469 6e67 2070 7572 706f 7365 7329 2e0a  ting purposes)..
-00002e50: 2020 2a0a 2020 2a20 5c73 6120 7365 7443    *.  * \sa setC
-00002e60: 7075 4361 6368 6553 697a 6573 202a 2f0a  puCacheSizes */.
-00002e70: 0a74 656d 706c 6174 653c 7479 7065 6e61  .template<typena
-00002e80: 6d65 204c 6873 5363 616c 6172 2c20 7479  me LhsScalar, ty
-00002e90: 7065 6e61 6d65 2052 6873 5363 616c 6172  pename RhsScalar
-00002ea0: 2c20 696e 7420 4b63 4661 6374 6f72 2c20  , int KcFactor, 
-00002eb0: 7479 7065 6e61 6d65 2049 6e64 6578 3e0a  typename Index>.
-00002ec0: 766f 6964 2063 6f6d 7075 7465 5072 6f64  void computeProd
-00002ed0: 7563 7442 6c6f 636b 696e 6753 697a 6573  uctBlockingSizes
-00002ee0: 2849 6e64 6578 2620 6b2c 2049 6e64 6578  (Index& k, Index
-00002ef0: 2620 6d2c 2049 6e64 6578 2620 6e2c 2049  & m, Index& n, I
-00002f00: 6e64 6578 206e 756d 5f74 6872 6561 6473  ndex num_threads
-00002f10: 203d 2031 290a 7b0a 2020 6966 2028 2175   = 1).{.  if (!u
-00002f20: 7365 5370 6563 6966 6963 426c 6f63 6b69  seSpecificBlocki
-00002f30: 6e67 5369 7a65 7328 6b2c 206d 2c20 6e29  ngSizes(k, m, n)
-00002f40: 2920 7b0a 2020 2020 6576 616c 7561 7465  ) {.    evaluate
-00002f50: 5072 6f64 7563 7442 6c6f 636b 696e 6753  ProductBlockingS
-00002f60: 697a 6573 4865 7572 6973 7469 633c 4c68  izesHeuristic<Lh
-00002f70: 7353 6361 6c61 722c 2052 6873 5363 616c  sScalar, RhsScal
-00002f80: 6172 2c20 4b63 4661 6374 6f72 2c20 496e  ar, KcFactor, In
-00002f90: 6465 783e 286b 2c20 6d2c 206e 2c20 6e75  dex>(k, m, n, nu
-00002fa0: 6d5f 7468 7265 6164 7329 3b0a 2020 7d0a  m_threads);.  }.
-00002fb0: 7d0a 0a74 656d 706c 6174 653c 7479 7065  }..template<type
-00002fc0: 6e61 6d65 204c 6873 5363 616c 6172 2c20  name LhsScalar, 
-00002fd0: 7479 7065 6e61 6d65 2052 6873 5363 616c  typename RhsScal
-00002fe0: 6172 2c20 7479 7065 6e61 6d65 2049 6e64  ar, typename Ind
-00002ff0: 6578 3e0a 696e 6c69 6e65 2076 6f69 6420  ex>.inline void 
-00003000: 636f 6d70 7574 6550 726f 6475 6374 426c  computeProductBl
-00003010: 6f63 6b69 6e67 5369 7a65 7328 496e 6465  ockingSizes(Inde
-00003020: 7826 206b 2c20 496e 6465 7826 206d 2c20  x& k, Index& m, 
-00003030: 496e 6465 7826 206e 2c20 496e 6465 7820  Index& n, Index 
-00003040: 6e75 6d5f 7468 7265 6164 7320 3d20 3129  num_threads = 1)
-00003050: 0a7b 0a20 2063 6f6d 7075 7465 5072 6f64  .{.  computeProd
-00003060: 7563 7442 6c6f 636b 696e 6753 697a 6573  uctBlockingSizes
-00003070: 3c4c 6873 5363 616c 6172 2c52 6873 5363  <LhsScalar,RhsSc
-00003080: 616c 6172 2c31 2c49 6e64 6578 3e28 6b2c  alar,1,Index>(k,
-00003090: 206d 2c20 6e2c 206e 756d 5f74 6872 6561   m, n, num_threa
-000030a0: 6473 293b 0a7d 0a0a 2369 6664 6566 2045  ds);.}..#ifdef E
-000030b0: 4947 454e 5f48 4153 5f53 494e 474c 455f  IGEN_HAS_SINGLE_
-000030c0: 494e 5354 5255 4354 494f 4e5f 434a 4d41  INSTRUCTION_CJMA
-000030d0: 4444 0a20 2023 6465 6669 6e65 2043 4a4d  DD.  #define CJM
-000030e0: 4144 4428 434a 2c41 2c42 2c43 2c54 2920  ADD(CJ,A,B,C,T) 
-000030f0: 2043 203d 2043 4a2e 706d 6164 6428 412c   C = CJ.pmadd(A,
-00003100: 422c 4329 3b0a 2365 6c73 650a 0a20 202f  B,C);.#else..  /
-00003110: 2f20 4649 584d 4520 2861 2062 6974 206f  / FIXME (a bit o
-00003120: 7665 726b 696c 6c20 6d61 7962 6520 3f29  verkill maybe ?)
-00003130: 0a0a 2020 7465 6d70 6c61 7465 3c74 7970  ..  template<typ
-00003140: 656e 616d 6520 434a 2c20 7479 7065 6e61  ename CJ, typena
-00003150: 6d65 2041 2c20 7479 7065 6e61 6d65 2042  me A, typename B
-00003160: 2c20 7479 7065 6e61 6d65 2043 2c20 7479  , typename C, ty
-00003170: 7065 6e61 6d65 2054 3e20 7374 7275 6374  pename T> struct
-00003180: 2067 6562 705f 6d61 6464 5f73 656c 6563   gebp_madd_selec
-00003190: 746f 7220 7b0a 2020 2020 4549 4745 4e5f  tor {.    EIGEN_
-000031a0: 414c 5741 5953 5f49 4e4c 494e 4520 7374  ALWAYS_INLINE st
-000031b0: 6174 6963 2076 6f69 6420 7275 6e28 636f  atic void run(co
-000031c0: 6e73 7420 434a 2620 636a 2c20 4126 2061  nst CJ& cj, A& a
-000031d0: 2c20 4226 2062 2c20 4326 2063 2c20 5426  , B& b, C& c, T&
-000031e0: 202f 2a74 2a2f 290a 2020 2020 7b0a 2020   /*t*/).    {.  
-000031f0: 2020 2020 6320 3d20 636a 2e70 6d61 6464      c = cj.pmadd
-00003200: 2861 2c62 2c63 293b 0a20 2020 207d 0a20  (a,b,c);.    }. 
-00003210: 207d 3b0a 0a20 2074 656d 706c 6174 653c   };..  template<
-00003220: 7479 7065 6e61 6d65 2043 4a2c 2074 7970  typename CJ, typ
-00003230: 656e 616d 6520 543e 2073 7472 7563 7420  ename T> struct 
-00003240: 6765 6270 5f6d 6164 645f 7365 6c65 6374  gebp_madd_select
-00003250: 6f72 3c43 4a2c 542c 542c 542c 543e 207b  or<CJ,T,T,T,T> {
-00003260: 0a20 2020 2045 4947 454e 5f41 4c57 4159  .    EIGEN_ALWAY
-00003270: 535f 494e 4c49 4e45 2073 7461 7469 6320  S_INLINE static 
-00003280: 766f 6964 2072 756e 2863 6f6e 7374 2043  void run(const C
-00003290: 4a26 2063 6a2c 2054 2620 612c 2054 2620  J& cj, T& a, T& 
-000032a0: 622c 2054 2620 632c 2054 2620 7429 0a20  b, T& c, T& t). 
-000032b0: 2020 207b 0a20 2020 2020 2074 203d 2062     {.      t = b
-000032c0: 3b20 7420 3d20 636a 2e70 6d75 6c28 612c  ; t = cj.pmul(a,
-000032d0: 7429 3b20 6320 3d20 7061 6464 2863 2c74  t); c = padd(c,t
-000032e0: 293b 0a20 2020 207d 0a20 207d 3b0a 0a20  );.    }.  };.. 
-000032f0: 2074 656d 706c 6174 653c 7479 7065 6e61   template<typena
-00003300: 6d65 2043 4a2c 2074 7970 656e 616d 6520  me CJ, typename 
-00003310: 412c 2074 7970 656e 616d 6520 422c 2074  A, typename B, t
-00003320: 7970 656e 616d 6520 432c 2074 7970 656e  ypename C, typen
-00003330: 616d 6520 543e 0a20 2045 4947 454e 5f53  ame T>.  EIGEN_S
-00003340: 5452 4f4e 475f 494e 4c49 4e45 2076 6f69  TRONG_INLINE voi
-00003350: 6420 6765 6270 5f6d 6164 6428 636f 6e73  d gebp_madd(cons
-00003360: 7420 434a 2620 636a 2c20 4126 2061 2c20  t CJ& cj, A& a, 
-00003370: 4226 2062 2c20 4326 2063 2c20 5426 2074  B& b, C& c, T& t
-00003380: 290a 2020 7b0a 2020 2020 6765 6270 5f6d  ).  {.    gebp_m
-00003390: 6164 645f 7365 6c65 6374 6f72 3c43 4a2c  add_selector<CJ,
-000033a0: 412c 422c 432c 543e 3a3a 7275 6e28 636a  A,B,C,T>::run(cj
-000033b0: 2c61 2c62 2c63 2c74 293b 0a20 207d 0a0a  ,a,b,c,t);.  }..
-000033c0: 2020 2364 6566 696e 6520 434a 4d41 4444    #define CJMADD
-000033d0: 2843 4a2c 412c 422c 432c 5429 2020 6765  (CJ,A,B,C,T)  ge
-000033e0: 6270 5f6d 6164 6428 434a 2c41 2c42 2c43  bp_madd(CJ,A,B,C
-000033f0: 2c54 293b 0a2f 2f20 2020 2364 6566 696e  ,T);.//   #defin
-00003400: 6520 434a 4d41 4444 2843 4a2c 412c 422c  e CJMADD(CJ,A,B,
-00003410: 432c 5429 2020 5420 3d20 423b 2054 203d  C,T)  T = B; T =
-00003420: 2043 4a2e 706d 756c 2841 2c54 293b 2043   CJ.pmul(A,T); C
-00003430: 203d 2070 6164 6428 432c 5429 3b0a 2365   = padd(C,T);.#e
-00003440: 6e64 6966 0a0a 2f2a 2056 6563 746f 7269  ndif../* Vectori
-00003450: 7a61 7469 6f6e 206c 6f67 6963 0a20 2a20  zation logic. * 
-00003460: 2072 6561 6c2a 7265 616c 3a20 756e 7061   real*real: unpa
-00003470: 636b 2072 6873 2074 6f20 636f 6e73 7461  ck rhs to consta
-00003480: 6e74 2070 6163 6b65 7473 2c20 2e2e 2e0a  nt packets, ....
-00003490: 202a 200a 202a 2020 6364 2a63 6420 3a20   * . *  cd*cd : 
-000034a0: 756e 7061 636b 2072 6873 2074 6f20 2862  unpack rhs to (b
-000034b0: 5f72 2c62 5f72 292c 2028 625f 692c 625f  _r,b_r), (b_i,b_
-000034c0: 6929 2c20 6d75 6c20 746f 2067 6574 2028  i), mul to get (
-000034d0: 615f 7220 625f 722c 615f 6920 625f 7229  a_r b_r,a_i b_r)
-000034e0: 2028 615f 7220 625f 692c 615f 6920 625f   (a_r b_i,a_i b_
-000034f0: 6929 2c0a 202a 2020 2020 2020 2020 2020  i),. *          
-00003500: 7374 6f72 696e 6720 6561 6368 2072 6573  storing each res
-00003510: 2070 6163 6b65 7420 696e 746f 2074 776f   packet into two
-00003520: 2070 6163 6b65 7473 2028 3278 3229 2c0a   packets (2x2),.
-00003530: 202a 2020 2020 2020 2020 2020 6174 2074   *          at t
-00003540: 6865 2065 6e64 2063 6f6d 6269 6e65 2074  he end combine t
-00003550: 6865 6d3a 2073 7761 7020 7468 6520 7365  hem: swap the se
-00003560: 636f 6e64 2061 6e64 2061 6464 7375 6220  cond and addsub 
-00003570: 7468 656d 200a 202a 2020 6366 2a63 6620  them . *  cf*cf 
-00003580: 3a20 7361 6d65 2062 7574 2077 6974 6820  : same but with 
-00003590: 3278 3420 626c 6f63 6b73 0a20 2a20 2063  2x4 blocks. *  c
-000035a0: 706c 782a 7265 616c 203a 2075 6e70 6163  plx*real : unpac
-000035b0: 6b20 7268 7320 746f 2063 6f6e 7374 616e  k rhs to constan
-000035c0: 7420 7061 636b 6574 732c 202e 2e2e 0a20  t packets, .... 
-000035d0: 2a20 2072 6561 6c2a 6370 6c78 203a 206c  *  real*cplx : l
-000035e0: 6f61 6420 6c68 7320 6173 2028 6130 2c61  oad lhs as (a0,a
-000035f0: 302c 6131 2c61 3129 2c20 616e 6420 6d75  0,a1,a1), and mu
-00003600: 6c20 6173 2075 7375 616c 0a20 2a2f 0a74  l as usual. */.t
-00003610: 656d 706c 6174 653c 7479 7065 6e61 6d65  emplate<typename
-00003620: 205f 4c68 7353 6361 6c61 722c 2074 7970   _LhsScalar, typ
-00003630: 656e 616d 6520 5f52 6873 5363 616c 6172  ename _RhsScalar
-00003640: 2c20 626f 6f6c 205f 436f 6e6a 4c68 732c  , bool _ConjLhs,
-00003650: 2062 6f6f 6c20 5f43 6f6e 6a52 6873 3e0a   bool _ConjRhs>.
-00003660: 636c 6173 7320 6765 6270 5f74 7261 6974  class gebp_trait
-00003670: 730a 7b0a 7075 626c 6963 3a0a 2020 7479  s.{.public:.  ty
-00003680: 7065 6465 6620 5f4c 6873 5363 616c 6172  pedef _LhsScalar
-00003690: 204c 6873 5363 616c 6172 3b0a 2020 7479   LhsScalar;.  ty
-000036a0: 7065 6465 6620 5f52 6873 5363 616c 6172  pedef _RhsScalar
-000036b0: 2052 6873 5363 616c 6172 3b0a 2020 7479   RhsScalar;.  ty
-000036c0: 7065 6465 6620 7479 7065 6e61 6d65 2053  pedef typename S
-000036d0: 6361 6c61 7242 696e 6172 794f 7054 7261  calarBinaryOpTra
-000036e0: 6974 733c 4c68 7353 6361 6c61 722c 2052  its<LhsScalar, R
-000036f0: 6873 5363 616c 6172 3e3a 3a52 6574 7572  hsScalar>::Retur
-00003700: 6e54 7970 6520 5265 7353 6361 6c61 723b  nType ResScalar;
-00003710: 0a0a 2020 656e 756d 207b 0a20 2020 2043  ..  enum {.    C
-00003720: 6f6e 6a4c 6873 203d 205f 436f 6e6a 4c68  onjLhs = _ConjLh
-00003730: 732c 0a20 2020 2043 6f6e 6a52 6873 203d  s,.    ConjRhs =
-00003740: 205f 436f 6e6a 5268 732c 0a20 2020 2056   _ConjRhs,.    V
-00003750: 6563 746f 7269 7a61 626c 6520 3d20 7061  ectorizable = pa
-00003760: 636b 6574 5f74 7261 6974 733c 4c68 7353  cket_traits<LhsS
-00003770: 6361 6c61 723e 3a3a 5665 6374 6f72 697a  calar>::Vectoriz
-00003780: 6162 6c65 2026 2620 7061 636b 6574 5f74  able && packet_t
-00003790: 7261 6974 733c 5268 7353 6361 6c61 723e  raits<RhsScalar>
-000037a0: 3a3a 5665 6374 6f72 697a 6162 6c65 2c0a  ::Vectorizable,.
-000037b0: 2020 2020 4c68 7350 6163 6b65 7453 697a      LhsPacketSiz
-000037c0: 6520 3d20 5665 6374 6f72 697a 6162 6c65  e = Vectorizable
-000037d0: 203f 2070 6163 6b65 745f 7472 6169 7473   ? packet_traits
-000037e0: 3c4c 6873 5363 616c 6172 3e3a 3a73 697a  <LhsScalar>::siz
-000037f0: 6520 3a20 312c 0a20 2020 2052 6873 5061  e : 1,.    RhsPa
-00003800: 636b 6574 5369 7a65 203d 2056 6563 746f  cketSize = Vecto
-00003810: 7269 7a61 626c 6520 3f20 7061 636b 6574  rizable ? packet
-00003820: 5f74 7261 6974 733c 5268 7353 6361 6c61  _traits<RhsScala
-00003830: 723e 3a3a 7369 7a65 203a 2031 2c0a 2020  r>::size : 1,.  
-00003840: 2020 5265 7350 6163 6b65 7453 697a 6520    ResPacketSize 
-00003850: 3d20 5665 6374 6f72 697a 6162 6c65 203f  = Vectorizable ?
-00003860: 2070 6163 6b65 745f 7472 6169 7473 3c52   packet_traits<R
-00003870: 6573 5363 616c 6172 3e3a 3a73 697a 6520  esScalar>::size 
-00003880: 3a20 312c 0a20 2020 200a 2020 2020 4e75  : 1,.    .    Nu
-00003890: 6d62 6572 4f66 5265 6769 7374 6572 7320  mberOfRegisters 
-000038a0: 3d20 4549 4745 4e5f 4152 4348 5f44 4546  = EIGEN_ARCH_DEF
-000038b0: 4155 4c54 5f4e 554d 4245 525f 4f46 5f52  AULT_NUMBER_OF_R
-000038c0: 4547 4953 5445 5253 2c0a 0a20 2020 202f  EGISTERS,..    /
-000038d0: 2f20 7265 6769 7374 6572 2062 6c6f 636b  / register block
-000038e0: 2073 697a 6520 616c 6f6e 6720 7468 6520   size along the 
-000038f0: 4e20 6469 7265 6374 696f 6e20 6d75 7374  N direction must
-00003900: 2062 6520 3120 6f72 2034 0a20 2020 206e   be 1 or 4.    n
-00003910: 7220 3d20 342c 0a0a 2020 2020 2f2f 2072  r = 4,..    // r
-00003920: 6567 6973 7465 7220 626c 6f63 6b20 7369  egister block si
-00003930: 7a65 2061 6c6f 6e67 2074 6865 204d 2064  ze along the M d
-00003940: 6972 6563 7469 6f6e 2028 6375 7272 656e  irection (curren
-00003950: 746c 792c 2074 6869 7320 6f6e 6520 6361  tly, this one ca
-00003960: 6e6e 6f74 2062 6520 6d6f 6469 6669 6564  nnot be modified
-00003970: 290a 2020 2020 6465 6661 756c 745f 6d72  ).    default_mr
-00003980: 203d 2028 4549 4745 4e5f 504c 4149 4e5f   = (EIGEN_PLAIN_
-00003990: 454e 554d 5f4d 494e 2831 362c 4e75 6d62  ENUM_MIN(16,Numb
-000039a0: 6572 4f66 5265 6769 7374 6572 7329 2f32  erOfRegisters)/2
-000039b0: 2f6e 7229 2a4c 6873 5061 636b 6574 5369  /nr)*LhsPacketSi
-000039c0: 7a65 2c0a 2369 6620 6465 6669 6e65 6428  ze,.#if defined(
-000039d0: 4549 4745 4e5f 4841 535f 5349 4e47 4c45  EIGEN_HAS_SINGLE
-000039e0: 5f49 4e53 5452 5543 5449 4f4e 5f4d 4144  _INSTRUCTION_MAD
-000039f0: 4429 2026 2620 2164 6566 696e 6564 2845  D) && !defined(E
-00003a00: 4947 454e 5f56 4543 544f 5249 5a45 5f41  IGEN_VECTORIZE_A
-00003a10: 4c54 4956 4543 2920 2626 2021 6465 6669  LTIVEC) && !defi
-00003a20: 6e65 6428 4549 4745 4e5f 5645 4354 4f52  ned(EIGEN_VECTOR
-00003a30: 495a 455f 5653 5829 0a20 2020 202f 2f20  IZE_VSX).    // 
-00003a40: 7765 2061 7373 756d 6520 3136 2072 6567  we assume 16 reg
-00003a50: 6973 7465 7273 0a20 2020 202f 2f20 5365  isters.    // Se
-00003a60: 6520 6275 6720 3939 322c 2069 6620 7468  e bug 992, if th
-00003a70: 6520 7363 616c 6172 2074 7970 6520 6973  e scalar type is
-00003a80: 206e 6f74 2076 6563 746f 7269 7a61 626c   not vectorizabl
-00003a90: 6520 6275 7420 7468 6174 2045 4947 454e  e but that EIGEN
-00003aa0: 5f48 4153 5f53 494e 474c 455f 494e 5354  _HAS_SINGLE_INST
-00003ab0: 5255 4354 494f 4e5f 4d41 4444 2069 7320  RUCTION_MADD is 
-00003ac0: 6465 6669 6e65 642c 0a20 2020 202f 2f20  defined,.    // 
-00003ad0: 7468 656e 2075 7369 6e67 2033 2a4c 6873  then using 3*Lhs
-00003ae0: 5061 636b 6574 5369 7a65 2074 7269 6767  PacketSize trigg
-00003af0: 6572 7320 6e6f 6e2d 696d 706c 656d 656e  ers non-implemen
-00003b00: 7465 6420 7061 7468 7320 696e 2073 7972  ted paths in syr
-00003b10: 6b2e 0a20 2020 206d 7220 3d20 5665 6374  k..    mr = Vect
-00003b20: 6f72 697a 6162 6c65 203f 2033 2a4c 6873  orizable ? 3*Lhs
-00003b30: 5061 636b 6574 5369 7a65 203a 2064 6566  PacketSize : def
-00003b40: 6175 6c74 5f6d 722c 0a23 656c 7365 0a20  ault_mr,.#else. 
-00003b50: 2020 206d 7220 3d20 6465 6661 756c 745f     mr = default_
-00003b60: 6d72 2c0a 2365 6e64 6966 0a20 2020 200a  mr,.#endif.    .
-00003b70: 2020 2020 4c68 7350 726f 6772 6573 7320      LhsProgress 
-00003b80: 3d20 4c68 7350 6163 6b65 7453 697a 652c  = LhsPacketSize,
-00003b90: 0a20 2020 2052 6873 5072 6f67 7265 7373  .    RhsProgress
-00003ba0: 203d 2031 0a20 207d 3b0a 0a20 2074 7970   = 1.  };..  typ
-00003bb0: 6564 6566 2074 7970 656e 616d 6520 7061  edef typename pa
-00003bc0: 636b 6574 5f74 7261 6974 733c 4c68 7353  cket_traits<LhsS
-00003bd0: 6361 6c61 723e 3a3a 7479 7065 2020 5f4c  calar>::type  _L
-00003be0: 6873 5061 636b 6574 3b0a 2020 7479 7065  hsPacket;.  type
-00003bf0: 6465 6620 7479 7065 6e61 6d65 2070 6163  def typename pac
-00003c00: 6b65 745f 7472 6169 7473 3c52 6873 5363  ket_traits<RhsSc
-00003c10: 616c 6172 3e3a 3a74 7970 6520 205f 5268  alar>::type  _Rh
-00003c20: 7350 6163 6b65 743b 0a20 2074 7970 6564  sPacket;.  typed
-00003c30: 6566 2074 7970 656e 616d 6520 7061 636b  ef typename pack
-00003c40: 6574 5f74 7261 6974 733c 5265 7353 6361  et_traits<ResSca
-00003c50: 6c61 723e 3a3a 7479 7065 2020 5f52 6573  lar>::type  _Res
-00003c60: 5061 636b 6574 3b0a 0a20 2074 7970 6564  Packet;..  typed
-00003c70: 6566 2074 7970 656e 616d 6520 636f 6e64  ef typename cond
-00003c80: 6974 696f 6e61 6c3c 5665 6374 6f72 697a  itional<Vectoriz
-00003c90: 6162 6c65 2c5f 4c68 7350 6163 6b65 742c  able,_LhsPacket,
-00003ca0: 4c68 7353 6361 6c61 723e 3a3a 7479 7065  LhsScalar>::type
-00003cb0: 204c 6873 5061 636b 6574 3b0a 2020 7479   LhsPacket;.  ty
-00003cc0: 7065 6465 6620 7479 7065 6e61 6d65 2063  pedef typename c
-00003cd0: 6f6e 6469 7469 6f6e 616c 3c56 6563 746f  onditional<Vecto
-00003ce0: 7269 7a61 626c 652c 5f52 6873 5061 636b  rizable,_RhsPack
-00003cf0: 6574 2c52 6873 5363 616c 6172 3e3a 3a74  et,RhsScalar>::t
-00003d00: 7970 6520 5268 7350 6163 6b65 743b 0a20  ype RhsPacket;. 
-00003d10: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
-00003d20: 6520 636f 6e64 6974 696f 6e61 6c3c 5665  e conditional<Ve
-00003d30: 6374 6f72 697a 6162 6c65 2c5f 5265 7350  ctorizable,_ResP
-00003d40: 6163 6b65 742c 5265 7353 6361 6c61 723e  acket,ResScalar>
-00003d50: 3a3a 7479 7065 2052 6573 5061 636b 6574  ::type ResPacket
-00003d60: 3b0a 0a20 2074 7970 6564 6566 2052 6573  ;..  typedef Res
-00003d70: 5061 636b 6574 2041 6363 5061 636b 6574  Packet AccPacket
-00003d80: 3b0a 2020 0a20 2045 4947 454e 5f53 5452  ;.  .  EIGEN_STR
-00003d90: 4f4e 475f 494e 4c49 4e45 2076 6f69 6420  ONG_INLINE void 
-00003da0: 696e 6974 4163 6328 4163 6350 6163 6b65  initAcc(AccPacke
-00003db0: 7426 2070 290a 2020 7b0a 2020 2020 7020  t& p).  {.    p 
-00003dc0: 3d20 7073 6574 313c 5265 7350 6163 6b65  = pset1<ResPacke
-00003dd0: 743e 2852 6573 5363 616c 6172 2830 2929  t>(ResScalar(0))
-00003de0: 3b0a 2020 7d0a 2020 0a20 2045 4947 454e  ;.  }.  .  EIGEN
-00003df0: 5f53 5452 4f4e 475f 494e 4c49 4e45 2076  _STRONG_INLINE v
-00003e00: 6f69 6420 6272 6f61 6463 6173 7452 6873  oid broadcastRhs
-00003e10: 2863 6f6e 7374 2052 6873 5363 616c 6172  (const RhsScalar
-00003e20: 2a20 622c 2052 6873 5061 636b 6574 2620  * b, RhsPacket& 
-00003e30: 6230 2c20 5268 7350 6163 6b65 7426 2062  b0, RhsPacket& b
-00003e40: 312c 2052 6873 5061 636b 6574 2620 6232  1, RhsPacket& b2
-00003e50: 2c20 5268 7350 6163 6b65 7426 2062 3329  , RhsPacket& b3)
-00003e60: 0a20 207b 0a20 2020 2070 6272 6f61 6463  .  {.    pbroadc
-00003e70: 6173 7434 2862 2c20 6230 2c20 6231 2c20  ast4(b, b0, b1, 
-00003e80: 6232 2c20 6233 293b 0a20 207d 0a20 200a  b2, b3);.  }.  .
-00003e90: 2f2f 2020 2045 4947 454e 5f53 5452 4f4e  //   EIGEN_STRON
-00003ea0: 475f 494e 4c49 4e45 2076 6f69 6420 6272  G_INLINE void br
-00003eb0: 6f61 6463 6173 7452 6873 2863 6f6e 7374  oadcastRhs(const
-00003ec0: 2052 6873 5363 616c 6172 2a20 622c 2052   RhsScalar* b, R
-00003ed0: 6873 5061 636b 6574 2620 6230 2c20 5268  hsPacket& b0, Rh
-00003ee0: 7350 6163 6b65 7426 2062 3129 0a2f 2f20  sPacket& b1).// 
-00003ef0: 2020 7b0a 2f2f 2020 2020 2070 6272 6f61    {.//     pbroa
-00003f00: 6463 6173 7432 2862 2c20 6230 2c20 6231  dcast2(b, b0, b1
-00003f10: 293b 0a2f 2f20 2020 7d0a 2020 0a20 2074  );.//   }.  .  t
-00003f20: 656d 706c 6174 653c 7479 7065 6e61 6d65  emplate<typename
-00003f30: 2052 6873 5061 636b 6574 5479 7065 3e0a   RhsPacketType>.
-00003f40: 2020 4549 4745 4e5f 5354 524f 4e47 5f49    EIGEN_STRONG_I
-00003f50: 4e4c 494e 4520 766f 6964 206c 6f61 6452  NLINE void loadR
-00003f60: 6873 2863 6f6e 7374 2052 6873 5363 616c  hs(const RhsScal
-00003f70: 6172 2a20 622c 2052 6873 5061 636b 6574  ar* b, RhsPacket
-00003f80: 5479 7065 2620 6465 7374 2920 636f 6e73  Type& dest) cons
-00003f90: 740a 2020 7b0a 2020 2020 6465 7374 203d  t.  {.    dest =
-00003fa0: 2070 7365 7431 3c52 6873 5061 636b 6574   pset1<RhsPacket
-00003fb0: 5479 7065 3e28 2a62 293b 0a20 207d 0a20  Type>(*b);.  }. 
-00003fc0: 200a 2020 4549 4745 4e5f 5354 524f 4e47   .  EIGEN_STRONG
-00003fd0: 5f49 4e4c 494e 4520 766f 6964 206c 6f61  _INLINE void loa
-00003fe0: 6452 6873 5175 6164 2863 6f6e 7374 2052  dRhsQuad(const R
-00003ff0: 6873 5363 616c 6172 2a20 622c 2052 6873  hsScalar* b, Rhs
-00004000: 5061 636b 6574 2620 6465 7374 2920 636f  Packet& dest) co
-00004010: 6e73 740a 2020 7b0a 2020 2020 6465 7374  nst.  {.    dest
-00004020: 203d 2070 6c6f 6164 7175 6164 3c52 6873   = ploadquad<Rhs
-00004030: 5061 636b 6574 3e28 6229 3b0a 2020 7d0a  Packet>(b);.  }.
-00004040: 0a20 2074 656d 706c 6174 653c 7479 7065  .  template<type
-00004050: 6e61 6d65 204c 6873 5061 636b 6574 5479  name LhsPacketTy
-00004060: 7065 3e0a 2020 4549 4745 4e5f 5354 524f  pe>.  EIGEN_STRO
-00004070: 4e47 5f49 4e4c 494e 4520 766f 6964 206c  NG_INLINE void l
-00004080: 6f61 644c 6873 2863 6f6e 7374 204c 6873  oadLhs(const Lhs
-00004090: 5363 616c 6172 2a20 612c 204c 6873 5061  Scalar* a, LhsPa
-000040a0: 636b 6574 5479 7065 2620 6465 7374 2920  cketType& dest) 
-000040b0: 636f 6e73 740a 2020 7b0a 2020 2020 6465  const.  {.    de
-000040c0: 7374 203d 2070 6c6f 6164 3c4c 6873 5061  st = pload<LhsPa
-000040d0: 636b 6574 5479 7065 3e28 6129 3b0a 2020  cketType>(a);.  
-000040e0: 7d0a 0a20 2074 656d 706c 6174 653c 7479  }..  template<ty
-000040f0: 7065 6e61 6d65 204c 6873 5061 636b 6574  pename LhsPacket
-00004100: 5479 7065 3e0a 2020 4549 4745 4e5f 5354  Type>.  EIGEN_ST
-00004110: 524f 4e47 5f49 4e4c 494e 4520 766f 6964  RONG_INLINE void
-00004120: 206c 6f61 644c 6873 556e 616c 6967 6e65   loadLhsUnaligne
-00004130: 6428 636f 6e73 7420 4c68 7353 6361 6c61  d(const LhsScala
-00004140: 722a 2061 2c20 4c68 7350 6163 6b65 7454  r* a, LhsPacketT
-00004150: 7970 6526 2064 6573 7429 2063 6f6e 7374  ype& dest) const
-00004160: 0a20 207b 0a20 2020 2064 6573 7420 3d20  .  {.    dest = 
-00004170: 706c 6f61 6475 3c4c 6873 5061 636b 6574  ploadu<LhsPacket
-00004180: 5479 7065 3e28 6129 3b0a 2020 7d0a 0a20  Type>(a);.  }.. 
-00004190: 2074 656d 706c 6174 653c 7479 7065 6e61   template<typena
-000041a0: 6d65 204c 6873 5061 636b 6574 5479 7065  me LhsPacketType
-000041b0: 2c20 7479 7065 6e61 6d65 2052 6873 5061  , typename RhsPa
-000041c0: 636b 6574 5479 7065 2c20 7479 7065 6e61  cketType, typena
-000041d0: 6d65 2041 6363 5061 636b 6574 5479 7065  me AccPacketType
-000041e0: 3e0a 2020 4549 4745 4e5f 5354 524f 4e47  >.  EIGEN_STRONG
-000041f0: 5f49 4e4c 494e 4520 766f 6964 206d 6164  _INLINE void mad
-00004200: 6428 636f 6e73 7420 4c68 7350 6163 6b65  d(const LhsPacke
-00004210: 7454 7970 6526 2061 2c20 636f 6e73 7420  tType& a, const 
-00004220: 5268 7350 6163 6b65 7454 7970 6526 2062  RhsPacketType& b
-00004230: 2c20 4163 6350 6163 6b65 7454 7970 6526  , AccPacketType&
-00004240: 2063 2c20 4163 6350 6163 6b65 7454 7970   c, AccPacketTyp
-00004250: 6526 2074 6d70 2920 636f 6e73 740a 2020  e& tmp) const.  
-00004260: 7b0a 2020 2020 636f 6e6a 5f68 656c 7065  {.    conj_helpe
-00004270: 723c 4c68 7350 6163 6b65 7454 7970 652c  r<LhsPacketType,
-00004280: 5268 7350 6163 6b65 7454 7970 652c 436f  RhsPacketType,Co
-00004290: 6e6a 4c68 732c 436f 6e6a 5268 733e 2063  njLhs,ConjRhs> c
-000042a0: 6a3b 0a20 2020 202f 2f20 4974 2077 6f75  j;.    // It wou
-000042b0: 6c64 2062 6520 6120 6c6f 7420 636c 6561  ld be a lot clea
-000042c0: 6e65 7220 746f 2063 616c 6c20 706d 6164  ner to call pmad
-000042d0: 6420 616c 6c20 7468 6520 7469 6d65 2e20  d all the time. 
-000042e0: 556e 666f 7274 756e 6174 656c 7920 6966  Unfortunately if
-000042f0: 2077 650a 2020 2020 2f2f 206c 6574 2067   we.    // let g
-00004300: 6363 2061 6c6c 6f63 6174 6520 7468 6520  cc allocate the 
-00004310: 7265 6769 7374 6572 2069 6e20 7768 6963  register in whic
-00004320: 6820 746f 2073 746f 7265 2074 6865 2072  h to store the r
-00004330: 6573 756c 7420 6f66 2074 6865 2070 6d75  esult of the pmu
-00004340: 6c0a 2020 2020 2f2f 2028 696e 2074 6865  l.    // (in the
-00004350: 2063 6173 6520 7768 6572 6520 7468 6572   case where ther
-00004360: 6520 6973 206e 6f20 464d 4129 2067 6363  e is no FMA) gcc
-00004370: 2066 6169 6c73 2074 6f20 6669 6775 7265   fails to figure
-00004380: 206f 7574 2068 6f77 2074 6f20 6176 6f69   out how to avoi
-00004390: 640a 2020 2020 2f2f 2073 7069 6c6c 696e  d.    // spillin
-000043a0: 6720 7265 6769 7374 6572 2e0a 2369 6664  g register..#ifd
-000043b0: 6566 2045 4947 454e 5f48 4153 5f53 494e  ef EIGEN_HAS_SIN
-000043c0: 474c 455f 494e 5354 5255 4354 494f 4e5f  GLE_INSTRUCTION_
-000043d0: 4d41 4444 0a20 2020 2045 4947 454e 5f55  MADD.    EIGEN_U
-000043e0: 4e55 5345 445f 5641 5249 4142 4c45 2874  NUSED_VARIABLE(t
-000043f0: 6d70 293b 0a20 2020 2063 203d 2063 6a2e  mp);.    c = cj.
-00004400: 706d 6164 6428 612c 622c 6329 3b0a 2365  pmadd(a,b,c);.#e
-00004410: 6c73 650a 2020 2020 746d 7020 3d20 623b  lse.    tmp = b;
-00004420: 2074 6d70 203d 2063 6a2e 706d 756c 2861   tmp = cj.pmul(a
-00004430: 2c74 6d70 293b 2063 203d 2070 6164 6428  ,tmp); c = padd(
-00004440: 632c 746d 7029 3b0a 2365 6e64 6966 0a20  c,tmp);.#endif. 
-00004450: 207d 0a0a 2020 4549 4745 4e5f 5354 524f   }..  EIGEN_STRO
-00004460: 4e47 5f49 4e4c 494e 4520 766f 6964 2061  NG_INLINE void a
-00004470: 6363 2863 6f6e 7374 2041 6363 5061 636b  cc(const AccPack
-00004480: 6574 2620 632c 2063 6f6e 7374 2052 6573  et& c, const Res
-00004490: 5061 636b 6574 2620 616c 7068 612c 2052  Packet& alpha, R
-000044a0: 6573 5061 636b 6574 2620 7229 2063 6f6e  esPacket& r) con
-000044b0: 7374 0a20 207b 0a20 2020 2072 203d 2070  st.  {.    r = p
-000044c0: 6d61 6464 2863 2c61 6c70 6861 2c72 293b  madd(c,alpha,r);
-000044d0: 0a20 207d 0a20 200a 2020 7465 6d70 6c61  .  }.  .  templa
-000044e0: 7465 3c74 7970 656e 616d 6520 5265 7350  te<typename ResP
-000044f0: 6163 6b65 7448 616c 663e 0a20 2045 4947  acketHalf>.  EIG
-00004500: 454e 5f53 5452 4f4e 475f 494e 4c49 4e45  EN_STRONG_INLINE
-00004510: 2076 6f69 6420 6163 6328 636f 6e73 7420   void acc(const 
-00004520: 5265 7350 6163 6b65 7448 616c 6626 2063  ResPacketHalf& c
-00004530: 2c20 636f 6e73 7420 5265 7350 6163 6b65  , const ResPacke
-00004540: 7448 616c 6626 2061 6c70 6861 2c20 5265  tHalf& alpha, Re
-00004550: 7350 6163 6b65 7448 616c 6626 2072 2920  sPacketHalf& r) 
-00004560: 636f 6e73 740a 2020 7b0a 2020 2020 7220  const.  {.    r 
-00004570: 3d20 706d 6164 6428 632c 616c 7068 612c  = pmadd(c,alpha,
-00004580: 7229 3b0a 2020 7d0a 0a7d 3b0a 0a74 656d  r);.  }..};..tem
-00004590: 706c 6174 653c 7479 7065 6e61 6d65 2052  plate<typename R
-000045a0: 6561 6c53 6361 6c61 722c 2062 6f6f 6c20  ealScalar, bool 
-000045b0: 5f43 6f6e 6a4c 6873 3e0a 636c 6173 7320  _ConjLhs>.class 
-000045c0: 6765 6270 5f74 7261 6974 733c 7374 643a  gebp_traits<std:
-000045d0: 3a63 6f6d 706c 6578 3c52 6561 6c53 6361  :complex<RealSca
-000045e0: 6c61 723e 2c20 5265 616c 5363 616c 6172  lar>, RealScalar
-000045f0: 2c20 5f43 6f6e 6a4c 6873 2c20 6661 6c73  , _ConjLhs, fals
-00004600: 653e 0a7b 0a70 7562 6c69 633a 0a20 2074  e>.{.public:.  t
-00004610: 7970 6564 6566 2073 7464 3a3a 636f 6d70  ypedef std::comp
-00004620: 6c65 783c 5265 616c 5363 616c 6172 3e20  lex<RealScalar> 
-00004630: 4c68 7353 6361 6c61 723b 0a20 2074 7970  LhsScalar;.  typ
-00004640: 6564 6566 2052 6561 6c53 6361 6c61 7220  edef RealScalar 
-00004650: 5268 7353 6361 6c61 723b 0a20 2074 7970  RhsScalar;.  typ
-00004660: 6564 6566 2074 7970 656e 616d 6520 5363  edef typename Sc
-00004670: 616c 6172 4269 6e61 7279 4f70 5472 6169  alarBinaryOpTrai
-00004680: 7473 3c4c 6873 5363 616c 6172 2c20 5268  ts<LhsScalar, Rh
-00004690: 7353 6361 6c61 723e 3a3a 5265 7475 726e  sScalar>::Return
-000046a0: 5479 7065 2052 6573 5363 616c 6172 3b0a  Type ResScalar;.
-000046b0: 0a20 2065 6e75 6d20 7b0a 2020 2020 436f  .  enum {.    Co
-000046c0: 6e6a 4c68 7320 3d20 5f43 6f6e 6a4c 6873  njLhs = _ConjLhs
-000046d0: 2c0a 2020 2020 436f 6e6a 5268 7320 3d20  ,.    ConjRhs = 
-000046e0: 6661 6c73 652c 0a20 2020 2056 6563 746f  false,.    Vecto
-000046f0: 7269 7a61 626c 6520 3d20 7061 636b 6574  rizable = packet
-00004700: 5f74 7261 6974 733c 4c68 7353 6361 6c61  _traits<LhsScala
-00004710: 723e 3a3a 5665 6374 6f72 697a 6162 6c65  r>::Vectorizable
-00004720: 2026 2620 7061 636b 6574 5f74 7261 6974   && packet_trait
-00004730: 733c 5268 7353 6361 6c61 723e 3a3a 5665  s<RhsScalar>::Ve
-00004740: 6374 6f72 697a 6162 6c65 2c0a 2020 2020  ctorizable,.    
-00004750: 4c68 7350 6163 6b65 7453 697a 6520 3d20  LhsPacketSize = 
-00004760: 5665 6374 6f72 697a 6162 6c65 203f 2070  Vectorizable ? p
-00004770: 6163 6b65 745f 7472 6169 7473 3c4c 6873  acket_traits<Lhs
-00004780: 5363 616c 6172 3e3a 3a73 697a 6520 3a20  Scalar>::size : 
-00004790: 312c 0a20 2020 2052 6873 5061 636b 6574  1,.    RhsPacket
-000047a0: 5369 7a65 203d 2056 6563 746f 7269 7a61  Size = Vectoriza
-000047b0: 626c 6520 3f20 7061 636b 6574 5f74 7261  ble ? packet_tra
-000047c0: 6974 733c 5268 7353 6361 6c61 723e 3a3a  its<RhsScalar>::
-000047d0: 7369 7a65 203a 2031 2c0a 2020 2020 5265  size : 1,.    Re
-000047e0: 7350 6163 6b65 7453 697a 6520 3d20 5665  sPacketSize = Ve
-000047f0: 6374 6f72 697a 6162 6c65 203f 2070 6163  ctorizable ? pac
-00004800: 6b65 745f 7472 6169 7473 3c52 6573 5363  ket_traits<ResSc
-00004810: 616c 6172 3e3a 3a73 697a 6520 3a20 312c  alar>::size : 1,
-00004820: 0a20 2020 200a 2020 2020 4e75 6d62 6572  .    .    Number
-00004830: 4f66 5265 6769 7374 6572 7320 3d20 4549  OfRegisters = EI
-00004840: 4745 4e5f 4152 4348 5f44 4546 4155 4c54  GEN_ARCH_DEFAULT
-00004850: 5f4e 554d 4245 525f 4f46 5f52 4547 4953  _NUMBER_OF_REGIS
-00004860: 5445 5253 2c0a 2020 2020 6e72 203d 2034  TERS,.    nr = 4
-00004870: 2c0a 2369 6620 6465 6669 6e65 6428 4549  ,.#if defined(EI
-00004880: 4745 4e5f 4841 535f 5349 4e47 4c45 5f49  GEN_HAS_SINGLE_I
-00004890: 4e53 5452 5543 5449 4f4e 5f4d 4144 4429  NSTRUCTION_MADD)
-000048a0: 2026 2620 2164 6566 696e 6564 2845 4947   && !defined(EIG
-000048b0: 454e 5f56 4543 544f 5249 5a45 5f41 4c54  EN_VECTORIZE_ALT
-000048c0: 4956 4543 2920 2626 2021 6465 6669 6e65  IVEC) && !define
-000048d0: 6428 4549 4745 4e5f 5645 4354 4f52 495a  d(EIGEN_VECTORIZ
-000048e0: 455f 5653 5829 0a20 2020 202f 2f20 7765  E_VSX).    // we
-000048f0: 2061 7373 756d 6520 3136 2072 6567 6973   assume 16 regis
-00004900: 7465 7273 0a20 2020 206d 7220 3d20 332a  ters.    mr = 3*
-00004910: 4c68 7350 6163 6b65 7453 697a 652c 0a23  LhsPacketSize,.#
-00004920: 656c 7365 0a20 2020 206d 7220 3d20 2845  else.    mr = (E
-00004930: 4947 454e 5f50 4c41 494e 5f45 4e55 4d5f  IGEN_PLAIN_ENUM_
-00004940: 4d49 4e28 3136 2c4e 756d 6265 724f 6652  MIN(16,NumberOfR
-00004950: 6567 6973 7465 7273 292f 322f 6e72 292a  egisters)/2/nr)*
-00004960: 4c68 7350 6163 6b65 7453 697a 652c 0a23  LhsPacketSize,.#
-00004970: 656e 6469 660a 0a20 2020 204c 6873 5072  endif..    LhsPr
-00004980: 6f67 7265 7373 203d 204c 6873 5061 636b  ogress = LhsPack
-00004990: 6574 5369 7a65 2c0a 2020 2020 5268 7350  etSize,.    RhsP
-000049a0: 726f 6772 6573 7320 3d20 310a 2020 7d3b  rogress = 1.  };
-000049b0: 0a0a 2020 7479 7065 6465 6620 7479 7065  ..  typedef type
-000049c0: 6e61 6d65 2070 6163 6b65 745f 7472 6169  name packet_trai
-000049d0: 7473 3c4c 6873 5363 616c 6172 3e3a 3a74  ts<LhsScalar>::t
-000049e0: 7970 6520 205f 4c68 7350 6163 6b65 743b  ype  _LhsPacket;
-000049f0: 0a20 2074 7970 6564 6566 2074 7970 656e  .  typedef typen
-00004a00: 616d 6520 7061 636b 6574 5f74 7261 6974  ame packet_trait
-00004a10: 733c 5268 7353 6361 6c61 723e 3a3a 7479  s<RhsScalar>::ty
-00004a20: 7065 2020 5f52 6873 5061 636b 6574 3b0a  pe  _RhsPacket;.
-00004a30: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
-00004a40: 6d65 2070 6163 6b65 745f 7472 6169 7473  me packet_traits
-00004a50: 3c52 6573 5363 616c 6172 3e3a 3a74 7970  <ResScalar>::typ
-00004a60: 6520 205f 5265 7350 6163 6b65 743b 0a0a  e  _ResPacket;..
-00004a70: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
-00004a80: 6d65 2063 6f6e 6469 7469 6f6e 616c 3c56  me conditional<V
-00004a90: 6563 746f 7269 7a61 626c 652c 5f4c 6873  ectorizable,_Lhs
-00004aa0: 5061 636b 6574 2c4c 6873 5363 616c 6172  Packet,LhsScalar
-00004ab0: 3e3a 3a74 7970 6520 4c68 7350 6163 6b65  >::type LhsPacke
-00004ac0: 743b 0a20 2074 7970 6564 6566 2074 7970  t;.  typedef typ
-00004ad0: 656e 616d 6520 636f 6e64 6974 696f 6e61  ename conditiona
-00004ae0: 6c3c 5665 6374 6f72 697a 6162 6c65 2c5f  l<Vectorizable,_
-00004af0: 5268 7350 6163 6b65 742c 5268 7353 6361  RhsPacket,RhsSca
-00004b00: 6c61 723e 3a3a 7479 7065 2052 6873 5061  lar>::type RhsPa
-00004b10: 636b 6574 3b0a 2020 7479 7065 6465 6620  cket;.  typedef 
-00004b20: 7479 7065 6e61 6d65 2063 6f6e 6469 7469  typename conditi
-00004b30: 6f6e 616c 3c56 6563 746f 7269 7a61 626c  onal<Vectorizabl
-00004b40: 652c 5f52 6573 5061 636b 6574 2c52 6573  e,_ResPacket,Res
-00004b50: 5363 616c 6172 3e3a 3a74 7970 6520 5265  Scalar>::type Re
-00004b60: 7350 6163 6b65 743b 0a0a 2020 7479 7065  sPacket;..  type
-00004b70: 6465 6620 5265 7350 6163 6b65 7420 4163  def ResPacket Ac
-00004b80: 6350 6163 6b65 743b 0a0a 2020 4549 4745  cPacket;..  EIGE
-00004b90: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
-00004ba0: 766f 6964 2069 6e69 7441 6363 2841 6363  void initAcc(Acc
-00004bb0: 5061 636b 6574 2620 7029 0a20 207b 0a20  Packet& p).  {. 
-00004bc0: 2020 2070 203d 2070 7365 7431 3c52 6573     p = pset1<Res
-00004bd0: 5061 636b 6574 3e28 5265 7353 6361 6c61  Packet>(ResScala
-00004be0: 7228 3029 293b 0a20 207d 0a0a 2020 4549  r(0));.  }..  EI
-00004bf0: 4745 4e5f 5354 524f 4e47 5f49 4e4c 494e  GEN_STRONG_INLIN
-00004c00: 4520 766f 6964 206c 6f61 6452 6873 2863  E void loadRhs(c
-00004c10: 6f6e 7374 2052 6873 5363 616c 6172 2a20  onst RhsScalar* 
-00004c20: 622c 2052 6873 5061 636b 6574 2620 6465  b, RhsPacket& de
-00004c30: 7374 2920 636f 6e73 740a 2020 7b0a 2020  st) const.  {.  
-00004c40: 2020 6465 7374 203d 2070 7365 7431 3c52    dest = pset1<R
-00004c50: 6873 5061 636b 6574 3e28 2a62 293b 0a20  hsPacket>(*b);. 
-00004c60: 207d 0a20 200a 2020 4549 4745 4e5f 5354   }.  .  EIGEN_ST
-00004c70: 524f 4e47 5f49 4e4c 494e 4520 766f 6964  RONG_INLINE void
-00004c80: 206c 6f61 6452 6873 5175 6164 2863 6f6e   loadRhsQuad(con
-00004c90: 7374 2052 6873 5363 616c 6172 2a20 622c  st RhsScalar* b,
-00004ca0: 2052 6873 5061 636b 6574 2620 6465 7374   RhsPacket& dest
-00004cb0: 2920 636f 6e73 740a 2020 7b0a 2020 2020  ) const.  {.    
-00004cc0: 6465 7374 203d 2070 7365 7431 3c52 6873  dest = pset1<Rhs
-00004cd0: 5061 636b 6574 3e28 2a62 293b 0a20 207d  Packet>(*b);.  }
-00004ce0: 0a0a 2020 4549 4745 4e5f 5354 524f 4e47  ..  EIGEN_STRONG
-00004cf0: 5f49 4e4c 494e 4520 766f 6964 206c 6f61  _INLINE void loa
-00004d00: 644c 6873 2863 6f6e 7374 204c 6873 5363  dLhs(const LhsSc
-00004d10: 616c 6172 2a20 612c 204c 6873 5061 636b  alar* a, LhsPack
-00004d20: 6574 2620 6465 7374 2920 636f 6e73 740a  et& dest) const.
-00004d30: 2020 7b0a 2020 2020 6465 7374 203d 2070    {.    dest = p
-00004d40: 6c6f 6164 3c4c 6873 5061 636b 6574 3e28  load<LhsPacket>(
-00004d50: 6129 3b0a 2020 7d0a 0a20 2045 4947 454e  a);.  }..  EIGEN
-00004d60: 5f53 5452 4f4e 475f 494e 4c49 4e45 2076  _STRONG_INLINE v
-00004d70: 6f69 6420 6c6f 6164 4c68 7355 6e61 6c69  oid loadLhsUnali
-00004d80: 676e 6564 2863 6f6e 7374 204c 6873 5363  gned(const LhsSc
-00004d90: 616c 6172 2a20 612c 204c 6873 5061 636b  alar* a, LhsPack
-00004da0: 6574 2620 6465 7374 2920 636f 6e73 740a  et& dest) const.
-00004db0: 2020 7b0a 2020 2020 6465 7374 203d 2070    {.    dest = p
-00004dc0: 6c6f 6164 753c 4c68 7350 6163 6b65 743e  loadu<LhsPacket>
-00004dd0: 2861 293b 0a20 207d 0a0a 2020 4549 4745  (a);.  }..  EIGE
-00004de0: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
-00004df0: 766f 6964 2062 726f 6164 6361 7374 5268  void broadcastRh
-00004e00: 7328 636f 6e73 7420 5268 7353 6361 6c61  s(const RhsScala
-00004e10: 722a 2062 2c20 5268 7350 6163 6b65 7426  r* b, RhsPacket&
-00004e20: 2062 302c 2052 6873 5061 636b 6574 2620   b0, RhsPacket& 
-00004e30: 6231 2c20 5268 7350 6163 6b65 7426 2062  b1, RhsPacket& b
-00004e40: 322c 2052 6873 5061 636b 6574 2620 6233  2, RhsPacket& b3
-00004e50: 290a 2020 7b0a 2020 2020 7062 726f 6164  ).  {.    pbroad
-00004e60: 6361 7374 3428 622c 2062 302c 2062 312c  cast4(b, b0, b1,
-00004e70: 2062 322c 2062 3329 3b0a 2020 7d0a 2020   b2, b3);.  }.  
-00004e80: 0a2f 2f20 2020 4549 4745 4e5f 5354 524f  .//   EIGEN_STRO
-00004e90: 4e47 5f49 4e4c 494e 4520 766f 6964 2062  NG_INLINE void b
-00004ea0: 726f 6164 6361 7374 5268 7328 636f 6e73  roadcastRhs(cons
-00004eb0: 7420 5268 7353 6361 6c61 722a 2062 2c20  t RhsScalar* b, 
-00004ec0: 5268 7350 6163 6b65 7426 2062 302c 2052  RhsPacket& b0, R
-00004ed0: 6873 5061 636b 6574 2620 6231 290a 2f2f  hsPacket& b1).//
-00004ee0: 2020 207b 0a2f 2f20 2020 2020 7062 726f     {.//     pbro
-00004ef0: 6164 6361 7374 3228 622c 2062 302c 2062  adcast2(b, b0, b
-00004f00: 3129 3b0a 2f2f 2020 207d 0a0a 2020 4549  1);.//   }..  EI
-00004f10: 4745 4e5f 5354 524f 4e47 5f49 4e4c 494e  GEN_STRONG_INLIN
-00004f20: 4520 766f 6964 206d 6164 6428 636f 6e73  E void madd(cons
-00004f30: 7420 4c68 7350 6163 6b65 7426 2061 2c20  t LhsPacket& a, 
-00004f40: 636f 6e73 7420 5268 7350 6163 6b65 7426  const RhsPacket&
-00004f50: 2062 2c20 4163 6350 6163 6b65 7426 2063   b, AccPacket& c
-00004f60: 2c20 5268 7350 6163 6b65 7426 2074 6d70  , RhsPacket& tmp
-00004f70: 2920 636f 6e73 740a 2020 7b0a 2020 2020  ) const.  {.    
-00004f80: 6d61 6464 5f69 6d70 6c28 612c 2062 2c20  madd_impl(a, b, 
-00004f90: 632c 2074 6d70 2c20 7479 7065 6e61 6d65  c, tmp, typename
-00004fa0: 2063 6f6e 6469 7469 6f6e 616c 3c56 6563   conditional<Vec
-00004fb0: 746f 7269 7a61 626c 652c 7472 7565 5f74  torizable,true_t
-00004fc0: 7970 652c 6661 6c73 655f 7479 7065 3e3a  ype,false_type>:
-00004fd0: 3a74 7970 6528 2929 3b0a 2020 7d0a 0a20  :type());.  }.. 
-00004fe0: 2045 4947 454e 5f53 5452 4f4e 475f 494e   EIGEN_STRONG_IN
-00004ff0: 4c49 4e45 2076 6f69 6420 6d61 6464 5f69  LINE void madd_i
-00005000: 6d70 6c28 636f 6e73 7420 4c68 7350 6163  mpl(const LhsPac
-00005010: 6b65 7426 2061 2c20 636f 6e73 7420 5268  ket& a, const Rh
-00005020: 7350 6163 6b65 7426 2062 2c20 4163 6350  sPacket& b, AccP
-00005030: 6163 6b65 7426 2063 2c20 5268 7350 6163  acket& c, RhsPac
-00005040: 6b65 7426 2074 6d70 2c20 636f 6e73 7420  ket& tmp, const 
-00005050: 7472 7565 5f74 7970 6526 2920 636f 6e73  true_type&) cons
-00005060: 740a 2020 7b0a 2369 6664 6566 2045 4947  t.  {.#ifdef EIG
-00005070: 454e 5f48 4153 5f53 494e 474c 455f 494e  EN_HAS_SINGLE_IN
-00005080: 5354 5255 4354 494f 4e5f 4d41 4444 0a20  STRUCTION_MADD. 
-00005090: 2020 2045 4947 454e 5f55 4e55 5345 445f     EIGEN_UNUSED_
-000050a0: 5641 5249 4142 4c45 2874 6d70 293b 0a20  VARIABLE(tmp);. 
-000050b0: 2020 2063 2e76 203d 2070 6d61 6464 2861     c.v = pmadd(a
-000050c0: 2e76 2c62 2c63 2e76 293b 0a23 656c 7365  .v,b,c.v);.#else
-000050d0: 0a20 2020 2074 6d70 203d 2062 3b20 746d  .    tmp = b; tm
-000050e0: 7020 3d20 706d 756c 2861 2e76 2c74 6d70  p = pmul(a.v,tmp
-000050f0: 293b 2063 2e76 203d 2070 6164 6428 632e  ); c.v = padd(c.
-00005100: 762c 746d 7029 3b0a 2365 6e64 6966 0a20  v,tmp);.#endif. 
-00005110: 207d 0a0a 2020 4549 4745 4e5f 5354 524f   }..  EIGEN_STRO
-00005120: 4e47 5f49 4e4c 494e 4520 766f 6964 206d  NG_INLINE void m
-00005130: 6164 645f 696d 706c 2863 6f6e 7374 204c  add_impl(const L
-00005140: 6873 5363 616c 6172 2620 612c 2063 6f6e  hsScalar& a, con
-00005150: 7374 2052 6873 5363 616c 6172 2620 622c  st RhsScalar& b,
-00005160: 2052 6573 5363 616c 6172 2620 632c 2052   ResScalar& c, R
-00005170: 6873 5363 616c 6172 2620 2f2a 746d 702a  hsScalar& /*tmp*
-00005180: 2f2c 2063 6f6e 7374 2066 616c 7365 5f74  /, const false_t
-00005190: 7970 6526 2920 636f 6e73 740a 2020 7b0a  ype&) const.  {.
-000051a0: 2020 2020 6320 2b3d 2061 202a 2062 3b0a      c += a * b;.
-000051b0: 2020 7d0a 0a20 2045 4947 454e 5f53 5452    }..  EIGEN_STR
-000051c0: 4f4e 475f 494e 4c49 4e45 2076 6f69 6420  ONG_INLINE void 
-000051d0: 6163 6328 636f 6e73 7420 4163 6350 6163  acc(const AccPac
-000051e0: 6b65 7426 2063 2c20 636f 6e73 7420 5265  ket& c, const Re
-000051f0: 7350 6163 6b65 7426 2061 6c70 6861 2c20  sPacket& alpha, 
-00005200: 5265 7350 6163 6b65 7426 2072 2920 636f  ResPacket& r) co
-00005210: 6e73 740a 2020 7b0a 2020 2020 7220 3d20  nst.  {.    r = 
-00005220: 636a 2e70 6d61 6464 2863 2c61 6c70 6861  cj.pmadd(c,alpha
-00005230: 2c72 293b 0a20 207d 0a0a 7072 6f74 6563  ,r);.  }..protec
-00005240: 7465 643a 0a20 2063 6f6e 6a5f 6865 6c70  ted:.  conj_help
-00005250: 6572 3c52 6573 5061 636b 6574 2c52 6573  er<ResPacket,Res
-00005260: 5061 636b 6574 2c43 6f6e 6a4c 6873 2c66  Packet,ConjLhs,f
-00005270: 616c 7365 3e20 636a 3b0a 7d3b 0a0a 7465  alse> cj;.};..te
-00005280: 6d70 6c61 7465 3c74 7970 656e 616d 6520  mplate<typename 
-00005290: 5061 636b 6574 3e0a 7374 7275 6374 2044  Packet>.struct D
-000052a0: 6f75 626c 6550 6163 6b65 740a 7b0a 2020  oublePacket.{.  
-000052b0: 5061 636b 6574 2066 6972 7374 3b0a 2020  Packet first;.  
-000052c0: 5061 636b 6574 2073 6563 6f6e 643b 0a7d  Packet second;.}
-000052d0: 3b0a 0a74 656d 706c 6174 653c 7479 7065  ;..template<type
-000052e0: 6e61 6d65 2050 6163 6b65 743e 0a44 6f75  name Packet>.Dou
-000052f0: 626c 6550 6163 6b65 743c 5061 636b 6574  blePacket<Packet
-00005300: 3e20 7061 6464 2863 6f6e 7374 2044 6f75  > padd(const Dou
-00005310: 626c 6550 6163 6b65 743c 5061 636b 6574  blePacket<Packet
-00005320: 3e20 2661 2c20 636f 6e73 7420 446f 7562  > &a, const Doub
-00005330: 6c65 5061 636b 6574 3c50 6163 6b65 743e  lePacket<Packet>
-00005340: 2026 6229 0a7b 0a20 2044 6f75 626c 6550   &b).{.  DoubleP
-00005350: 6163 6b65 743c 5061 636b 6574 3e20 7265  acket<Packet> re
-00005360: 733b 0a20 2072 6573 2e66 6972 7374 2020  s;.  res.first  
-00005370: 3d20 7061 6464 2861 2e66 6972 7374 2c20  = padd(a.first, 
-00005380: 622e 6669 7273 7429 3b0a 2020 7265 732e  b.first);.  res.
-00005390: 7365 636f 6e64 203d 2070 6164 6428 612e  second = padd(a.
-000053a0: 7365 636f 6e64 2c62 2e73 6563 6f6e 6429  second,b.second)
-000053b0: 3b0a 2020 7265 7475 726e 2072 6573 3b0a  ;.  return res;.
-000053c0: 7d0a 0a74 656d 706c 6174 653c 7479 7065  }..template<type
-000053d0: 6e61 6d65 2050 6163 6b65 743e 0a63 6f6e  name Packet>.con
-000053e0: 7374 2044 6f75 626c 6550 6163 6b65 743c  st DoublePacket<
-000053f0: 5061 636b 6574 3e26 2070 7265 6475 785f  Packet>& predux_
-00005400: 646f 776e 746f 3428 636f 6e73 7420 446f  downto4(const Do
-00005410: 7562 6c65 5061 636b 6574 3c50 6163 6b65  ublePacket<Packe
-00005420: 743e 2026 6129 0a7b 0a20 2072 6574 7572  t> &a).{.  retur
-00005430: 6e20 613b 0a7d 0a0a 7465 6d70 6c61 7465  n a;.}..template
-00005440: 3c74 7970 656e 616d 6520 5061 636b 6574  <typename Packet
-00005450: 3e20 7374 7275 6374 2075 6e70 6163 6b65  > struct unpacke
-00005460: 745f 7472 6169 7473 3c44 6f75 626c 6550  t_traits<DoubleP
-00005470: 6163 6b65 743c 5061 636b 6574 3e20 3e20  acket<Packet> > 
-00005480: 7b20 7479 7065 6465 6620 446f 7562 6c65  { typedef Double
-00005490: 5061 636b 6574 3c50 6163 6b65 743e 2068  Packet<Packet> h
-000054a0: 616c 663b 207d 3b0a 2f2f 2074 656d 706c  alf; };.// templ
-000054b0: 6174 653c 7479 7065 6e61 6d65 2050 6163  ate<typename Pac
-000054c0: 6b65 743e 0a2f 2f20 446f 7562 6c65 5061  ket>.// DoublePa
-000054d0: 636b 6574 3c50 6163 6b65 743e 2070 6d61  cket<Packet> pma
-000054e0: 6464 2863 6f6e 7374 2044 6f75 626c 6550  dd(const DoubleP
-000054f0: 6163 6b65 743c 5061 636b 6574 3e20 2661  acket<Packet> &a
-00005500: 2c20 636f 6e73 7420 446f 7562 6c65 5061  , const DoublePa
-00005510: 636b 6574 3c50 6163 6b65 743e 2026 6229  cket<Packet> &b)
-00005520: 0a2f 2f20 7b0a 2f2f 2020 2044 6f75 626c  .// {.//   Doubl
-00005530: 6550 6163 6b65 743c 5061 636b 6574 3e20  ePacket<Packet> 
-00005540: 7265 733b 0a2f 2f20 2020 7265 732e 6669  res;.//   res.fi
-00005550: 7273 7420 203d 2070 6164 6428 612e 6669  rst  = padd(a.fi
-00005560: 7273 742c 2062 2e66 6972 7374 293b 0a2f  rst, b.first);./
-00005570: 2f20 2020 7265 732e 7365 636f 6e64 203d  /   res.second =
-00005580: 2070 6164 6428 612e 7365 636f 6e64 2c62   padd(a.second,b
-00005590: 2e73 6563 6f6e 6429 3b0a 2f2f 2020 2072  .second);.//   r
-000055a0: 6574 7572 6e20 7265 733b 0a2f 2f20 7d0a  eturn res;.// }.
-000055b0: 0a74 656d 706c 6174 653c 7479 7065 6e61  .template<typena
-000055c0: 6d65 2052 6561 6c53 6361 6c61 722c 2062  me RealScalar, b
-000055d0: 6f6f 6c20 5f43 6f6e 6a4c 6873 2c20 626f  ool _ConjLhs, bo
-000055e0: 6f6c 205f 436f 6e6a 5268 733e 0a63 6c61  ol _ConjRhs>.cla
-000055f0: 7373 2067 6562 705f 7472 6169 7473 3c73  ss gebp_traits<s
-00005600: 7464 3a3a 636f 6d70 6c65 783c 5265 616c  td::complex<Real
-00005610: 5363 616c 6172 3e2c 2073 7464 3a3a 636f  Scalar>, std::co
-00005620: 6d70 6c65 783c 5265 616c 5363 616c 6172  mplex<RealScalar
-00005630: 3e2c 205f 436f 6e6a 4c68 732c 205f 436f  >, _ConjLhs, _Co
-00005640: 6e6a 5268 7320 3e0a 7b0a 7075 626c 6963  njRhs >.{.public
-00005650: 3a0a 2020 7479 7065 6465 6620 7374 643a  :.  typedef std:
-00005660: 3a63 6f6d 706c 6578 3c52 6561 6c53 6361  :complex<RealSca
-00005670: 6c61 723e 2020 5363 616c 6172 3b0a 2020  lar>  Scalar;.  
-00005680: 7479 7065 6465 6620 7374 643a 3a63 6f6d  typedef std::com
-00005690: 706c 6578 3c52 6561 6c53 6361 6c61 723e  plex<RealScalar>
-000056a0: 2020 4c68 7353 6361 6c61 723b 0a20 2074    LhsScalar;.  t
-000056b0: 7970 6564 6566 2073 7464 3a3a 636f 6d70  ypedef std::comp
-000056c0: 6c65 783c 5265 616c 5363 616c 6172 3e20  lex<RealScalar> 
-000056d0: 2052 6873 5363 616c 6172 3b0a 2020 7479   RhsScalar;.  ty
-000056e0: 7065 6465 6620 7374 643a 3a63 6f6d 706c  pedef std::compl
-000056f0: 6578 3c52 6561 6c53 6361 6c61 723e 2020  ex<RealScalar>  
-00005700: 5265 7353 6361 6c61 723b 0a20 200a 2020  ResScalar;.  .  
-00005710: 656e 756d 207b 0a20 2020 2043 6f6e 6a4c  enum {.    ConjL
-00005720: 6873 203d 205f 436f 6e6a 4c68 732c 0a20  hs = _ConjLhs,. 
-00005730: 2020 2043 6f6e 6a52 6873 203d 205f 436f     ConjRhs = _Co
-00005740: 6e6a 5268 732c 0a20 2020 2056 6563 746f  njRhs,.    Vecto
-00005750: 7269 7a61 626c 6520 3d20 7061 636b 6574  rizable = packet
-00005760: 5f74 7261 6974 733c 5265 616c 5363 616c  _traits<RealScal
-00005770: 6172 3e3a 3a56 6563 746f 7269 7a61 626c  ar>::Vectorizabl
-00005780: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00005790: 2020 2626 2070 6163 6b65 745f 7472 6169    && packet_trai
-000057a0: 7473 3c53 6361 6c61 723e 3a3a 5665 6374  ts<Scalar>::Vect
-000057b0: 6f72 697a 6162 6c65 2c0a 2020 2020 5265  orizable,.    Re
-000057c0: 616c 5061 636b 6574 5369 7a65 2020 3d20  alPacketSize  = 
-000057d0: 5665 6374 6f72 697a 6162 6c65 203f 2070  Vectorizable ? p
-000057e0: 6163 6b65 745f 7472 6169 7473 3c52 6561  acket_traits<Rea
-000057f0: 6c53 6361 6c61 723e 3a3a 7369 7a65 203a  lScalar>::size :
-00005800: 2031 2c0a 2020 2020 5265 7350 6163 6b65   1,.    ResPacke
-00005810: 7453 697a 6520 2020 3d20 5665 6374 6f72  tSize   = Vector
-00005820: 697a 6162 6c65 203f 2070 6163 6b65 745f  izable ? packet_
-00005830: 7472 6169 7473 3c52 6573 5363 616c 6172  traits<ResScalar
-00005840: 3e3a 3a73 697a 6520 3a20 312c 0a20 2020  >::size : 1,.   
-00005850: 204c 6873 5061 636b 6574 5369 7a65 203d   LhsPacketSize =
-00005860: 2056 6563 746f 7269 7a61 626c 6520 3f20   Vectorizable ? 
-00005870: 7061 636b 6574 5f74 7261 6974 733c 4c68  packet_traits<Lh
-00005880: 7353 6361 6c61 723e 3a3a 7369 7a65 203a  sScalar>::size :
-00005890: 2031 2c0a 2020 2020 5268 7350 6163 6b65   1,.    RhsPacke
-000058a0: 7453 697a 6520 3d20 5665 6374 6f72 697a  tSize = Vectoriz
-000058b0: 6162 6c65 203f 2070 6163 6b65 745f 7472  able ? packet_tr
-000058c0: 6169 7473 3c52 6873 5363 616c 6172 3e3a  aits<RhsScalar>:
-000058d0: 3a73 697a 6520 3a20 312c 0a0a 2020 2020  :size : 1,..    
-000058e0: 2f2f 2046 4958 4d45 3a20 7368 6f75 6c64  // FIXME: should
-000058f0: 2064 6570 656e 6420 6f6e 204e 756d 6265   depend on Numbe
-00005900: 724f 6652 6567 6973 7465 7273 0a20 2020  rOfRegisters.   
-00005910: 206e 7220 3d20 342c 0a20 2020 206d 7220   nr = 4,.    mr 
-00005920: 3d20 5265 7350 6163 6b65 7453 697a 652c  = ResPacketSize,
-00005930: 0a0a 2020 2020 4c68 7350 726f 6772 6573  ..    LhsProgres
-00005940: 7320 3d20 5265 7350 6163 6b65 7453 697a  s = ResPacketSiz
-00005950: 652c 0a20 2020 2052 6873 5072 6f67 7265  e,.    RhsProgre
-00005960: 7373 203d 2031 0a20 207d 3b0a 2020 0a20  ss = 1.  };.  . 
-00005970: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
-00005980: 6520 7061 636b 6574 5f74 7261 6974 733c  e packet_traits<
-00005990: 5265 616c 5363 616c 6172 3e3a 3a74 7970  RealScalar>::typ
-000059a0: 6520 5265 616c 5061 636b 6574 3b0a 2020  e RealPacket;.  
-000059b0: 7479 7065 6465 6620 7479 7065 6e61 6d65  typedef typename
-000059c0: 2070 6163 6b65 745f 7472 6169 7473 3c53   packet_traits<S
-000059d0: 6361 6c61 723e 3a3a 7479 7065 2020 2020  calar>::type    
-000059e0: 2053 6361 6c61 7250 6163 6b65 743b 0a20   ScalarPacket;. 
-000059f0: 2074 7970 6564 6566 2044 6f75 626c 6550   typedef DoubleP
-00005a00: 6163 6b65 743c 5265 616c 5061 636b 6574  acket<RealPacket
-00005a10: 3e20 446f 7562 6c65 5061 636b 6574 5479  > DoublePacketTy
-00005a20: 7065 3b0a 0a20 2074 7970 6564 6566 2074  pe;..  typedef t
-00005a30: 7970 656e 616d 6520 636f 6e64 6974 696f  ypename conditio
-00005a40: 6e61 6c3c 5665 6374 6f72 697a 6162 6c65  nal<Vectorizable
-00005a50: 2c52 6561 6c50 6163 6b65 742c 2020 5363  ,RealPacket,  Sc
-00005a60: 616c 6172 3e3a 3a74 7970 6520 4c68 7350  alar>::type LhsP
-00005a70: 6163 6b65 743b 0a20 2074 7970 6564 6566  acket;.  typedef
-00005a80: 2074 7970 656e 616d 6520 636f 6e64 6974   typename condit
-00005a90: 696f 6e61 6c3c 5665 6374 6f72 697a 6162  ional<Vectorizab
-00005aa0: 6c65 2c44 6f75 626c 6550 6163 6b65 7454  le,DoublePacketT
-00005ab0: 7970 652c 5363 616c 6172 3e3a 3a74 7970  ype,Scalar>::typ
-00005ac0: 6520 5268 7350 6163 6b65 743b 0a20 2074  e RhsPacket;.  t
-00005ad0: 7970 6564 6566 2074 7970 656e 616d 6520  ypedef typename 
-00005ae0: 636f 6e64 6974 696f 6e61 6c3c 5665 6374  conditional<Vect
-00005af0: 6f72 697a 6162 6c65 2c53 6361 6c61 7250  orizable,ScalarP
-00005b00: 6163 6b65 742c 5363 616c 6172 3e3a 3a74  acket,Scalar>::t
-00005b10: 7970 6520 5265 7350 6163 6b65 743b 0a20  ype ResPacket;. 
-00005b20: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
-00005b30: 6520 636f 6e64 6974 696f 6e61 6c3c 5665  e conditional<Ve
-00005b40: 6374 6f72 697a 6162 6c65 2c44 6f75 626c  ctorizable,Doubl
-00005b50: 6550 6163 6b65 7454 7970 652c 5363 616c  ePacketType,Scal
-00005b60: 6172 3e3a 3a74 7970 6520 4163 6350 6163  ar>::type AccPac
-00005b70: 6b65 743b 0a20 200a 2020 4549 4745 4e5f  ket;.  .  EIGEN_
-00005b80: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
-00005b90: 6964 2069 6e69 7441 6363 2853 6361 6c61  id initAcc(Scala
-00005ba0: 7226 2070 2920 7b20 7020 3d20 5363 616c  r& p) { p = Scal
-00005bb0: 6172 2830 293b 207d 0a0a 2020 4549 4745  ar(0); }..  EIGE
-00005bc0: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
-00005bd0: 766f 6964 2069 6e69 7441 6363 2844 6f75  void initAcc(Dou
-00005be0: 626c 6550 6163 6b65 7454 7970 6526 2070  blePacketType& p
-00005bf0: 290a 2020 7b0a 2020 2020 702e 6669 7273  ).  {.    p.firs
-00005c00: 7420 2020 3d20 7073 6574 313c 5265 616c  t   = pset1<Real
-00005c10: 5061 636b 6574 3e28 5265 616c 5363 616c  Packet>(RealScal
-00005c20: 6172 2830 2929 3b0a 2020 2020 702e 7365  ar(0));.    p.se
-00005c30: 636f 6e64 2020 3d20 7073 6574 313c 5265  cond  = pset1<Re
-00005c40: 616c 5061 636b 6574 3e28 5265 616c 5363  alPacket>(RealSc
-00005c50: 616c 6172 2830 2929 3b0a 2020 7d0a 0a20  alar(0));.  }.. 
-00005c60: 202f 2f20 5363 616c 6172 2070 6174 680a   // Scalar path.
-00005c70: 2020 4549 4745 4e5f 5354 524f 4e47 5f49    EIGEN_STRONG_I
-00005c80: 4e4c 494e 4520 766f 6964 206c 6f61 6452  NLINE void loadR
-00005c90: 6873 2863 6f6e 7374 2052 6873 5363 616c  hs(const RhsScal
-00005ca0: 6172 2a20 622c 2052 6573 5061 636b 6574  ar* b, ResPacket
-00005cb0: 2620 6465 7374 2920 636f 6e73 740a 2020  & dest) const.  
-00005cc0: 7b0a 2020 2020 6465 7374 203d 2070 7365  {.    dest = pse
-00005cd0: 7431 3c52 6573 5061 636b 6574 3e28 2a62  t1<ResPacket>(*b
-00005ce0: 293b 0a20 207d 0a0a 2020 2f2f 2056 6563  );.  }..  // Vec
-00005cf0: 746f 7269 7a65 6420 7061 7468 0a20 2045  torized path.  E
-00005d00: 4947 454e 5f53 5452 4f4e 475f 494e 4c49  IGEN_STRONG_INLI
-00005d10: 4e45 2076 6f69 6420 6c6f 6164 5268 7328  NE void loadRhs(
-00005d20: 636f 6e73 7420 5268 7353 6361 6c61 722a  const RhsScalar*
-00005d30: 2062 2c20 446f 7562 6c65 5061 636b 6574   b, DoublePacket
-00005d40: 5479 7065 2620 6465 7374 2920 636f 6e73  Type& dest) cons
-00005d50: 740a 2020 7b0a 2020 2020 6465 7374 2e66  t.  {.    dest.f
-00005d60: 6972 7374 2020 3d20 7073 6574 313c 5265  irst  = pset1<Re
-00005d70: 616c 5061 636b 6574 3e28 7265 616c 282a  alPacket>(real(*
-00005d80: 6229 293b 0a20 2020 2064 6573 742e 7365  b));.    dest.se
-00005d90: 636f 6e64 203d 2070 7365 7431 3c52 6561  cond = pset1<Rea
-00005da0: 6c50 6163 6b65 743e 2869 6d61 6728 2a62  lPacket>(imag(*b
-00005db0: 2929 3b0a 2020 7d0a 2020 0a20 2045 4947  ));.  }.  .  EIG
-00005dc0: 454e 5f53 5452 4f4e 475f 494e 4c49 4e45  EN_STRONG_INLINE
-00005dd0: 2076 6f69 6420 6c6f 6164 5268 7351 7561   void loadRhsQua
-00005de0: 6428 636f 6e73 7420 5268 7353 6361 6c61  d(const RhsScala
-00005df0: 722a 2062 2c20 5265 7350 6163 6b65 7426  r* b, ResPacket&
-00005e00: 2064 6573 7429 2063 6f6e 7374 0a20 207b   dest) const.  {
-00005e10: 0a20 2020 206c 6f61 6452 6873 2862 2c64  .    loadRhs(b,d
-00005e20: 6573 7429 3b0a 2020 7d0a 2020 4549 4745  est);.  }.  EIGE
-00005e30: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
-00005e40: 766f 6964 206c 6f61 6452 6873 5175 6164  void loadRhsQuad
-00005e50: 2863 6f6e 7374 2052 6873 5363 616c 6172  (const RhsScalar
-00005e60: 2a20 622c 2044 6f75 626c 6550 6163 6b65  * b, DoublePacke
-00005e70: 7454 7970 6526 2064 6573 7429 2063 6f6e  tType& dest) con
-00005e80: 7374 0a20 207b 0a20 2020 2065 6967 656e  st.  {.    eigen
-00005e90: 5f69 6e74 6572 6e61 6c5f 6173 7365 7274  _internal_assert
-00005ea0: 2875 6e70 6163 6b65 745f 7472 6169 7473  (unpacket_traits
-00005eb0: 3c53 6361 6c61 7250 6163 6b65 743e 3a3a  <ScalarPacket>::
-00005ec0: 7369 7a65 3c3d 3429 3b0a 2020 2020 6c6f  size<=4);.    lo
-00005ed0: 6164 5268 7328 622c 6465 7374 293b 0a20  adRhs(b,dest);. 
-00005ee0: 207d 0a20 200a 2020 4549 4745 4e5f 5354   }.  .  EIGEN_ST
-00005ef0: 524f 4e47 5f49 4e4c 494e 4520 766f 6964  RONG_INLINE void
-00005f00: 2062 726f 6164 6361 7374 5268 7328 636f   broadcastRhs(co
-00005f10: 6e73 7420 5268 7353 6361 6c61 722a 2062  nst RhsScalar* b
-00005f20: 2c20 5268 7350 6163 6b65 7426 2062 302c  , RhsPacket& b0,
-00005f30: 2052 6873 5061 636b 6574 2620 6231 2c20   RhsPacket& b1, 
-00005f40: 5268 7350 6163 6b65 7426 2062 322c 2052  RhsPacket& b2, R
-00005f50: 6873 5061 636b 6574 2620 6233 290a 2020  hsPacket& b3).  
-00005f60: 7b0a 2020 2020 2f2f 2046 4958 4d45 206e  {.    // FIXME n
-00005f70: 6f74 2073 7572 6520 7468 6174 2773 2074  ot sure that's t
-00005f80: 6865 2062 6573 7420 7761 7920 746f 2069  he best way to i
-00005f90: 6d70 6c65 6d65 6e74 2069 7421 0a20 2020  mplement it!.   
-00005fa0: 206c 6f61 6452 6873 2862 2b30 2c20 6230   loadRhs(b+0, b0
-00005fb0: 293b 0a20 2020 206c 6f61 6452 6873 2862  );.    loadRhs(b
-00005fc0: 2b31 2c20 6231 293b 0a20 2020 206c 6f61  +1, b1);.    loa
-00005fd0: 6452 6873 2862 2b32 2c20 6232 293b 0a20  dRhs(b+2, b2);. 
-00005fe0: 2020 206c 6f61 6452 6873 2862 2b33 2c20     loadRhs(b+3, 
-00005ff0: 6233 293b 0a20 207d 0a20 200a 2020 2f2f  b3);.  }.  .  //
-00006000: 2056 6563 746f 7269 7a65 6420 7061 7468   Vectorized path
-00006010: 0a20 2045 4947 454e 5f53 5452 4f4e 475f  .  EIGEN_STRONG_
-00006020: 494e 4c49 4e45 2076 6f69 6420 6272 6f61  INLINE void broa
-00006030: 6463 6173 7452 6873 2863 6f6e 7374 2052  dcastRhs(const R
-00006040: 6873 5363 616c 6172 2a20 622c 2044 6f75  hsScalar* b, Dou
-00006050: 626c 6550 6163 6b65 7454 7970 6526 2062  blePacketType& b
-00006060: 302c 2044 6f75 626c 6550 6163 6b65 7454  0, DoublePacketT
-00006070: 7970 6526 2062 3129 0a20 207b 0a20 2020  ype& b1).  {.   
-00006080: 202f 2f20 4649 584d 4520 6e6f 7420 7375   // FIXME not su
-00006090: 7265 2074 6861 7427 7320 7468 6520 6265  re that's the be
-000060a0: 7374 2077 6179 2074 6f20 696d 706c 656d  st way to implem
-000060b0: 656e 7420 6974 210a 2020 2020 6c6f 6164  ent it!.    load
-000060c0: 5268 7328 622b 302c 2062 3029 3b0a 2020  Rhs(b+0, b0);.  
-000060d0: 2020 6c6f 6164 5268 7328 622b 312c 2062    loadRhs(b+1, b
-000060e0: 3129 3b0a 2020 7d0a 2020 0a20 202f 2f20  1);.  }.  .  // 
-000060f0: 5363 616c 6172 2070 6174 680a 2020 4549  Scalar path.  EI
-00006100: 4745 4e5f 5354 524f 4e47 5f49 4e4c 494e  GEN_STRONG_INLIN
-00006110: 4520 766f 6964 2062 726f 6164 6361 7374  E void broadcast
-00006120: 5268 7328 636f 6e73 7420 5268 7353 6361  Rhs(const RhsSca
-00006130: 6c61 722a 2062 2c20 5268 7353 6361 6c61  lar* b, RhsScala
-00006140: 7226 2062 302c 2052 6873 5363 616c 6172  r& b0, RhsScalar
-00006150: 2620 6231 290a 2020 7b0a 2020 2020 2f2f  & b1).  {.    //
-00006160: 2046 4958 4d45 206e 6f74 2073 7572 6520   FIXME not sure 
-00006170: 7468 6174 2773 2074 6865 2062 6573 7420  that's the best 
-00006180: 7761 7920 746f 2069 6d70 6c65 6d65 6e74  way to implement
-00006190: 2069 7421 0a20 2020 206c 6f61 6452 6873   it!.    loadRhs
-000061a0: 2862 2b30 2c20 6230 293b 0a20 2020 206c  (b+0, b0);.    l
-000061b0: 6f61 6452 6873 2862 2b31 2c20 6231 293b  oadRhs(b+1, b1);
-000061c0: 0a20 207d 0a0a 2020 2f2f 206e 6f74 6869  .  }..  // nothi
-000061d0: 6e67 2073 7065 6369 616c 2068 6572 650a  ng special here.
-000061e0: 2020 4549 4745 4e5f 5354 524f 4e47 5f49    EIGEN_STRONG_I
-000061f0: 4e4c 494e 4520 766f 6964 206c 6f61 644c  NLINE void loadL
-00006200: 6873 2863 6f6e 7374 204c 6873 5363 616c  hs(const LhsScal
-00006210: 6172 2a20 612c 204c 6873 5061 636b 6574  ar* a, LhsPacket
-00006220: 2620 6465 7374 2920 636f 6e73 740a 2020  & dest) const.  
-00006230: 7b0a 2020 2020 6465 7374 203d 2070 6c6f  {.    dest = plo
-00006240: 6164 3c4c 6873 5061 636b 6574 3e28 2863  ad<LhsPacket>((c
-00006250: 6f6e 7374 2074 7970 656e 616d 6520 756e  onst typename un
-00006260: 7061 636b 6574 5f74 7261 6974 733c 4c68  packet_traits<Lh
-00006270: 7350 6163 6b65 743e 3a3a 7479 7065 2a29  sPacket>::type*)
-00006280: 2861 2929 3b0a 2020 7d0a 0a20 2045 4947  (a));.  }..  EIG
-00006290: 454e 5f53 5452 4f4e 475f 494e 4c49 4e45  EN_STRONG_INLINE
-000062a0: 2076 6f69 6420 6c6f 6164 4c68 7355 6e61   void loadLhsUna
-000062b0: 6c69 676e 6564 2863 6f6e 7374 204c 6873  ligned(const Lhs
-000062c0: 5363 616c 6172 2a20 612c 204c 6873 5061  Scalar* a, LhsPa
-000062d0: 636b 6574 2620 6465 7374 2920 636f 6e73  cket& dest) cons
-000062e0: 740a 2020 7b0a 2020 2020 6465 7374 203d  t.  {.    dest =
-000062f0: 2070 6c6f 6164 753c 4c68 7350 6163 6b65   ploadu<LhsPacke
-00006300: 743e 2828 636f 6e73 7420 7479 7065 6e61  t>((const typena
-00006310: 6d65 2075 6e70 6163 6b65 745f 7472 6169  me unpacket_trai
-00006320: 7473 3c4c 6873 5061 636b 6574 3e3a 3a74  ts<LhsPacket>::t
-00006330: 7970 652a 2928 6129 293b 0a20 207d 0a0a  ype*)(a));.  }..
-00006340: 2020 4549 4745 4e5f 5354 524f 4e47 5f49    EIGEN_STRONG_I
-00006350: 4e4c 494e 4520 766f 6964 206d 6164 6428  NLINE void madd(
-00006360: 636f 6e73 7420 4c68 7350 6163 6b65 7426  const LhsPacket&
-00006370: 2061 2c20 636f 6e73 7420 5268 7350 6163   a, const RhsPac
-00006380: 6b65 7426 2062 2c20 446f 7562 6c65 5061  ket& b, DoublePa
-00006390: 636b 6574 5479 7065 2620 632c 2052 6873  cketType& c, Rhs
-000063a0: 5061 636b 6574 2620 2f2a 746d 702a 2f29  Packet& /*tmp*/)
-000063b0: 2063 6f6e 7374 0a20 207b 0a20 2020 2063   const.  {.    c
-000063c0: 2e66 6972 7374 2020 203d 2070 6164 6428  .first   = padd(
-000063d0: 706d 756c 2861 2c62 2e66 6972 7374 292c  pmul(a,b.first),
-000063e0: 2063 2e66 6972 7374 293b 0a20 2020 2063   c.first);.    c
-000063f0: 2e73 6563 6f6e 6420 203d 2070 6164 6428  .second  = padd(
-00006400: 706d 756c 2861 2c62 2e73 6563 6f6e 6429  pmul(a,b.second)
-00006410: 2c63 2e73 6563 6f6e 6429 3b0a 2020 7d0a  ,c.second);.  }.
-00006420: 0a20 2045 4947 454e 5f53 5452 4f4e 475f  .  EIGEN_STRONG_
-00006430: 494e 4c49 4e45 2076 6f69 6420 6d61 6464  INLINE void madd
-00006440: 2863 6f6e 7374 204c 6873 5061 636b 6574  (const LhsPacket
-00006450: 2620 612c 2063 6f6e 7374 2052 6873 5061  & a, const RhsPa
-00006460: 636b 6574 2620 622c 2052 6573 5061 636b  cket& b, ResPack
-00006470: 6574 2620 632c 2052 6873 5061 636b 6574  et& c, RhsPacket
-00006480: 2620 2f2a 746d 702a 2f29 2063 6f6e 7374  & /*tmp*/) const
-00006490: 0a20 207b 0a20 2020 2063 203d 2063 6a2e  .  {.    c = cj.
-000064a0: 706d 6164 6428 612c 622c 6329 3b0a 2020  pmadd(a,b,c);.  
-000064b0: 7d0a 2020 0a20 2045 4947 454e 5f53 5452  }.  .  EIGEN_STR
-000064c0: 4f4e 475f 494e 4c49 4e45 2076 6f69 6420  ONG_INLINE void 
-000064d0: 6163 6328 636f 6e73 7420 5363 616c 6172  acc(const Scalar
-000064e0: 2620 632c 2063 6f6e 7374 2053 6361 6c61  & c, const Scala
-000064f0: 7226 2061 6c70 6861 2c20 5363 616c 6172  r& alpha, Scalar
-00006500: 2620 7229 2063 6f6e 7374 207b 2072 202b  & r) const { r +
-00006510: 3d20 616c 7068 6120 2a20 633b 207d 0a20  = alpha * c; }. 
-00006520: 200a 2020 4549 4745 4e5f 5354 524f 4e47   .  EIGEN_STRONG
-00006530: 5f49 4e4c 494e 4520 766f 6964 2061 6363  _INLINE void acc
-00006540: 2863 6f6e 7374 2044 6f75 626c 6550 6163  (const DoublePac
-00006550: 6b65 7454 7970 6526 2063 2c20 636f 6e73  ketType& c, cons
-00006560: 7420 5265 7350 6163 6b65 7426 2061 6c70  t ResPacket& alp
-00006570: 6861 2c20 5265 7350 6163 6b65 7426 2072  ha, ResPacket& r
-00006580: 2920 636f 6e73 740a 2020 7b0a 2020 2020  ) const.  {.    
-00006590: 2f2f 2061 7373 656d 626c 6520 630a 2020  // assemble c.  
-000065a0: 2020 5265 7350 6163 6b65 7420 746d 703b    ResPacket tmp;
-000065b0: 0a20 2020 2069 6628 2821 436f 6e6a 4c68  .    if((!ConjLh
-000065c0: 7329 2626 2821 436f 6e6a 5268 7329 290a  s)&&(!ConjRhs)).
-000065d0: 2020 2020 7b0a 2020 2020 2020 746d 7020      {.      tmp 
-000065e0: 3d20 7063 706c 7866 6c69 7028 7063 6f6e  = pcplxflip(pcon
-000065f0: 6a28 5265 7350 6163 6b65 7428 632e 7365  j(ResPacket(c.se
-00006600: 636f 6e64 2929 293b 0a20 2020 2020 2074  cond)));.      t
-00006610: 6d70 203d 2070 6164 6428 5265 7350 6163  mp = padd(ResPac
-00006620: 6b65 7428 632e 6669 7273 7429 2c74 6d70  ket(c.first),tmp
-00006630: 293b 0a20 2020 207d 0a20 2020 2065 6c73  );.    }.    els
-00006640: 6520 6966 2828 2143 6f6e 6a4c 6873 2926  e if((!ConjLhs)&
-00006650: 2628 436f 6e6a 5268 7329 290a 2020 2020  &(ConjRhs)).    
-00006660: 7b0a 2020 2020 2020 746d 7020 3d20 7063  {.      tmp = pc
-00006670: 6f6e 6a28 7063 706c 7866 6c69 7028 5265  onj(pcplxflip(Re
-00006680: 7350 6163 6b65 7428 632e 7365 636f 6e64  sPacket(c.second
-00006690: 2929 293b 0a20 2020 2020 2074 6d70 203d  )));.      tmp =
-000066a0: 2070 6164 6428 5265 7350 6163 6b65 7428   padd(ResPacket(
-000066b0: 632e 6669 7273 7429 2c74 6d70 293b 0a20  c.first),tmp);. 
-000066c0: 2020 207d 0a20 2020 2065 6c73 6520 6966     }.    else if
-000066d0: 2828 436f 6e6a 4c68 7329 2626 2821 436f  ((ConjLhs)&&(!Co
-000066e0: 6e6a 5268 7329 290a 2020 2020 7b0a 2020  njRhs)).    {.  
-000066f0: 2020 2020 746d 7020 3d20 7063 706c 7866      tmp = pcplxf
-00006700: 6c69 7028 5265 7350 6163 6b65 7428 632e  lip(ResPacket(c.
-00006710: 7365 636f 6e64 2929 3b0a 2020 2020 2020  second));.      
-00006720: 746d 7020 3d20 7061 6464 2870 636f 6e6a  tmp = padd(pconj
-00006730: 2852 6573 5061 636b 6574 2863 2e66 6972  (ResPacket(c.fir
-00006740: 7374 2929 2c74 6d70 293b 0a20 2020 207d  st)),tmp);.    }
-00006750: 0a20 2020 2065 6c73 6520 6966 2828 436f  .    else if((Co
-00006760: 6e6a 4c68 7329 2626 2843 6f6e 6a52 6873  njLhs)&&(ConjRhs
-00006770: 2929 0a20 2020 207b 0a20 2020 2020 2074  )).    {.      t
-00006780: 6d70 203d 2070 6370 6c78 666c 6970 2852  mp = pcplxflip(R
-00006790: 6573 5061 636b 6574 2863 2e73 6563 6f6e  esPacket(c.secon
-000067a0: 6429 293b 0a20 2020 2020 2074 6d70 203d  d));.      tmp =
-000067b0: 2070 7375 6228 7063 6f6e 6a28 5265 7350   psub(pconj(ResP
-000067c0: 6163 6b65 7428 632e 6669 7273 7429 292c  acket(c.first)),
-000067d0: 746d 7029 3b0a 2020 2020 7d0a 2020 2020  tmp);.    }.    
-000067e0: 0a20 2020 2072 203d 2070 6d61 6464 2874  .    r = pmadd(t
-000067f0: 6d70 2c61 6c70 6861 2c72 293b 0a20 207d  mp,alpha,r);.  }
-00006800: 0a0a 7072 6f74 6563 7465 643a 0a20 2063  ..protected:.  c
-00006810: 6f6e 6a5f 6865 6c70 6572 3c4c 6873 5363  onj_helper<LhsSc
-00006820: 616c 6172 2c52 6873 5363 616c 6172 2c43  alar,RhsScalar,C
-00006830: 6f6e 6a4c 6873 2c43 6f6e 6a52 6873 3e20  onjLhs,ConjRhs> 
-00006840: 636a 3b0a 7d3b 0a0a 7465 6d70 6c61 7465  cj;.};..template
-00006850: 3c74 7970 656e 616d 6520 5265 616c 5363  <typename RealSc
-00006860: 616c 6172 2c20 626f 6f6c 205f 436f 6e6a  alar, bool _Conj
-00006870: 5268 733e 0a63 6c61 7373 2067 6562 705f  Rhs>.class gebp_
-00006880: 7472 6169 7473 3c52 6561 6c53 6361 6c61  traits<RealScala
-00006890: 722c 2073 7464 3a3a 636f 6d70 6c65 783c  r, std::complex<
-000068a0: 5265 616c 5363 616c 6172 3e2c 2066 616c  RealScalar>, fal
-000068b0: 7365 2c20 5f43 6f6e 6a52 6873 203e 0a7b  se, _ConjRhs >.{
-000068c0: 0a70 7562 6c69 633a 0a20 2074 7970 6564  .public:.  typed
-000068d0: 6566 2073 7464 3a3a 636f 6d70 6c65 783c  ef std::complex<
-000068e0: 5265 616c 5363 616c 6172 3e20 2053 6361  RealScalar>  Sca
-000068f0: 6c61 723b 0a20 2074 7970 6564 6566 2052  lar;.  typedef R
-00006900: 6561 6c53 6361 6c61 7220 204c 6873 5363  ealScalar  LhsSc
-00006910: 616c 6172 3b0a 2020 7479 7065 6465 6620  alar;.  typedef 
-00006920: 5363 616c 6172 2020 2020 2020 5268 7353  Scalar      RhsS
-00006930: 6361 6c61 723b 0a20 2074 7970 6564 6566  calar;.  typedef
-00006940: 2053 6361 6c61 7220 2020 2020 2052 6573   Scalar      Res
-00006950: 5363 616c 6172 3b0a 0a20 2065 6e75 6d20  Scalar;..  enum 
-00006960: 7b0a 2020 2020 436f 6e6a 4c68 7320 3d20  {.    ConjLhs = 
-00006970: 6661 6c73 652c 0a20 2020 2043 6f6e 6a52  false,.    ConjR
-00006980: 6873 203d 205f 436f 6e6a 5268 732c 0a20  hs = _ConjRhs,. 
-00006990: 2020 2056 6563 746f 7269 7a61 626c 6520     Vectorizable 
-000069a0: 3d20 7061 636b 6574 5f74 7261 6974 733c  = packet_traits<
-000069b0: 5265 616c 5363 616c 6172 3e3a 3a56 6563  RealScalar>::Vec
-000069c0: 746f 7269 7a61 626c 650a 2020 2020 2020  torizable.      
-000069d0: 2020 2020 2020 2020 2020 2626 2070 6163            && pac
-000069e0: 6b65 745f 7472 6169 7473 3c53 6361 6c61  ket_traits<Scala
-000069f0: 723e 3a3a 5665 6374 6f72 697a 6162 6c65  r>::Vectorizable
-00006a00: 2c0a 2020 2020 4c68 7350 6163 6b65 7453  ,.    LhsPacketS
-00006a10: 697a 6520 3d20 5665 6374 6f72 697a 6162  ize = Vectorizab
-00006a20: 6c65 203f 2070 6163 6b65 745f 7472 6169  le ? packet_trai
-00006a30: 7473 3c4c 6873 5363 616c 6172 3e3a 3a73  ts<LhsScalar>::s
-00006a40: 697a 6520 3a20 312c 0a20 2020 2052 6873  ize : 1,.    Rhs
-00006a50: 5061 636b 6574 5369 7a65 203d 2056 6563  PacketSize = Vec
-00006a60: 746f 7269 7a61 626c 6520 3f20 7061 636b  torizable ? pack
-00006a70: 6574 5f74 7261 6974 733c 5268 7353 6361  et_traits<RhsSca
-00006a80: 6c61 723e 3a3a 7369 7a65 203a 2031 2c0a  lar>::size : 1,.
-00006a90: 2020 2020 5265 7350 6163 6b65 7453 697a      ResPacketSiz
-00006aa0: 6520 3d20 5665 6374 6f72 697a 6162 6c65  e = Vectorizable
-00006ab0: 203f 2070 6163 6b65 745f 7472 6169 7473   ? packet_traits
-00006ac0: 3c52 6573 5363 616c 6172 3e3a 3a73 697a  <ResScalar>::siz
-00006ad0: 6520 3a20 312c 0a20 2020 200a 2020 2020  e : 1,.    .    
-00006ae0: 4e75 6d62 6572 4f66 5265 6769 7374 6572  NumberOfRegister
-00006af0: 7320 3d20 4549 4745 4e5f 4152 4348 5f44  s = EIGEN_ARCH_D
-00006b00: 4546 4155 4c54 5f4e 554d 4245 525f 4f46  EFAULT_NUMBER_OF
-00006b10: 5f52 4547 4953 5445 5253 2c0a 2020 2020  _REGISTERS,.    
-00006b20: 2f2f 2046 4958 4d45 3a20 7368 6f75 6c64  // FIXME: should
-00006b30: 2064 6570 656e 6420 6f6e 204e 756d 6265   depend on Numbe
-00006b40: 724f 6652 6567 6973 7465 7273 0a20 2020  rOfRegisters.   
-00006b50: 206e 7220 3d20 342c 0a20 2020 206d 7220   nr = 4,.    mr 
-00006b60: 3d20 2845 4947 454e 5f50 4c41 494e 5f45  = (EIGEN_PLAIN_E
-00006b70: 4e55 4d5f 4d49 4e28 3136 2c4e 756d 6265  NUM_MIN(16,Numbe
-00006b80: 724f 6652 6567 6973 7465 7273 292f 322f  rOfRegisters)/2/
-00006b90: 6e72 292a 5265 7350 6163 6b65 7453 697a  nr)*ResPacketSiz
-00006ba0: 652c 0a0a 2020 2020 4c68 7350 726f 6772  e,..    LhsProgr
-00006bb0: 6573 7320 3d20 5265 7350 6163 6b65 7453  ess = ResPacketS
-00006bc0: 697a 652c 0a20 2020 2052 6873 5072 6f67  ize,.    RhsProg
-00006bd0: 7265 7373 203d 2031 0a20 207d 3b0a 0a20  ress = 1.  };.. 
-00006be0: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
-00006bf0: 6520 7061 636b 6574 5f74 7261 6974 733c  e packet_traits<
-00006c00: 4c68 7353 6361 6c61 723e 3a3a 7479 7065  LhsScalar>::type
-00006c10: 2020 5f4c 6873 5061 636b 6574 3b0a 2020    _LhsPacket;.  
-00006c20: 7479 7065 6465 6620 7479 7065 6e61 6d65  typedef typename
-00006c30: 2070 6163 6b65 745f 7472 6169 7473 3c52   packet_traits<R
-00006c40: 6873 5363 616c 6172 3e3a 3a74 7970 6520  hsScalar>::type 
-00006c50: 205f 5268 7350 6163 6b65 743b 0a20 2074   _RhsPacket;.  t
-00006c60: 7970 6564 6566 2074 7970 656e 616d 6520  ypedef typename 
-00006c70: 7061 636b 6574 5f74 7261 6974 733c 5265  packet_traits<Re
-00006c80: 7353 6361 6c61 723e 3a3a 7479 7065 2020  sScalar>::type  
-00006c90: 5f52 6573 5061 636b 6574 3b0a 0a20 2074  _ResPacket;..  t
-00006ca0: 7970 6564 6566 2074 7970 656e 616d 6520  ypedef typename 
-00006cb0: 636f 6e64 6974 696f 6e61 6c3c 5665 6374  conditional<Vect
-00006cc0: 6f72 697a 6162 6c65 2c5f 4c68 7350 6163  orizable,_LhsPac
-00006cd0: 6b65 742c 4c68 7353 6361 6c61 723e 3a3a  ket,LhsScalar>::
-00006ce0: 7479 7065 204c 6873 5061 636b 6574 3b0a  type LhsPacket;.
-00006cf0: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
-00006d00: 6d65 2063 6f6e 6469 7469 6f6e 616c 3c56  me conditional<V
-00006d10: 6563 746f 7269 7a61 626c 652c 5f52 6873  ectorizable,_Rhs
-00006d20: 5061 636b 6574 2c52 6873 5363 616c 6172  Packet,RhsScalar
-00006d30: 3e3a 3a74 7970 6520 5268 7350 6163 6b65  >::type RhsPacke
-00006d40: 743b 0a20 2074 7970 6564 6566 2074 7970  t;.  typedef typ
-00006d50: 656e 616d 6520 636f 6e64 6974 696f 6e61  ename conditiona
-00006d60: 6c3c 5665 6374 6f72 697a 6162 6c65 2c5f  l<Vectorizable,_
-00006d70: 5265 7350 6163 6b65 742c 5265 7353 6361  ResPacket,ResSca
-00006d80: 6c61 723e 3a3a 7479 7065 2052 6573 5061  lar>::type ResPa
-00006d90: 636b 6574 3b0a 0a20 2074 7970 6564 6566  cket;..  typedef
-00006da0: 2052 6573 5061 636b 6574 2041 6363 5061   ResPacket AccPa
-00006db0: 636b 6574 3b0a 0a20 2045 4947 454e 5f53  cket;..  EIGEN_S
-00006dc0: 5452 4f4e 475f 494e 4c49 4e45 2076 6f69  TRONG_INLINE voi
-00006dd0: 6420 696e 6974 4163 6328 4163 6350 6163  d initAcc(AccPac
-00006de0: 6b65 7426 2070 290a 2020 7b0a 2020 2020  ket& p).  {.    
-00006df0: 7020 3d20 7073 6574 313c 5265 7350 6163  p = pset1<ResPac
-00006e00: 6b65 743e 2852 6573 5363 616c 6172 2830  ket>(ResScalar(0
-00006e10: 2929 3b0a 2020 7d0a 0a20 2045 4947 454e  ));.  }..  EIGEN
-00006e20: 5f53 5452 4f4e 475f 494e 4c49 4e45 2076  _STRONG_INLINE v
-00006e30: 6f69 6420 6c6f 6164 5268 7328 636f 6e73  oid loadRhs(cons
-00006e40: 7420 5268 7353 6361 6c61 722a 2062 2c20  t RhsScalar* b, 
-00006e50: 5268 7350 6163 6b65 7426 2064 6573 7429  RhsPacket& dest)
-00006e60: 2063 6f6e 7374 0a20 207b 0a20 2020 2064   const.  {.    d
-00006e70: 6573 7420 3d20 7073 6574 313c 5268 7350  est = pset1<RhsP
-00006e80: 6163 6b65 743e 282a 6229 3b0a 2020 7d0a  acket>(*b);.  }.
-00006e90: 2020 0a20 2076 6f69 6420 6272 6f61 6463    .  void broadc
-00006ea0: 6173 7452 6873 2863 6f6e 7374 2052 6873  astRhs(const Rhs
-00006eb0: 5363 616c 6172 2a20 622c 2052 6873 5061  Scalar* b, RhsPa
-00006ec0: 636b 6574 2620 6230 2c20 5268 7350 6163  cket& b0, RhsPac
-00006ed0: 6b65 7426 2062 312c 2052 6873 5061 636b  ket& b1, RhsPack
-00006ee0: 6574 2620 6232 2c20 5268 7350 6163 6b65  et& b2, RhsPacke
-00006ef0: 7426 2062 3329 0a20 207b 0a20 2020 2070  t& b3).  {.    p
-00006f00: 6272 6f61 6463 6173 7434 2862 2c20 6230  broadcast4(b, b0
-00006f10: 2c20 6231 2c20 6232 2c20 6233 293b 0a20  , b1, b2, b3);. 
-00006f20: 207d 0a20 200a 2f2f 2020 2045 4947 454e   }.  .//   EIGEN
-00006f30: 5f53 5452 4f4e 475f 494e 4c49 4e45 2076  _STRONG_INLINE v
-00006f40: 6f69 6420 6272 6f61 6463 6173 7452 6873  oid broadcastRhs
-00006f50: 2863 6f6e 7374 2052 6873 5363 616c 6172  (const RhsScalar
-00006f60: 2a20 622c 2052 6873 5061 636b 6574 2620  * b, RhsPacket& 
-00006f70: 6230 2c20 5268 7350 6163 6b65 7426 2062  b0, RhsPacket& b
-00006f80: 3129 0a2f 2f20 2020 7b0a 2f2f 2020 2020  1).//   {.//    
-00006f90: 202f 2f20 4649 584d 4520 6e6f 7420 7375   // FIXME not su
-00006fa0: 7265 2074 6861 7427 7320 7468 6520 6265  re that's the be
-00006fb0: 7374 2077 6179 2074 6f20 696d 706c 656d  st way to implem
-00006fc0: 656e 7420 6974 210a 2f2f 2020 2020 2062  ent it!.//     b
-00006fd0: 3020 3d20 706c 6f61 6431 3c52 6873 5061  0 = pload1<RhsPa
-00006fe0: 636b 6574 3e28 622b 3029 3b0a 2f2f 2020  cket>(b+0);.//  
-00006ff0: 2020 2062 3120 3d20 706c 6f61 6431 3c52     b1 = pload1<R
-00007000: 6873 5061 636b 6574 3e28 622b 3129 3b0a  hsPacket>(b+1);.
-00007010: 2f2f 2020 207d 0a0a 2020 4549 4745 4e5f  //   }..  EIGEN_
-00007020: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
-00007030: 6964 206c 6f61 644c 6873 2863 6f6e 7374  id loadLhs(const
-00007040: 204c 6873 5363 616c 6172 2a20 612c 204c   LhsScalar* a, L
-00007050: 6873 5061 636b 6574 2620 6465 7374 2920  hsPacket& dest) 
-00007060: 636f 6e73 740a 2020 7b0a 2020 2020 6465  const.  {.    de
-00007070: 7374 203d 2070 6c6f 6164 6475 703c 4c68  st = ploaddup<Lh
-00007080: 7350 6163 6b65 743e 2861 293b 0a20 207d  sPacket>(a);.  }
-00007090: 0a20 200a 2020 4549 4745 4e5f 5354 524f  .  .  EIGEN_STRO
-000070a0: 4e47 5f49 4e4c 494e 4520 766f 6964 206c  NG_INLINE void l
-000070b0: 6f61 6452 6873 5175 6164 2863 6f6e 7374  oadRhsQuad(const
-000070c0: 2052 6873 5363 616c 6172 2a20 622c 2052   RhsScalar* b, R
-000070d0: 6873 5061 636b 6574 2620 6465 7374 2920  hsPacket& dest) 
-000070e0: 636f 6e73 740a 2020 7b0a 2020 2020 6569  const.  {.    ei
-000070f0: 6765 6e5f 696e 7465 726e 616c 5f61 7373  gen_internal_ass
-00007100: 6572 7428 756e 7061 636b 6574 5f74 7261  ert(unpacket_tra
-00007110: 6974 733c 5268 7350 6163 6b65 743e 3a3a  its<RhsPacket>::
-00007120: 7369 7a65 3c3d 3429 3b0a 2020 2020 6c6f  size<=4);.    lo
-00007130: 6164 5268 7328 622c 6465 7374 293b 0a20  adRhs(b,dest);. 
-00007140: 207d 0a0a 2020 4549 4745 4e5f 5354 524f   }..  EIGEN_STRO
-00007150: 4e47 5f49 4e4c 494e 4520 766f 6964 206c  NG_INLINE void l
-00007160: 6f61 644c 6873 556e 616c 6967 6e65 6428  oadLhsUnaligned(
-00007170: 636f 6e73 7420 4c68 7353 6361 6c61 722a  const LhsScalar*
-00007180: 2061 2c20 4c68 7350 6163 6b65 7426 2064   a, LhsPacket& d
-00007190: 6573 7429 2063 6f6e 7374 0a20 207b 0a20  est) const.  {. 
-000071a0: 2020 2064 6573 7420 3d20 706c 6f61 6464     dest = ploadd
-000071b0: 7570 3c4c 6873 5061 636b 6574 3e28 6129  up<LhsPacket>(a)
-000071c0: 3b0a 2020 7d0a 0a20 2045 4947 454e 5f53  ;.  }..  EIGEN_S
-000071d0: 5452 4f4e 475f 494e 4c49 4e45 2076 6f69  TRONG_INLINE voi
-000071e0: 6420 6d61 6464 2863 6f6e 7374 204c 6873  d madd(const Lhs
-000071f0: 5061 636b 6574 2620 612c 2063 6f6e 7374  Packet& a, const
-00007200: 2052 6873 5061 636b 6574 2620 622c 2041   RhsPacket& b, A
-00007210: 6363 5061 636b 6574 2620 632c 2052 6873  ccPacket& c, Rhs
-00007220: 5061 636b 6574 2620 746d 7029 2063 6f6e  Packet& tmp) con
-00007230: 7374 0a20 207b 0a20 2020 206d 6164 645f  st.  {.    madd_
-00007240: 696d 706c 2861 2c20 622c 2063 2c20 746d  impl(a, b, c, tm
-00007250: 702c 2074 7970 656e 616d 6520 636f 6e64  p, typename cond
-00007260: 6974 696f 6e61 6c3c 5665 6374 6f72 697a  itional<Vectoriz
-00007270: 6162 6c65 2c74 7275 655f 7479 7065 2c66  able,true_type,f
-00007280: 616c 7365 5f74 7970 653e 3a3a 7479 7065  alse_type>::type
-00007290: 2829 293b 0a20 207d 0a0a 2020 4549 4745  ());.  }..  EIGE
-000072a0: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
-000072b0: 766f 6964 206d 6164 645f 696d 706c 2863  void madd_impl(c
-000072c0: 6f6e 7374 204c 6873 5061 636b 6574 2620  onst LhsPacket& 
-000072d0: 612c 2063 6f6e 7374 2052 6873 5061 636b  a, const RhsPack
-000072e0: 6574 2620 622c 2041 6363 5061 636b 6574  et& b, AccPacket
-000072f0: 2620 632c 2052 6873 5061 636b 6574 2620  & c, RhsPacket& 
-00007300: 746d 702c 2063 6f6e 7374 2074 7275 655f  tmp, const true_
-00007310: 7479 7065 2629 2063 6f6e 7374 0a20 207b  type&) const.  {
-00007320: 0a23 6966 6465 6620 4549 4745 4e5f 4841  .#ifdef EIGEN_HA
-00007330: 535f 5349 4e47 4c45 5f49 4e53 5452 5543  S_SINGLE_INSTRUC
-00007340: 5449 4f4e 5f4d 4144 440a 2020 2020 4549  TION_MADD.    EI
-00007350: 4745 4e5f 554e 5553 4544 5f56 4152 4941  GEN_UNUSED_VARIA
-00007360: 424c 4528 746d 7029 3b0a 2020 2020 632e  BLE(tmp);.    c.
-00007370: 7620 3d20 706d 6164 6428 612c 622e 762c  v = pmadd(a,b.v,
-00007380: 632e 7629 3b0a 2365 6c73 650a 2020 2020  c.v);.#else.    
-00007390: 746d 7020 3d20 623b 2074 6d70 2e76 203d  tmp = b; tmp.v =
-000073a0: 2070 6d75 6c28 612c 746d 702e 7629 3b20   pmul(a,tmp.v); 
-000073b0: 6320 3d20 7061 6464 2863 2c74 6d70 293b  c = padd(c,tmp);
-000073c0: 0a23 656e 6469 660a 2020 2020 0a20 207d  .#endif.    .  }
-000073d0: 0a0a 2020 4549 4745 4e5f 5354 524f 4e47  ..  EIGEN_STRONG
-000073e0: 5f49 4e4c 494e 4520 766f 6964 206d 6164  _INLINE void mad
-000073f0: 645f 696d 706c 2863 6f6e 7374 204c 6873  d_impl(const Lhs
-00007400: 5363 616c 6172 2620 612c 2063 6f6e 7374  Scalar& a, const
-00007410: 2052 6873 5363 616c 6172 2620 622c 2052   RhsScalar& b, R
-00007420: 6573 5363 616c 6172 2620 632c 2052 6873  esScalar& c, Rhs
-00007430: 5363 616c 6172 2620 2f2a 746d 702a 2f2c  Scalar& /*tmp*/,
-00007440: 2063 6f6e 7374 2066 616c 7365 5f74 7970   const false_typ
-00007450: 6526 2920 636f 6e73 740a 2020 7b0a 2020  e&) const.  {.  
-00007460: 2020 6320 2b3d 2061 202a 2062 3b0a 2020    c += a * b;.  
-00007470: 7d0a 0a20 2045 4947 454e 5f53 5452 4f4e  }..  EIGEN_STRON
-00007480: 475f 494e 4c49 4e45 2076 6f69 6420 6163  G_INLINE void ac
-00007490: 6328 636f 6e73 7420 4163 6350 6163 6b65  c(const AccPacke
-000074a0: 7426 2063 2c20 636f 6e73 7420 5265 7350  t& c, const ResP
-000074b0: 6163 6b65 7426 2061 6c70 6861 2c20 5265  acket& alpha, Re
-000074c0: 7350 6163 6b65 7426 2072 2920 636f 6e73  sPacket& r) cons
-000074d0: 740a 2020 7b0a 2020 2020 7220 3d20 636a  t.  {.    r = cj
-000074e0: 2e70 6d61 6464 2861 6c70 6861 2c63 2c72  .pmadd(alpha,c,r
-000074f0: 293b 0a20 207d 0a0a 7072 6f74 6563 7465  );.  }..protecte
-00007500: 643a 0a20 2063 6f6e 6a5f 6865 6c70 6572  d:.  conj_helper
-00007510: 3c52 6573 5061 636b 6574 2c52 6573 5061  <ResPacket,ResPa
-00007520: 636b 6574 2c66 616c 7365 2c43 6f6e 6a52  cket,false,ConjR
-00007530: 6873 3e20 636a 3b0a 7d3b 0a0a 2f2a 206f  hs> cj;.};../* o
-00007540: 7074 696d 697a 6564 2047 456e 6572 616c  ptimized GEneral
-00007550: 2070 6163 6b65 6420 426c 6f63 6b20 2a20   packed Block * 
-00007560: 7061 636b 6564 2050 616e 656c 2070 726f  packed Panel pro
-00007570: 6475 6374 206b 6572 6e65 6c0a 202a 0a20  duct kernel. *. 
-00007580: 2a20 4d69 7869 6e67 2074 7970 6520 6c6f  * Mixing type lo
-00007590: 6769 633a 2043 202b 3d20 4120 2a20 420a  gic: C += A * B.
-000075a0: 202a 2020 7c20 2041 2020 7c20 2042 2020   *  |  A  |  B  
-000075b0: 7c20 636f 6d6d 656e 7473 0a20 2a20 207c  | comments. *  |
-000075c0: 7265 616c 207c 6370 6c78 207c 206e 6f20  real |cplx | no 
-000075d0: 7665 6374 6f72 697a 6174 696f 6e20 7965  vectorization ye
-000075e0: 742c 2077 6f75 6c64 2072 6571 7569 7265  t, would require
-000075f0: 2074 6f20 7061 636b 2041 2077 6974 6820   to pack A with 
-00007600: 6475 706c 6963 6174 696f 6e0a 202a 2020  duplication. *  
-00007610: 7c63 706c 7820 7c72 6561 6c20 7c20 6561  |cplx |real | ea
-00007620: 7379 2076 6563 746f 7269 7a61 7469 6f6e  sy vectorization
-00007630: 0a20 2a2f 0a74 656d 706c 6174 653c 7479  . */.template<ty
-00007640: 7065 6e61 6d65 204c 6873 5363 616c 6172  pename LhsScalar
-00007650: 2c20 7479 7065 6e61 6d65 2052 6873 5363  , typename RhsSc
-00007660: 616c 6172 2c20 7479 7065 6e61 6d65 2049  alar, typename I
-00007670: 6e64 6578 2c20 7479 7065 6e61 6d65 2044  ndex, typename D
-00007680: 6174 614d 6170 7065 722c 2069 6e74 206d  ataMapper, int m
-00007690: 722c 2069 6e74 206e 722c 2062 6f6f 6c20  r, int nr, bool 
-000076a0: 436f 6e6a 7567 6174 654c 6873 2c20 626f  ConjugateLhs, bo
-000076b0: 6f6c 2043 6f6e 6a75 6761 7465 5268 733e  ol ConjugateRhs>
-000076c0: 0a73 7472 7563 7420 6765 6270 5f6b 6572  .struct gebp_ker
-000076d0: 6e65 6c0a 7b0a 2020 7479 7065 6465 6620  nel.{.  typedef 
-000076e0: 6765 6270 5f74 7261 6974 733c 4c68 7353  gebp_traits<LhsS
-000076f0: 6361 6c61 722c 5268 7353 6361 6c61 722c  calar,RhsScalar,
-00007700: 436f 6e6a 7567 6174 654c 6873 2c43 6f6e  ConjugateLhs,Con
-00007710: 6a75 6761 7465 5268 733e 2054 7261 6974  jugateRhs> Trait
-00007720: 733b 0a20 2074 7970 6564 6566 2074 7970  s;.  typedef typ
-00007730: 656e 616d 6520 5472 6169 7473 3a3a 5265  ename Traits::Re
-00007740: 7353 6361 6c61 7220 5265 7353 6361 6c61  sScalar ResScala
-00007750: 723b 0a20 2074 7970 6564 6566 2074 7970  r;.  typedef typ
-00007760: 656e 616d 6520 5472 6169 7473 3a3a 4c68  ename Traits::Lh
-00007770: 7350 6163 6b65 7420 4c68 7350 6163 6b65  sPacket LhsPacke
-00007780: 743b 0a20 2074 7970 6564 6566 2074 7970  t;.  typedef typ
-00007790: 656e 616d 6520 5472 6169 7473 3a3a 5268  ename Traits::Rh
-000077a0: 7350 6163 6b65 7420 5268 7350 6163 6b65  sPacket RhsPacke
-000077b0: 743b 0a20 2074 7970 6564 6566 2074 7970  t;.  typedef typ
-000077c0: 656e 616d 6520 5472 6169 7473 3a3a 5265  ename Traits::Re
-000077d0: 7350 6163 6b65 7420 5265 7350 6163 6b65  sPacket ResPacke
-000077e0: 743b 0a20 2074 7970 6564 6566 2074 7970  t;.  typedef typ
-000077f0: 656e 616d 6520 5472 6169 7473 3a3a 4163  ename Traits::Ac
-00007800: 6350 6163 6b65 7420 4163 6350 6163 6b65  cPacket AccPacke
-00007810: 743b 0a0a 2020 7479 7065 6465 6620 6765  t;..  typedef ge
-00007820: 6270 5f74 7261 6974 733c 5268 7353 6361  bp_traits<RhsSca
-00007830: 6c61 722c 4c68 7353 6361 6c61 722c 436f  lar,LhsScalar,Co
-00007840: 6e6a 7567 6174 6552 6873 2c43 6f6e 6a75  njugateRhs,Conju
-00007850: 6761 7465 4c68 733e 2053 7761 7070 6564  gateLhs> Swapped
-00007860: 5472 6169 7473 3b0a 2020 7479 7065 6465  Traits;.  typede
-00007870: 6620 7479 7065 6e61 6d65 2053 7761 7070  f typename Swapp
-00007880: 6564 5472 6169 7473 3a3a 5265 7353 6361  edTraits::ResSca
-00007890: 6c61 7220 5352 6573 5363 616c 6172 3b0a  lar SResScalar;.
-000078a0: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
-000078b0: 6d65 2053 7761 7070 6564 5472 6169 7473  me SwappedTraits
-000078c0: 3a3a 4c68 7350 6163 6b65 7420 534c 6873  ::LhsPacket SLhs
-000078d0: 5061 636b 6574 3b0a 2020 7479 7065 6465  Packet;.  typede
-000078e0: 6620 7479 7065 6e61 6d65 2053 7761 7070  f typename Swapp
-000078f0: 6564 5472 6169 7473 3a3a 5268 7350 6163  edTraits::RhsPac
-00007900: 6b65 7420 5352 6873 5061 636b 6574 3b0a  ket SRhsPacket;.
-00007910: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
-00007920: 6d65 2053 7761 7070 6564 5472 6169 7473  me SwappedTraits
-00007930: 3a3a 5265 7350 6163 6b65 7420 5352 6573  ::ResPacket SRes
-00007940: 5061 636b 6574 3b0a 2020 7479 7065 6465  Packet;.  typede
-00007950: 6620 7479 7065 6e61 6d65 2053 7761 7070  f typename Swapp
-00007960: 6564 5472 6169 7473 3a3a 4163 6350 6163  edTraits::AccPac
-00007970: 6b65 7420 5341 6363 5061 636b 6574 3b0a  ket SAccPacket;.
-00007980: 0a20 2074 7970 6564 6566 2074 7970 656e  .  typedef typen
-00007990: 616d 6520 4461 7461 4d61 7070 6572 3a3a  ame DataMapper::
-000079a0: 4c69 6e65 6172 4d61 7070 6572 204c 696e  LinearMapper Lin
-000079b0: 6561 724d 6170 7065 723b 0a0a 2020 656e  earMapper;..  en
-000079c0: 756d 207b 0a20 2020 2056 6563 746f 7269  um {.    Vectori
-000079d0: 7a61 626c 6520 203d 2054 7261 6974 733a  zable  = Traits:
-000079e0: 3a56 6563 746f 7269 7a61 626c 652c 0a20  :Vectorizable,. 
-000079f0: 2020 204c 6873 5072 6f67 7265 7373 2020     LhsProgress  
-00007a00: 203d 2054 7261 6974 733a 3a4c 6873 5072   = Traits::LhsPr
-00007a10: 6f67 7265 7373 2c0a 2020 2020 5268 7350  ogress,.    RhsP
-00007a20: 726f 6772 6573 7320 2020 3d20 5472 6169  rogress   = Trai
-00007a30: 7473 3a3a 5268 7350 726f 6772 6573 732c  ts::RhsProgress,
-00007a40: 0a20 2020 2052 6573 5061 636b 6574 5369  .    ResPacketSi
-00007a50: 7a65 203d 2054 7261 6974 733a 3a52 6573  ze = Traits::Res
-00007a60: 5061 636b 6574 5369 7a65 0a20 207d 3b0a  PacketSize.  };.
-00007a70: 0a20 2045 4947 454e 5f44 4f4e 545f 494e  .  EIGEN_DONT_IN
-00007a80: 4c49 4e45 0a20 2076 6f69 6420 6f70 6572  LINE.  void oper
-00007a90: 6174 6f72 2829 2863 6f6e 7374 2044 6174  ator()(const Dat
-00007aa0: 614d 6170 7065 7226 2072 6573 2c20 636f  aMapper& res, co
-00007ab0: 6e73 7420 4c68 7353 6361 6c61 722a 2062  nst LhsScalar* b
-00007ac0: 6c6f 636b 412c 2063 6f6e 7374 2052 6873  lockA, const Rhs
-00007ad0: 5363 616c 6172 2a20 626c 6f63 6b42 2c0a  Scalar* blockB,.
-00007ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007af0: 2020 496e 6465 7820 726f 7773 2c20 496e    Index rows, In
-00007b00: 6465 7820 6465 7074 682c 2049 6e64 6578  dex depth, Index
-00007b10: 2063 6f6c 732c 2052 6573 5363 616c 6172   cols, ResScalar
-00007b20: 2061 6c70 6861 2c0a 2020 2020 2020 2020   alpha,.        
-00007b30: 2020 2020 2020 2020 2020 496e 6465 7820            Index 
-00007b40: 7374 7269 6465 413d 2d31 2c20 496e 6465  strideA=-1, Inde
-00007b50: 7820 7374 7269 6465 423d 2d31 2c20 496e  x strideB=-1, In
-00007b60: 6465 7820 6f66 6673 6574 413d 302c 2049  dex offsetA=0, I
-00007b70: 6e64 6578 206f 6666 7365 7442 3d30 293b  ndex offsetB=0);
-00007b80: 0a7d 3b0a 0a74 656d 706c 6174 653c 7479  .};..template<ty
-00007b90: 7065 6e61 6d65 204c 6873 5363 616c 6172  pename LhsScalar
-00007ba0: 2c20 7479 7065 6e61 6d65 2052 6873 5363  , typename RhsSc
-00007bb0: 616c 6172 2c20 7479 7065 6e61 6d65 2049  alar, typename I
-00007bc0: 6e64 6578 2c20 7479 7065 6e61 6d65 2044  ndex, typename D
-00007bd0: 6174 614d 6170 7065 722c 2069 6e74 206d  ataMapper, int m
-00007be0: 722c 2069 6e74 206e 722c 2062 6f6f 6c20  r, int nr, bool 
-00007bf0: 436f 6e6a 7567 6174 654c 6873 2c20 626f  ConjugateLhs, bo
-00007c00: 6f6c 2043 6f6e 6a75 6761 7465 5268 733e  ol ConjugateRhs>
-00007c10: 0a45 4947 454e 5f44 4f4e 545f 494e 4c49  .EIGEN_DONT_INLI
-00007c20: 4e45 0a76 6f69 6420 6765 6270 5f6b 6572  NE.void gebp_ker
-00007c30: 6e65 6c3c 4c68 7353 6361 6c61 722c 5268  nel<LhsScalar,Rh
-00007c40: 7353 6361 6c61 722c 496e 6465 782c 4461  sScalar,Index,Da
-00007c50: 7461 4d61 7070 6572 2c6d 722c 6e72 2c43  taMapper,mr,nr,C
-00007c60: 6f6e 6a75 6761 7465 4c68 732c 436f 6e6a  onjugateLhs,Conj
-00007c70: 7567 6174 6552 6873 3e0a 2020 3a3a 6f70  ugateRhs>.  ::op
-00007c80: 6572 6174 6f72 2829 2863 6f6e 7374 2044  erator()(const D
-00007c90: 6174 614d 6170 7065 7226 2072 6573 2c20  ataMapper& res, 
-00007ca0: 636f 6e73 7420 4c68 7353 6361 6c61 722a  const LhsScalar*
-00007cb0: 2062 6c6f 636b 412c 2063 6f6e 7374 2052   blockA, const R
-00007cc0: 6873 5363 616c 6172 2a20 626c 6f63 6b42  hsScalar* blockB
-00007cd0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00007ce0: 2049 6e64 6578 2072 6f77 732c 2049 6e64   Index rows, Ind
-00007cf0: 6578 2064 6570 7468 2c20 496e 6465 7820  ex depth, Index 
-00007d00: 636f 6c73 2c20 5265 7353 6361 6c61 7220  cols, ResScalar 
-00007d10: 616c 7068 612c 0a20 2020 2020 2020 2020  alpha,.         
-00007d20: 2020 2020 2020 496e 6465 7820 7374 7269        Index stri
-00007d30: 6465 412c 2049 6e64 6578 2073 7472 6964  deA, Index strid
-00007d40: 6542 2c20 496e 6465 7820 6f66 6673 6574  eB, Index offset
-00007d50: 412c 2049 6e64 6578 206f 6666 7365 7442  A, Index offsetB
-00007d60: 290a 2020 7b0a 2020 2020 5472 6169 7473  ).  {.    Traits
-00007d70: 2074 7261 6974 733b 0a20 2020 2053 7761   traits;.    Swa
-00007d80: 7070 6564 5472 6169 7473 2073 7472 6169  ppedTraits strai
-00007d90: 7473 3b0a 2020 2020 0a20 2020 2069 6628  ts;.    .    if(
-00007da0: 7374 7269 6465 413d 3d2d 3129 2073 7472  strideA==-1) str
-00007db0: 6964 6541 203d 2064 6570 7468 3b0a 2020  ideA = depth;.  
-00007dc0: 2020 6966 2873 7472 6964 6542 3d3d 2d31    if(strideB==-1
-00007dd0: 2920 7374 7269 6465 4220 3d20 6465 7074  ) strideB = dept
-00007de0: 683b 0a20 2020 2063 6f6e 6a5f 6865 6c70  h;.    conj_help
-00007df0: 6572 3c4c 6873 5363 616c 6172 2c52 6873  er<LhsScalar,Rhs
-00007e00: 5363 616c 6172 2c43 6f6e 6a75 6761 7465  Scalar,Conjugate
-00007e10: 4c68 732c 436f 6e6a 7567 6174 6552 6873  Lhs,ConjugateRhs
-00007e20: 3e20 636a 3b0a 2020 2020 496e 6465 7820  > cj;.    Index 
-00007e30: 7061 636b 6574 5f63 6f6c 7334 203d 206e  packet_cols4 = n
-00007e40: 723e 3d34 203f 2028 636f 6c73 2f34 2920  r>=4 ? (cols/4) 
-00007e50: 2a20 3420 3a20 303b 0a20 2020 2063 6f6e  * 4 : 0;.    con
-00007e60: 7374 2049 6e64 6578 2070 6565 6c65 645f  st Index peeled_
-00007e70: 6d63 3320 3d20 6d72 3e3d 332a 5472 6169  mc3 = mr>=3*Trai
-00007e80: 7473 3a3a 4c68 7350 726f 6772 6573 7320  ts::LhsProgress 
-00007e90: 3f20 2872 6f77 732f 2833 2a4c 6873 5072  ? (rows/(3*LhsPr
-00007ea0: 6f67 7265 7373 2929 2a28 332a 4c68 7350  ogress))*(3*LhsP
-00007eb0: 726f 6772 6573 7329 203a 2030 3b0a 2020  rogress) : 0;.  
-00007ec0: 2020 636f 6e73 7420 496e 6465 7820 7065    const Index pe
-00007ed0: 656c 6564 5f6d 6332 203d 206d 723e 3d32  eled_mc2 = mr>=2
-00007ee0: 2a54 7261 6974 733a 3a4c 6873 5072 6f67  *Traits::LhsProg
-00007ef0: 7265 7373 203f 2070 6565 6c65 645f 6d63  ress ? peeled_mc
-00007f00: 332b 2828 726f 7773 2d70 6565 6c65 645f  3+((rows-peeled_
-00007f10: 6d63 3329 2f28 322a 4c68 7350 726f 6772  mc3)/(2*LhsProgr
-00007f20: 6573 7329 292a 2832 2a4c 6873 5072 6f67  ess))*(2*LhsProg
-00007f30: 7265 7373 2920 3a20 303b 0a20 2020 2063  ress) : 0;.    c
-00007f40: 6f6e 7374 2049 6e64 6578 2070 6565 6c65  onst Index peele
-00007f50: 645f 6d63 3120 3d20 6d72 3e3d 312a 5472  d_mc1 = mr>=1*Tr
-00007f60: 6169 7473 3a3a 4c68 7350 726f 6772 6573  aits::LhsProgres
-00007f70: 7320 3f20 2872 6f77 732f 2831 2a4c 6873  s ? (rows/(1*Lhs
-00007f80: 5072 6f67 7265 7373 2929 2a28 312a 4c68  Progress))*(1*Lh
-00007f90: 7350 726f 6772 6573 7329 203a 2030 3b0a  sProgress) : 0;.
-00007fa0: 2020 2020 656e 756d 207b 2070 6b20 3d20      enum { pk = 
-00007fb0: 3820 7d3b 202f 2f20 4e4f 5445 2053 7563  8 }; // NOTE Suc
-00007fc0: 6820 6120 6c61 7267 6520 7065 656c 696e  h a large peelin
-00007fd0: 6720 6661 6374 6f72 2069 7320 696d 706f  g factor is impo
-00007fe0: 7274 616e 7420 666f 7220 6c61 7267 6520  rtant for large 
-00007ff0: 6d61 7472 6963 6573 2028 7e20 2b35 2520  matrices (~ +5% 
-00008000: 7768 656e 203e 3130 3030 206f 6e20 4861  when >1000 on Ha
-00008010: 7377 656c 6c29 0a20 2020 2063 6f6e 7374  swell).    const
-00008020: 2049 6e64 6578 2070 6565 6c65 645f 6b63   Index peeled_kc
-00008030: 2020 3d20 6465 7074 6820 2620 7e28 706b    = depth & ~(pk
-00008040: 2d31 293b 0a20 2020 2063 6f6e 7374 2049  -1);.    const I
-00008050: 6e64 6578 2070 7265 6665 7463 685f 7265  ndex prefetch_re
-00008060: 735f 6f66 6673 6574 203d 2033 322f 7369  s_offset = 32/si
-00008070: 7a65 6f66 2852 6573 5363 616c 6172 293b  zeof(ResScalar);
-00008080: 2020 2020 0a2f 2f20 2020 2020 636f 6e73      .//     cons
-00008090: 7420 496e 6465 7820 6465 7074 6832 2020  t Index depth2  
-000080a0: 2020 203d 2064 6570 7468 2026 207e 313b     = depth & ~1;
-000080b0: 0a0a 2020 2020 2f2f 2d2d 2d2d 2d2d 2d2d  ..    //--------
-000080c0: 2d2d 2050 726f 6365 7373 2033 202a 204c  -- Process 3 * L
-000080d0: 6873 5072 6f67 7265 7373 2072 6f77 7320  hsProgress rows 
-000080e0: 6174 206f 6e63 6520 2d2d 2d2d 2d2d 2d2d  at once --------
-000080f0: 2d2d 0a20 2020 202f 2f20 5468 6973 2063  --.    // This c
-00008100: 6f72 7265 7370 6f6e 6473 2074 6f20 332a  orresponds to 3*
-00008110: 4c68 7350 726f 6772 6573 7320 7820 6e72  LhsProgress x nr
-00008120: 2072 6567 6973 7465 7220 626c 6f63 6b73   register blocks
-00008130: 2e0a 2020 2020 2f2f 2055 7375 616c 6c79  ..    // Usually
-00008140: 2c20 6d61 6b65 2073 656e 7365 206f 6e6c  , make sense onl
-00008150: 7920 7769 7468 2046 4d41 0a20 2020 2069  y with FMA.    i
-00008160: 6628 6d72 3e3d 332a 5472 6169 7473 3a3a  f(mr>=3*Traits::
-00008170: 4c68 7350 726f 6772 6573 7329 0a20 2020  LhsProgress).   
-00008180: 207b 0a20 2020 2020 202f 2f20 4865 7265   {.      // Here
-00008190: 2c20 7468 6520 6765 6e65 7261 6c20 6964  , the general id
-000081a0: 6561 2069 7320 746f 206c 6f6f 7020 6f6e  ea is to loop on
-000081b0: 2065 6163 6820 6c61 7267 6573 7420 6d69   each largest mi
-000081c0: 6372 6f20 686f 7269 7a6f 6e74 616c 2070  cro horizontal p
-000081d0: 616e 656c 206f 6620 7468 6520 6c68 7320  anel of the lhs 
-000081e0: 2833 2a54 7261 6974 733a 3a4c 6873 5072  (3*Traits::LhsPr
-000081f0: 6f67 7265 7373 2078 2064 6570 7468 290a  ogress x depth).
-00008200: 2020 2020 2020 2f2f 2061 6e64 206f 6e20        // and on 
-00008210: 6561 6368 206c 6172 6765 7374 206d 6963  each largest mic
-00008220: 726f 2076 6572 7469 6361 6c20 7061 6e65  ro vertical pane
-00008230: 6c20 6f66 2074 6865 2072 6873 2028 6465  l of the rhs (de
-00008240: 7074 6820 2a20 6e72 292e 0a20 2020 2020  pth * nr)..     
-00008250: 202f 2f20 426c 6f63 6b69 6e67 2073 697a   // Blocking siz
-00008260: 6573 2c20 692e 652e 2c20 2764 6570 7468  es, i.e., 'depth
-00008270: 2720 6861 7320 6265 656e 2063 6f6d 7075  ' has been compu
-00008280: 7465 6420 736f 2074 6861 7420 7468 6520  ted so that the 
-00008290: 6d69 6372 6f20 686f 7269 7a6f 6e74 616c  micro horizontal
-000082a0: 2070 616e 656c 206f 6620 7468 6520 6c68   panel of the lh
-000082b0: 7320 6669 7420 696e 204c 312e 0a20 2020  s fit in L1..   
-000082c0: 2020 202f 2f20 486f 7765 7665 722c 2069     // However, i
-000082d0: 6620 6465 7074 6820 6973 2074 6f6f 2073  f depth is too s
-000082e0: 6d61 6c6c 2c20 7765 2063 616e 2065 7874  mall, we can ext
-000082f0: 656e 6420 7468 6520 6e75 6d62 6572 206f  end the number o
-00008300: 6620 726f 7773 206f 6620 7468 6573 6520  f rows of these 
-00008310: 686f 7269 7a6f 6e74 616c 2070 616e 656c  horizontal panel
-00008320: 732e 0a20 2020 2020 202f 2f20 5468 6973  s..      // This
-00008330: 2061 6374 7561 6c20 6e75 6d62 6572 206f   actual number o
-00008340: 6620 726f 7773 2069 7320 636f 6d70 7574  f rows is comput
-00008350: 6564 2061 7320 666f 6c6c 6f77 3a0a 2020  ed as follow:.  
-00008360: 2020 2020 636f 6e73 7420 496e 6465 7820      const Index 
-00008370: 6c31 203d 2064 6566 6175 6c74 4c31 4361  l1 = defaultL1Ca
-00008380: 6368 6553 697a 653b 202f 2f20 696e 2042  cheSize; // in B
-00008390: 7974 6573 2c20 544f 444f 2c20 6c31 2073  ytes, TODO, l1 s
-000083a0: 686f 756c 6420 6265 2070 6173 7365 6420  hould be passed 
-000083b0: 746f 2074 6869 7320 6675 6e63 7469 6f6e  to this function
-000083c0: 2e0a 2020 2020 2020 2f2f 2054 6865 206d  ..      // The m
-000083d0: 6178 2831 2c20 2e2e 2e29 2068 6572 6520  ax(1, ...) here 
-000083e0: 6973 206e 6565 6465 6420 6265 6361 7573  is needed becaus
-000083f0: 6520 7765 206d 6179 2062 6520 7573 696e  e we may be usin
-00008400: 6720 626c 6f63 6b69 6e67 2070 6172 616d  g blocking param
-00008410: 7320 6c61 7267 6572 2074 6861 6e20 7768  s larger than wh
-00008420: 6174 206f 7572 206b 6e6f 776e 206c 3120  at our known l1 
-00008430: 6361 6368 6520 7369 7a65 0a20 2020 2020  cache size.     
-00008440: 202f 2f20 7375 6767 6573 7473 2077 6520   // suggests we 
-00008450: 7368 6f75 6c64 2062 6520 7573 696e 673a  should be using:
-00008460: 2065 6974 6865 7220 6265 6361 7573 6520   either because 
-00008470: 6f75 7220 6b6e 6f77 6e20 6c31 2063 6163  our known l1 cac
-00008480: 6865 2073 697a 6520 6973 2069 6e61 6363  he size is inacc
-00008490: 7572 6174 6520 2865 2e67 2e20 6f6e 2041  urate (e.g. on A
-000084a0: 6e64 726f 6964 2c20 7765 2063 616e 206f  ndroid, we can o
-000084b0: 6e6c 7920 6775 6573 7329 2c0a 2020 2020  nly guess),.    
-000084c0: 2020 2f2f 206f 7220 6265 6361 7573 6520    // or because 
-000084d0: 7765 2061 7265 2074 6573 7469 6e67 2073  we are testing s
-000084e0: 7065 6369 6669 6320 626c 6f63 6b69 6e67  pecific blocking
-000084f0: 2073 697a 6573 2e0a 2020 2020 2020 636f   sizes..      co
-00008500: 6e73 7420 496e 6465 7820 6163 7475 616c  nst Index actual
-00008510: 5f70 616e 656c 5f72 6f77 7320 3d20 2833  _panel_rows = (3
-00008520: 2a4c 6873 5072 6f67 7265 7373 2920 2a20  *LhsProgress) * 
-00008530: 7374 643a 3a6d 6178 3c49 6e64 6578 3e28  std::max<Index>(
-00008540: 312c 2820 286c 3120 2d20 7369 7a65 6f66  1,( (l1 - sizeof
-00008550: 2852 6573 5363 616c 6172 292a 6d72 2a6e  (ResScalar)*mr*n
-00008560: 7220 2d20 6465 7074 682a 6e72 2a73 697a  r - depth*nr*siz
-00008570: 656f 6628 5268 7353 6361 6c61 7229 2920  eof(RhsScalar)) 
-00008580: 2f20 2864 6570 7468 202a 2073 697a 656f  / (depth * sizeo
-00008590: 6628 4c68 7353 6361 6c61 7229 202a 2033  f(LhsScalar) * 3
-000085a0: 2a4c 6873 5072 6f67 7265 7373 2920 2929  *LhsProgress) ))
-000085b0: 3b0a 2020 2020 2020 666f 7228 496e 6465  ;.      for(Inde
-000085c0: 7820 6931 3d30 3b20 6931 3c70 6565 6c65  x i1=0; i1<peele
-000085d0: 645f 6d63 333b 2069 312b 3d61 6374 7561  d_mc3; i1+=actua
-000085e0: 6c5f 7061 6e65 6c5f 726f 7773 290a 2020  l_panel_rows).  
-000085f0: 2020 2020 7b0a 2020 2020 2020 2020 636f      {.        co
-00008600: 6e73 7420 496e 6465 7820 6163 7475 616c  nst Index actual
-00008610: 5f70 616e 656c 5f65 6e64 203d 2028 7374  _panel_end = (st
-00008620: 643a 3a6d 696e 2928 6931 2b61 6374 7561  d::min)(i1+actua
-00008630: 6c5f 7061 6e65 6c5f 726f 7773 2c20 7065  l_panel_rows, pe
-00008640: 656c 6564 5f6d 6333 293b 0a20 2020 2020  eled_mc3);.     
-00008650: 2020 2066 6f72 2849 6e64 6578 206a 323d     for(Index j2=
-00008660: 303b 206a 323c 7061 636b 6574 5f63 6f6c  0; j2<packet_col
-00008670: 7334 3b20 6a32 2b3d 6e72 290a 2020 2020  s4; j2+=nr).    
-00008680: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
-00008690: 666f 7228 496e 6465 7820 693d 6931 3b20  for(Index i=i1; 
-000086a0: 693c 6163 7475 616c 5f70 616e 656c 5f65  i<actual_panel_e
-000086b0: 6e64 3b20 692b 3d33 2a4c 6873 5072 6f67  nd; i+=3*LhsProg
-000086c0: 7265 7373 290a 2020 2020 2020 2020 2020  ress).          
-000086d0: 7b0a 2020 2020 2020 2020 2020 0a20 2020  {.          .   
-000086e0: 2020 2020 2020 202f 2f20 5765 2073 656c         // We sel
-000086f0: 6563 7465 6420 6120 332a 5472 6169 7473  ected a 3*Traits
-00008700: 3a3a 4c68 7350 726f 6772 6573 7320 7820  ::LhsProgress x 
-00008710: 6e72 206d 6963 726f 2062 6c6f 636b 206f  nr micro block o
-00008720: 6620 7265 7320 7768 6963 6820 6973 2065  f res which is e
-00008730: 6e74 6972 656c 790a 2020 2020 2020 2020  ntirely.        
-00008740: 2020 2f2f 2073 746f 7265 6420 696e 746f    // stored into
-00008750: 2033 2078 206e 7220 7265 6769 7374 6572   3 x nr register
-00008760: 732e 0a20 2020 2020 2020 2020 200a 2020  s..          .  
-00008770: 2020 2020 2020 2020 636f 6e73 7420 4c68          const Lh
-00008780: 7353 6361 6c61 722a 2062 6c41 203d 2026  sScalar* blA = &
-00008790: 626c 6f63 6b41 5b69 2a73 7472 6964 6541  blockA[i*strideA
-000087a0: 2b6f 6666 7365 7441 2a28 332a 4c68 7350  +offsetA*(3*LhsP
-000087b0: 726f 6772 6573 7329 5d3b 0a20 2020 2020  rogress)];.     
-000087c0: 2020 2020 2070 7265 6665 7463 6828 2662       prefetch(&b
-000087d0: 6c41 5b30 5d29 3b0a 0a20 2020 2020 2020  lA[0]);..       
-000087e0: 2020 202f 2f20 6765 7473 2072 6573 2062     // gets res b
-000087f0: 6c6f 636b 2061 7320 7265 6769 7374 6572  lock as register
-00008800: 0a20 2020 2020 2020 2020 2041 6363 5061  .          AccPa
-00008810: 636b 6574 2043 302c 2043 312c 2043 322c  cket C0, C1, C2,
-00008820: 2020 4333 2c0a 2020 2020 2020 2020 2020    C3,.          
-00008830: 2020 2020 2020 2020 2020 4334 2c20 4335            C4, C5
-00008840: 2c20 4336 2c20 2043 372c 0a20 2020 2020  , C6,  C7,.     
-00008850: 2020 2020 2020 2020 2020 2020 2020 2043                 C
-00008860: 382c 2043 392c 2043 3130 2c20 4331 313b  8, C9, C10, C11;
-00008870: 0a20 2020 2020 2020 2020 2074 7261 6974  .          trait
-00008880: 732e 696e 6974 4163 6328 4330 293b 2020  s.initAcc(C0);  
-00008890: 7472 6169 7473 2e69 6e69 7441 6363 2843  traits.initAcc(C
-000088a0: 3129 3b20 2074 7261 6974 732e 696e 6974  1);  traits.init
-000088b0: 4163 6328 4332 293b 2020 7472 6169 7473  Acc(C2);  traits
-000088c0: 2e69 6e69 7441 6363 2843 3329 3b0a 2020  .initAcc(C3);.  
-000088d0: 2020 2020 2020 2020 7472 6169 7473 2e69          traits.i
-000088e0: 6e69 7441 6363 2843 3429 3b20 2074 7261  nitAcc(C4);  tra
-000088f0: 6974 732e 696e 6974 4163 6328 4335 293b  its.initAcc(C5);
-00008900: 2020 7472 6169 7473 2e69 6e69 7441 6363    traits.initAcc
-00008910: 2843 3629 3b20 2074 7261 6974 732e 696e  (C6);  traits.in
-00008920: 6974 4163 6328 4337 293b 0a20 2020 2020  itAcc(C7);.     
-00008930: 2020 2020 2074 7261 6974 732e 696e 6974       traits.init
-00008940: 4163 6328 4338 293b 2020 7472 6169 7473  Acc(C8);  traits
-00008950: 2e69 6e69 7441 6363 2843 3929 3b20 2074  .initAcc(C9);  t
-00008960: 7261 6974 732e 696e 6974 4163 6328 4331  raits.initAcc(C1
-00008970: 3029 3b20 7472 6169 7473 2e69 6e69 7441  0); traits.initA
-00008980: 6363 2843 3131 293b 0a0a 2020 2020 2020  cc(C11);..      
-00008990: 2020 2020 4c69 6e65 6172 4d61 7070 6572      LinearMapper
-000089a0: 2072 3020 3d20 7265 732e 6765 744c 696e   r0 = res.getLin
-000089b0: 6561 724d 6170 7065 7228 692c 206a 3220  earMapper(i, j2 
-000089c0: 2b20 3029 3b0a 2020 2020 2020 2020 2020  + 0);.          
-000089d0: 4c69 6e65 6172 4d61 7070 6572 2072 3120  LinearMapper r1 
-000089e0: 3d20 7265 732e 6765 744c 696e 6561 724d  = res.getLinearM
-000089f0: 6170 7065 7228 692c 206a 3220 2b20 3129  apper(i, j2 + 1)
-00008a00: 3b0a 2020 2020 2020 2020 2020 4c69 6e65  ;.          Line
-00008a10: 6172 4d61 7070 6572 2072 3220 3d20 7265  arMapper r2 = re
-00008a20: 732e 6765 744c 696e 6561 724d 6170 7065  s.getLinearMappe
-00008a30: 7228 692c 206a 3220 2b20 3229 3b0a 2020  r(i, j2 + 2);.  
-00008a40: 2020 2020 2020 2020 4c69 6e65 6172 4d61          LinearMa
-00008a50: 7070 6572 2072 3320 3d20 7265 732e 6765  pper r3 = res.ge
-00008a60: 744c 696e 6561 724d 6170 7065 7228 692c  tLinearMapper(i,
-00008a70: 206a 3220 2b20 3329 3b0a 0a20 2020 2020   j2 + 3);..     
-00008a80: 2020 2020 2072 302e 7072 6566 6574 6368       r0.prefetch
-00008a90: 2830 293b 0a20 2020 2020 2020 2020 2072  (0);.          r
-00008aa0: 312e 7072 6566 6574 6368 2830 293b 0a20  1.prefetch(0);. 
-00008ab0: 2020 2020 2020 2020 2072 322e 7072 6566           r2.pref
-00008ac0: 6574 6368 2830 293b 0a20 2020 2020 2020  etch(0);.       
-00008ad0: 2020 2072 332e 7072 6566 6574 6368 2830     r3.prefetch(0
-00008ae0: 293b 0a0a 2020 2020 2020 2020 2020 2f2f  );..          //
-00008af0: 2070 6572 666f 726d 7320 2269 6e6e 6572   performs "inner
-00008b00: 2220 7072 6f64 7563 7473 0a20 2020 2020  " products.     
-00008b10: 2020 2020 2063 6f6e 7374 2052 6873 5363       const RhsSc
-00008b20: 616c 6172 2a20 626c 4220 3d20 2662 6c6f  alar* blB = &blo
-00008b30: 636b 425b 6a32 2a73 7472 6964 6542 2b6f  ckB[j2*strideB+o
-00008b40: 6666 7365 7442 2a6e 725d 3b0a 2020 2020  ffsetB*nr];.    
-00008b50: 2020 2020 2020 7072 6566 6574 6368 2826        prefetch(&
-00008b60: 626c 425b 305d 293b 0a20 2020 2020 2020  blB[0]);.       
-00008b70: 2020 204c 6873 5061 636b 6574 2041 302c     LhsPacket A0,
-00008b80: 2041 313b 0a0a 2020 2020 2020 2020 2020   A1;..          
-00008b90: 666f 7228 496e 6465 7820 6b3d 303b 206b  for(Index k=0; k
-00008ba0: 3c70 6565 6c65 645f 6b63 3b20 6b2b 3d70  <peeled_kc; k+=p
-00008bb0: 6b29 0a20 2020 2020 2020 2020 207b 0a20  k).          {. 
-00008bc0: 2020 2020 2020 2020 2020 2045 4947 454e             EIGEN
-00008bd0: 5f41 534d 5f43 4f4d 4d45 4e54 2822 6265  _ASM_COMMENT("be
-00008be0: 6769 6e20 6765 6270 206d 6963 726f 206b  gin gebp micro k
-00008bf0: 6572 6e65 6c20 3370 5834 2229 3b0a 2020  ernel 3pX4");.  
-00008c00: 2020 2020 2020 2020 2020 5268 7350 6163            RhsPac
-00008c10: 6b65 7420 425f 302c 2054 303b 0a20 2020  ket B_0, T0;.   
-00008c20: 2020 2020 2020 2020 204c 6873 5061 636b           LhsPack
-00008c30: 6574 2041 323b 0a0a 2364 6566 696e 6520  et A2;..#define 
-00008c40: 4549 4745 4e5f 4745 4250 5f4f 4e45 5354  EIGEN_GEBP_ONEST
-00008c50: 4550 284b 2920 5c0a 2020 2020 2020 2020  EP(K) \.        
-00008c60: 2020 2020 646f 207b 205c 0a20 2020 2020      do { \.     
-00008c70: 2020 2020 2020 2020 2045 4947 454e 5f41           EIGEN_A
-00008c80: 534d 5f43 4f4d 4d45 4e54 2822 6265 6769  SM_COMMENT("begi
-00008c90: 6e20 7374 6570 206f 6620 6765 6270 206d  n step of gebp m
-00008ca0: 6963 726f 206b 6572 6e65 6c20 3370 5834  icro kernel 3pX4
-00008cb0: 2229 3b20 5c0a 2020 2020 2020 2020 2020  "); \.          
-00008cc0: 2020 2020 4549 4745 4e5f 4153 4d5f 434f      EIGEN_ASM_CO
-00008cd0: 4d4d 454e 5428 224e 6f74 653a 2074 6865  MMENT("Note: the
-00008ce0: 7365 2061 736d 2063 6f6d 6d65 6e74 7320  se asm comments 
-00008cf0: 776f 726b 2061 726f 756e 6420 6275 6720  work around bug 
-00008d00: 3933 3521 2229 3b20 5c0a 2020 2020 2020  935!"); \.      
-00008d10: 2020 2020 2020 2020 696e 7465 726e 616c          internal
-00008d20: 3a3a 7072 6566 6574 6368 2862 6c41 2b28  ::prefetch(blA+(
-00008d30: 332a 4b2b 3136 292a 4c68 7350 726f 6772  3*K+16)*LhsProgr
-00008d40: 6573 7329 3b20 5c0a 2020 2020 2020 2020  ess); \.        
-00008d50: 2020 2020 2020 6966 2028 4549 4745 4e5f        if (EIGEN_
-00008d60: 4152 4348 5f41 524d 2920 7b20 696e 7465  ARCH_ARM) { inte
-00008d70: 726e 616c 3a3a 7072 6566 6574 6368 2862  rnal::prefetch(b
-00008d80: 6c42 2b28 342a 4b2b 3136 292a 5268 7350  lB+(4*K+16)*RhsP
-00008d90: 726f 6772 6573 7329 3b20 7d20 2f2a 2042  rogress); } /* B
-00008da0: 7567 2039 3533 202a 2f20 5c0a 2020 2020  ug 953 */ \.    
-00008db0: 2020 2020 2020 2020 2020 7472 6169 7473            traits
-00008dc0: 2e6c 6f61 644c 6873 2826 626c 415b 2830  .loadLhs(&blA[(0
-00008dd0: 2b33 2a4b 292a 4c68 7350 726f 6772 6573  +3*K)*LhsProgres
-00008de0: 735d 2c20 4130 293b 2020 5c0a 2020 2020  s], A0);  \.    
-00008df0: 2020 2020 2020 2020 2020 7472 6169 7473            traits
-00008e00: 2e6c 6f61 644c 6873 2826 626c 415b 2831  .loadLhs(&blA[(1
-00008e10: 2b33 2a4b 292a 4c68 7350 726f 6772 6573  +3*K)*LhsProgres
-00008e20: 735d 2c20 4131 293b 2020 5c0a 2020 2020  s], A1);  \.    
-00008e30: 2020 2020 2020 2020 2020 7472 6169 7473            traits
-00008e40: 2e6c 6f61 644c 6873 2826 626c 415b 2832  .loadLhs(&blA[(2
-00008e50: 2b33 2a4b 292a 4c68 7350 726f 6772 6573  +3*K)*LhsProgres
-00008e60: 735d 2c20 4132 293b 2020 5c0a 2020 2020  s], A2);  \.    
-00008e70: 2020 2020 2020 2020 2020 7472 6169 7473            traits
-00008e80: 2e6c 6f61 6452 6873 2862 6c42 202b 2028  .loadRhs(blB + (
-00008e90: 302b 342a 4b29 2a54 7261 6974 733a 3a52  0+4*K)*Traits::R
-00008ea0: 6873 5072 6f67 7265 7373 2c20 425f 3029  hsProgress, B_0)
-00008eb0: 3b20 5c0a 2020 2020 2020 2020 2020 2020  ; \.            
-00008ec0: 2020 7472 6169 7473 2e6d 6164 6428 4130    traits.madd(A0
-00008ed0: 2c20 425f 302c 2043 302c 2054 3029 3b20  , B_0, C0, T0); 
-00008ee0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-00008ef0: 7472 6169 7473 2e6d 6164 6428 4131 2c20  traits.madd(A1, 
-00008f00: 425f 302c 2043 342c 2054 3029 3b20 5c0a  B_0, C4, T0); \.
-00008f10: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-00008f20: 6169 7473 2e6d 6164 6428 4132 2c20 425f  aits.madd(A2, B_
-00008f30: 302c 2043 382c 2042 5f30 293b 205c 0a20  0, C8, B_0); \. 
-00008f40: 2020 2020 2020 2020 2020 2020 2074 7261               tra
-00008f50: 6974 732e 6c6f 6164 5268 7328 626c 4220  its.loadRhs(blB 
-00008f60: 2b20 2831 2b34 2a4b 292a 5472 6169 7473  + (1+4*K)*Traits
-00008f70: 3a3a 5268 7350 726f 6772 6573 732c 2042  ::RhsProgress, B
-00008f80: 5f30 293b 205c 0a20 2020 2020 2020 2020  _0); \.         
-00008f90: 2020 2020 2074 7261 6974 732e 6d61 6464       traits.madd
-00008fa0: 2841 302c 2042 5f30 2c20 4331 2c20 5430  (A0, B_0, C1, T0
-00008fb0: 293b 205c 0a20 2020 2020 2020 2020 2020  ); \.           
-00008fc0: 2020 2074 7261 6974 732e 6d61 6464 2841     traits.madd(A
-00008fd0: 312c 2042 5f30 2c20 4335 2c20 5430 293b  1, B_0, C5, T0);
-00008fe0: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-00008ff0: 2074 7261 6974 732e 6d61 6464 2841 322c   traits.madd(A2,
-00009000: 2042 5f30 2c20 4339 2c20 425f 3029 3b20   B_0, C9, B_0); 
-00009010: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-00009020: 7472 6169 7473 2e6c 6f61 6452 6873 2862  traits.loadRhs(b
-00009030: 6c42 202b 2028 322b 342a 4b29 2a54 7261  lB + (2+4*K)*Tra
-00009040: 6974 733a 3a52 6873 5072 6f67 7265 7373  its::RhsProgress
-00009050: 2c20 425f 3029 3b20 5c0a 2020 2020 2020  , B_0); \.      
-00009060: 2020 2020 2020 2020 7472 6169 7473 2e6d          traits.m
-00009070: 6164 6428 4130 2c20 425f 302c 2043 322c  add(A0, B_0, C2,
-00009080: 2020 5430 293b 205c 0a20 2020 2020 2020    T0); \.       
-00009090: 2020 2020 2020 2074 7261 6974 732e 6d61         traits.ma
-000090a0: 6464 2841 312c 2042 5f30 2c20 4336 2c20  dd(A1, B_0, C6, 
-000090b0: 2054 3029 3b20 5c0a 2020 2020 2020 2020   T0); \.        
-000090c0: 2020 2020 2020 7472 6169 7473 2e6d 6164        traits.mad
-000090d0: 6428 4132 2c20 425f 302c 2043 3130 2c20  d(A2, B_0, C10, 
-000090e0: 425f 3029 3b20 5c0a 2020 2020 2020 2020  B_0); \.        
-000090f0: 2020 2020 2020 7472 6169 7473 2e6c 6f61        traits.loa
-00009100: 6452 6873 2862 6c42 202b 2028 332b 342a  dRhs(blB + (3+4*
-00009110: 4b29 2a54 7261 6974 733a 3a52 6873 5072  K)*Traits::RhsPr
-00009120: 6f67 7265 7373 2c20 425f 3029 3b20 5c0a  ogress, B_0); \.
-00009130: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-00009140: 6169 7473 2e6d 6164 6428 4130 2c20 425f  aits.madd(A0, B_
-00009150: 302c 2043 3320 2c20 5430 293b 205c 0a20  0, C3 , T0); \. 
-00009160: 2020 2020 2020 2020 2020 2020 2074 7261               tra
-00009170: 6974 732e 6d61 6464 2841 312c 2042 5f30  its.madd(A1, B_0
-00009180: 2c20 4337 2c20 2054 3029 3b20 5c0a 2020  , C7,  T0); \.  
-00009190: 2020 2020 2020 2020 2020 2020 7472 6169              trai
-000091a0: 7473 2e6d 6164 6428 4132 2c20 425f 302c  ts.madd(A2, B_0,
-000091b0: 2043 3131 2c20 425f 3029 3b20 5c0a 2020   C11, B_0); \.  
-000091c0: 2020 2020 2020 2020 2020 2020 4549 4745              EIGE
-000091d0: 4e5f 4153 4d5f 434f 4d4d 454e 5428 2265  N_ASM_COMMENT("e
-000091e0: 6e64 2073 7465 7020 6f66 2067 6562 7020  nd step of gebp 
-000091f0: 6d69 6372 6f20 6b65 726e 656c 2033 7058  micro kernel 3pX
-00009200: 3422 293b 205c 0a20 2020 2020 2020 2020  4"); \.         
-00009210: 2020 207d 2077 6869 6c65 2866 616c 7365     } while(false
-00009220: 290a 0a20 2020 2020 2020 2020 2020 2069  )..            i
-00009230: 6e74 6572 6e61 6c3a 3a70 7265 6665 7463  nternal::prefetc
-00009240: 6828 626c 4229 3b0a 2020 2020 2020 2020  h(blB);.        
-00009250: 2020 2020 4549 4745 4e5f 4745 4250 5f4f      EIGEN_GEBP_O
-00009260: 4e45 5354 4550 2830 293b 0a20 2020 2020  NESTEP(0);.     
-00009270: 2020 2020 2020 2045 4947 454e 5f47 4542         EIGEN_GEB
-00009280: 505f 4f4e 4553 5445 5028 3129 3b0a 2020  P_ONESTEP(1);.  
-00009290: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
-000092a0: 4745 4250 5f4f 4e45 5354 4550 2832 293b  GEBP_ONESTEP(2);
-000092b0: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-000092c0: 454e 5f47 4542 505f 4f4e 4553 5445 5028  EN_GEBP_ONESTEP(
-000092d0: 3329 3b0a 2020 2020 2020 2020 2020 2020  3);.            
-000092e0: 4549 4745 4e5f 4745 4250 5f4f 4e45 5354  EIGEN_GEBP_ONEST
-000092f0: 4550 2834 293b 0a20 2020 2020 2020 2020  EP(4);.         
-00009300: 2020 2045 4947 454e 5f47 4542 505f 4f4e     EIGEN_GEBP_ON
-00009310: 4553 5445 5028 3529 3b0a 2020 2020 2020  ESTEP(5);.      
-00009320: 2020 2020 2020 4549 4745 4e5f 4745 4250        EIGEN_GEBP
-00009330: 5f4f 4e45 5354 4550 2836 293b 0a20 2020  _ONESTEP(6);.   
-00009340: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
-00009350: 4542 505f 4f4e 4553 5445 5028 3729 3b0a  EBP_ONESTEP(7);.
-00009360: 0a20 2020 2020 2020 2020 2020 2062 6c42  .            blB
-00009370: 202b 3d20 706b 2a34 2a52 6873 5072 6f67   += pk*4*RhsProg
-00009380: 7265 7373 3b0a 2020 2020 2020 2020 2020  ress;.          
-00009390: 2020 626c 4120 2b3d 2070 6b2a 332a 5472    blA += pk*3*Tr
-000093a0: 6169 7473 3a3a 4c68 7350 726f 6772 6573  aits::LhsProgres
-000093b0: 733b 0a0a 2020 2020 2020 2020 2020 2020  s;..            
-000093c0: 4549 4745 4e5f 4153 4d5f 434f 4d4d 454e  EIGEN_ASM_COMMEN
-000093d0: 5428 2265 6e64 2067 6562 7020 6d69 6372  T("end gebp micr
-000093e0: 6f20 6b65 726e 656c 2033 7058 3422 293b  o kernel 3pX4");
-000093f0: 0a20 2020 2020 2020 2020 207d 0a20 2020  .          }.   
-00009400: 2020 2020 2020 202f 2f20 7072 6f63 6573         // proces
-00009410: 7320 7265 6d61 696e 696e 6720 7065 656c  s remaining peel
-00009420: 6564 206c 6f6f 700a 2020 2020 2020 2020  ed loop.        
-00009430: 2020 666f 7228 496e 6465 7820 6b3d 7065    for(Index k=pe
-00009440: 656c 6564 5f6b 633b 206b 3c64 6570 7468  eled_kc; k<depth
-00009450: 3b20 6b2b 2b29 0a20 2020 2020 2020 2020  ; k++).         
-00009460: 207b 0a20 2020 2020 2020 2020 2020 2052   {.            R
-00009470: 6873 5061 636b 6574 2042 5f30 2c20 5430  hsPacket B_0, T0
-00009480: 3b0a 2020 2020 2020 2020 2020 2020 4c68  ;.            Lh
-00009490: 7350 6163 6b65 7420 4132 3b0a 2020 2020  sPacket A2;.    
-000094a0: 2020 2020 2020 2020 4549 4745 4e5f 4745          EIGEN_GE
-000094b0: 4250 5f4f 4e45 5354 4550 2830 293b 0a20  BP_ONESTEP(0);. 
-000094c0: 2020 2020 2020 2020 2020 2062 6c42 202b             blB +
-000094d0: 3d20 342a 5268 7350 726f 6772 6573 733b  = 4*RhsProgress;
-000094e0: 0a20 2020 2020 2020 2020 2020 2062 6c41  .            blA
-000094f0: 202b 3d20 332a 5472 6169 7473 3a3a 4c68   += 3*Traits::Lh
-00009500: 7350 726f 6772 6573 733b 0a20 2020 2020  sProgress;.     
-00009510: 2020 2020 207d 0a0a 2375 6e64 6566 2045       }..#undef E
-00009520: 4947 454e 5f47 4542 505f 4f4e 4553 5445  IGEN_GEBP_ONESTE
-00009530: 500a 0a20 2020 2020 2020 2020 2052 6573  P..          Res
-00009540: 5061 636b 6574 2052 302c 2052 312c 2052  Packet R0, R1, R
-00009550: 323b 0a20 2020 2020 2020 2020 2052 6573  2;.          Res
-00009560: 5061 636b 6574 2061 6c70 6861 7620 3d20  Packet alphav = 
-00009570: 7073 6574 313c 5265 7350 6163 6b65 743e  pset1<ResPacket>
-00009580: 2861 6c70 6861 293b 0a0a 2020 2020 2020  (alpha);..      
-00009590: 2020 2020 5230 203d 2072 302e 6c6f 6164      R0 = r0.load
-000095a0: 5061 636b 6574 2830 202a 2054 7261 6974  Packet(0 * Trait
-000095b0: 733a 3a52 6573 5061 636b 6574 5369 7a65  s::ResPacketSize
-000095c0: 293b 0a20 2020 2020 2020 2020 2052 3120  );.          R1 
-000095d0: 3d20 7230 2e6c 6f61 6450 6163 6b65 7428  = r0.loadPacket(
-000095e0: 3120 2a20 5472 6169 7473 3a3a 5265 7350  1 * Traits::ResP
-000095f0: 6163 6b65 7453 697a 6529 3b0a 2020 2020  acketSize);.    
-00009600: 2020 2020 2020 5232 203d 2072 302e 6c6f        R2 = r0.lo
-00009610: 6164 5061 636b 6574 2832 202a 2054 7261  adPacket(2 * Tra
-00009620: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
-00009630: 7a65 293b 0a20 2020 2020 2020 2020 2074  ze);.          t
-00009640: 7261 6974 732e 6163 6328 4330 2c20 616c  raits.acc(C0, al
-00009650: 7068 6176 2c20 5230 293b 0a20 2020 2020  phav, R0);.     
-00009660: 2020 2020 2074 7261 6974 732e 6163 6328       traits.acc(
-00009670: 4334 2c20 616c 7068 6176 2c20 5231 293b  C4, alphav, R1);
-00009680: 0a20 2020 2020 2020 2020 2074 7261 6974  .          trait
-00009690: 732e 6163 6328 4338 2c20 616c 7068 6176  s.acc(C8, alphav
-000096a0: 2c20 5232 293b 0a20 2020 2020 2020 2020  , R2);.         
-000096b0: 2072 302e 7374 6f72 6550 6163 6b65 7428   r0.storePacket(
-000096c0: 3020 2a20 5472 6169 7473 3a3a 5265 7350  0 * Traits::ResP
-000096d0: 6163 6b65 7453 697a 652c 2052 3029 3b0a  acketSize, R0);.
-000096e0: 2020 2020 2020 2020 2020 7230 2e73 746f            r0.sto
-000096f0: 7265 5061 636b 6574 2831 202a 2054 7261  rePacket(1 * Tra
-00009700: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
-00009710: 7a65 2c20 5231 293b 0a20 2020 2020 2020  ze, R1);.       
-00009720: 2020 2072 302e 7374 6f72 6550 6163 6b65     r0.storePacke
-00009730: 7428 3220 2a20 5472 6169 7473 3a3a 5265  t(2 * Traits::Re
-00009740: 7350 6163 6b65 7453 697a 652c 2052 3229  sPacketSize, R2)
-00009750: 3b0a 0a20 2020 2020 2020 2020 2052 3020  ;..          R0 
-00009760: 3d20 7231 2e6c 6f61 6450 6163 6b65 7428  = r1.loadPacket(
-00009770: 3020 2a20 5472 6169 7473 3a3a 5265 7350  0 * Traits::ResP
-00009780: 6163 6b65 7453 697a 6529 3b0a 2020 2020  acketSize);.    
-00009790: 2020 2020 2020 5231 203d 2072 312e 6c6f        R1 = r1.lo
-000097a0: 6164 5061 636b 6574 2831 202a 2054 7261  adPacket(1 * Tra
-000097b0: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
-000097c0: 7a65 293b 0a20 2020 2020 2020 2020 2052  ze);.          R
-000097d0: 3220 3d20 7231 2e6c 6f61 6450 6163 6b65  2 = r1.loadPacke
-000097e0: 7428 3220 2a20 5472 6169 7473 3a3a 5265  t(2 * Traits::Re
-000097f0: 7350 6163 6b65 7453 697a 6529 3b0a 2020  sPacketSize);.  
-00009800: 2020 2020 2020 2020 7472 6169 7473 2e61          traits.a
-00009810: 6363 2843 312c 2061 6c70 6861 762c 2052  cc(C1, alphav, R
-00009820: 3029 3b0a 2020 2020 2020 2020 2020 7472  0);.          tr
-00009830: 6169 7473 2e61 6363 2843 352c 2061 6c70  aits.acc(C5, alp
-00009840: 6861 762c 2052 3129 3b0a 2020 2020 2020  hav, R1);.      
-00009850: 2020 2020 7472 6169 7473 2e61 6363 2843      traits.acc(C
-00009860: 392c 2061 6c70 6861 762c 2052 3229 3b0a  9, alphav, R2);.
-00009870: 2020 2020 2020 2020 2020 7231 2e73 746f            r1.sto
-00009880: 7265 5061 636b 6574 2830 202a 2054 7261  rePacket(0 * Tra
-00009890: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
-000098a0: 7a65 2c20 5230 293b 0a20 2020 2020 2020  ze, R0);.       
-000098b0: 2020 2072 312e 7374 6f72 6550 6163 6b65     r1.storePacke
-000098c0: 7428 3120 2a20 5472 6169 7473 3a3a 5265  t(1 * Traits::Re
-000098d0: 7350 6163 6b65 7453 697a 652c 2052 3129  sPacketSize, R1)
-000098e0: 3b0a 2020 2020 2020 2020 2020 7231 2e73  ;.          r1.s
-000098f0: 746f 7265 5061 636b 6574 2832 202a 2054  torePacket(2 * T
-00009900: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
-00009910: 5369 7a65 2c20 5232 293b 0a0a 2020 2020  Size, R2);..    
-00009920: 2020 2020 2020 5230 203d 2072 322e 6c6f        R0 = r2.lo
-00009930: 6164 5061 636b 6574 2830 202a 2054 7261  adPacket(0 * Tra
-00009940: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
-00009950: 7a65 293b 0a20 2020 2020 2020 2020 2052  ze);.          R
-00009960: 3120 3d20 7232 2e6c 6f61 6450 6163 6b65  1 = r2.loadPacke
-00009970: 7428 3120 2a20 5472 6169 7473 3a3a 5265  t(1 * Traits::Re
-00009980: 7350 6163 6b65 7453 697a 6529 3b0a 2020  sPacketSize);.  
-00009990: 2020 2020 2020 2020 5232 203d 2072 322e          R2 = r2.
-000099a0: 6c6f 6164 5061 636b 6574 2832 202a 2054  loadPacket(2 * T
-000099b0: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
-000099c0: 5369 7a65 293b 0a20 2020 2020 2020 2020  Size);.         
-000099d0: 2074 7261 6974 732e 6163 6328 4332 2c20   traits.acc(C2, 
-000099e0: 616c 7068 6176 2c20 5230 293b 0a20 2020  alphav, R0);.   
-000099f0: 2020 2020 2020 2074 7261 6974 732e 6163         traits.ac
-00009a00: 6328 4336 2c20 616c 7068 6176 2c20 5231  c(C6, alphav, R1
-00009a10: 293b 0a20 2020 2020 2020 2020 2074 7261  );.          tra
-00009a20: 6974 732e 6163 6328 4331 302c 2061 6c70  its.acc(C10, alp
-00009a30: 6861 762c 2052 3229 3b0a 2020 2020 2020  hav, R2);.      
-00009a40: 2020 2020 7232 2e73 746f 7265 5061 636b      r2.storePack
-00009a50: 6574 2830 202a 2054 7261 6974 733a 3a52  et(0 * Traits::R
-00009a60: 6573 5061 636b 6574 5369 7a65 2c20 5230  esPacketSize, R0
-00009a70: 293b 0a20 2020 2020 2020 2020 2072 322e  );.          r2.
-00009a80: 7374 6f72 6550 6163 6b65 7428 3120 2a20  storePacket(1 * 
-00009a90: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
-00009aa0: 7453 697a 652c 2052 3129 3b0a 2020 2020  tSize, R1);.    
-00009ab0: 2020 2020 2020 7232 2e73 746f 7265 5061        r2.storePa
-00009ac0: 636b 6574 2832 202a 2054 7261 6974 733a  cket(2 * Traits:
-00009ad0: 3a52 6573 5061 636b 6574 5369 7a65 2c20  :ResPacketSize, 
-00009ae0: 5232 293b 0a0a 2020 2020 2020 2020 2020  R2);..          
-00009af0: 5230 203d 2072 332e 6c6f 6164 5061 636b  R0 = r3.loadPack
-00009b00: 6574 2830 202a 2054 7261 6974 733a 3a52  et(0 * Traits::R
-00009b10: 6573 5061 636b 6574 5369 7a65 293b 0a20  esPacketSize);. 
-00009b20: 2020 2020 2020 2020 2052 3120 3d20 7233           R1 = r3
-00009b30: 2e6c 6f61 6450 6163 6b65 7428 3120 2a20  .loadPacket(1 * 
-00009b40: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
-00009b50: 7453 697a 6529 3b0a 2020 2020 2020 2020  tSize);.        
-00009b60: 2020 5232 203d 2072 332e 6c6f 6164 5061    R2 = r3.loadPa
-00009b70: 636b 6574 2832 202a 2054 7261 6974 733a  cket(2 * Traits:
-00009b80: 3a52 6573 5061 636b 6574 5369 7a65 293b  :ResPacketSize);
-00009b90: 0a20 2020 2020 2020 2020 2074 7261 6974  .          trait
-00009ba0: 732e 6163 6328 4333 2c20 616c 7068 6176  s.acc(C3, alphav
-00009bb0: 2c20 5230 293b 0a20 2020 2020 2020 2020  , R0);.         
-00009bc0: 2074 7261 6974 732e 6163 6328 4337 2c20   traits.acc(C7, 
-00009bd0: 616c 7068 6176 2c20 5231 293b 0a20 2020  alphav, R1);.   
-00009be0: 2020 2020 2020 2074 7261 6974 732e 6163         traits.ac
-00009bf0: 6328 4331 312c 2061 6c70 6861 762c 2052  c(C11, alphav, R
-00009c00: 3229 3b0a 2020 2020 2020 2020 2020 7233  2);.          r3
-00009c10: 2e73 746f 7265 5061 636b 6574 2830 202a  .storePacket(0 *
-00009c20: 2054 7261 6974 733a 3a52 6573 5061 636b   Traits::ResPack
-00009c30: 6574 5369 7a65 2c20 5230 293b 0a20 2020  etSize, R0);.   
-00009c40: 2020 2020 2020 2072 332e 7374 6f72 6550         r3.storeP
-00009c50: 6163 6b65 7428 3120 2a20 5472 6169 7473  acket(1 * Traits
-00009c60: 3a3a 5265 7350 6163 6b65 7453 697a 652c  ::ResPacketSize,
-00009c70: 2052 3129 3b0a 2020 2020 2020 2020 2020   R1);.          
-00009c80: 7233 2e73 746f 7265 5061 636b 6574 2832  r3.storePacket(2
-00009c90: 202a 2054 7261 6974 733a 3a52 6573 5061   * Traits::ResPa
-00009ca0: 636b 6574 5369 7a65 2c20 5232 293b 2020  cketSize, R2);  
-00009cb0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-00009cc0: 2020 207d 0a20 2020 2020 2020 207d 0a0a     }.        }..
-00009cd0: 2020 2020 2020 2020 2f2f 2044 6561 6c20          // Deal 
-00009ce0: 7769 7468 2072 656d 6169 6e69 6e67 2063  with remaining c
-00009cf0: 6f6c 756d 6e73 206f 6620 7468 6520 7268  olumns of the rh
-00009d00: 730a 2020 2020 2020 2020 666f 7228 496e  s.        for(In
-00009d10: 6465 7820 6a32 3d70 6163 6b65 745f 636f  dex j2=packet_co
-00009d20: 6c73 343b 206a 323c 636f 6c73 3b20 6a32  ls4; j2<cols; j2
-00009d30: 2b2b 290a 2020 2020 2020 2020 7b0a 2020  ++).        {.  
-00009d40: 2020 2020 2020 2020 666f 7228 496e 6465          for(Inde
-00009d50: 7820 693d 6931 3b20 693c 6163 7475 616c  x i=i1; i<actual
-00009d60: 5f70 616e 656c 5f65 6e64 3b20 692b 3d33  _panel_end; i+=3
-00009d70: 2a4c 6873 5072 6f67 7265 7373 290a 2020  *LhsProgress).  
-00009d80: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
-00009d90: 2020 2020 2f2f 204f 6e65 2063 6f6c 756d      // One colum
-00009da0: 6e20 6174 2061 2074 696d 650a 2020 2020  n at a time.    
-00009db0: 2020 2020 2020 636f 6e73 7420 4c68 7353        const LhsS
-00009dc0: 6361 6c61 722a 2062 6c41 203d 2026 626c  calar* blA = &bl
-00009dd0: 6f63 6b41 5b69 2a73 7472 6964 6541 2b6f  ockA[i*strideA+o
-00009de0: 6666 7365 7441 2a28 332a 5472 6169 7473  ffsetA*(3*Traits
-00009df0: 3a3a 4c68 7350 726f 6772 6573 7329 5d3b  ::LhsProgress)];
-00009e00: 0a20 2020 2020 2020 2020 2070 7265 6665  .          prefe
-00009e10: 7463 6828 2662 6c41 5b30 5d29 3b0a 0a20  tch(&blA[0]);.. 
-00009e20: 2020 2020 2020 2020 202f 2f20 6765 7473           // gets
-00009e30: 2072 6573 2062 6c6f 636b 2061 7320 7265   res block as re
-00009e40: 6769 7374 6572 0a20 2020 2020 2020 2020  gister.         
-00009e50: 2041 6363 5061 636b 6574 2043 302c 2043   AccPacket C0, C
-00009e60: 342c 2043 383b 0a20 2020 2020 2020 2020  4, C8;.         
-00009e70: 2074 7261 6974 732e 696e 6974 4163 6328   traits.initAcc(
-00009e80: 4330 293b 0a20 2020 2020 2020 2020 2074  C0);.          t
-00009e90: 7261 6974 732e 696e 6974 4163 6328 4334  raits.initAcc(C4
-00009ea0: 293b 0a20 2020 2020 2020 2020 2074 7261  );.          tra
-00009eb0: 6974 732e 696e 6974 4163 6328 4338 293b  its.initAcc(C8);
-00009ec0: 0a0a 2020 2020 2020 2020 2020 4c69 6e65  ..          Line
-00009ed0: 6172 4d61 7070 6572 2072 3020 3d20 7265  arMapper r0 = re
-00009ee0: 732e 6765 744c 696e 6561 724d 6170 7065  s.getLinearMappe
-00009ef0: 7228 692c 206a 3229 3b0a 2020 2020 2020  r(i, j2);.      
-00009f00: 2020 2020 7230 2e70 7265 6665 7463 6828      r0.prefetch(
-00009f10: 3029 3b0a 0a20 2020 2020 2020 2020 202f  0);..          /
-00009f20: 2f20 7065 7266 6f72 6d73 2022 696e 6e65  / performs "inne
-00009f30: 7222 2070 726f 6475 6374 730a 2020 2020  r" products.    
-00009f40: 2020 2020 2020 636f 6e73 7420 5268 7353        const RhsS
-00009f50: 6361 6c61 722a 2062 6c42 203d 2026 626c  calar* blB = &bl
-00009f60: 6f63 6b42 5b6a 322a 7374 7269 6465 422b  ockB[j2*strideB+
-00009f70: 6f66 6673 6574 425d 3b0a 2020 2020 2020  offsetB];.      
-00009f80: 2020 2020 4c68 7350 6163 6b65 7420 4130      LhsPacket A0
-00009f90: 2c20 4131 2c20 4132 3b0a 2020 2020 2020  , A1, A2;.      
-00009fa0: 2020 2020 0a20 2020 2020 2020 2020 2066      .          f
-00009fb0: 6f72 2849 6e64 6578 206b 3d30 3b20 6b3c  or(Index k=0; k<
-00009fc0: 7065 656c 6564 5f6b 633b 206b 2b3d 706b  peeled_kc; k+=pk
-00009fd0: 290a 2020 2020 2020 2020 2020 7b0a 2020  ).          {.  
-00009fe0: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
-00009ff0: 4153 4d5f 434f 4d4d 454e 5428 2262 6567  ASM_COMMENT("beg
-0000a000: 696e 2067 6562 7020 6d69 6372 6f20 6b65  in gebp micro ke
-0000a010: 726e 656c 2033 7058 3122 293b 0a20 2020  rnel 3pX1");.   
-0000a020: 2020 2020 2020 2020 2052 6873 5061 636b           RhsPack
-0000a030: 6574 2042 5f30 3b0a 2364 6566 696e 6520  et B_0;.#define 
-0000a040: 4549 4745 4e5f 4745 4247 505f 4f4e 4553  EIGEN_GEBGP_ONES
-0000a050: 5445 5028 4b29 205c 0a20 2020 2020 2020  TEP(K) \.       
-0000a060: 2020 2020 2064 6f20 7b20 5c0a 2020 2020       do { \.    
-0000a070: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
-0000a080: 4153 4d5f 434f 4d4d 454e 5428 2262 6567  ASM_COMMENT("beg
-0000a090: 696e 2073 7465 7020 6f66 2067 6562 7020  in step of gebp 
-0000a0a0: 6d69 6372 6f20 6b65 726e 656c 2033 7058  micro kernel 3pX
-0000a0b0: 3122 293b 205c 0a20 2020 2020 2020 2020  1"); \.         
-0000a0c0: 2020 2020 2045 4947 454e 5f41 534d 5f43       EIGEN_ASM_C
-0000a0d0: 4f4d 4d45 4e54 2822 4e6f 7465 3a20 7468  OMMENT("Note: th
-0000a0e0: 6573 6520 6173 6d20 636f 6d6d 656e 7473  ese asm comments
-0000a0f0: 2077 6f72 6b20 6172 6f75 6e64 2062 7567   work around bug
-0000a100: 2039 3335 2122 293b 205c 0a20 2020 2020   935!"); \.     
-0000a110: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
-0000a120: 6c6f 6164 4c68 7328 2662 6c41 5b28 302b  loadLhs(&blA[(0+
-0000a130: 332a 4b29 2a4c 6873 5072 6f67 7265 7373  3*K)*LhsProgress
-0000a140: 5d2c 2041 3029 3b20 205c 0a20 2020 2020  ], A0);  \.     
-0000a150: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
-0000a160: 6c6f 6164 4c68 7328 2662 6c41 5b28 312b  loadLhs(&blA[(1+
-0000a170: 332a 4b29 2a4c 6873 5072 6f67 7265 7373  3*K)*LhsProgress
-0000a180: 5d2c 2041 3129 3b20 205c 0a20 2020 2020  ], A1);  \.     
-0000a190: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
-0000a1a0: 6c6f 6164 4c68 7328 2662 6c41 5b28 322b  loadLhs(&blA[(2+
-0000a1b0: 332a 4b29 2a4c 6873 5072 6f67 7265 7373  3*K)*LhsProgress
-0000a1c0: 5d2c 2041 3229 3b20 205c 0a20 2020 2020  ], A2);  \.     
-0000a1d0: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
-0000a1e0: 6c6f 6164 5268 7328 2662 6c42 5b28 302b  loadRhs(&blB[(0+
-0000a1f0: 4b29 2a52 6873 5072 6f67 7265 7373 5d2c  K)*RhsProgress],
-0000a200: 2042 5f30 293b 2020 205c 0a20 2020 2020   B_0);   \.     
-0000a210: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
-0000a220: 6d61 6464 2841 302c 2042 5f30 2c20 4330  madd(A0, B_0, C0
-0000a230: 2c20 425f 3029 3b20 5c0a 2020 2020 2020  , B_0); \.      
-0000a240: 2020 2020 2020 2020 7472 6169 7473 2e6d          traits.m
-0000a250: 6164 6428 4131 2c20 425f 302c 2043 342c  add(A1, B_0, C4,
-0000a260: 2042 5f30 293b 205c 0a20 2020 2020 2020   B_0); \.       
-0000a270: 2020 2020 2020 2074 7261 6974 732e 6d61         traits.ma
-0000a280: 6464 2841 322c 2042 5f30 2c20 4338 2c20  dd(A2, B_0, C8, 
-0000a290: 425f 3029 3b20 5c0a 2020 2020 2020 2020  B_0); \.        
-0000a2a0: 2020 2020 2020 4549 4745 4e5f 4153 4d5f        EIGEN_ASM_
-0000a2b0: 434f 4d4d 454e 5428 2265 6e64 2073 7465  COMMENT("end ste
-0000a2c0: 7020 6f66 2067 6562 7020 6d69 6372 6f20  p of gebp micro 
-0000a2d0: 6b65 726e 656c 2033 7058 3122 293b 205c  kernel 3pX1"); \
-0000a2e0: 0a20 2020 2020 2020 2020 2020 207d 2077  .            } w
-0000a2f0: 6869 6c65 2866 616c 7365 290a 2020 2020  hile(false).    
-0000a300: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
-0000a310: 2045 4947 454e 5f47 4542 4750 5f4f 4e45   EIGEN_GEBGP_ONE
-0000a320: 5354 4550 2830 293b 0a20 2020 2020 2020  STEP(0);.       
-0000a330: 2020 2020 2045 4947 454e 5f47 4542 4750       EIGEN_GEBGP
-0000a340: 5f4f 4e45 5354 4550 2831 293b 0a20 2020  _ONESTEP(1);.   
-0000a350: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
-0000a360: 4542 4750 5f4f 4e45 5354 4550 2832 293b  EBGP_ONESTEP(2);
-0000a370: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-0000a380: 454e 5f47 4542 4750 5f4f 4e45 5354 4550  EN_GEBGP_ONESTEP
-0000a390: 2833 293b 0a20 2020 2020 2020 2020 2020  (3);.           
-0000a3a0: 2045 4947 454e 5f47 4542 4750 5f4f 4e45   EIGEN_GEBGP_ONE
-0000a3b0: 5354 4550 2834 293b 0a20 2020 2020 2020  STEP(4);.       
-0000a3c0: 2020 2020 2045 4947 454e 5f47 4542 4750       EIGEN_GEBGP
-0000a3d0: 5f4f 4e45 5354 4550 2835 293b 0a20 2020  _ONESTEP(5);.   
-0000a3e0: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
-0000a3f0: 4542 4750 5f4f 4e45 5354 4550 2836 293b  EBGP_ONESTEP(6);
-0000a400: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-0000a410: 454e 5f47 4542 4750 5f4f 4e45 5354 4550  EN_GEBGP_ONESTEP
-0000a420: 2837 293b 0a0a 2020 2020 2020 2020 2020  (7);..          
-0000a430: 2020 626c 4220 2b3d 2070 6b2a 5268 7350    blB += pk*RhsP
-0000a440: 726f 6772 6573 733b 0a20 2020 2020 2020  rogress;.       
-0000a450: 2020 2020 2062 6c41 202b 3d20 706b 2a33       blA += pk*3
-0000a460: 2a54 7261 6974 733a 3a4c 6873 5072 6f67  *Traits::LhsProg
-0000a470: 7265 7373 3b0a 0a20 2020 2020 2020 2020  ress;..         
-0000a480: 2020 2045 4947 454e 5f41 534d 5f43 4f4d     EIGEN_ASM_COM
-0000a490: 4d45 4e54 2822 656e 6420 6765 6270 206d  MENT("end gebp m
-0000a4a0: 6963 726f 206b 6572 6e65 6c20 3370 5831  icro kernel 3pX1
-0000a4b0: 2229 3b0a 2020 2020 2020 2020 2020 7d0a  ");.          }.
-0000a4c0: 0a20 2020 2020 2020 2020 202f 2f20 7072  .          // pr
-0000a4d0: 6f63 6573 7320 7265 6d61 696e 696e 6720  ocess remaining 
-0000a4e0: 7065 656c 6564 206c 6f6f 700a 2020 2020  peeled loop.    
-0000a4f0: 2020 2020 2020 666f 7228 496e 6465 7820        for(Index 
-0000a500: 6b3d 7065 656c 6564 5f6b 633b 206b 3c64  k=peeled_kc; k<d
-0000a510: 6570 7468 3b20 6b2b 2b29 0a20 2020 2020  epth; k++).     
-0000a520: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
-0000a530: 2020 2052 6873 5061 636b 6574 2042 5f30     RhsPacket B_0
-0000a540: 3b0a 2020 2020 2020 2020 2020 2020 4549  ;.            EI
-0000a550: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
-0000a560: 5028 3029 3b0a 2020 2020 2020 2020 2020  P(0);.          
-0000a570: 2020 626c 4220 2b3d 2052 6873 5072 6f67    blB += RhsProg
-0000a580: 7265 7373 3b0a 2020 2020 2020 2020 2020  ress;.          
-0000a590: 2020 626c 4120 2b3d 2033 2a54 7261 6974    blA += 3*Trait
-0000a5a0: 733a 3a4c 6873 5072 6f67 7265 7373 3b0a  s::LhsProgress;.
-0000a5b0: 2020 2020 2020 2020 2020 7d0a 2375 6e64            }.#und
-0000a5c0: 6566 2045 4947 454e 5f47 4542 4750 5f4f  ef EIGEN_GEBGP_O
-0000a5d0: 4e45 5354 4550 0a20 2020 2020 2020 2020  NESTEP.         
-0000a5e0: 2052 6573 5061 636b 6574 2052 302c 2052   ResPacket R0, R
-0000a5f0: 312c 2052 323b 0a20 2020 2020 2020 2020  1, R2;.         
-0000a600: 2052 6573 5061 636b 6574 2061 6c70 6861   ResPacket alpha
-0000a610: 7620 3d20 7073 6574 313c 5265 7350 6163  v = pset1<ResPac
-0000a620: 6b65 743e 2861 6c70 6861 293b 0a0a 2020  ket>(alpha);..  
-0000a630: 2020 2020 2020 2020 5230 203d 2072 302e          R0 = r0.
-0000a640: 6c6f 6164 5061 636b 6574 2830 202a 2054  loadPacket(0 * T
-0000a650: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
-0000a660: 5369 7a65 293b 0a20 2020 2020 2020 2020  Size);.         
-0000a670: 2052 3120 3d20 7230 2e6c 6f61 6450 6163   R1 = r0.loadPac
-0000a680: 6b65 7428 3120 2a20 5472 6169 7473 3a3a  ket(1 * Traits::
-0000a690: 5265 7350 6163 6b65 7453 697a 6529 3b0a  ResPacketSize);.
-0000a6a0: 2020 2020 2020 2020 2020 5232 203d 2072            R2 = r
-0000a6b0: 302e 6c6f 6164 5061 636b 6574 2832 202a  0.loadPacket(2 *
-0000a6c0: 2054 7261 6974 733a 3a52 6573 5061 636b   Traits::ResPack
-0000a6d0: 6574 5369 7a65 293b 0a20 2020 2020 2020  etSize);.       
-0000a6e0: 2020 2074 7261 6974 732e 6163 6328 4330     traits.acc(C0
-0000a6f0: 2c20 616c 7068 6176 2c20 5230 293b 0a20  , alphav, R0);. 
-0000a700: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
-0000a710: 6163 6328 4334 2c20 616c 7068 6176 2c20  acc(C4, alphav, 
-0000a720: 5231 293b 0a20 2020 2020 2020 2020 2074  R1);.          t
-0000a730: 7261 6974 732e 6163 6328 4338 2c20 616c  raits.acc(C8, al
-0000a740: 7068 6176 2c20 5232 293b 0a20 2020 2020  phav, R2);.     
-0000a750: 2020 2020 2072 302e 7374 6f72 6550 6163       r0.storePac
-0000a760: 6b65 7428 3020 2a20 5472 6169 7473 3a3a  ket(0 * Traits::
-0000a770: 5265 7350 6163 6b65 7453 697a 652c 2052  ResPacketSize, R
-0000a780: 3029 3b0a 2020 2020 2020 2020 2020 7230  0);.          r0
-0000a790: 2e73 746f 7265 5061 636b 6574 2831 202a  .storePacket(1 *
-0000a7a0: 2054 7261 6974 733a 3a52 6573 5061 636b   Traits::ResPack
-0000a7b0: 6574 5369 7a65 2c20 5231 293b 0a20 2020  etSize, R1);.   
-0000a7c0: 2020 2020 2020 2072 302e 7374 6f72 6550         r0.storeP
-0000a7d0: 6163 6b65 7428 3220 2a20 5472 6169 7473  acket(2 * Traits
-0000a7e0: 3a3a 5265 7350 6163 6b65 7453 697a 652c  ::ResPacketSize,
-0000a7f0: 2052 3229 3b20 2020 2020 2020 2020 200a   R2);          .
-0000a800: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
-0000a810: 2020 2020 7d0a 2020 2020 2020 7d0a 2020      }.      }.  
-0000a820: 2020 7d0a 0a20 2020 202f 2f2d 2d2d 2d2d    }..    //-----
-0000a830: 2d2d 2d2d 2d20 5072 6f63 6573 7320 3220  ----- Process 2 
-0000a840: 2a20 4c68 7350 726f 6772 6573 7320 726f  * LhsProgress ro
-0000a850: 7773 2061 7420 6f6e 6365 202d 2d2d 2d2d  ws at once -----
-0000a860: 2d2d 2d2d 2d0a 2020 2020 6966 286d 723e  -----.    if(mr>
-0000a870: 3d32 2a54 7261 6974 733a 3a4c 6873 5072  =2*Traits::LhsPr
-0000a880: 6f67 7265 7373 290a 2020 2020 7b0a 2020  ogress).    {.  
-0000a890: 2020 2020 636f 6e73 7420 496e 6465 7820      const Index 
-0000a8a0: 6c31 203d 2064 6566 6175 6c74 4c31 4361  l1 = defaultL1Ca
-0000a8b0: 6368 6553 697a 653b 202f 2f20 696e 2042  cheSize; // in B
-0000a8c0: 7974 6573 2c20 544f 444f 2c20 6c31 2073  ytes, TODO, l1 s
-0000a8d0: 686f 756c 6420 6265 2070 6173 7365 6420  hould be passed 
-0000a8e0: 746f 2074 6869 7320 6675 6e63 7469 6f6e  to this function
-0000a8f0: 2e0a 2020 2020 2020 2f2f 2054 6865 206d  ..      // The m
-0000a900: 6178 2831 2c20 2e2e 2e29 2068 6572 6520  ax(1, ...) here 
-0000a910: 6973 206e 6565 6465 6420 6265 6361 7573  is needed becaus
-0000a920: 6520 7765 206d 6179 2062 6520 7573 696e  e we may be usin
-0000a930: 6720 626c 6f63 6b69 6e67 2070 6172 616d  g blocking param
-0000a940: 7320 6c61 7267 6572 2074 6861 6e20 7768  s larger than wh
-0000a950: 6174 206f 7572 206b 6e6f 776e 206c 3120  at our known l1 
-0000a960: 6361 6368 6520 7369 7a65 0a20 2020 2020  cache size.     
-0000a970: 202f 2f20 7375 6767 6573 7473 2077 6520   // suggests we 
-0000a980: 7368 6f75 6c64 2062 6520 7573 696e 673a  should be using:
-0000a990: 2065 6974 6865 7220 6265 6361 7573 6520   either because 
-0000a9a0: 6f75 7220 6b6e 6f77 6e20 6c31 2063 6163  our known l1 cac
-0000a9b0: 6865 2073 697a 6520 6973 2069 6e61 6363  he size is inacc
-0000a9c0: 7572 6174 6520 2865 2e67 2e20 6f6e 2041  urate (e.g. on A
-0000a9d0: 6e64 726f 6964 2c20 7765 2063 616e 206f  ndroid, we can o
-0000a9e0: 6e6c 7920 6775 6573 7329 2c0a 2020 2020  nly guess),.    
-0000a9f0: 2020 2f2f 206f 7220 6265 6361 7573 6520    // or because 
-0000aa00: 7765 2061 7265 2074 6573 7469 6e67 2073  we are testing s
-0000aa10: 7065 6369 6669 6320 626c 6f63 6b69 6e67  pecific blocking
-0000aa20: 2073 697a 6573 2e0a 2020 2020 2020 496e   sizes..      In
-0000aa30: 6465 7820 6163 7475 616c 5f70 616e 656c  dex actual_panel
-0000aa40: 5f72 6f77 7320 3d20 2832 2a4c 6873 5072  _rows = (2*LhsPr
-0000aa50: 6f67 7265 7373 2920 2a20 7374 643a 3a6d  ogress) * std::m
-0000aa60: 6178 3c49 6e64 6578 3e28 312c 2820 286c  ax<Index>(1,( (l
-0000aa70: 3120 2d20 7369 7a65 6f66 2852 6573 5363  1 - sizeof(ResSc
-0000aa80: 616c 6172 292a 6d72 2a6e 7220 2d20 6465  alar)*mr*nr - de
-0000aa90: 7074 682a 6e72 2a73 697a 656f 6628 5268  pth*nr*sizeof(Rh
-0000aaa0: 7353 6361 6c61 7229 2920 2f20 2864 6570  sScalar)) / (dep
-0000aab0: 7468 202a 2073 697a 656f 6628 4c68 7353  th * sizeof(LhsS
-0000aac0: 6361 6c61 7229 202a 2032 2a4c 6873 5072  calar) * 2*LhsPr
-0000aad0: 6f67 7265 7373 2920 2929 3b0a 0a20 2020  ogress) ));..   
-0000aae0: 2020 2066 6f72 2849 6e64 6578 2069 313d     for(Index i1=
-0000aaf0: 7065 656c 6564 5f6d 6333 3b20 6931 3c70  peeled_mc3; i1<p
-0000ab00: 6565 6c65 645f 6d63 323b 2069 312b 3d61  eeled_mc2; i1+=a
-0000ab10: 6374 7561 6c5f 7061 6e65 6c5f 726f 7773  ctual_panel_rows
-0000ab20: 290a 2020 2020 2020 7b0a 2020 2020 2020  ).      {.      
-0000ab30: 2020 496e 6465 7820 6163 7475 616c 5f70    Index actual_p
-0000ab40: 616e 656c 5f65 6e64 203d 2028 7374 643a  anel_end = (std:
-0000ab50: 3a6d 696e 2928 6931 2b61 6374 7561 6c5f  :min)(i1+actual_
-0000ab60: 7061 6e65 6c5f 726f 7773 2c20 7065 656c  panel_rows, peel
-0000ab70: 6564 5f6d 6332 293b 0a20 2020 2020 2020  ed_mc2);.       
-0000ab80: 2066 6f72 2849 6e64 6578 206a 323d 303b   for(Index j2=0;
-0000ab90: 206a 323c 7061 636b 6574 5f63 6f6c 7334   j2<packet_cols4
-0000aba0: 3b20 6a32 2b3d 6e72 290a 2020 2020 2020  ; j2+=nr).      
-0000abb0: 2020 7b0a 2020 2020 2020 2020 2020 666f    {.          fo
-0000abc0: 7228 496e 6465 7820 693d 6931 3b20 693c  r(Index i=i1; i<
-0000abd0: 6163 7475 616c 5f70 616e 656c 5f65 6e64  actual_panel_end
-0000abe0: 3b20 692b 3d32 2a4c 6873 5072 6f67 7265  ; i+=2*LhsProgre
-0000abf0: 7373 290a 2020 2020 2020 2020 2020 7b0a  ss).          {.
-0000ac00: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
-0000ac10: 2020 2020 202f 2f20 5765 2073 656c 6563       // We selec
-0000ac20: 7465 6420 6120 322a 5472 6169 7473 3a3a  ted a 2*Traits::
-0000ac30: 4c68 7350 726f 6772 6573 7320 7820 6e72  LhsProgress x nr
-0000ac40: 206d 6963 726f 2062 6c6f 636b 206f 6620   micro block of 
-0000ac50: 7265 7320 7768 6963 6820 6973 2065 6e74  res which is ent
-0000ac60: 6972 656c 790a 2020 2020 2020 2020 2020  irely.          
-0000ac70: 2f2f 2073 746f 7265 6420 696e 746f 2032  // stored into 2
-0000ac80: 2078 206e 7220 7265 6769 7374 6572 732e   x nr registers.
-0000ac90: 0a20 2020 2020 2020 2020 200a 2020 2020  .          .    
-0000aca0: 2020 2020 2020 636f 6e73 7420 4c68 7353        const LhsS
-0000acb0: 6361 6c61 722a 2062 6c41 203d 2026 626c  calar* blA = &bl
-0000acc0: 6f63 6b41 5b69 2a73 7472 6964 6541 2b6f  ockA[i*strideA+o
-0000acd0: 6666 7365 7441 2a28 322a 5472 6169 7473  ffsetA*(2*Traits
-0000ace0: 3a3a 4c68 7350 726f 6772 6573 7329 5d3b  ::LhsProgress)];
-0000acf0: 0a20 2020 2020 2020 2020 2070 7265 6665  .          prefe
-0000ad00: 7463 6828 2662 6c41 5b30 5d29 3b0a 0a20  tch(&blA[0]);.. 
-0000ad10: 2020 2020 2020 2020 202f 2f20 6765 7473           // gets
-0000ad20: 2072 6573 2062 6c6f 636b 2061 7320 7265   res block as re
-0000ad30: 6769 7374 6572 0a20 2020 2020 2020 2020  gister.         
-0000ad40: 2041 6363 5061 636b 6574 2043 302c 2043   AccPacket C0, C
-0000ad50: 312c 2043 322c 2043 332c 0a20 2020 2020  1, C2, C3,.     
-0000ad60: 2020 2020 2020 2020 2020 2020 2020 2043                 C
-0000ad70: 342c 2043 352c 2043 362c 2043 373b 0a20  4, C5, C6, C7;. 
-0000ad80: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
-0000ad90: 696e 6974 4163 6328 4330 293b 2074 7261  initAcc(C0); tra
-0000ada0: 6974 732e 696e 6974 4163 6328 4331 293b  its.initAcc(C1);
-0000adb0: 2074 7261 6974 732e 696e 6974 4163 6328   traits.initAcc(
-0000adc0: 4332 293b 2074 7261 6974 732e 696e 6974  C2); traits.init
-0000add0: 4163 6328 4333 293b 0a20 2020 2020 2020  Acc(C3);.       
-0000ade0: 2020 2074 7261 6974 732e 696e 6974 4163     traits.initAc
-0000adf0: 6328 4334 293b 2074 7261 6974 732e 696e  c(C4); traits.in
-0000ae00: 6974 4163 6328 4335 293b 2074 7261 6974  itAcc(C5); trait
-0000ae10: 732e 696e 6974 4163 6328 4336 293b 2074  s.initAcc(C6); t
-0000ae20: 7261 6974 732e 696e 6974 4163 6328 4337  raits.initAcc(C7
-0000ae30: 293b 0a0a 2020 2020 2020 2020 2020 4c69  );..          Li
-0000ae40: 6e65 6172 4d61 7070 6572 2072 3020 3d20  nearMapper r0 = 
-0000ae50: 7265 732e 6765 744c 696e 6561 724d 6170  res.getLinearMap
-0000ae60: 7065 7228 692c 206a 3220 2b20 3029 3b0a  per(i, j2 + 0);.
-0000ae70: 2020 2020 2020 2020 2020 4c69 6e65 6172            Linear
-0000ae80: 4d61 7070 6572 2072 3120 3d20 7265 732e  Mapper r1 = res.
-0000ae90: 6765 744c 696e 6561 724d 6170 7065 7228  getLinearMapper(
-0000aea0: 692c 206a 3220 2b20 3129 3b0a 2020 2020  i, j2 + 1);.    
-0000aeb0: 2020 2020 2020 4c69 6e65 6172 4d61 7070        LinearMapp
-0000aec0: 6572 2072 3220 3d20 7265 732e 6765 744c  er r2 = res.getL
-0000aed0: 696e 6561 724d 6170 7065 7228 692c 206a  inearMapper(i, j
-0000aee0: 3220 2b20 3229 3b0a 2020 2020 2020 2020  2 + 2);.        
-0000aef0: 2020 4c69 6e65 6172 4d61 7070 6572 2072    LinearMapper r
-0000af00: 3320 3d20 7265 732e 6765 744c 696e 6561  3 = res.getLinea
-0000af10: 724d 6170 7065 7228 692c 206a 3220 2b20  rMapper(i, j2 + 
-0000af20: 3329 3b0a 0a20 2020 2020 2020 2020 2072  3);..          r
-0000af30: 302e 7072 6566 6574 6368 2870 7265 6665  0.prefetch(prefe
-0000af40: 7463 685f 7265 735f 6f66 6673 6574 293b  tch_res_offset);
-0000af50: 0a20 2020 2020 2020 2020 2072 312e 7072  .          r1.pr
-0000af60: 6566 6574 6368 2870 7265 6665 7463 685f  efetch(prefetch_
-0000af70: 7265 735f 6f66 6673 6574 293b 0a20 2020  res_offset);.   
-0000af80: 2020 2020 2020 2072 322e 7072 6566 6574         r2.prefet
-0000af90: 6368 2870 7265 6665 7463 685f 7265 735f  ch(prefetch_res_
-0000afa0: 6f66 6673 6574 293b 0a20 2020 2020 2020  offset);.       
-0000afb0: 2020 2072 332e 7072 6566 6574 6368 2870     r3.prefetch(p
-0000afc0: 7265 6665 7463 685f 7265 735f 6f66 6673  refetch_res_offs
-0000afd0: 6574 293b 0a0a 2020 2020 2020 2020 2020  et);..          
-0000afe0: 2f2f 2070 6572 666f 726d 7320 2269 6e6e  // performs "inn
-0000aff0: 6572 2220 7072 6f64 7563 7473 0a20 2020  er" products.   
-0000b000: 2020 2020 2020 2063 6f6e 7374 2052 6873         const Rhs
-0000b010: 5363 616c 6172 2a20 626c 4220 3d20 2662  Scalar* blB = &b
-0000b020: 6c6f 636b 425b 6a32 2a73 7472 6964 6542  lockB[j2*strideB
-0000b030: 2b6f 6666 7365 7442 2a6e 725d 3b0a 2020  +offsetB*nr];.  
-0000b040: 2020 2020 2020 2020 7072 6566 6574 6368          prefetch
-0000b050: 2826 626c 425b 305d 293b 0a20 2020 2020  (&blB[0]);.     
-0000b060: 2020 2020 204c 6873 5061 636b 6574 2041       LhsPacket A
-0000b070: 302c 2041 313b 0a0a 2020 2020 2020 2020  0, A1;..        
-0000b080: 2020 666f 7228 496e 6465 7820 6b3d 303b    for(Index k=0;
-0000b090: 206b 3c70 6565 6c65 645f 6b63 3b20 6b2b   k<peeled_kc; k+
-0000b0a0: 3d70 6b29 0a20 2020 2020 2020 2020 207b  =pk).          {
-0000b0b0: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-0000b0c0: 454e 5f41 534d 5f43 4f4d 4d45 4e54 2822  EN_ASM_COMMENT("
-0000b0d0: 6265 6769 6e20 6765 6270 206d 6963 726f  begin gebp micro
-0000b0e0: 206b 6572 6e65 6c20 3270 5834 2229 3b0a   kernel 2pX4");.
-0000b0f0: 2020 2020 2020 2020 2020 2020 5268 7350              RhsP
-0000b100: 6163 6b65 7420 425f 302c 2042 312c 2042  acket B_0, B1, B
-0000b110: 322c 2042 332c 2054 303b 0a0a 2020 2020  2, B3, T0;..    
-0000b120: 2020 2020 2020 2f2f 204e 4f54 453a 2074        // NOTE: t
-0000b130: 6865 2062 6567 696e 2f65 6e64 2061 736d  he begin/end asm
-0000b140: 2063 6f6d 6d65 6e74 7320 6265 6c6f 7720   comments below 
-0000b150: 776f 726b 2061 726f 756e 6420 6275 6720  work around bug 
-0000b160: 3933 3521 0a20 2020 2020 2020 2020 202f  935!.          /
-0000b170: 2f20 6275 7420 7468 6579 2061 7265 206e  / but they are n
-0000b180: 6f74 2065 6e6f 7567 6820 666f 7220 6763  ot enough for gc
-0000b190: 633e 3d36 2077 6974 686f 7574 2046 4d41  c>=6 without FMA
-0000b1a0: 2028 6275 6720 3136 3337 290a 2020 2020   (bug 1637).    
-0000b1b0: 2020 2020 2020 2369 6620 4549 4745 4e5f        #if EIGEN_
-0000b1c0: 474e 5543 5f41 545f 4c45 4153 5428 362c  GNUC_AT_LEAST(6,
-0000b1d0: 3029 2026 2620 6465 6669 6e65 6428 4549  0) && defined(EI
-0000b1e0: 4745 4e5f 5645 4354 4f52 495a 455f 5353  GEN_VECTORIZE_SS
-0000b1f0: 4529 0a20 2020 2020 2020 2020 2020 2023  E).            #
-0000b200: 6465 6669 6e65 2045 4947 454e 5f47 4542  define EIGEN_GEB
-0000b210: 505f 3250 5834 5f53 5049 4c4c 494e 475f  P_2PX4_SPILLING_
-0000b220: 574f 524b 4152 4f55 4e44 205f 5f61 736d  WORKAROUND __asm
-0000b230: 5f5f 2020 2822 2220 3a20 5b61 305d 2022  __  ("" : [a0] "
-0000b240: 2b78 2c6d 2220 2841 3029 2c5b 6131 5d20  +x,m" (A0),[a1] 
-0000b250: 222b 782c 6d22 2028 4131 2929 3b0a 2020  "+x,m" (A1));.  
-0000b260: 2020 2020 2020 2020 2365 6c73 650a 2020          #else.  
-0000b270: 2020 2020 2020 2020 2020 2364 6566 696e            #defin
-0000b280: 6520 4549 4745 4e5f 4745 4250 5f32 5058  e EIGEN_GEBP_2PX
-0000b290: 345f 5350 494c 4c49 4e47 5f57 4f52 4b41  4_SPILLING_WORKA
-0000b2a0: 524f 554e 440a 2020 2020 2020 2020 2020  ROUND.          
-0000b2b0: 2365 6e64 6966 0a20 2020 2020 2020 2020  #endif.         
-0000b2c0: 2023 6465 6669 6e65 2045 4947 454e 5f47   #define EIGEN_G
-0000b2d0: 4542 4750 5f4f 4e45 5354 4550 284b 2920  EBGP_ONESTEP(K) 
-0000b2e0: 5c0a 2020 2020 2020 2020 2020 2020 646f  \.            do
-0000b2f0: 207b 2020 2020 2020 2020 2020 2020 2020   {              
-0000b300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b330: 2020 5c0a 2020 2020 2020 2020 2020 2020    \.            
-0000b340: 2020 4549 4745 4e5f 4153 4d5f 434f 4d4d    EIGEN_ASM_COMM
-0000b350: 454e 5428 2262 6567 696e 2073 7465 7020  ENT("begin step 
-0000b360: 6f66 2067 6562 7020 6d69 6372 6f20 6b65  of gebp micro ke
-0000b370: 726e 656c 2032 7058 3422 293b 2020 2020  rnel 2pX4");    
-0000b380: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
-0000b390: 2020 2020 7472 6169 7473 2e6c 6f61 644c      traits.loadL
-0000b3a0: 6873 2826 626c 415b 2830 2b32 2a4b 292a  hs(&blA[(0+2*K)*
-0000b3b0: 4c68 7350 726f 6772 6573 735d 2c20 4130  LhsProgress], A0
-0000b3c0: 293b 2020 2020 2020 2020 2020 2020 2020  );              
-0000b3d0: 2020 2020 2020 5c0a 2020 2020 2020 2020        \.        
-0000b3e0: 2020 2020 2020 7472 6169 7473 2e6c 6f61        traits.loa
-0000b3f0: 644c 6873 2826 626c 415b 2831 2b32 2a4b  dLhs(&blA[(1+2*K
-0000b400: 292a 4c68 7350 726f 6772 6573 735d 2c20  )*LhsProgress], 
-0000b410: 4131 293b 2020 2020 2020 2020 2020 2020  A1);            
-0000b420: 2020 2020 2020 2020 5c0a 2020 2020 2020          \.      
-0000b430: 2020 2020 2020 2020 7472 6169 7473 2e62          traits.b
-0000b440: 726f 6164 6361 7374 5268 7328 2662 6c42  roadcastRhs(&blB
-0000b450: 5b28 302b 342a 4b29 2a52 6873 5072 6f67  [(0+4*K)*RhsProg
-0000b460: 7265 7373 5d2c 2042 5f30 2c20 4231 2c20  ress], B_0, B1, 
-0000b470: 4232 2c20 4233 293b 2020 5c0a 2020 2020  B2, B3);  \.    
-0000b480: 2020 2020 2020 2020 2020 7472 6169 7473            traits
-0000b490: 2e6d 6164 6428 4130 2c20 425f 302c 2043  .madd(A0, B_0, C
-0000b4a0: 302c 2054 3029 3b20 2020 2020 2020 2020  0, T0);         
-0000b4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b4c0: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
-0000b4d0: 2020 2020 2020 2020 2020 2020 7472 6169              trai
-0000b4e0: 7473 2e6d 6164 6428 4131 2c20 425f 302c  ts.madd(A1, B_0,
-0000b4f0: 2043 342c 2042 5f30 293b 2020 2020 2020   C4, B_0);      
-0000b500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b510: 2020 2020 2020 2020 2020 2020 2020 5c0a                \.
-0000b520: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-0000b530: 6169 7473 2e6d 6164 6428 4130 2c20 4231  aits.madd(A0, B1
-0000b540: 2c20 2043 312c 2054 3029 3b20 2020 2020  ,  C1, T0);     
-0000b550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b570: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-0000b580: 7472 6169 7473 2e6d 6164 6428 4131 2c20  traits.madd(A1, 
-0000b590: 4231 2c20 2043 352c 2042 3129 3b20 2020  B1,  C5, B1);   
-0000b5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5c0: 2020 5c0a 2020 2020 2020 2020 2020 2020    \.            
-0000b5d0: 2020 7472 6169 7473 2e6d 6164 6428 4130    traits.madd(A0
-0000b5e0: 2c20 4232 2c20 2043 322c 2054 3029 3b20  , B2,  C2, T0); 
-0000b5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b610: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
-0000b620: 2020 2020 7472 6169 7473 2e6d 6164 6428      traits.madd(
-0000b630: 4131 2c20 4232 2c20 2043 362c 2042 3229  A1, B2,  C6, B2)
-0000b640: 3b20 2020 2020 2020 2020 2020 2020 2020  ;               
-0000b650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b660: 2020 2020 2020 5c0a 2020 2020 2020 2020        \.        
-0000b670: 2020 2020 2020 7472 6169 7473 2e6d 6164        traits.mad
-0000b680: 6428 4130 2c20 4233 2c20 2043 332c 2054  d(A0, B3,  C3, T
-0000b690: 3029 3b20 2020 2020 2020 2020 2020 2020  0);             
-0000b6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6b0: 2020 2020 2020 2020 5c0a 2020 2020 2020          \.      
-0000b6c0: 2020 2020 2020 2020 7472 6169 7473 2e6d          traits.m
-0000b6d0: 6164 6428 4131 2c20 4233 2c20 2043 372c  add(A1, B3,  C7,
-0000b6e0: 2042 3329 3b20 2020 2020 2020 2020 2020   B3);           
-0000b6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b700: 2020 2020 2020 2020 2020 5c0a 2020 2020            \.    
-0000b710: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
-0000b720: 4745 4250 5f32 5058 345f 5350 494c 4c49  GEBP_2PX4_SPILLI
-0000b730: 4e47 5f57 4f52 4b41 524f 554e 4420 2020  NG_WORKAROUND   
-0000b740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b750: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
-0000b760: 2020 2020 2020 2020 2020 2020 4549 4745              EIGE
-0000b770: 4e5f 4153 4d5f 434f 4d4d 454e 5428 2265  N_ASM_COMMENT("e
-0000b780: 6e64 2073 7465 7020 6f66 2067 6562 7020  nd step of gebp 
-0000b790: 6d69 6372 6f20 6b65 726e 656c 2032 7058  micro kernel 2pX
-0000b7a0: 3422 293b 2020 2020 2020 2020 2020 5c0a  4");          \.
-0000b7b0: 2020 2020 2020 2020 2020 2020 7d20 7768              } wh
-0000b7c0: 696c 6528 6661 6c73 6529 0a20 2020 2020  ile(false).     
-0000b7d0: 2020 2020 2020 200a 2020 2020 2020 2020         .        
-0000b7e0: 2020 2020 696e 7465 726e 616c 3a3a 7072      internal::pr
-0000b7f0: 6566 6574 6368 2862 6c42 2b28 3438 2b30  efetch(blB+(48+0
-0000b800: 2929 3b0a 2020 2020 2020 2020 2020 2020  ));.            
-0000b810: 4549 4745 4e5f 4745 4247 505f 4f4e 4553  EIGEN_GEBGP_ONES
-0000b820: 5445 5028 3029 3b0a 2020 2020 2020 2020  TEP(0);.        
-0000b830: 2020 2020 4549 4745 4e5f 4745 4247 505f      EIGEN_GEBGP_
-0000b840: 4f4e 4553 5445 5028 3129 3b0a 2020 2020  ONESTEP(1);.    
-0000b850: 2020 2020 2020 2020 4549 4745 4e5f 4745          EIGEN_GE
-0000b860: 4247 505f 4f4e 4553 5445 5028 3229 3b0a  BGP_ONESTEP(2);.
-0000b870: 2020 2020 2020 2020 2020 2020 4549 4745              EIGE
-0000b880: 4e5f 4745 4247 505f 4f4e 4553 5445 5028  N_GEBGP_ONESTEP(
-0000b890: 3329 3b0a 2020 2020 2020 2020 2020 2020  3);.            
-0000b8a0: 696e 7465 726e 616c 3a3a 7072 6566 6574  internal::prefet
-0000b8b0: 6368 2862 6c42 2b28 3438 2b31 3629 293b  ch(blB+(48+16));
-0000b8c0: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-0000b8d0: 454e 5f47 4542 4750 5f4f 4e45 5354 4550  EN_GEBGP_ONESTEP
-0000b8e0: 2834 293b 0a20 2020 2020 2020 2020 2020  (4);.           
-0000b8f0: 2045 4947 454e 5f47 4542 4750 5f4f 4e45   EIGEN_GEBGP_ONE
-0000b900: 5354 4550 2835 293b 0a20 2020 2020 2020  STEP(5);.       
-0000b910: 2020 2020 2045 4947 454e 5f47 4542 4750       EIGEN_GEBGP
-0000b920: 5f4f 4e45 5354 4550 2836 293b 0a20 2020  _ONESTEP(6);.   
-0000b930: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
-0000b940: 4542 4750 5f4f 4e45 5354 4550 2837 293b  EBGP_ONESTEP(7);
-0000b950: 0a0a 2020 2020 2020 2020 2020 2020 626c  ..            bl
-0000b960: 4220 2b3d 2070 6b2a 342a 5268 7350 726f  B += pk*4*RhsPro
-0000b970: 6772 6573 733b 0a20 2020 2020 2020 2020  gress;.         
-0000b980: 2020 2062 6c41 202b 3d20 706b 2a28 322a     blA += pk*(2*
-0000b990: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
-0000b9a0: 6573 7329 3b0a 0a20 2020 2020 2020 2020  ess);..         
-0000b9b0: 2020 2045 4947 454e 5f41 534d 5f43 4f4d     EIGEN_ASM_COM
-0000b9c0: 4d45 4e54 2822 656e 6420 6765 6270 206d  MENT("end gebp m
-0000b9d0: 6963 726f 206b 6572 6e65 6c20 3270 5834  icro kernel 2pX4
-0000b9e0: 2229 3b0a 2020 2020 2020 2020 2020 7d0a  ");.          }.
-0000b9f0: 2020 2020 2020 2020 2020 2f2f 2070 726f            // pro
-0000ba00: 6365 7373 2072 656d 6169 6e69 6e67 2070  cess remaining p
-0000ba10: 6565 6c65 6420 6c6f 6f70 0a20 2020 2020  eeled loop.     
-0000ba20: 2020 2020 2066 6f72 2849 6e64 6578 206b       for(Index k
-0000ba30: 3d70 6565 6c65 645f 6b63 3b20 6b3c 6465  =peeled_kc; k<de
-0000ba40: 7074 683b 206b 2b2b 290a 2020 2020 2020  pth; k++).      
-0000ba50: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
-0000ba60: 2020 5268 7350 6163 6b65 7420 425f 302c    RhsPacket B_0,
-0000ba70: 2042 312c 2042 322c 2042 332c 2054 303b   B1, B2, B3, T0;
-0000ba80: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-0000ba90: 454e 5f47 4542 4750 5f4f 4e45 5354 4550  EN_GEBGP_ONESTEP
-0000baa0: 2830 293b 0a20 2020 2020 2020 2020 2020  (0);.           
-0000bab0: 2062 6c42 202b 3d20 342a 5268 7350 726f   blB += 4*RhsPro
-0000bac0: 6772 6573 733b 0a20 2020 2020 2020 2020  gress;.         
-0000bad0: 2020 2062 6c41 202b 3d20 322a 5472 6169     blA += 2*Trai
-0000bae0: 7473 3a3a 4c68 7350 726f 6772 6573 733b  ts::LhsProgress;
-0000baf0: 0a20 2020 2020 2020 2020 207d 0a23 756e  .          }.#un
-0000bb00: 6465 6620 4549 4745 4e5f 4745 4247 505f  def EIGEN_GEBGP_
-0000bb10: 4f4e 4553 5445 500a 0a20 2020 2020 2020  ONESTEP..       
-0000bb20: 2020 2052 6573 5061 636b 6574 2052 302c     ResPacket R0,
-0000bb30: 2052 312c 2052 322c 2052 333b 0a20 2020   R1, R2, R3;.   
-0000bb40: 2020 2020 2020 2052 6573 5061 636b 6574         ResPacket
-0000bb50: 2061 6c70 6861 7620 3d20 7073 6574 313c   alphav = pset1<
-0000bb60: 5265 7350 6163 6b65 743e 2861 6c70 6861  ResPacket>(alpha
-0000bb70: 293b 0a0a 2020 2020 2020 2020 2020 5230  );..          R0
-0000bb80: 203d 2072 302e 6c6f 6164 5061 636b 6574   = r0.loadPacket
-0000bb90: 2830 202a 2054 7261 6974 733a 3a52 6573  (0 * Traits::Res
-0000bba0: 5061 636b 6574 5369 7a65 293b 0a20 2020  PacketSize);.   
-0000bbb0: 2020 2020 2020 2052 3120 3d20 7230 2e6c         R1 = r0.l
-0000bbc0: 6f61 6450 6163 6b65 7428 3120 2a20 5472  oadPacket(1 * Tr
-0000bbd0: 6169 7473 3a3a 5265 7350 6163 6b65 7453  aits::ResPacketS
-0000bbe0: 697a 6529 3b0a 2020 2020 2020 2020 2020  ize);.          
-0000bbf0: 5232 203d 2072 312e 6c6f 6164 5061 636b  R2 = r1.loadPack
-0000bc00: 6574 2830 202a 2054 7261 6974 733a 3a52  et(0 * Traits::R
-0000bc10: 6573 5061 636b 6574 5369 7a65 293b 0a20  esPacketSize);. 
-0000bc20: 2020 2020 2020 2020 2052 3320 3d20 7231           R3 = r1
-0000bc30: 2e6c 6f61 6450 6163 6b65 7428 3120 2a20  .loadPacket(1 * 
-0000bc40: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
-0000bc50: 7453 697a 6529 3b0a 2020 2020 2020 2020  tSize);.        
-0000bc60: 2020 7472 6169 7473 2e61 6363 2843 302c    traits.acc(C0,
-0000bc70: 2061 6c70 6861 762c 2052 3029 3b0a 2020   alphav, R0);.  
-0000bc80: 2020 2020 2020 2020 7472 6169 7473 2e61          traits.a
-0000bc90: 6363 2843 342c 2061 6c70 6861 762c 2052  cc(C4, alphav, R
-0000bca0: 3129 3b0a 2020 2020 2020 2020 2020 7472  1);.          tr
-0000bcb0: 6169 7473 2e61 6363 2843 312c 2061 6c70  aits.acc(C1, alp
-0000bcc0: 6861 762c 2052 3229 3b0a 2020 2020 2020  hav, R2);.      
-0000bcd0: 2020 2020 7472 6169 7473 2e61 6363 2843      traits.acc(C
-0000bce0: 352c 2061 6c70 6861 762c 2052 3329 3b0a  5, alphav, R3);.
-0000bcf0: 2020 2020 2020 2020 2020 7230 2e73 746f            r0.sto
-0000bd00: 7265 5061 636b 6574 2830 202a 2054 7261  rePacket(0 * Tra
-0000bd10: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
-0000bd20: 7a65 2c20 5230 293b 0a20 2020 2020 2020  ze, R0);.       
-0000bd30: 2020 2072 302e 7374 6f72 6550 6163 6b65     r0.storePacke
-0000bd40: 7428 3120 2a20 5472 6169 7473 3a3a 5265  t(1 * Traits::Re
-0000bd50: 7350 6163 6b65 7453 697a 652c 2052 3129  sPacketSize, R1)
-0000bd60: 3b0a 2020 2020 2020 2020 2020 7231 2e73  ;.          r1.s
-0000bd70: 746f 7265 5061 636b 6574 2830 202a 2054  torePacket(0 * T
-0000bd80: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
-0000bd90: 5369 7a65 2c20 5232 293b 0a20 2020 2020  Size, R2);.     
-0000bda0: 2020 2020 2072 312e 7374 6f72 6550 6163       r1.storePac
-0000bdb0: 6b65 7428 3120 2a20 5472 6169 7473 3a3a  ket(1 * Traits::
-0000bdc0: 5265 7350 6163 6b65 7453 697a 652c 2052  ResPacketSize, R
-0000bdd0: 3329 3b0a 0a20 2020 2020 2020 2020 2052  3);..          R
-0000bde0: 3020 3d20 7232 2e6c 6f61 6450 6163 6b65  0 = r2.loadPacke
-0000bdf0: 7428 3020 2a20 5472 6169 7473 3a3a 5265  t(0 * Traits::Re
-0000be00: 7350 6163 6b65 7453 697a 6529 3b0a 2020  sPacketSize);.  
-0000be10: 2020 2020 2020 2020 5231 203d 2072 322e          R1 = r2.
-0000be20: 6c6f 6164 5061 636b 6574 2831 202a 2054  loadPacket(1 * T
-0000be30: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
-0000be40: 5369 7a65 293b 0a20 2020 2020 2020 2020  Size);.         
-0000be50: 2052 3220 3d20 7233 2e6c 6f61 6450 6163   R2 = r3.loadPac
-0000be60: 6b65 7428 3020 2a20 5472 6169 7473 3a3a  ket(0 * Traits::
-0000be70: 5265 7350 6163 6b65 7453 697a 6529 3b0a  ResPacketSize);.
-0000be80: 2020 2020 2020 2020 2020 5233 203d 2072            R3 = r
-0000be90: 332e 6c6f 6164 5061 636b 6574 2831 202a  3.loadPacket(1 *
-0000bea0: 2054 7261 6974 733a 3a52 6573 5061 636b   Traits::ResPack
-0000beb0: 6574 5369 7a65 293b 0a20 2020 2020 2020  etSize);.       
-0000bec0: 2020 2074 7261 6974 732e 6163 6328 4332     traits.acc(C2
-0000bed0: 2c20 2061 6c70 6861 762c 2052 3029 3b0a  ,  alphav, R0);.
-0000bee0: 2020 2020 2020 2020 2020 7472 6169 7473            traits
-0000bef0: 2e61 6363 2843 362c 2020 616c 7068 6176  .acc(C6,  alphav
-0000bf00: 2c20 5231 293b 0a20 2020 2020 2020 2020  , R1);.         
-0000bf10: 2074 7261 6974 732e 6163 6328 4333 2c20   traits.acc(C3, 
-0000bf20: 2061 6c70 6861 762c 2052 3229 3b0a 2020   alphav, R2);.  
-0000bf30: 2020 2020 2020 2020 7472 6169 7473 2e61          traits.a
-0000bf40: 6363 2843 372c 2020 616c 7068 6176 2c20  cc(C7,  alphav, 
-0000bf50: 5233 293b 0a20 2020 2020 2020 2020 2072  R3);.          r
-0000bf60: 322e 7374 6f72 6550 6163 6b65 7428 3020  2.storePacket(0 
-0000bf70: 2a20 5472 6169 7473 3a3a 5265 7350 6163  * Traits::ResPac
-0000bf80: 6b65 7453 697a 652c 2052 3029 3b0a 2020  ketSize, R0);.  
-0000bf90: 2020 2020 2020 2020 7232 2e73 746f 7265          r2.store
-0000bfa0: 5061 636b 6574 2831 202a 2054 7261 6974  Packet(1 * Trait
-0000bfb0: 733a 3a52 6573 5061 636b 6574 5369 7a65  s::ResPacketSize
-0000bfc0: 2c20 5231 293b 0a20 2020 2020 2020 2020  , R1);.         
-0000bfd0: 2072 332e 7374 6f72 6550 6163 6b65 7428   r3.storePacket(
-0000bfe0: 3020 2a20 5472 6169 7473 3a3a 5265 7350  0 * Traits::ResP
-0000bff0: 6163 6b65 7453 697a 652c 2052 3229 3b0a  acketSize, R2);.
-0000c000: 2020 2020 2020 2020 2020 7233 2e73 746f            r3.sto
-0000c010: 7265 5061 636b 6574 2831 202a 2054 7261  rePacket(1 * Tra
-0000c020: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
-0000c030: 7a65 2c20 5233 293b 0a20 2020 2020 2020  ze, R3);.       
-0000c040: 2020 207d 0a20 2020 2020 2020 207d 0a20     }.        }. 
-0000c050: 2020 2020 200a 2020 2020 2020 2020 2f2f       .        //
-0000c060: 2044 6561 6c20 7769 7468 2072 656d 6169   Deal with remai
-0000c070: 6e69 6e67 2063 6f6c 756d 6e73 206f 6620  ning columns of 
-0000c080: 7468 6520 7268 730a 2020 2020 2020 2020  the rhs.        
-0000c090: 666f 7228 496e 6465 7820 6a32 3d70 6163  for(Index j2=pac
-0000c0a0: 6b65 745f 636f 6c73 343b 206a 323c 636f  ket_cols4; j2<co
-0000c0b0: 6c73 3b20 6a32 2b2b 290a 2020 2020 2020  ls; j2++).      
-0000c0c0: 2020 7b0a 2020 2020 2020 2020 2020 666f    {.          fo
-0000c0d0: 7228 496e 6465 7820 693d 6931 3b20 693c  r(Index i=i1; i<
-0000c0e0: 6163 7475 616c 5f70 616e 656c 5f65 6e64  actual_panel_end
-0000c0f0: 3b20 692b 3d32 2a4c 6873 5072 6f67 7265  ; i+=2*LhsProgre
-0000c100: 7373 290a 2020 2020 2020 2020 2020 7b0a  ss).          {.
-0000c110: 2020 2020 2020 2020 2020 2f2f 204f 6e65            // One
-0000c120: 2063 6f6c 756d 6e20 6174 2061 2074 696d   column at a tim
-0000c130: 650a 2020 2020 2020 2020 2020 636f 6e73  e.          cons
-0000c140: 7420 4c68 7353 6361 6c61 722a 2062 6c41  t LhsScalar* blA
-0000c150: 203d 2026 626c 6f63 6b41 5b69 2a73 7472   = &blockA[i*str
-0000c160: 6964 6541 2b6f 6666 7365 7441 2a28 322a  ideA+offsetA*(2*
-0000c170: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
-0000c180: 6573 7329 5d3b 0a20 2020 2020 2020 2020  ess)];.         
-0000c190: 2070 7265 6665 7463 6828 2662 6c41 5b30   prefetch(&blA[0
-0000c1a0: 5d29 3b0a 0a20 2020 2020 2020 2020 202f  ]);..          /
-0000c1b0: 2f20 6765 7473 2072 6573 2062 6c6f 636b  / gets res block
-0000c1c0: 2061 7320 7265 6769 7374 6572 0a20 2020   as register.   
-0000c1d0: 2020 2020 2020 2041 6363 5061 636b 6574         AccPacket
-0000c1e0: 2043 302c 2043 343b 0a20 2020 2020 2020   C0, C4;.       
-0000c1f0: 2020 2074 7261 6974 732e 696e 6974 4163     traits.initAc
-0000c200: 6328 4330 293b 0a20 2020 2020 2020 2020  c(C0);.         
-0000c210: 2074 7261 6974 732e 696e 6974 4163 6328   traits.initAcc(
-0000c220: 4334 293b 0a0a 2020 2020 2020 2020 2020  C4);..          
-0000c230: 4c69 6e65 6172 4d61 7070 6572 2072 3020  LinearMapper r0 
-0000c240: 3d20 7265 732e 6765 744c 696e 6561 724d  = res.getLinearM
-0000c250: 6170 7065 7228 692c 206a 3229 3b0a 2020  apper(i, j2);.  
-0000c260: 2020 2020 2020 2020 7230 2e70 7265 6665          r0.prefe
-0000c270: 7463 6828 7072 6566 6574 6368 5f72 6573  tch(prefetch_res
-0000c280: 5f6f 6666 7365 7429 3b0a 0a20 2020 2020  _offset);..     
-0000c290: 2020 2020 202f 2f20 7065 7266 6f72 6d73       // performs
-0000c2a0: 2022 696e 6e65 7222 2070 726f 6475 6374   "inner" product
-0000c2b0: 730a 2020 2020 2020 2020 2020 636f 6e73  s.          cons
-0000c2c0: 7420 5268 7353 6361 6c61 722a 2062 6c42  t RhsScalar* blB
-0000c2d0: 203d 2026 626c 6f63 6b42 5b6a 322a 7374   = &blockB[j2*st
-0000c2e0: 7269 6465 422b 6f66 6673 6574 425d 3b0a  rideB+offsetB];.
-0000c2f0: 2020 2020 2020 2020 2020 4c68 7350 6163            LhsPac
-0000c300: 6b65 7420 4130 2c20 4131 3b0a 0a20 2020  ket A0, A1;..   
-0000c310: 2020 2020 2020 2066 6f72 2849 6e64 6578         for(Index
-0000c320: 206b 3d30 3b20 6b3c 7065 656c 6564 5f6b   k=0; k<peeled_k
-0000c330: 633b 206b 2b3d 706b 290a 2020 2020 2020  c; k+=pk).      
-0000c340: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
-0000c350: 2020 4549 4745 4e5f 4153 4d5f 434f 4d4d    EIGEN_ASM_COMM
-0000c360: 454e 5428 2262 6567 696e 2067 6562 7020  ENT("begin gebp 
-0000c370: 6d69 6372 6f20 6b65 726e 656c 2032 7058  micro kernel 2pX
-0000c380: 3122 293b 0a20 2020 2020 2020 2020 2020  1");.           
-0000c390: 2052 6873 5061 636b 6574 2042 5f30 2c20   RhsPacket B_0, 
-0000c3a0: 4231 3b0a 2020 2020 2020 2020 0a23 6465  B1;.        .#de
-0000c3b0: 6669 6e65 2045 4947 454e 5f47 4542 4750  fine EIGEN_GEBGP
-0000c3c0: 5f4f 4e45 5354 4550 284b 2920 5c0a 2020  _ONESTEP(K) \.  
-0000c3d0: 2020 2020 2020 2020 2020 646f 207b 2020            do {  
-0000c3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c420: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-0000c430: 4549 4745 4e5f 4153 4d5f 434f 4d4d 454e  EIGEN_ASM_COMMEN
-0000c440: 5428 2262 6567 696e 2073 7465 7020 6f66  T("begin step of
-0000c450: 2067 6562 7020 6d69 6372 6f20 6b65 726e   gebp micro kern
-0000c460: 656c 2032 7058 3122 293b 2020 2020 2020  el 2pX1");      
-0000c470: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
-0000c480: 2020 2020 4549 4745 4e5f 4153 4d5f 434f      EIGEN_ASM_CO
-0000c490: 4d4d 454e 5428 224e 6f74 653a 2074 6865  MMENT("Note: the
-0000c4a0: 7365 2061 736d 2063 6f6d 6d65 6e74 7320  se asm comments 
-0000c4b0: 776f 726b 2061 726f 756e 6420 6275 6720  work around bug 
-0000c4c0: 3933 3521 2229 3b20 5c0a 2020 2020 2020  935!"); \.      
-0000c4d0: 2020 2020 2020 2020 7472 6169 7473 2e6c          traits.l
-0000c4e0: 6f61 644c 6873 2826 626c 415b 2830 2b32  oadLhs(&blA[(0+2
-0000c4f0: 2a4b 292a 4c68 7350 726f 6772 6573 735d  *K)*LhsProgress]
-0000c500: 2c20 4130 293b 2020 2020 2020 2020 2020  , A0);          
-0000c510: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
-0000c520: 2020 2020 2020 2020 2020 2020 7472 6169              trai
-0000c530: 7473 2e6c 6f61 644c 6873 2826 626c 415b  ts.loadLhs(&blA[
-0000c540: 2831 2b32 2a4b 292a 4c68 7350 726f 6772  (1+2*K)*LhsProgr
-0000c550: 6573 735d 2c20 4131 293b 2020 2020 2020  ess], A1);      
-0000c560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c570: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-0000c580: 7472 6169 7473 2e6c 6f61 6452 6873 2826  traits.loadRhs(&
-0000c590: 626c 425b 2830 2b4b 292a 5268 7350 726f  blB[(0+K)*RhsPro
-0000c5a0: 6772 6573 735d 2c20 425f 3029 3b20 2020  gress], B_0);   
-0000c5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c5c0: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
-0000c5d0: 2020 2020 7472 6169 7473 2e6d 6164 6428      traits.madd(
-0000c5e0: 4130 2c20 425f 302c 2043 302c 2042 3129  A0, B_0, C0, B1)
-0000c5f0: 3b20 2020 2020 2020 2020 2020 2020 2020  ;               
-0000c600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c610: 2020 2020 2020 2020 5c0a 2020 2020 2020          \.      
-0000c620: 2020 2020 2020 2020 7472 6169 7473 2e6d          traits.m
-0000c630: 6164 6428 4131 2c20 425f 302c 2043 342c  add(A1, B_0, C4,
-0000c640: 2042 5f30 293b 2020 2020 2020 2020 2020   B_0);          
-0000c650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c660: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
-0000c670: 2020 2020 2020 2020 2020 2020 4549 4745              EIGE
-0000c680: 4e5f 4153 4d5f 434f 4d4d 454e 5428 2265  N_ASM_COMMENT("e
-0000c690: 6e64 2073 7465 7020 6f66 2067 6562 7020  nd step of gebp 
-0000c6a0: 6d69 6372 6f20 6b65 726e 656c 2032 7058  micro kernel 2pX
-0000c6b0: 3122 293b 2020 2020 2020 2020 2020 2020  1");            
-0000c6c0: 5c0a 2020 2020 2020 2020 2020 2020 7d20  \.            } 
-0000c6d0: 7768 696c 6528 6661 6c73 6529 0a20 2020  while(false).   
-0000c6e0: 2020 2020 200a 2020 2020 2020 2020 2020       .          
-0000c6f0: 2020 4549 4745 4e5f 4745 4247 505f 4f4e    EIGEN_GEBGP_ON
-0000c700: 4553 5445 5028 3029 3b0a 2020 2020 2020  ESTEP(0);.      
-0000c710: 2020 2020 2020 4549 4745 4e5f 4745 4247        EIGEN_GEBG
-0000c720: 505f 4f4e 4553 5445 5028 3129 3b0a 2020  P_ONESTEP(1);.  
-0000c730: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
-0000c740: 4745 4247 505f 4f4e 4553 5445 5028 3229  GEBGP_ONESTEP(2)
-0000c750: 3b0a 2020 2020 2020 2020 2020 2020 4549  ;.            EI
-0000c760: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
-0000c770: 5028 3329 3b0a 2020 2020 2020 2020 2020  P(3);.          
-0000c780: 2020 4549 4745 4e5f 4745 4247 505f 4f4e    EIGEN_GEBGP_ON
-0000c790: 4553 5445 5028 3429 3b0a 2020 2020 2020  ESTEP(4);.      
-0000c7a0: 2020 2020 2020 4549 4745 4e5f 4745 4247        EIGEN_GEBG
-0000c7b0: 505f 4f4e 4553 5445 5028 3529 3b0a 2020  P_ONESTEP(5);.  
-0000c7c0: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
-0000c7d0: 4745 4247 505f 4f4e 4553 5445 5028 3629  GEBGP_ONESTEP(6)
-0000c7e0: 3b0a 2020 2020 2020 2020 2020 2020 4549  ;.            EI
-0000c7f0: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
-0000c800: 5028 3729 3b0a 0a20 2020 2020 2020 2020  P(7);..         
-0000c810: 2020 2062 6c42 202b 3d20 706b 2a52 6873     blB += pk*Rhs
-0000c820: 5072 6f67 7265 7373 3b0a 2020 2020 2020  Progress;.      
-0000c830: 2020 2020 2020 626c 4120 2b3d 2070 6b2a        blA += pk*
-0000c840: 322a 5472 6169 7473 3a3a 4c68 7350 726f  2*Traits::LhsPro
-0000c850: 6772 6573 733b 0a0a 2020 2020 2020 2020  gress;..        
-0000c860: 2020 2020 4549 4745 4e5f 4153 4d5f 434f      EIGEN_ASM_CO
-0000c870: 4d4d 454e 5428 2265 6e64 2067 6562 7020  MMENT("end gebp 
-0000c880: 6d69 6372 6f20 6b65 726e 656c 2032 7058  micro kernel 2pX
-0000c890: 3122 293b 0a20 2020 2020 2020 2020 207d  1");.          }
-0000c8a0: 0a0a 2020 2020 2020 2020 2020 2f2f 2070  ..          // p
-0000c8b0: 726f 6365 7373 2072 656d 6169 6e69 6e67  rocess remaining
-0000c8c0: 2070 6565 6c65 6420 6c6f 6f70 0a20 2020   peeled loop.   
-0000c8d0: 2020 2020 2020 2066 6f72 2849 6e64 6578         for(Index
-0000c8e0: 206b 3d70 6565 6c65 645f 6b63 3b20 6b3c   k=peeled_kc; k<
-0000c8f0: 6465 7074 683b 206b 2b2b 290a 2020 2020  depth; k++).    
-0000c900: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
-0000c910: 2020 2020 5268 7350 6163 6b65 7420 425f      RhsPacket B_
-0000c920: 302c 2042 313b 0a20 2020 2020 2020 2020  0, B1;.         
-0000c930: 2020 2045 4947 454e 5f47 4542 4750 5f4f     EIGEN_GEBGP_O
-0000c940: 4e45 5354 4550 2830 293b 0a20 2020 2020  NESTEP(0);.     
-0000c950: 2020 2020 2020 2062 6c42 202b 3d20 5268         blB += Rh
-0000c960: 7350 726f 6772 6573 733b 0a20 2020 2020  sProgress;.     
-0000c970: 2020 2020 2020 2062 6c41 202b 3d20 322a         blA += 2*
-0000c980: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
-0000c990: 6573 733b 0a20 2020 2020 2020 2020 207d  ess;.          }
-0000c9a0: 0a23 756e 6465 6620 4549 4745 4e5f 4745  .#undef EIGEN_GE
-0000c9b0: 4247 505f 4f4e 4553 5445 500a 2020 2020  BGP_ONESTEP.    
-0000c9c0: 2020 2020 2020 5265 7350 6163 6b65 7420        ResPacket 
-0000c9d0: 5230 2c20 5231 3b0a 2020 2020 2020 2020  R0, R1;.        
-0000c9e0: 2020 5265 7350 6163 6b65 7420 616c 7068    ResPacket alph
-0000c9f0: 6176 203d 2070 7365 7431 3c52 6573 5061  av = pset1<ResPa
-0000ca00: 636b 6574 3e28 616c 7068 6129 3b0a 0a20  cket>(alpha);.. 
-0000ca10: 2020 2020 2020 2020 2052 3020 3d20 7230           R0 = r0
-0000ca20: 2e6c 6f61 6450 6163 6b65 7428 3020 2a20  .loadPacket(0 * 
-0000ca30: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
-0000ca40: 7453 697a 6529 3b0a 2020 2020 2020 2020  tSize);.        
-0000ca50: 2020 5231 203d 2072 302e 6c6f 6164 5061    R1 = r0.loadPa
-0000ca60: 636b 6574 2831 202a 2054 7261 6974 733a  cket(1 * Traits:
-0000ca70: 3a52 6573 5061 636b 6574 5369 7a65 293b  :ResPacketSize);
-0000ca80: 0a20 2020 2020 2020 2020 2074 7261 6974  .          trait
-0000ca90: 732e 6163 6328 4330 2c20 616c 7068 6176  s.acc(C0, alphav
-0000caa0: 2c20 5230 293b 0a20 2020 2020 2020 2020  , R0);.         
-0000cab0: 2074 7261 6974 732e 6163 6328 4334 2c20   traits.acc(C4, 
-0000cac0: 616c 7068 6176 2c20 5231 293b 0a20 2020  alphav, R1);.   
-0000cad0: 2020 2020 2020 2072 302e 7374 6f72 6550         r0.storeP
-0000cae0: 6163 6b65 7428 3020 2a20 5472 6169 7473  acket(0 * Traits
-0000caf0: 3a3a 5265 7350 6163 6b65 7453 697a 652c  ::ResPacketSize,
-0000cb00: 2052 3029 3b0a 2020 2020 2020 2020 2020   R0);.          
-0000cb10: 7230 2e73 746f 7265 5061 636b 6574 2831  r0.storePacket(1
-0000cb20: 202a 2054 7261 6974 733a 3a52 6573 5061   * Traits::ResPa
-0000cb30: 636b 6574 5369 7a65 2c20 5231 293b 0a20  cketSize, R1);. 
-0000cb40: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
-0000cb50: 2020 207d 0a20 2020 2020 207d 0a20 2020     }.      }.   
-0000cb60: 207d 0a20 2020 202f 2f2d 2d2d 2d2d 2d2d   }.    //-------
-0000cb70: 2d2d 2d20 5072 6f63 6573 7320 3120 2a20  --- Process 1 * 
-0000cb80: 4c68 7350 726f 6772 6573 7320 726f 7773  LhsProgress rows
-0000cb90: 2061 7420 6f6e 6365 202d 2d2d 2d2d 2d2d   at once -------
-0000cba0: 2d2d 2d0a 2020 2020 6966 286d 723e 3d31  ---.    if(mr>=1
-0000cbb0: 2a54 7261 6974 733a 3a4c 6873 5072 6f67  *Traits::LhsProg
-0000cbc0: 7265 7373 290a 2020 2020 7b0a 2020 2020  ress).    {.    
-0000cbd0: 2020 2f2f 206c 6f6f 7073 206f 6e20 6561    // loops on ea
-0000cbe0: 6368 206c 6172 6765 7374 206d 6963 726f  ch largest micro
-0000cbf0: 2068 6f72 697a 6f6e 7461 6c20 7061 6e65   horizontal pane
-0000cc00: 6c20 6f66 206c 6873 2028 312a 4c68 7350  l of lhs (1*LhsP
-0000cc10: 726f 6772 6573 7320 7820 6465 7074 6829  rogress x depth)
-0000cc20: 0a20 2020 2020 2066 6f72 2849 6e64 6578  .      for(Index
-0000cc30: 2069 3d70 6565 6c65 645f 6d63 323b 2069   i=peeled_mc2; i
-0000cc40: 3c70 6565 6c65 645f 6d63 313b 2069 2b3d  <peeled_mc1; i+=
-0000cc50: 312a 4c68 7350 726f 6772 6573 7329 0a20  1*LhsProgress). 
-0000cc60: 2020 2020 207b 0a20 2020 2020 2020 202f       {.        /
-0000cc70: 2f20 6c6f 6f70 7320 6f6e 2065 6163 6820  / loops on each 
-0000cc80: 6c61 7267 6573 7420 6d69 6372 6f20 7665  largest micro ve
-0000cc90: 7274 6963 616c 2070 616e 656c 206f 6620  rtical panel of 
-0000cca0: 7268 7320 2864 6570 7468 202a 206e 7229  rhs (depth * nr)
-0000ccb0: 0a20 2020 2020 2020 2066 6f72 2849 6e64  .        for(Ind
-0000ccc0: 6578 206a 323d 303b 206a 323c 7061 636b  ex j2=0; j2<pack
-0000ccd0: 6574 5f63 6f6c 7334 3b20 6a32 2b3d 6e72  et_cols4; j2+=nr
-0000cce0: 290a 2020 2020 2020 2020 7b0a 2020 2020  ).        {.    
-0000ccf0: 2020 2020 2020 2f2f 2057 6520 7365 6c65        // We sele
-0000cd00: 6374 2061 2031 2a54 7261 6974 733a 3a4c  ct a 1*Traits::L
-0000cd10: 6873 5072 6f67 7265 7373 2078 206e 7220  hsProgress x nr 
-0000cd20: 6d69 6372 6f20 626c 6f63 6b20 6f66 2072  micro block of r
-0000cd30: 6573 2077 6869 6368 2069 7320 656e 7469  es which is enti
-0000cd40: 7265 6c79 0a20 2020 2020 2020 2020 202f  rely.          /
-0000cd50: 2f20 7374 6f72 6564 2069 6e74 6f20 3120  / stored into 1 
-0000cd60: 7820 6e72 2072 6567 6973 7465 7273 2e0a  x nr registers..
-0000cd70: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
-0000cd80: 2020 2020 2063 6f6e 7374 204c 6873 5363       const LhsSc
-0000cd90: 616c 6172 2a20 626c 4120 3d20 2662 6c6f  alar* blA = &blo
-0000cda0: 636b 415b 692a 7374 7269 6465 412b 6f66  ckA[i*strideA+of
-0000cdb0: 6673 6574 412a 2831 2a54 7261 6974 733a  fsetA*(1*Traits:
-0000cdc0: 3a4c 6873 5072 6f67 7265 7373 295d 3b0a  :LhsProgress)];.
-0000cdd0: 2020 2020 2020 2020 2020 7072 6566 6574            prefet
-0000cde0: 6368 2826 626c 415b 305d 293b 0a0a 2020  ch(&blA[0]);..  
-0000cdf0: 2020 2020 2020 2020 2f2f 2067 6574 7320          // gets 
-0000ce00: 7265 7320 626c 6f63 6b20 6173 2072 6567  res block as reg
-0000ce10: 6973 7465 720a 2020 2020 2020 2020 2020  ister.          
-0000ce20: 4163 6350 6163 6b65 7420 4330 2c20 4331  AccPacket C0, C1
-0000ce30: 2c20 4332 2c20 4333 3b0a 2020 2020 2020  , C2, C3;.      
-0000ce40: 2020 2020 7472 6169 7473 2e69 6e69 7441      traits.initA
-0000ce50: 6363 2843 3029 3b0a 2020 2020 2020 2020  cc(C0);.        
-0000ce60: 2020 7472 6169 7473 2e69 6e69 7441 6363    traits.initAcc
-0000ce70: 2843 3129 3b0a 2020 2020 2020 2020 2020  (C1);.          
-0000ce80: 7472 6169 7473 2e69 6e69 7441 6363 2843  traits.initAcc(C
-0000ce90: 3229 3b0a 2020 2020 2020 2020 2020 7472  2);.          tr
-0000cea0: 6169 7473 2e69 6e69 7441 6363 2843 3329  aits.initAcc(C3)
-0000ceb0: 3b0a 0a20 2020 2020 2020 2020 204c 696e  ;..          Lin
-0000cec0: 6561 724d 6170 7065 7220 7230 203d 2072  earMapper r0 = r
-0000ced0: 6573 2e67 6574 4c69 6e65 6172 4d61 7070  es.getLinearMapp
-0000cee0: 6572 2869 2c20 6a32 202b 2030 293b 0a20  er(i, j2 + 0);. 
-0000cef0: 2020 2020 2020 2020 204c 696e 6561 724d           LinearM
-0000cf00: 6170 7065 7220 7231 203d 2072 6573 2e67  apper r1 = res.g
-0000cf10: 6574 4c69 6e65 6172 4d61 7070 6572 2869  etLinearMapper(i
-0000cf20: 2c20 6a32 202b 2031 293b 0a20 2020 2020  , j2 + 1);.     
-0000cf30: 2020 2020 204c 696e 6561 724d 6170 7065       LinearMappe
-0000cf40: 7220 7232 203d 2072 6573 2e67 6574 4c69  r r2 = res.getLi
-0000cf50: 6e65 6172 4d61 7070 6572 2869 2c20 6a32  nearMapper(i, j2
-0000cf60: 202b 2032 293b 0a20 2020 2020 2020 2020   + 2);.         
-0000cf70: 204c 696e 6561 724d 6170 7065 7220 7233   LinearMapper r3
-0000cf80: 203d 2072 6573 2e67 6574 4c69 6e65 6172   = res.getLinear
-0000cf90: 4d61 7070 6572 2869 2c20 6a32 202b 2033  Mapper(i, j2 + 3
-0000cfa0: 293b 0a0a 2020 2020 2020 2020 2020 7230  );..          r0
-0000cfb0: 2e70 7265 6665 7463 6828 7072 6566 6574  .prefetch(prefet
-0000cfc0: 6368 5f72 6573 5f6f 6666 7365 7429 3b0a  ch_res_offset);.
-0000cfd0: 2020 2020 2020 2020 2020 7231 2e70 7265            r1.pre
-0000cfe0: 6665 7463 6828 7072 6566 6574 6368 5f72  fetch(prefetch_r
-0000cff0: 6573 5f6f 6666 7365 7429 3b0a 2020 2020  es_offset);.    
-0000d000: 2020 2020 2020 7232 2e70 7265 6665 7463        r2.prefetc
-0000d010: 6828 7072 6566 6574 6368 5f72 6573 5f6f  h(prefetch_res_o
-0000d020: 6666 7365 7429 3b0a 2020 2020 2020 2020  ffset);.        
-0000d030: 2020 7233 2e70 7265 6665 7463 6828 7072    r3.prefetch(pr
-0000d040: 6566 6574 6368 5f72 6573 5f6f 6666 7365  efetch_res_offse
-0000d050: 7429 3b0a 0a20 2020 2020 2020 2020 202f  t);..          /
-0000d060: 2f20 7065 7266 6f72 6d73 2022 696e 6e65  / performs "inne
-0000d070: 7222 2070 726f 6475 6374 730a 2020 2020  r" products.    
-0000d080: 2020 2020 2020 636f 6e73 7420 5268 7353        const RhsS
-0000d090: 6361 6c61 722a 2062 6c42 203d 2026 626c  calar* blB = &bl
-0000d0a0: 6f63 6b42 5b6a 322a 7374 7269 6465 422b  ockB[j2*strideB+
-0000d0b0: 6f66 6673 6574 422a 6e72 5d3b 0a20 2020  offsetB*nr];.   
-0000d0c0: 2020 2020 2020 2070 7265 6665 7463 6828         prefetch(
-0000d0d0: 2662 6c42 5b30 5d29 3b0a 2020 2020 2020  &blB[0]);.      
-0000d0e0: 2020 2020 4c68 7350 6163 6b65 7420 4130      LhsPacket A0
-0000d0f0: 3b0a 0a20 2020 2020 2020 2020 2066 6f72  ;..          for
-0000d100: 2849 6e64 6578 206b 3d30 3b20 6b3c 7065  (Index k=0; k<pe
-0000d110: 656c 6564 5f6b 633b 206b 2b3d 706b 290a  eled_kc; k+=pk).
-0000d120: 2020 2020 2020 2020 2020 7b0a 2020 2020            {.    
-0000d130: 2020 2020 2020 2020 4549 4745 4e5f 4153          EIGEN_AS
-0000d140: 4d5f 434f 4d4d 454e 5428 2262 6567 696e  M_COMMENT("begin
-0000d150: 2067 6562 7020 6d69 6372 6f20 6b65 726e   gebp micro kern
-0000d160: 656c 2031 7058 3422 293b 0a20 2020 2020  el 1pX4");.     
-0000d170: 2020 2020 2020 2052 6873 5061 636b 6574         RhsPacket
-0000d180: 2042 5f30 2c20 4231 2c20 4232 2c20 4233   B_0, B1, B2, B3
-0000d190: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-0000d1a0: 200a 2364 6566 696e 6520 4549 4745 4e5f   .#define EIGEN_
-0000d1b0: 4745 4247 505f 4f4e 4553 5445 5028 4b29  GEBGP_ONESTEP(K)
-0000d1c0: 205c 0a20 2020 2020 2020 2020 2020 2064   \.            d
-0000d1d0: 6f20 7b20 2020 2020 2020 2020 2020 2020  o {             
-0000d1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d210: 2020 205c 0a20 2020 2020 2020 2020 2020     \.           
-0000d220: 2020 2045 4947 454e 5f41 534d 5f43 4f4d     EIGEN_ASM_COM
-0000d230: 4d45 4e54 2822 6265 6769 6e20 7374 6570  MENT("begin step
-0000d240: 206f 6620 6765 6270 206d 6963 726f 206b   of gebp micro k
-0000d250: 6572 6e65 6c20 3170 5834 2229 3b20 2020  ernel 1pX4");   
-0000d260: 2020 2020 205c 0a20 2020 2020 2020 2020       \.         
-0000d270: 2020 2020 2045 4947 454e 5f41 534d 5f43       EIGEN_ASM_C
-0000d280: 4f4d 4d45 4e54 2822 4e6f 7465 3a20 7468  OMMENT("Note: th
-0000d290: 6573 6520 6173 6d20 636f 6d6d 656e 7473  ese asm comments
-0000d2a0: 2077 6f72 6b20 6172 6f75 6e64 2062 7567   work around bug
-0000d2b0: 2039 3335 2122 293b 205c 0a20 2020 2020   935!"); \.     
-0000d2c0: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
-0000d2d0: 6c6f 6164 4c68 7328 2662 6c41 5b28 302b  loadLhs(&blA[(0+
-0000d2e0: 312a 4b29 2a4c 6873 5072 6f67 7265 7373  1*K)*LhsProgress
-0000d2f0: 5d2c 2041 3029 3b20 2020 2020 2020 2020  ], A0);         
-0000d300: 2020 2020 2020 2020 2020 205c 0a20 2020             \.   
-0000d310: 2020 2020 2020 2020 2020 2074 7261 6974             trait
-0000d320: 732e 6272 6f61 6463 6173 7452 6873 2826  s.broadcastRhs(&
-0000d330: 626c 425b 2830 2b34 2a4b 292a 5268 7350  blB[(0+4*K)*RhsP
-0000d340: 726f 6772 6573 735d 2c20 425f 302c 2042  rogress], B_0, B
-0000d350: 312c 2042 322c 2042 3329 3b20 205c 0a20  1, B2, B3);  \. 
-0000d360: 2020 2020 2020 2020 2020 2020 2074 7261               tra
-0000d370: 6974 732e 6d61 6464 2841 302c 2042 5f30  its.madd(A0, B_0
-0000d380: 2c20 4330 2c20 425f 3029 3b20 2020 2020  , C0, B_0);     
-0000d390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d3a0: 2020 2020 2020 2020 2020 2020 2020 205c                 \
-0000d3b0: 0a20 2020 2020 2020 2020 2020 2020 2074  .              t
-0000d3c0: 7261 6974 732e 6d61 6464 2841 302c 2042  raits.madd(A0, B
-0000d3d0: 312c 2020 4331 2c20 4231 293b 2020 2020  1,  C1, B1);    
-0000d3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d400: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
-0000d410: 2074 7261 6974 732e 6d61 6464 2841 302c   traits.madd(A0,
-0000d420: 2042 322c 2020 4332 2c20 4232 293b 2020   B2,  C2, B2);  
-0000d430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d450: 2020 205c 0a20 2020 2020 2020 2020 2020     \.           
-0000d460: 2020 2074 7261 6974 732e 6d61 6464 2841     traits.madd(A
-0000d470: 302c 2042 332c 2020 4333 2c20 4233 293b  0, B3,  C3, B3);
-0000d480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d4a0: 2020 2020 205c 0a20 2020 2020 2020 2020       \.         
-0000d4b0: 2020 2020 2045 4947 454e 5f41 534d 5f43       EIGEN_ASM_C
-0000d4c0: 4f4d 4d45 4e54 2822 656e 6420 7374 6570  OMMENT("end step
-0000d4d0: 206f 6620 6765 6270 206d 6963 726f 206b   of gebp micro k
-0000d4e0: 6572 6e65 6c20 3170 5834 2229 3b20 2020  ernel 1pX4");   
-0000d4f0: 2020 2020 2020 205c 0a20 2020 2020 2020         \.       
-0000d500: 2020 2020 207d 2077 6869 6c65 2866 616c       } while(fal
-0000d510: 7365 290a 2020 2020 2020 2020 2020 2020  se).            
-0000d520: 0a20 2020 2020 2020 2020 2020 2069 6e74  .            int
-0000d530: 6572 6e61 6c3a 3a70 7265 6665 7463 6828  ernal::prefetch(
-0000d540: 626c 422b 2834 382b 3029 293b 0a20 2020  blB+(48+0));.   
-0000d550: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
-0000d560: 4542 4750 5f4f 4e45 5354 4550 2830 293b  EBGP_ONESTEP(0);
-0000d570: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-0000d580: 454e 5f47 4542 4750 5f4f 4e45 5354 4550  EN_GEBGP_ONESTEP
-0000d590: 2831 293b 0a20 2020 2020 2020 2020 2020  (1);.           
-0000d5a0: 2045 4947 454e 5f47 4542 4750 5f4f 4e45   EIGEN_GEBGP_ONE
-0000d5b0: 5354 4550 2832 293b 0a20 2020 2020 2020  STEP(2);.       
-0000d5c0: 2020 2020 2045 4947 454e 5f47 4542 4750       EIGEN_GEBGP
-0000d5d0: 5f4f 4e45 5354 4550 2833 293b 0a20 2020  _ONESTEP(3);.   
-0000d5e0: 2020 2020 2020 2020 2069 6e74 6572 6e61           interna
-0000d5f0: 6c3a 3a70 7265 6665 7463 6828 626c 422b  l::prefetch(blB+
-0000d600: 2834 382b 3136 2929 3b0a 2020 2020 2020  (48+16));.      
-0000d610: 2020 2020 2020 4549 4745 4e5f 4745 4247        EIGEN_GEBG
-0000d620: 505f 4f4e 4553 5445 5028 3429 3b0a 2020  P_ONESTEP(4);.  
-0000d630: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
-0000d640: 4745 4247 505f 4f4e 4553 5445 5028 3529  GEBGP_ONESTEP(5)
-0000d650: 3b0a 2020 2020 2020 2020 2020 2020 4549  ;.            EI
-0000d660: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
-0000d670: 5028 3629 3b0a 2020 2020 2020 2020 2020  P(6);.          
-0000d680: 2020 4549 4745 4e5f 4745 4247 505f 4f4e    EIGEN_GEBGP_ON
-0000d690: 4553 5445 5028 3729 3b0a 0a20 2020 2020  ESTEP(7);..     
-0000d6a0: 2020 2020 2020 2062 6c42 202b 3d20 706b         blB += pk
-0000d6b0: 2a34 2a52 6873 5072 6f67 7265 7373 3b0a  *4*RhsProgress;.
-0000d6c0: 2020 2020 2020 2020 2020 2020 626c 4120              blA 
-0000d6d0: 2b3d 2070 6b2a 312a 4c68 7350 726f 6772  += pk*1*LhsProgr
-0000d6e0: 6573 733b 0a0a 2020 2020 2020 2020 2020  ess;..          
-0000d6f0: 2020 4549 4745 4e5f 4153 4d5f 434f 4d4d    EIGEN_ASM_COMM
-0000d700: 454e 5428 2265 6e64 2067 6562 7020 6d69  ENT("end gebp mi
-0000d710: 6372 6f20 6b65 726e 656c 2031 7058 3422  cro kernel 1pX4"
-0000d720: 293b 0a20 2020 2020 2020 2020 207d 0a20  );.          }. 
-0000d730: 2020 2020 2020 2020 202f 2f20 7072 6f63           // proc
-0000d740: 6573 7320 7265 6d61 696e 696e 6720 7065  ess remaining pe
-0000d750: 656c 6564 206c 6f6f 700a 2020 2020 2020  eled loop.      
-0000d760: 2020 2020 666f 7228 496e 6465 7820 6b3d      for(Index k=
-0000d770: 7065 656c 6564 5f6b 633b 206b 3c64 6570  peeled_kc; k<dep
-0000d780: 7468 3b20 6b2b 2b29 0a20 2020 2020 2020  th; k++).       
-0000d790: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
-0000d7a0: 2052 6873 5061 636b 6574 2042 5f30 2c20   RhsPacket B_0, 
-0000d7b0: 4231 2c20 4232 2c20 4233 3b0a 2020 2020  B1, B2, B3;.    
-0000d7c0: 2020 2020 2020 2020 4549 4745 4e5f 4745          EIGEN_GE
-0000d7d0: 4247 505f 4f4e 4553 5445 5028 3029 3b0a  BGP_ONESTEP(0);.
-0000d7e0: 2020 2020 2020 2020 2020 2020 626c 4220              blB 
-0000d7f0: 2b3d 2034 2a52 6873 5072 6f67 7265 7373  += 4*RhsProgress
-0000d800: 3b0a 2020 2020 2020 2020 2020 2020 626c  ;.            bl
-0000d810: 4120 2b3d 2031 2a4c 6873 5072 6f67 7265  A += 1*LhsProgre
-0000d820: 7373 3b0a 2020 2020 2020 2020 2020 7d0a  ss;.          }.
-0000d830: 2375 6e64 6566 2045 4947 454e 5f47 4542  #undef EIGEN_GEB
-0000d840: 4750 5f4f 4e45 5354 4550 0a0a 2020 2020  GP_ONESTEP..    
-0000d850: 2020 2020 2020 5265 7350 6163 6b65 7420        ResPacket 
-0000d860: 5230 2c20 5231 3b0a 2020 2020 2020 2020  R0, R1;.        
-0000d870: 2020 5265 7350 6163 6b65 7420 616c 7068    ResPacket alph
-0000d880: 6176 203d 2070 7365 7431 3c52 6573 5061  av = pset1<ResPa
-0000d890: 636b 6574 3e28 616c 7068 6129 3b0a 0a20  cket>(alpha);.. 
-0000d8a0: 2020 2020 2020 2020 2052 3020 3d20 7230           R0 = r0
-0000d8b0: 2e6c 6f61 6450 6163 6b65 7428 3020 2a20  .loadPacket(0 * 
-0000d8c0: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
-0000d8d0: 7453 697a 6529 3b0a 2020 2020 2020 2020  tSize);.        
-0000d8e0: 2020 5231 203d 2072 312e 6c6f 6164 5061    R1 = r1.loadPa
-0000d8f0: 636b 6574 2830 202a 2054 7261 6974 733a  cket(0 * Traits:
-0000d900: 3a52 6573 5061 636b 6574 5369 7a65 293b  :ResPacketSize);
-0000d910: 0a20 2020 2020 2020 2020 2074 7261 6974  .          trait
-0000d920: 732e 6163 6328 4330 2c20 616c 7068 6176  s.acc(C0, alphav
-0000d930: 2c20 5230 293b 0a20 2020 2020 2020 2020  , R0);.         
-0000d940: 2074 7261 6974 732e 6163 6328 4331 2c20   traits.acc(C1, 
-0000d950: 2061 6c70 6861 762c 2052 3129 3b0a 2020   alphav, R1);.  
-0000d960: 2020 2020 2020 2020 7230 2e73 746f 7265          r0.store
-0000d970: 5061 636b 6574 2830 202a 2054 7261 6974  Packet(0 * Trait
-0000d980: 733a 3a52 6573 5061 636b 6574 5369 7a65  s::ResPacketSize
-0000d990: 2c20 5230 293b 0a20 2020 2020 2020 2020  , R0);.         
-0000d9a0: 2072 312e 7374 6f72 6550 6163 6b65 7428   r1.storePacket(
-0000d9b0: 3020 2a20 5472 6169 7473 3a3a 5265 7350  0 * Traits::ResP
-0000d9c0: 6163 6b65 7453 697a 652c 2052 3129 3b0a  acketSize, R1);.
-0000d9d0: 0a20 2020 2020 2020 2020 2052 3020 3d20  .          R0 = 
-0000d9e0: 7232 2e6c 6f61 6450 6163 6b65 7428 3020  r2.loadPacket(0 
-0000d9f0: 2a20 5472 6169 7473 3a3a 5265 7350 6163  * Traits::ResPac
-0000da00: 6b65 7453 697a 6529 3b0a 2020 2020 2020  ketSize);.      
-0000da10: 2020 2020 5231 203d 2072 332e 6c6f 6164      R1 = r3.load
-0000da20: 5061 636b 6574 2830 202a 2054 7261 6974  Packet(0 * Trait
-0000da30: 733a 3a52 6573 5061 636b 6574 5369 7a65  s::ResPacketSize
-0000da40: 293b 0a20 2020 2020 2020 2020 2074 7261  );.          tra
-0000da50: 6974 732e 6163 6328 4332 2c20 2061 6c70  its.acc(C2,  alp
-0000da60: 6861 762c 2052 3029 3b0a 2020 2020 2020  hav, R0);.      
-0000da70: 2020 2020 7472 6169 7473 2e61 6363 2843      traits.acc(C
-0000da80: 332c 2020 616c 7068 6176 2c20 5231 293b  3,  alphav, R1);
-0000da90: 0a20 2020 2020 2020 2020 2072 322e 7374  .          r2.st
-0000daa0: 6f72 6550 6163 6b65 7428 3020 2a20 5472  orePacket(0 * Tr
-0000dab0: 6169 7473 3a3a 5265 7350 6163 6b65 7453  aits::ResPacketS
-0000dac0: 697a 652c 2052 3029 3b0a 2020 2020 2020  ize, R0);.      
-0000dad0: 2020 2020 7233 2e73 746f 7265 5061 636b      r3.storePack
-0000dae0: 6574 2830 202a 2054 7261 6974 733a 3a52  et(0 * Traits::R
-0000daf0: 6573 5061 636b 6574 5369 7a65 2c20 5231  esPacketSize, R1
-0000db00: 293b 0a20 2020 2020 2020 207d 0a0a 2020  );.        }..  
-0000db10: 2020 2020 2020 2f2f 2044 6561 6c20 7769        // Deal wi
-0000db20: 7468 2072 656d 6169 6e69 6e67 2063 6f6c  th remaining col
-0000db30: 756d 6e73 206f 6620 7468 6520 7268 730a  umns of the rhs.
-0000db40: 2020 2020 2020 2020 666f 7228 496e 6465          for(Inde
-0000db50: 7820 6a32 3d70 6163 6b65 745f 636f 6c73  x j2=packet_cols
-0000db60: 343b 206a 323c 636f 6c73 3b20 6a32 2b2b  4; j2<cols; j2++
-0000db70: 290a 2020 2020 2020 2020 7b0a 2020 2020  ).        {.    
-0000db80: 2020 2020 2020 2f2f 204f 6e65 2063 6f6c        // One col
-0000db90: 756d 6e20 6174 2061 2074 696d 650a 2020  umn at a time.  
-0000dba0: 2020 2020 2020 2020 636f 6e73 7420 4c68          const Lh
-0000dbb0: 7353 6361 6c61 722a 2062 6c41 203d 2026  sScalar* blA = &
-0000dbc0: 626c 6f63 6b41 5b69 2a73 7472 6964 6541  blockA[i*strideA
-0000dbd0: 2b6f 6666 7365 7441 2a28 312a 5472 6169  +offsetA*(1*Trai
-0000dbe0: 7473 3a3a 4c68 7350 726f 6772 6573 7329  ts::LhsProgress)
-0000dbf0: 5d3b 0a20 2020 2020 2020 2020 2070 7265  ];.          pre
-0000dc00: 6665 7463 6828 2662 6c41 5b30 5d29 3b0a  fetch(&blA[0]);.
-0000dc10: 0a20 2020 2020 2020 2020 202f 2f20 6765  .          // ge
-0000dc20: 7473 2072 6573 2062 6c6f 636b 2061 7320  ts res block as 
-0000dc30: 7265 6769 7374 6572 0a20 2020 2020 2020  register.       
-0000dc40: 2020 2041 6363 5061 636b 6574 2043 303b     AccPacket C0;
-0000dc50: 0a20 2020 2020 2020 2020 2074 7261 6974  .          trait
-0000dc60: 732e 696e 6974 4163 6328 4330 293b 0a0a  s.initAcc(C0);..
-0000dc70: 2020 2020 2020 2020 2020 4c69 6e65 6172            Linear
-0000dc80: 4d61 7070 6572 2072 3020 3d20 7265 732e  Mapper r0 = res.
-0000dc90: 6765 744c 696e 6561 724d 6170 7065 7228  getLinearMapper(
-0000dca0: 692c 206a 3229 3b0a 0a20 2020 2020 2020  i, j2);..       
-0000dcb0: 2020 202f 2f20 7065 7266 6f72 6d73 2022     // performs "
-0000dcc0: 696e 6e65 7222 2070 726f 6475 6374 730a  inner" products.
-0000dcd0: 2020 2020 2020 2020 2020 636f 6e73 7420            const 
-0000dce0: 5268 7353 6361 6c61 722a 2062 6c42 203d  RhsScalar* blB =
-0000dcf0: 2026 626c 6f63 6b42 5b6a 322a 7374 7269   &blockB[j2*stri
-0000dd00: 6465 422b 6f66 6673 6574 425d 3b0a 2020  deB+offsetB];.  
-0000dd10: 2020 2020 2020 2020 4c68 7350 6163 6b65          LhsPacke
-0000dd20: 7420 4130 3b0a 0a20 2020 2020 2020 2020  t A0;..         
-0000dd30: 2066 6f72 2849 6e64 6578 206b 3d30 3b20   for(Index k=0; 
-0000dd40: 6b3c 7065 656c 6564 5f6b 633b 206b 2b3d  k<peeled_kc; k+=
-0000dd50: 706b 290a 2020 2020 2020 2020 2020 7b0a  pk).          {.
-0000dd60: 2020 2020 2020 2020 2020 2020 4549 4745              EIGE
-0000dd70: 4e5f 4153 4d5f 434f 4d4d 454e 5428 2262  N_ASM_COMMENT("b
-0000dd80: 6567 696e 2067 6562 7020 6d69 6372 6f20  egin gebp micro 
-0000dd90: 6b65 726e 656c 2031 7058 3122 293b 0a20  kernel 1pX1");. 
-0000dda0: 2020 2020 2020 2020 2020 2052 6873 5061             RhsPa
-0000ddb0: 636b 6574 2042 5f30 3b0a 2020 2020 2020  cket B_0;.      
-0000ddc0: 2020 0a23 6465 6669 6e65 2045 4947 454e    .#define EIGEN
-0000ddd0: 5f47 4542 4750 5f4f 4e45 5354 4550 284b  _GEBGP_ONESTEP(K
-0000dde0: 2920 5c0a 2020 2020 2020 2020 2020 2020  ) \.            
-0000ddf0: 646f 207b 2020 2020 2020 2020 2020 2020  do {            
-0000de00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de30: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
-0000de40: 2020 2020 4549 4745 4e5f 4153 4d5f 434f      EIGEN_ASM_CO
-0000de50: 4d4d 454e 5428 2262 6567 696e 2073 7465  MMENT("begin ste
-0000de60: 7020 6f66 2067 6562 7020 6d69 6372 6f20  p of gebp micro 
-0000de70: 6b65 726e 656c 2031 7058 3122 293b 2020  kernel 1pX1");  
-0000de80: 2020 2020 2020 5c0a 2020 2020 2020 2020        \.        
-0000de90: 2020 2020 2020 4549 4745 4e5f 4153 4d5f        EIGEN_ASM_
-0000dea0: 434f 4d4d 454e 5428 224e 6f74 653a 2074  COMMENT("Note: t
-0000deb0: 6865 7365 2061 736d 2063 6f6d 6d65 6e74  hese asm comment
-0000dec0: 7320 776f 726b 2061 726f 756e 6420 6275  s work around bu
-0000ded0: 6720 3933 3521 2229 3b20 5c0a 2020 2020  g 935!"); \.    
-0000dee0: 2020 2020 2020 2020 2020 7472 6169 7473            traits
-0000def0: 2e6c 6f61 644c 6873 2826 626c 415b 2830  .loadLhs(&blA[(0
-0000df00: 2b31 2a4b 292a 4c68 7350 726f 6772 6573  +1*K)*LhsProgres
-0000df10: 735d 2c20 4130 293b 2020 2020 2020 2020  s], A0);        
-0000df20: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
-0000df30: 2020 2020 2020 2020 2020 2020 7472 6169              trai
-0000df40: 7473 2e6c 6f61 6452 6873 2826 626c 425b  ts.loadRhs(&blB[
-0000df50: 2830 2b4b 292a 5268 7350 726f 6772 6573  (0+K)*RhsProgres
-0000df60: 735d 2c20 425f 3029 3b20 2020 2020 2020  s], B_0);       
-0000df70: 2020 2020 2020 2020 2020 2020 2020 5c0a                \.
-0000df80: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-0000df90: 6169 7473 2e6d 6164 6428 4130 2c20 425f  aits.madd(A0, B_
-0000dfa0: 302c 2043 302c 2042 5f30 293b 2020 2020  0, C0, B_0);    
-0000dfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dfc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dfd0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
-0000dfe0: 4549 4745 4e5f 4153 4d5f 434f 4d4d 454e  EIGEN_ASM_COMMEN
-0000dff0: 5428 2265 6e64 2073 7465 7020 6f66 2067  T("end step of g
-0000e000: 6562 7020 6d69 6372 6f20 6b65 726e 656c  ebp micro kernel
-0000e010: 2031 7058 3122 293b 2020 2020 2020 2020   1pX1");        
-0000e020: 2020 5c0a 2020 2020 2020 2020 2020 2020    \.            
-0000e030: 7d20 7768 696c 6528 6661 6c73 6529 3b0a  } while(false);.
-0000e040: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-0000e050: 454e 5f47 4542 4750 5f4f 4e45 5354 4550  EN_GEBGP_ONESTEP
-0000e060: 2830 293b 0a20 2020 2020 2020 2020 2020  (0);.           
-0000e070: 2045 4947 454e 5f47 4542 4750 5f4f 4e45   EIGEN_GEBGP_ONE
-0000e080: 5354 4550 2831 293b 0a20 2020 2020 2020  STEP(1);.       
-0000e090: 2020 2020 2045 4947 454e 5f47 4542 4750       EIGEN_GEBGP
-0000e0a0: 5f4f 4e45 5354 4550 2832 293b 0a20 2020  _ONESTEP(2);.   
-0000e0b0: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
-0000e0c0: 4542 4750 5f4f 4e45 5354 4550 2833 293b  EBGP_ONESTEP(3);
-0000e0d0: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
-0000e0e0: 454e 5f47 4542 4750 5f4f 4e45 5354 4550  EN_GEBGP_ONESTEP
-0000e0f0: 2834 293b 0a20 2020 2020 2020 2020 2020  (4);.           
-0000e100: 2045 4947 454e 5f47 4542 4750 5f4f 4e45   EIGEN_GEBGP_ONE
-0000e110: 5354 4550 2835 293b 0a20 2020 2020 2020  STEP(5);.       
-0000e120: 2020 2020 2045 4947 454e 5f47 4542 4750       EIGEN_GEBGP
-0000e130: 5f4f 4e45 5354 4550 2836 293b 0a20 2020  _ONESTEP(6);.   
-0000e140: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
-0000e150: 4542 4750 5f4f 4e45 5354 4550 2837 293b  EBGP_ONESTEP(7);
-0000e160: 0a0a 2020 2020 2020 2020 2020 2020 626c  ..            bl
-0000e170: 4220 2b3d 2070 6b2a 5268 7350 726f 6772  B += pk*RhsProgr
-0000e180: 6573 733b 0a20 2020 2020 2020 2020 2020  ess;.           
-0000e190: 2062 6c41 202b 3d20 706b 2a31 2a54 7261   blA += pk*1*Tra
-0000e1a0: 6974 733a 3a4c 6873 5072 6f67 7265 7373  its::LhsProgress
-0000e1b0: 3b0a 0a20 2020 2020 2020 2020 2020 2045  ;..            E
-0000e1c0: 4947 454e 5f41 534d 5f43 4f4d 4d45 4e54  IGEN_ASM_COMMENT
-0000e1d0: 2822 656e 6420 6765 6270 206d 6963 726f  ("end gebp micro
-0000e1e0: 206b 6572 6e65 6c20 3170 5831 2229 3b0a   kernel 1pX1");.
-0000e1f0: 2020 2020 2020 2020 2020 7d0a 0a20 2020            }..   
-0000e200: 2020 2020 2020 202f 2f20 7072 6f63 6573         // proces
-0000e210: 7320 7265 6d61 696e 696e 6720 7065 656c  s remaining peel
-0000e220: 6564 206c 6f6f 700a 2020 2020 2020 2020  ed loop.        
-0000e230: 2020 666f 7228 496e 6465 7820 6b3d 7065    for(Index k=pe
-0000e240: 656c 6564 5f6b 633b 206b 3c64 6570 7468  eled_kc; k<depth
-0000e250: 3b20 6b2b 2b29 0a20 2020 2020 2020 2020  ; k++).         
-0000e260: 207b 0a20 2020 2020 2020 2020 2020 2052   {.            R
-0000e270: 6873 5061 636b 6574 2042 5f30 3b0a 2020  hsPacket B_0;.  
-0000e280: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
-0000e290: 4745 4247 505f 4f4e 4553 5445 5028 3029  GEBGP_ONESTEP(0)
-0000e2a0: 3b0a 2020 2020 2020 2020 2020 2020 626c  ;.            bl
-0000e2b0: 4220 2b3d 2052 6873 5072 6f67 7265 7373  B += RhsProgress
-0000e2c0: 3b0a 2020 2020 2020 2020 2020 2020 626c  ;.            bl
-0000e2d0: 4120 2b3d 2031 2a54 7261 6974 733a 3a4c  A += 1*Traits::L
-0000e2e0: 6873 5072 6f67 7265 7373 3b0a 2020 2020  hsProgress;.    
-0000e2f0: 2020 2020 2020 7d0a 2375 6e64 6566 2045        }.#undef E
-0000e300: 4947 454e 5f47 4542 4750 5f4f 4e45 5354  IGEN_GEBGP_ONEST
-0000e310: 4550 0a20 2020 2020 2020 2020 2052 6573  EP.          Res
-0000e320: 5061 636b 6574 2052 303b 0a20 2020 2020  Packet R0;.     
-0000e330: 2020 2020 2052 6573 5061 636b 6574 2061       ResPacket a
-0000e340: 6c70 6861 7620 3d20 7073 6574 313c 5265  lphav = pset1<Re
-0000e350: 7350 6163 6b65 743e 2861 6c70 6861 293b  sPacket>(alpha);
-0000e360: 0a20 2020 2020 2020 2020 2052 3020 3d20  .          R0 = 
-0000e370: 7230 2e6c 6f61 6450 6163 6b65 7428 3020  r0.loadPacket(0 
-0000e380: 2a20 5472 6169 7473 3a3a 5265 7350 6163  * Traits::ResPac
-0000e390: 6b65 7453 697a 6529 3b0a 2020 2020 2020  ketSize);.      
-0000e3a0: 2020 2020 7472 6169 7473 2e61 6363 2843      traits.acc(C
-0000e3b0: 302c 2061 6c70 6861 762c 2052 3029 3b0a  0, alphav, R0);.
-0000e3c0: 2020 2020 2020 2020 2020 7230 2e73 746f            r0.sto
-0000e3d0: 7265 5061 636b 6574 2830 202a 2054 7261  rePacket(0 * Tra
-0000e3e0: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
-0000e3f0: 7a65 2c20 5230 293b 0a20 2020 2020 2020  ze, R0);.       
-0000e400: 207d 0a20 2020 2020 207d 0a20 2020 207d   }.      }.    }
-0000e410: 0a20 2020 202f 2f2d 2d2d 2d2d 2d2d 2d2d  .    //---------
-0000e420: 2d20 5072 6f63 6573 7320 7265 6d61 696e  - Process remain
-0000e430: 696e 6720 726f 7773 2c20 3120 6174 206f  ing rows, 1 at o
-0000e440: 6e63 6520 2d2d 2d2d 2d2d 2d2d 2d2d 0a20  nce ----------. 
-0000e450: 2020 2069 6628 7065 656c 6564 5f6d 6331     if(peeled_mc1
-0000e460: 3c72 6f77 7329 0a20 2020 207b 0a20 2020  <rows).    {.   
-0000e470: 2020 202f 2f20 6c6f 6f70 206f 6e20 6561     // loop on ea
-0000e480: 6368 2070 616e 656c 206f 6620 7468 6520  ch panel of the 
-0000e490: 7268 730a 2020 2020 2020 666f 7228 496e  rhs.      for(In
-0000e4a0: 6465 7820 6a32 3d30 3b20 6a32 3c70 6163  dex j2=0; j2<pac
-0000e4b0: 6b65 745f 636f 6c73 343b 206a 322b 3d6e  ket_cols4; j2+=n
-0000e4c0: 7229 0a20 2020 2020 207b 0a20 2020 2020  r).      {.     
-0000e4d0: 2020 202f 2f20 6c6f 6f70 206f 6e20 6561     // loop on ea
-0000e4e0: 6368 2072 6f77 206f 6620 7468 6520 6c68  ch row of the lh
-0000e4f0: 7320 2831 2a4c 6873 5072 6f67 7265 7373  s (1*LhsProgress
-0000e500: 2078 2064 6570 7468 290a 2020 2020 2020   x depth).      
-0000e510: 2020 666f 7228 496e 6465 7820 693d 7065    for(Index i=pe
-0000e520: 656c 6564 5f6d 6331 3b20 693c 726f 7773  eled_mc1; i<rows
-0000e530: 3b20 692b 3d31 290a 2020 2020 2020 2020  ; i+=1).        
-0000e540: 7b0a 2020 2020 2020 2020 2020 636f 6e73  {.          cons
-0000e550: 7420 4c68 7353 6361 6c61 722a 2062 6c41  t LhsScalar* blA
-0000e560: 203d 2026 626c 6f63 6b41 5b69 2a73 7472   = &blockA[i*str
-0000e570: 6964 6541 2b6f 6666 7365 7441 5d3b 0a20  ideA+offsetA];. 
-0000e580: 2020 2020 2020 2020 2070 7265 6665 7463           prefetc
-0000e590: 6828 2662 6c41 5b30 5d29 3b0a 2020 2020  h(&blA[0]);.    
-0000e5a0: 2020 2020 2020 636f 6e73 7420 5268 7353        const RhsS
-0000e5b0: 6361 6c61 722a 2062 6c42 203d 2026 626c  calar* blB = &bl
-0000e5c0: 6f63 6b42 5b6a 322a 7374 7269 6465 422b  ockB[j2*strideB+
-0000e5d0: 6f66 6673 6574 422a 6e72 5d3b 0a0a 2020  offsetB*nr];..  
-0000e5e0: 2020 2020 2020 2020 2f2f 2054 6865 2066          // The f
-0000e5f0: 6f6c 6c6f 7769 6e67 2070 6965 6365 206f  ollowing piece o
-0000e600: 6620 636f 6465 2077 6f6e 7420 776f 726b  f code wont work
-0000e610: 2066 6f72 2035 3132 2062 6974 2072 6567   for 512 bit reg
-0000e620: 6973 7465 7273 0a20 2020 2020 2020 2020  isters.         
-0000e630: 202f 2f20 4d6f 7265 6f76 6572 2c20 6966   // Moreover, if
-0000e640: 204c 6873 5072 6f67 7265 7373 3d3d 3820   LhsProgress==8 
-0000e650: 6974 2061 7373 756d 6573 2074 6861 7420  it assumes that 
-0000e660: 7468 6572 6520 6973 2061 2068 616c 6620  there is a half 
-0000e670: 7061 636b 6574 206f 6620 7468 6520 7361  packet of the sa
-0000e680: 6d65 2073 697a 650a 2020 2020 2020 2020  me size.        
-0000e690: 2020 2f2f 2061 7320 6e72 2028 7768 6963    // as nr (whic
-0000e6a0: 6820 6973 2063 7572 7265 6e74 6c79 2034  h is currently 4
-0000e6b0: 2920 666f 7220 7468 6520 7265 7475 726e  ) for the return
-0000e6c0: 2074 7970 652e 0a20 2020 2020 2020 2020   type..         
-0000e6d0: 2063 6f6e 7374 2069 6e74 2053 5265 7350   const int SResP
-0000e6e0: 6163 6b65 7448 616c 6653 697a 6520 3d20  acketHalfSize = 
-0000e6f0: 756e 7061 636b 6574 5f74 7261 6974 733c  unpacket_traits<
-0000e700: 7479 7065 6e61 6d65 2075 6e70 6163 6b65  typename unpacke
-0000e710: 745f 7472 6169 7473 3c53 5265 7350 6163  t_traits<SResPac
-0000e720: 6b65 743e 3a3a 6861 6c66 3e3a 3a73 697a  ket>::half>::siz
-0000e730: 653b 0a20 2020 2020 2020 2020 2069 6620  e;.          if 
-0000e740: 2828 5377 6170 7065 6454 7261 6974 733a  ((SwappedTraits:
-0000e750: 3a4c 6873 5072 6f67 7265 7373 2025 2034  :LhsProgress % 4
-0000e760: 2920 3d3d 2030 2026 260a 2020 2020 2020  ) == 0 &&.      
-0000e770: 2020 2020 2020 2020 2853 7761 7070 6564          (Swapped
-0000e780: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
-0000e790: 6573 7320 3c3d 2038 2920 2626 0a20 2020  ess <= 8) &&.   
-0000e7a0: 2020 2020 2020 2020 2020 2028 5377 6170             (Swap
-0000e7b0: 7065 6454 7261 6974 733a 3a4c 6873 5072  pedTraits::LhsPr
-0000e7c0: 6f67 7265 7373 213d 3820 7c7c 2053 5265  ogress!=8 || SRe
-0000e7d0: 7350 6163 6b65 7448 616c 6653 697a 653d  sPacketHalfSize=
-0000e7e0: 3d6e 7229 290a 2020 2020 2020 2020 2020  =nr)).          
-0000e7f0: 7b0a 2020 2020 2020 2020 2020 2020 5341  {.            SA
-0000e800: 6363 5061 636b 6574 2043 302c 2043 312c  ccPacket C0, C1,
-0000e810: 2043 322c 2043 333b 0a20 2020 2020 2020   C2, C3;.       
-0000e820: 2020 2020 2073 7472 6169 7473 2e69 6e69       straits.ini
-0000e830: 7441 6363 2843 3029 3b0a 2020 2020 2020  tAcc(C0);.      
-0000e840: 2020 2020 2020 7374 7261 6974 732e 696e        straits.in
-0000e850: 6974 4163 6328 4331 293b 0a20 2020 2020  itAcc(C1);.     
-0000e860: 2020 2020 2020 2073 7472 6169 7473 2e69         straits.i
-0000e870: 6e69 7441 6363 2843 3229 3b0a 2020 2020  nitAcc(C2);.    
-0000e880: 2020 2020 2020 2020 7374 7261 6974 732e          straits.
-0000e890: 696e 6974 4163 6328 4333 293b 0a0a 2020  initAcc(C3);..  
-0000e8a0: 2020 2020 2020 2020 2020 636f 6e73 7420            const 
-0000e8b0: 496e 6465 7820 7370 6b20 2020 3d20 2873  Index spk   = (s
-0000e8c0: 7464 3a3a 6d61 7829 2831 2c53 7761 7070  td::max)(1,Swapp
-0000e8d0: 6564 5472 6169 7473 3a3a 4c68 7350 726f  edTraits::LhsPro
-0000e8e0: 6772 6573 732f 3429 3b0a 2020 2020 2020  gress/4);.      
-0000e8f0: 2020 2020 2020 636f 6e73 7420 496e 6465        const Inde
-0000e900: 7820 656e 646b 2020 3d20 2864 6570 7468  x endk  = (depth
-0000e910: 2f73 706b 292a 7370 6b3b 0a20 2020 2020  /spk)*spk;.     
-0000e920: 2020 2020 2020 2063 6f6e 7374 2049 6e64         const Ind
-0000e930: 6578 2065 6e64 6b34 203d 2028 6465 7074  ex endk4 = (dept
-0000e940: 682f 2873 706b 2a34 2929 2a28 7370 6b2a  h/(spk*4))*(spk*
-0000e950: 3429 3b0a 0a20 2020 2020 2020 2020 2020  4);..           
-0000e960: 2049 6e64 6578 206b 3d30 3b0a 2020 2020   Index k=0;.    
-0000e970: 2020 2020 2020 2020 666f 7228 3b20 6b3c          for(; k<
-0000e980: 656e 646b 343b 206b 2b3d 342a 7370 6b29  endk4; k+=4*spk)
-0000e990: 0a20 2020 2020 2020 2020 2020 207b 0a20  .            {. 
-0000e9a0: 2020 2020 2020 2020 2020 2020 2053 4c68               SLh
-0000e9b0: 7350 6163 6b65 7420 4130 2c41 313b 0a20  sPacket A0,A1;. 
-0000e9c0: 2020 2020 2020 2020 2020 2020 2053 5268               SRh
-0000e9d0: 7350 6163 6b65 7420 425f 302c 425f 313b  sPacket B_0,B_1;
-0000e9e0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0000e9f0: 7374 7261 6974 732e 6c6f 6164 4c68 7355  straits.loadLhsU
-0000ea00: 6e61 6c69 676e 6564 2862 6c42 2b30 2a53  naligned(blB+0*S
-0000ea10: 7761 7070 6564 5472 6169 7473 3a3a 4c68  wappedTraits::Lh
-0000ea20: 7350 726f 6772 6573 732c 2041 3029 3b0a  sProgress, A0);.
-0000ea30: 2020 2020 2020 2020 2020 2020 2020 7374                st
-0000ea40: 7261 6974 732e 6c6f 6164 4c68 7355 6e61  raits.loadLhsUna
-0000ea50: 6c69 676e 6564 2862 6c42 2b31 2a53 7761  ligned(blB+1*Swa
-0000ea60: 7070 6564 5472 6169 7473 3a3a 4c68 7350  ppedTraits::LhsP
-0000ea70: 726f 6772 6573 732c 2041 3129 3b0a 0a20  rogress, A1);.. 
-0000ea80: 2020 2020 2020 2020 2020 2020 2073 7472               str
-0000ea90: 6169 7473 2e6c 6f61 6452 6873 5175 6164  aits.loadRhsQuad
-0000eaa0: 2862 6c41 2b30 2a73 706b 2c20 425f 3029  (blA+0*spk, B_0)
-0000eab0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-0000eac0: 7374 7261 6974 732e 6c6f 6164 5268 7351  straits.loadRhsQ
-0000ead0: 7561 6428 626c 412b 312a 7370 6b2c 2042  uad(blA+1*spk, B
-0000eae0: 5f31 293b 0a20 2020 2020 2020 2020 2020  _1);.           
-0000eaf0: 2020 2073 7472 6169 7473 2e6d 6164 6428     straits.madd(
-0000eb00: 4130 2c42 5f30 2c43 302c 425f 3029 3b0a  A0,B_0,C0,B_0);.
-0000eb10: 2020 2020 2020 2020 2020 2020 2020 7374                st
-0000eb20: 7261 6974 732e 6d61 6464 2841 312c 425f  raits.madd(A1,B_
-0000eb30: 312c 4331 2c42 5f31 293b 0a0a 2020 2020  1,C1,B_1);..    
-0000eb40: 2020 2020 2020 2020 2020 7374 7261 6974            strait
-0000eb50: 732e 6c6f 6164 4c68 7355 6e61 6c69 676e  s.loadLhsUnalign
-0000eb60: 6564 2862 6c42 2b32 2a53 7761 7070 6564  ed(blB+2*Swapped
-0000eb70: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
-0000eb80: 6573 732c 2041 3029 3b0a 2020 2020 2020  ess, A0);.      
-0000eb90: 2020 2020 2020 2020 7374 7261 6974 732e          straits.
-0000eba0: 6c6f 6164 4c68 7355 6e61 6c69 676e 6564  loadLhsUnaligned
-0000ebb0: 2862 6c42 2b33 2a53 7761 7070 6564 5472  (blB+3*SwappedTr
-0000ebc0: 6169 7473 3a3a 4c68 7350 726f 6772 6573  aits::LhsProgres
-0000ebd0: 732c 2041 3129 3b0a 2020 2020 2020 2020  s, A1);.        
-0000ebe0: 2020 2020 2020 7374 7261 6974 732e 6c6f        straits.lo
-0000ebf0: 6164 5268 7351 7561 6428 626c 412b 322a  adRhsQuad(blA+2*
-0000ec00: 7370 6b2c 2042 5f30 293b 0a20 2020 2020  spk, B_0);.     
-0000ec10: 2020 2020 2020 2020 2073 7472 6169 7473           straits
-0000ec20: 2e6c 6f61 6452 6873 5175 6164 2862 6c41  .loadRhsQuad(blA
-0000ec30: 2b33 2a73 706b 2c20 425f 3129 3b0a 2020  +3*spk, B_1);.  
-0000ec40: 2020 2020 2020 2020 2020 2020 7374 7261              stra
-0000ec50: 6974 732e 6d61 6464 2841 302c 425f 302c  its.madd(A0,B_0,
-0000ec60: 4332 2c42 5f30 293b 0a20 2020 2020 2020  C2,B_0);.       
-0000ec70: 2020 2020 2020 2073 7472 6169 7473 2e6d         straits.m
-0000ec80: 6164 6428 4131 2c42 5f31 2c43 332c 425f  add(A1,B_1,C3,B_
-0000ec90: 3129 3b0a 0a20 2020 2020 2020 2020 2020  1);..           
-0000eca0: 2020 2062 6c42 202b 3d20 342a 5377 6170     blB += 4*Swap
-0000ecb0: 7065 6454 7261 6974 733a 3a4c 6873 5072  pedTraits::LhsPr
-0000ecc0: 6f67 7265 7373 3b0a 2020 2020 2020 2020  ogress;.        
-0000ecd0: 2020 2020 2020 626c 4120 2b3d 2034 2a73        blA += 4*s
-0000ece0: 706b 3b0a 2020 2020 2020 2020 2020 2020  pk;.            
-0000ecf0: 7d0a 2020 2020 2020 2020 2020 2020 4330  }.            C0
-0000ed00: 203d 2070 6164 6428 7061 6464 2843 302c   = padd(padd(C0,
-0000ed10: 4331 292c 7061 6464 2843 322c 4333 2929  C1),padd(C2,C3))
-0000ed20: 3b0a 2020 2020 2020 2020 2020 2020 666f  ;.            fo
-0000ed30: 7228 3b20 6b3c 656e 646b 3b20 6b2b 3d73  r(; k<endk; k+=s
-0000ed40: 706b 290a 2020 2020 2020 2020 2020 2020  pk).            
-0000ed50: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-0000ed60: 534c 6873 5061 636b 6574 2041 303b 0a20  SLhsPacket A0;. 
-0000ed70: 2020 2020 2020 2020 2020 2020 2053 5268               SRh
-0000ed80: 7350 6163 6b65 7420 425f 303b 0a0a 2020  sPacket B_0;..  
-0000ed90: 2020 2020 2020 2020 2020 2020 7374 7261              stra
-0000eda0: 6974 732e 6c6f 6164 4c68 7355 6e61 6c69  its.loadLhsUnali
-0000edb0: 676e 6564 2862 6c42 2c20 4130 293b 0a20  gned(blB, A0);. 
-0000edc0: 2020 2020 2020 2020 2020 2020 2073 7472               str
-0000edd0: 6169 7473 2e6c 6f61 6452 6873 5175 6164  aits.loadRhsQuad
-0000ede0: 2862 6c41 2c20 425f 3029 3b0a 2020 2020  (blA, B_0);.    
-0000edf0: 2020 2020 2020 2020 2020 7374 7261 6974            strait
-0000ee00: 732e 6d61 6464 2841 302c 425f 302c 4330  s.madd(A0,B_0,C0
-0000ee10: 2c42 5f30 293b 0a0a 2020 2020 2020 2020  ,B_0);..        
-0000ee20: 2020 2020 2020 626c 4220 2b3d 2053 7761        blB += Swa
-0000ee30: 7070 6564 5472 6169 7473 3a3a 4c68 7350  ppedTraits::LhsP
-0000ee40: 726f 6772 6573 733b 0a20 2020 2020 2020  rogress;.       
-0000ee50: 2020 2020 2020 2062 6c41 202b 3d20 7370         blA += sp
-0000ee60: 6b3b 0a20 2020 2020 2020 2020 2020 207d  k;.            }
-0000ee70: 0a20 2020 2020 2020 2020 2020 2069 6628  .            if(
-0000ee80: 5377 6170 7065 6454 7261 6974 733a 3a4c  SwappedTraits::L
-0000ee90: 6873 5072 6f67 7265 7373 3d3d 3829 0a20  hsProgress==8). 
-0000eea0: 2020 2020 2020 2020 2020 207b 0a20 2020             {.   
-0000eeb0: 2020 2020 2020 2020 2020 202f 2f20 5370             // Sp
-0000eec0: 6563 6961 6c20 6361 7365 2077 6865 7265  ecial case where
-0000eed0: 2077 6520 6861 7665 2074 6f20 6669 7273   we have to firs
-0000eee0: 7420 7265 6475 6365 2074 6865 2061 6363  t reduce the acc
-0000eef0: 756d 756c 6174 696f 6e20 7265 6769 7374  umulation regist
-0000ef00: 6572 2043 300a 2020 2020 2020 2020 2020  er C0.          
-0000ef10: 2020 2020 7479 7065 6465 6620 7479 7065      typedef type
-0000ef20: 6e61 6d65 2063 6f6e 6469 7469 6f6e 616c  name conditional
-0000ef30: 3c53 7761 7070 6564 5472 6169 7473 3a3a  <SwappedTraits::
-0000ef40: 4c68 7350 726f 6772 6573 733e 3d38 2c74  LhsProgress>=8,t
-0000ef50: 7970 656e 616d 6520 756e 7061 636b 6574  ypename unpacket
-0000ef60: 5f74 7261 6974 733c 5352 6573 5061 636b  _traits<SResPack
-0000ef70: 6574 3e3a 3a68 616c 662c 5352 6573 5061  et>::half,SResPa
-0000ef80: 636b 6574 3e3a 3a74 7970 6520 5352 6573  cket>::type SRes
-0000ef90: 5061 636b 6574 4861 6c66 3b0a 2020 2020  PacketHalf;.    
-0000efa0: 2020 2020 2020 2020 2020 7479 7065 6465            typede
-0000efb0: 6620 7479 7065 6e61 6d65 2063 6f6e 6469  f typename condi
-0000efc0: 7469 6f6e 616c 3c53 7761 7070 6564 5472  tional<SwappedTr
-0000efd0: 6169 7473 3a3a 4c68 7350 726f 6772 6573  aits::LhsProgres
-0000efe0: 733e 3d38 2c74 7970 656e 616d 6520 756e  s>=8,typename un
-0000eff0: 7061 636b 6574 5f74 7261 6974 733c 534c  packet_traits<SL
-0000f000: 6873 5061 636b 6574 3e3a 3a68 616c 662c  hsPacket>::half,
-0000f010: 534c 6873 5061 636b 6574 3e3a 3a74 7970  SLhsPacket>::typ
-0000f020: 6520 534c 6873 5061 636b 6574 4861 6c66  e SLhsPacketHalf
-0000f030: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-0000f040: 7479 7065 6465 6620 7479 7065 6e61 6d65  typedef typename
-0000f050: 2063 6f6e 6469 7469 6f6e 616c 3c53 7761   conditional<Swa
-0000f060: 7070 6564 5472 6169 7473 3a3a 4c68 7350  ppedTraits::LhsP
-0000f070: 726f 6772 6573 733e 3d38 2c74 7970 656e  rogress>=8,typen
-0000f080: 616d 6520 756e 7061 636b 6574 5f74 7261  ame unpacket_tra
-0000f090: 6974 733c 534c 6873 5061 636b 6574 3e3a  its<SLhsPacket>:
-0000f0a0: 3a68 616c 662c 5352 6873 5061 636b 6574  :half,SRhsPacket
-0000f0b0: 3e3a 3a74 7970 6520 5352 6873 5061 636b  >::type SRhsPack
-0000f0c0: 6574 4861 6c66 3b0a 2020 2020 2020 2020  etHalf;.        
-0000f0d0: 2020 2020 2020 7479 7065 6465 6620 7479        typedef ty
-0000f0e0: 7065 6e61 6d65 2063 6f6e 6469 7469 6f6e  pename condition
-0000f0f0: 616c 3c53 7761 7070 6564 5472 6169 7473  al<SwappedTraits
-0000f100: 3a3a 4c68 7350 726f 6772 6573 733e 3d38  ::LhsProgress>=8
-0000f110: 2c74 7970 656e 616d 6520 756e 7061 636b  ,typename unpack
-0000f120: 6574 5f74 7261 6974 733c 5341 6363 5061  et_traits<SAccPa
-0000f130: 636b 6574 3e3a 3a68 616c 662c 5341 6363  cket>::half,SAcc
-0000f140: 5061 636b 6574 3e3a 3a74 7970 6520 5341  Packet>::type SA
-0000f150: 6363 5061 636b 6574 4861 6c66 3b0a 0a20  ccPacketHalf;.. 
-0000f160: 2020 2020 2020 2020 2020 2020 2053 5265               SRe
-0000f170: 7350 6163 6b65 7448 616c 6620 5220 3d20  sPacketHalf R = 
-0000f180: 7265 732e 7465 6d70 6c61 7465 2067 6174  res.template gat
-0000f190: 6865 7250 6163 6b65 743c 5352 6573 5061  herPacket<SResPa
-0000f1a0: 636b 6574 4861 6c66 3e28 692c 206a 3229  cketHalf>(i, j2)
-0000f1b0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-0000f1c0: 5352 6573 5061 636b 6574 4861 6c66 2061  SResPacketHalf a
-0000f1d0: 6c70 6861 7620 3d20 7073 6574 313c 5352  lphav = pset1<SR
-0000f1e0: 6573 5061 636b 6574 4861 6c66 3e28 616c  esPacketHalf>(al
-0000f1f0: 7068 6129 3b0a 0a20 2020 2020 2020 2020  pha);..         
-0000f200: 2020 2020 2069 6628 6465 7074 682d 656e       if(depth-en
-0000f210: 646b 3e30 290a 2020 2020 2020 2020 2020  dk>0).          
-0000f220: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
-0000f230: 2020 2020 2020 2f2f 2057 6520 6861 7665        // We have
-0000f240: 2074 6f20 6861 6e64 6c65 2074 6865 206c   to handle the l
-0000f250: 6173 7420 726f 7720 6f66 2074 6865 2072  ast row of the r
-0000f260: 6873 2077 6869 6368 2063 6f72 7265 7370  hs which corresp
-0000f270: 6f6e 6473 2074 6f20 6120 6861 6c66 2d70  onds to a half-p
-0000f280: 6163 6b65 740a 2020 2020 2020 2020 2020  acket.          
-0000f290: 2020 2020 2020 534c 6873 5061 636b 6574        SLhsPacket
-0000f2a0: 4861 6c66 2061 303b 0a20 2020 2020 2020  Half a0;.       
-0000f2b0: 2020 2020 2020 2020 2053 5268 7350 6163           SRhsPac
-0000f2c0: 6b65 7448 616c 6620 6230 3b0a 2020 2020  ketHalf b0;.    
-0000f2d0: 2020 2020 2020 2020 2020 2020 7374 7261              stra
-0000f2e0: 6974 732e 6c6f 6164 4c68 7355 6e61 6c69  its.loadLhsUnali
-0000f2f0: 676e 6564 2862 6c42 2c20 6130 293b 0a20  gned(blB, a0);. 
-0000f300: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000f310: 7472 6169 7473 2e6c 6f61 6452 6873 2862  traits.loadRhs(b
-0000f320: 6c41 2c20 6230 293b 0a20 2020 2020 2020  lA, b0);.       
-0000f330: 2020 2020 2020 2020 2053 4163 6350 6163           SAccPac
-0000f340: 6b65 7448 616c 6620 6330 203d 2070 7265  ketHalf c0 = pre
-0000f350: 6475 785f 646f 776e 746f 3428 4330 293b  dux_downto4(C0);
-0000f360: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f370: 2073 7472 6169 7473 2e6d 6164 6428 6130   straits.madd(a0
-0000f380: 2c62 302c 6330 2c62 3029 3b0a 2020 2020  ,b0,c0,b0);.    
-0000f390: 2020 2020 2020 2020 2020 2020 7374 7261              stra
-0000f3a0: 6974 732e 6163 6328 6330 2c20 616c 7068  its.acc(c0, alph
-0000f3b0: 6176 2c20 5229 3b0a 2020 2020 2020 2020  av, R);.        
-0000f3c0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
-0000f3d0: 2020 2020 2020 656c 7365 0a20 2020 2020        else.     
-0000f3e0: 2020 2020 2020 2020 207b 0a20 2020 2020           {.     
-0000f3f0: 2020 2020 2020 2020 2020 2073 7472 6169             strai
-0000f400: 7473 2e61 6363 2870 7265 6475 785f 646f  ts.acc(predux_do
-0000f410: 776e 746f 3428 4330 292c 2061 6c70 6861  wnto4(C0), alpha
-0000f420: 762c 2052 293b 0a20 2020 2020 2020 2020  v, R);.         
-0000f430: 2020 2020 207d 0a20 2020 2020 2020 2020       }.         
-0000f440: 2020 2020 2072 6573 2e73 6361 7474 6572       res.scatter
-0000f450: 5061 636b 6574 2869 2c20 6a32 2c20 5229  Packet(i, j2, R)
-0000f460: 3b0a 2020 2020 2020 2020 2020 2020 7d0a  ;.            }.
-0000f470: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0000f480: 0a20 2020 2020 2020 2020 2020 207b 0a20  .            {. 
-0000f490: 2020 2020 2020 2020 2020 2020 2053 5265               SRe
-0000f4a0: 7350 6163 6b65 7420 5220 3d20 7265 732e  sPacket R = res.
-0000f4b0: 7465 6d70 6c61 7465 2067 6174 6865 7250  template gatherP
-0000f4c0: 6163 6b65 743c 5352 6573 5061 636b 6574  acket<SResPacket
-0000f4d0: 3e28 692c 206a 3229 3b0a 2020 2020 2020  >(i, j2);.      
-0000f4e0: 2020 2020 2020 2020 5352 6573 5061 636b          SResPack
-0000f4f0: 6574 2061 6c70 6861 7620 3d20 7073 6574  et alphav = pset
-0000f500: 313c 5352 6573 5061 636b 6574 3e28 616c  1<SResPacket>(al
-0000f510: 7068 6129 3b0a 2020 2020 2020 2020 2020  pha);.          
-0000f520: 2020 2020 7374 7261 6974 732e 6163 6328      straits.acc(
-0000f530: 4330 2c20 616c 7068 6176 2c20 5229 3b0a  C0, alphav, R);.
-0000f540: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0000f550: 732e 7363 6174 7465 7250 6163 6b65 7428  s.scatterPacket(
-0000f560: 692c 206a 322c 2052 293b 0a20 2020 2020  i, j2, R);.     
-0000f570: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
-0000f580: 2020 207d 0a20 2020 2020 2020 2020 2065     }.          e
-0000f590: 6c73 6520 2f2f 2073 6361 6c61 7220 7061  lse // scalar pa
-0000f5a0: 7468 0a20 2020 2020 2020 2020 207b 0a20  th.          {. 
-0000f5b0: 2020 2020 2020 2020 2020 202f 2f20 6765             // ge
-0000f5c0: 7420 6120 3120 7820 3420 7265 7320 626c  t a 1 x 4 res bl
-0000f5d0: 6f63 6b20 6173 2072 6567 6973 7465 7273  ock as registers
-0000f5e0: 0a20 2020 2020 2020 2020 2020 2052 6573  .            Res
-0000f5f0: 5363 616c 6172 2043 3028 3029 2c20 4331  Scalar C0(0), C1
-0000f600: 2830 292c 2043 3228 3029 2c20 4333 2830  (0), C2(0), C3(0
-0000f610: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
-0000f620: 666f 7228 496e 6465 7820 6b3d 303b 206b  for(Index k=0; k
-0000f630: 3c64 6570 7468 3b20 6b2b 2b29 0a20 2020  <depth; k++).   
-0000f640: 2020 2020 2020 2020 207b 0a20 2020 2020           {.     
-0000f650: 2020 2020 2020 2020 204c 6873 5363 616c           LhsScal
-0000f660: 6172 2041 303b 0a20 2020 2020 2020 2020  ar A0;.         
-0000f670: 2020 2020 2052 6873 5363 616c 6172 2042       RhsScalar B
-0000f680: 5f30 2c20 425f 313b 0a0a 2020 2020 2020  _0, B_1;..      
-0000f690: 2020 2020 2020 2020 4130 203d 2062 6c41          A0 = blA
-0000f6a0: 5b6b 5d3b 0a0a 2020 2020 2020 2020 2020  [k];..          
-0000f6b0: 2020 2020 425f 3020 3d20 626c 425b 305d      B_0 = blB[0]
-0000f6c0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-0000f6d0: 425f 3120 3d20 626c 425b 315d 3b0a 2020  B_1 = blB[1];.  
-0000f6e0: 2020 2020 2020 2020 2020 2020 434a 4d41              CJMA
-0000f6f0: 4444 2863 6a2c 4130 2c42 5f30 2c43 302c  DD(cj,A0,B_0,C0,
-0000f700: 2020 425f 3029 3b0a 2020 2020 2020 2020    B_0);.        
-0000f710: 2020 2020 2020 434a 4d41 4444 2863 6a2c        CJMADD(cj,
-0000f720: 4130 2c42 5f31 2c43 312c 2020 425f 3129  A0,B_1,C1,  B_1)
-0000f730: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
-0000f740: 0a20 2020 2020 2020 2020 2020 2020 2042  .              B
-0000f750: 5f30 203d 2062 6c42 5b32 5d3b 0a20 2020  _0 = blB[2];.   
-0000f760: 2020 2020 2020 2020 2020 2042 5f31 203d             B_1 =
-0000f770: 2062 6c42 5b33 5d3b 0a20 2020 2020 2020   blB[3];.       
-0000f780: 2020 2020 2020 2043 4a4d 4144 4428 636a         CJMADD(cj
-0000f790: 2c41 302c 425f 302c 4332 2c20 2042 5f30  ,A0,B_0,C2,  B_0
-0000f7a0: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
-0000f7b0: 2043 4a4d 4144 4428 636a 2c41 302c 425f   CJMADD(cj,A0,B_
-0000f7c0: 312c 4333 2c20 2042 5f31 293b 0a20 2020  1,C3,  B_1);.   
-0000f7d0: 2020 2020 2020 2020 2020 200a 2020 2020             .    
-0000f7e0: 2020 2020 2020 2020 2020 626c 4220 2b3d            blB +=
-0000f7f0: 2034 3b0a 2020 2020 2020 2020 2020 2020   4;.            
-0000f800: 7d0a 2020 2020 2020 2020 2020 2020 7265  }.            re
-0000f810: 7328 692c 206a 3220 2b20 3029 202b 3d20  s(i, j2 + 0) += 
-0000f820: 616c 7068 6120 2a20 4330 3b0a 2020 2020  alpha * C0;.    
-0000f830: 2020 2020 2020 2020 7265 7328 692c 206a          res(i, j
-0000f840: 3220 2b20 3129 202b 3d20 616c 7068 6120  2 + 1) += alpha 
-0000f850: 2a20 4331 3b0a 2020 2020 2020 2020 2020  * C1;.          
-0000f860: 2020 7265 7328 692c 206a 3220 2b20 3229    res(i, j2 + 2)
-0000f870: 202b 3d20 616c 7068 6120 2a20 4332 3b0a   += alpha * C2;.
-0000f880: 2020 2020 2020 2020 2020 2020 7265 7328              res(
-0000f890: 692c 206a 3220 2b20 3329 202b 3d20 616c  i, j2 + 3) += al
-0000f8a0: 7068 6120 2a20 4333 3b0a 2020 2020 2020  pha * C3;.      
-0000f8b0: 2020 2020 7d0a 2020 2020 2020 2020 7d0a      }.        }.
-0000f8c0: 2020 2020 2020 7d0a 2020 2020 2020 2f2f        }.      //
-0000f8d0: 2072 656d 6169 6e69 6e67 2063 6f6c 756d   remaining colum
-0000f8e0: 6e73 0a20 2020 2020 2066 6f72 2849 6e64  ns.      for(Ind
-0000f8f0: 6578 206a 323d 7061 636b 6574 5f63 6f6c  ex j2=packet_col
-0000f900: 7334 3b20 6a32 3c63 6f6c 733b 206a 322b  s4; j2<cols; j2+
-0000f910: 2b29 0a20 2020 2020 207b 0a20 2020 2020  +).      {.     
-0000f920: 2020 202f 2f20 6c6f 6f70 206f 6e20 6561     // loop on ea
-0000f930: 6368 2072 6f77 206f 6620 7468 6520 6c68  ch row of the lh
-0000f940: 7320 2831 2a4c 6873 5072 6f67 7265 7373  s (1*LhsProgress
-0000f950: 2078 2064 6570 7468 290a 2020 2020 2020   x depth).      
-0000f960: 2020 666f 7228 496e 6465 7820 693d 7065    for(Index i=pe
-0000f970: 656c 6564 5f6d 6331 3b20 693c 726f 7773  eled_mc1; i<rows
-0000f980: 3b20 692b 3d31 290a 2020 2020 2020 2020  ; i+=1).        
-0000f990: 7b0a 2020 2020 2020 2020 2020 636f 6e73  {.          cons
-0000f9a0: 7420 4c68 7353 6361 6c61 722a 2062 6c41  t LhsScalar* blA
-0000f9b0: 203d 2026 626c 6f63 6b41 5b69 2a73 7472   = &blockA[i*str
-0000f9c0: 6964 6541 2b6f 6666 7365 7441 5d3b 0a20  ideA+offsetA];. 
-0000f9d0: 2020 2020 2020 2020 2070 7265 6665 7463           prefetc
-0000f9e0: 6828 2662 6c41 5b30 5d29 3b0a 2020 2020  h(&blA[0]);.    
-0000f9f0: 2020 2020 2020 2f2f 2067 6574 7320 6120        // gets a 
-0000fa00: 3120 7820 3120 7265 7320 626c 6f63 6b20  1 x 1 res block 
-0000fa10: 6173 2072 6567 6973 7465 7273 0a20 2020  as registers.   
-0000fa20: 2020 2020 2020 2052 6573 5363 616c 6172         ResScalar
-0000fa30: 2043 3028 3029 3b0a 2020 2020 2020 2020   C0(0);.        
-0000fa40: 2020 636f 6e73 7420 5268 7353 6361 6c61    const RhsScala
-0000fa50: 722a 2062 6c42 203d 2026 626c 6f63 6b42  r* blB = &blockB
-0000fa60: 5b6a 322a 7374 7269 6465 422b 6f66 6673  [j2*strideB+offs
-0000fa70: 6574 425d 3b0a 2020 2020 2020 2020 2020  etB];.          
-0000fa80: 666f 7228 496e 6465 7820 6b3d 303b 206b  for(Index k=0; k
-0000fa90: 3c64 6570 7468 3b20 6b2b 2b29 0a20 2020  <depth; k++).   
-0000faa0: 2020 2020 2020 207b 0a20 2020 2020 2020         {.       
-0000fab0: 2020 2020 204c 6873 5363 616c 6172 2041       LhsScalar A
-0000fac0: 3020 3d20 626c 415b 6b5d 3b0a 2020 2020  0 = blA[k];.    
-0000fad0: 2020 2020 2020 2020 5268 7353 6361 6c61          RhsScala
-0000fae0: 7220 425f 3020 3d20 626c 425b 6b5d 3b0a  r B_0 = blB[k];.
-0000faf0: 2020 2020 2020 2020 2020 2020 434a 4d41              CJMA
-0000fb00: 4444 2863 6a2c 2041 302c 2042 5f30 2c20  DD(cj, A0, B_0, 
-0000fb10: 4330 2c20 425f 3029 3b0a 2020 2020 2020  C0, B_0);.      
-0000fb20: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-0000fb30: 7265 7328 692c 206a 3229 202b 3d20 616c  res(i, j2) += al
-0000fb40: 7068 6120 2a20 4330 3b0a 2020 2020 2020  pha * C0;.      
-0000fb50: 2020 7d0a 2020 2020 2020 7d0a 2020 2020    }.      }.    
-0000fb60: 7d0a 2020 7d0a 0a0a 2375 6e64 6566 2043  }.  }...#undef C
-0000fb70: 4a4d 4144 440a 0a2f 2f20 7061 636b 2061  JMADD..// pack a
-0000fb80: 2062 6c6f 636b 206f 6620 7468 6520 6c68   block of the lh
-0000fb90: 730a 2f2f 2054 6865 2074 7261 7665 7273  s.// The travers
-0000fba0: 616c 2069 7320 6173 2066 6f6c 6c6f 7720  al is as follow 
-0000fbb0: 286d 723d 3d34 293a 0a2f 2f20 2020 3020  (mr==4):.//   0 
-0000fbc0: 2034 2020 3820 3132 202e 2e2e 0a2f 2f20   4  8 12 ....// 
-0000fbd0: 2020 3120 2035 2020 3920 3133 202e 2e2e    1  5  9 13 ...
-0000fbe0: 0a2f 2f20 2020 3220 2036 2031 3020 3134  .//   2  6 10 14
-0000fbf0: 202e 2e2e 0a2f 2f20 2020 3320 2037 2031   ....//   3  7 1
-0000fc00: 3120 3135 202e 2e2e 0a2f 2f0a 2f2f 2020  1 15 ....//.//  
-0000fc10: 3136 2032 3020 3234 2032 3820 2e2e 2e0a  16 20 24 28 ....
-0000fc20: 2f2f 2020 3137 2032 3120 3235 2032 3920  //  17 21 25 29 
-0000fc30: 2e2e 2e0a 2f2f 2020 3138 2032 3220 3236  ....//  18 22 26
-0000fc40: 2033 3020 2e2e 2e0a 2f2f 2020 3139 2032   30 ....//  19 2
-0000fc50: 3320 3237 2033 3120 2e2e 2e0a 2f2f 0a2f  3 27 31 ....//./
-0000fc60: 2f20 2033 3220 3333 2033 3420 3335 202e  /  32 33 34 35 .
-0000fc70: 2e2e 0a2f 2f20 2033 3620 3336 2033 3820  ...//  36 36 38 
-0000fc80: 3339 202e 2e2e 0a74 656d 706c 6174 653c  39 ....template<
-0000fc90: 7479 7065 6e61 6d65 2053 6361 6c61 722c  typename Scalar,
-0000fca0: 2074 7970 656e 616d 6520 496e 6465 782c   typename Index,
-0000fcb0: 2074 7970 656e 616d 6520 4461 7461 4d61   typename DataMa
-0000fcc0: 7070 6572 2c20 696e 7420 5061 636b 312c  pper, int Pack1,
-0000fcd0: 2069 6e74 2050 6163 6b32 2c20 626f 6f6c   int Pack2, bool
-0000fce0: 2043 6f6e 6a75 6761 7465 2c20 626f 6f6c   Conjugate, bool
-0000fcf0: 2050 616e 656c 4d6f 6465 3e0a 7374 7275   PanelMode>.stru
-0000fd00: 6374 2067 656d 6d5f 7061 636b 5f6c 6873  ct gemm_pack_lhs
-0000fd10: 3c53 6361 6c61 722c 2049 6e64 6578 2c20  <Scalar, Index, 
-0000fd20: 4461 7461 4d61 7070 6572 2c20 5061 636b  DataMapper, Pack
-0000fd30: 312c 2050 6163 6b32 2c20 436f 6c4d 616a  1, Pack2, ColMaj
-0000fd40: 6f72 2c20 436f 6e6a 7567 6174 652c 2050  or, Conjugate, P
-0000fd50: 616e 656c 4d6f 6465 3e0a 7b0a 2020 7479  anelMode>.{.  ty
-0000fd60: 7065 6465 6620 7479 7065 6e61 6d65 2044  pedef typename D
-0000fd70: 6174 614d 6170 7065 723a 3a4c 696e 6561  ataMapper::Linea
-0000fd80: 724d 6170 7065 7220 4c69 6e65 6172 4d61  rMapper LinearMa
-0000fd90: 7070 6572 3b0a 2020 4549 4745 4e5f 444f  pper;.  EIGEN_DO
-0000fda0: 4e54 5f49 4e4c 494e 4520 766f 6964 206f  NT_INLINE void o
-0000fdb0: 7065 7261 746f 7228 2928 5363 616c 6172  perator()(Scalar
-0000fdc0: 2a20 626c 6f63 6b41 2c20 636f 6e73 7420  * blockA, const 
-0000fdd0: 4461 7461 4d61 7070 6572 2620 6c68 732c  DataMapper& lhs,
-0000fde0: 2049 6e64 6578 2064 6570 7468 2c20 496e   Index depth, In
-0000fdf0: 6465 7820 726f 7773 2c20 496e 6465 7820  dex rows, Index 
-0000fe00: 7374 7269 6465 3d30 2c20 496e 6465 7820  stride=0, Index 
-0000fe10: 6f66 6673 6574 3d30 293b 0a7d 3b0a 0a74  offset=0);.};..t
-0000fe20: 656d 706c 6174 653c 7479 7065 6e61 6d65  emplate<typename
-0000fe30: 2053 6361 6c61 722c 2074 7970 656e 616d   Scalar, typenam
-0000fe40: 6520 496e 6465 782c 2074 7970 656e 616d  e Index, typenam
-0000fe50: 6520 4461 7461 4d61 7070 6572 2c20 696e  e DataMapper, in
-0000fe60: 7420 5061 636b 312c 2069 6e74 2050 6163  t Pack1, int Pac
-0000fe70: 6b32 2c20 626f 6f6c 2043 6f6e 6a75 6761  k2, bool Conjuga
-0000fe80: 7465 2c20 626f 6f6c 2050 616e 656c 4d6f  te, bool PanelMo
-0000fe90: 6465 3e0a 4549 4745 4e5f 444f 4e54 5f49  de>.EIGEN_DONT_I
-0000fea0: 4e4c 494e 4520 766f 6964 2067 656d 6d5f  NLINE void gemm_
-0000feb0: 7061 636b 5f6c 6873 3c53 6361 6c61 722c  pack_lhs<Scalar,
-0000fec0: 2049 6e64 6578 2c20 4461 7461 4d61 7070   Index, DataMapp
-0000fed0: 6572 2c20 5061 636b 312c 2050 6163 6b32  er, Pack1, Pack2
-0000fee0: 2c20 436f 6c4d 616a 6f72 2c20 436f 6e6a  , ColMajor, Conj
-0000fef0: 7567 6174 652c 2050 616e 656c 4d6f 6465  ugate, PanelMode
-0000ff00: 3e0a 2020 3a3a 6f70 6572 6174 6f72 2829  >.  ::operator()
-0000ff10: 2853 6361 6c61 722a 2062 6c6f 636b 412c  (Scalar* blockA,
-0000ff20: 2063 6f6e 7374 2044 6174 614d 6170 7065   const DataMappe
-0000ff30: 7226 206c 6873 2c20 496e 6465 7820 6465  r& lhs, Index de
-0000ff40: 7074 682c 2049 6e64 6578 2072 6f77 732c  pth, Index rows,
-0000ff50: 2049 6e64 6578 2073 7472 6964 652c 2049   Index stride, I
-0000ff60: 6e64 6578 206f 6666 7365 7429 0a7b 0a20  ndex offset).{. 
-0000ff70: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
-0000ff80: 6520 7061 636b 6574 5f74 7261 6974 733c  e packet_traits<
-0000ff90: 5363 616c 6172 3e3a 3a74 7970 6520 5061  Scalar>::type Pa
-0000ffa0: 636b 6574 3b0a 2020 656e 756d 207b 2050  cket;.  enum { P
-0000ffb0: 6163 6b65 7453 697a 6520 3d20 7061 636b  acketSize = pack
-0000ffc0: 6574 5f74 7261 6974 733c 5363 616c 6172  et_traits<Scalar
-0000ffd0: 3e3a 3a73 697a 6520 7d3b 0a0a 2020 4549  >::size };..  EI
-0000ffe0: 4745 4e5f 4153 4d5f 434f 4d4d 454e 5428  GEN_ASM_COMMENT(
-0000fff0: 2245 4947 454e 2050 524f 4455 4354 2050  "EIGEN PRODUCT P
-00010000: 4143 4b20 4c48 5322 293b 0a20 2045 4947  ACK LHS");.  EIG
-00010010: 454e 5f55 4e55 5345 445f 5641 5249 4142  EN_UNUSED_VARIAB
-00010020: 4c45 2873 7472 6964 6529 3b0a 2020 4549  LE(stride);.  EI
-00010030: 4745 4e5f 554e 5553 4544 5f56 4152 4941  GEN_UNUSED_VARIA
-00010040: 424c 4528 6f66 6673 6574 293b 0a20 2065  BLE(offset);.  e
-00010050: 6967 656e 5f61 7373 6572 7428 2828 2150  igen_assert(((!P
-00010060: 616e 656c 4d6f 6465 2920 2626 2073 7472  anelMode) && str
-00010070: 6964 653d 3d30 2026 2620 6f66 6673 6574  ide==0 && offset
-00010080: 3d3d 3029 207c 7c20 2850 616e 656c 4d6f  ==0) || (PanelMo
-00010090: 6465 2026 2620 7374 7269 6465 3e3d 6465  de && stride>=de
-000100a0: 7074 6820 2626 206f 6666 7365 743c 3d73  pth && offset<=s
-000100b0: 7472 6964 6529 293b 0a20 2065 6967 656e  tride));.  eigen
-000100c0: 5f61 7373 6572 7428 2028 2850 6163 6b31  _assert( ((Pack1
-000100d0: 2550 6163 6b65 7453 697a 6529 3d3d 3020  %PacketSize)==0 
-000100e0: 2626 2050 6163 6b31 3c3d 342a 5061 636b  && Pack1<=4*Pack
-000100f0: 6574 5369 7a65 2920 7c7c 2028 5061 636b  etSize) || (Pack
-00010100: 313c 3d34 2920 293b 0a20 2063 6f6e 6a5f  1<=4) );.  conj_
-00010110: 6966 3c4e 756d 5472 6169 7473 3c53 6361  if<NumTraits<Sca
-00010120: 6c61 723e 3a3a 4973 436f 6d70 6c65 7820  lar>::IsComplex 
-00010130: 2626 2043 6f6e 6a75 6761 7465 3e20 636a  && Conjugate> cj
-00010140: 3b0a 2020 496e 6465 7820 636f 756e 7420  ;.  Index count 
-00010150: 3d20 303b 0a0a 2020 636f 6e73 7420 496e  = 0;..  const In
-00010160: 6465 7820 7065 656c 6564 5f6d 6333 203d  dex peeled_mc3 =
-00010170: 2050 6163 6b31 3e3d 332a 5061 636b 6574   Pack1>=3*Packet
-00010180: 5369 7a65 203f 2028 726f 7773 2f28 332a  Size ? (rows/(3*
-00010190: 5061 636b 6574 5369 7a65 2929 2a28 332a  PacketSize))*(3*
-000101a0: 5061 636b 6574 5369 7a65 2920 3a20 303b  PacketSize) : 0;
-000101b0: 0a20 2063 6f6e 7374 2049 6e64 6578 2070  .  const Index p
-000101c0: 6565 6c65 645f 6d63 3220 3d20 5061 636b  eeled_mc2 = Pack
-000101d0: 313e 3d32 2a50 6163 6b65 7453 697a 6520  1>=2*PacketSize 
-000101e0: 3f20 7065 656c 6564 5f6d 6333 2b28 2872  ? peeled_mc3+((r
-000101f0: 6f77 732d 7065 656c 6564 5f6d 6333 292f  ows-peeled_mc3)/
-00010200: 2832 2a50 6163 6b65 7453 697a 6529 292a  (2*PacketSize))*
-00010210: 2832 2a50 6163 6b65 7453 697a 6529 203a  (2*PacketSize) :
-00010220: 2030 3b0a 2020 636f 6e73 7420 496e 6465   0;.  const Inde
-00010230: 7820 7065 656c 6564 5f6d 6331 203d 2050  x peeled_mc1 = P
-00010240: 6163 6b31 3e3d 312a 5061 636b 6574 5369  ack1>=1*PacketSi
-00010250: 7a65 203f 2028 726f 7773 2f28 312a 5061  ze ? (rows/(1*Pa
-00010260: 636b 6574 5369 7a65 2929 2a28 312a 5061  cketSize))*(1*Pa
-00010270: 636b 6574 5369 7a65 2920 3a20 303b 0a20  cketSize) : 0;. 
-00010280: 2063 6f6e 7374 2049 6e64 6578 2070 6565   const Index pee
-00010290: 6c65 645f 6d63 3020 3d20 5061 636b 323e  led_mc0 = Pack2>
-000102a0: 3d31 2a50 6163 6b65 7453 697a 6520 3f20  =1*PacketSize ? 
-000102b0: 7065 656c 6564 5f6d 6331 0a20 2020 2020  peeled_mc1.     
-000102c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000102d0: 2020 2020 3a20 5061 636b 323e 3120 2020      : Pack2>1   
-000102e0: 2020 2020 2020 2020 2020 3f20 2872 6f77            ? (row
-000102f0: 732f 5061 636b 3229 2a50 6163 6b32 203a  s/Pack2)*Pack2 :
-00010300: 2030 3b0a 0a20 2049 6e64 6578 2069 3d30   0;..  Index i=0
-00010310: 3b0a 0a20 202f 2f20 5061 636b 2033 2070  ;..  // Pack 3 p
-00010320: 6163 6b65 7473 0a20 2069 6628 5061 636b  ackets.  if(Pack
-00010330: 313e 3d33 2a50 6163 6b65 7453 697a 6529  1>=3*PacketSize)
-00010340: 0a20 207b 0a20 2020 2066 6f72 283b 2069  .  {.    for(; i
-00010350: 3c70 6565 6c65 645f 6d63 333b 2069 2b3d  <peeled_mc3; i+=
-00010360: 332a 5061 636b 6574 5369 7a65 290a 2020  3*PacketSize).  
-00010370: 2020 7b0a 2020 2020 2020 6966 2850 616e    {.      if(Pan
-00010380: 656c 4d6f 6465 2920 636f 756e 7420 2b3d  elMode) count +=
-00010390: 2028 332a 5061 636b 6574 5369 7a65 2920   (3*PacketSize) 
-000103a0: 2a20 6f66 6673 6574 3b0a 0a20 2020 2020  * offset;..     
-000103b0: 2066 6f72 2849 6e64 6578 206b 3d30 3b20   for(Index k=0; 
-000103c0: 6b3c 6465 7074 683b 206b 2b2b 290a 2020  k<depth; k++).  
-000103d0: 2020 2020 7b0a 2020 2020 2020 2020 5061      {.        Pa
-000103e0: 636b 6574 2041 2c20 422c 2043 3b0a 2020  cket A, B, C;.  
-000103f0: 2020 2020 2020 4120 3d20 6c68 732e 6c6f        A = lhs.lo
-00010400: 6164 5061 636b 6574 2869 2b30 2a50 6163  adPacket(i+0*Pac
-00010410: 6b65 7453 697a 652c 206b 293b 0a20 2020  ketSize, k);.   
-00010420: 2020 2020 2042 203d 206c 6873 2e6c 6f61       B = lhs.loa
-00010430: 6450 6163 6b65 7428 692b 312a 5061 636b  dPacket(i+1*Pack
-00010440: 6574 5369 7a65 2c20 6b29 3b0a 2020 2020  etSize, k);.    
-00010450: 2020 2020 4320 3d20 6c68 732e 6c6f 6164      C = lhs.load
-00010460: 5061 636b 6574 2869 2b32 2a50 6163 6b65  Packet(i+2*Packe
-00010470: 7453 697a 652c 206b 293b 0a20 2020 2020  tSize, k);.     
-00010480: 2020 2070 7374 6f72 6528 626c 6f63 6b41     pstore(blockA
-00010490: 2b63 6f75 6e74 2c20 636a 2e70 636f 6e6a  +count, cj.pconj
-000104a0: 2841 2929 3b20 636f 756e 742b 3d50 6163  (A)); count+=Pac
-000104b0: 6b65 7453 697a 653b 0a20 2020 2020 2020  ketSize;.       
-000104c0: 2070 7374 6f72 6528 626c 6f63 6b41 2b63   pstore(blockA+c
-000104d0: 6f75 6e74 2c20 636a 2e70 636f 6e6a 2842  ount, cj.pconj(B
-000104e0: 2929 3b20 636f 756e 742b 3d50 6163 6b65  )); count+=Packe
-000104f0: 7453 697a 653b 0a20 2020 2020 2020 2070  tSize;.        p
-00010500: 7374 6f72 6528 626c 6f63 6b41 2b63 6f75  store(blockA+cou
-00010510: 6e74 2c20 636a 2e70 636f 6e6a 2843 2929  nt, cj.pconj(C))
-00010520: 3b20 636f 756e 742b 3d50 6163 6b65 7453  ; count+=PacketS
-00010530: 697a 653b 0a20 2020 2020 207d 0a20 2020  ize;.      }.   
-00010540: 2020 2069 6628 5061 6e65 6c4d 6f64 6529     if(PanelMode)
-00010550: 2063 6f75 6e74 202b 3d20 2833 2a50 6163   count += (3*Pac
-00010560: 6b65 7453 697a 6529 202a 2028 7374 7269  ketSize) * (stri
-00010570: 6465 2d6f 6666 7365 742d 6465 7074 6829  de-offset-depth)
-00010580: 3b0a 2020 2020 7d0a 2020 7d0a 2020 2f2f  ;.    }.  }.  //
-00010590: 2050 6163 6b20 3220 7061 636b 6574 730a   Pack 2 packets.
-000105a0: 2020 6966 2850 6163 6b31 3e3d 322a 5061    if(Pack1>=2*Pa
-000105b0: 636b 6574 5369 7a65 290a 2020 7b0a 2020  cketSize).  {.  
-000105c0: 2020 666f 7228 3b20 693c 7065 656c 6564    for(; i<peeled
-000105d0: 5f6d 6332 3b20 692b 3d32 2a50 6163 6b65  _mc2; i+=2*Packe
-000105e0: 7453 697a 6529 0a20 2020 207b 0a20 2020  tSize).    {.   
-000105f0: 2020 2069 6628 5061 6e65 6c4d 6f64 6529     if(PanelMode)
-00010600: 2063 6f75 6e74 202b 3d20 2832 2a50 6163   count += (2*Pac
-00010610: 6b65 7453 697a 6529 202a 206f 6666 7365  ketSize) * offse
-00010620: 743b 0a0a 2020 2020 2020 666f 7228 496e  t;..      for(In
-00010630: 6465 7820 6b3d 303b 206b 3c64 6570 7468  dex k=0; k<depth
-00010640: 3b20 6b2b 2b29 0a20 2020 2020 207b 0a20  ; k++).      {. 
-00010650: 2020 2020 2020 2050 6163 6b65 7420 412c         Packet A,
-00010660: 2042 3b0a 2020 2020 2020 2020 4120 3d20   B;.        A = 
-00010670: 6c68 732e 6c6f 6164 5061 636b 6574 2869  lhs.loadPacket(i
-00010680: 2b30 2a50 6163 6b65 7453 697a 652c 206b  +0*PacketSize, k
-00010690: 293b 0a20 2020 2020 2020 2042 203d 206c  );.        B = l
-000106a0: 6873 2e6c 6f61 6450 6163 6b65 7428 692b  hs.loadPacket(i+
-000106b0: 312a 5061 636b 6574 5369 7a65 2c20 6b29  1*PacketSize, k)
-000106c0: 3b0a 2020 2020 2020 2020 7073 746f 7265  ;.        pstore
-000106d0: 2862 6c6f 636b 412b 636f 756e 742c 2063  (blockA+count, c
-000106e0: 6a2e 7063 6f6e 6a28 4129 293b 2063 6f75  j.pconj(A)); cou
-000106f0: 6e74 2b3d 5061 636b 6574 5369 7a65 3b0a  nt+=PacketSize;.
-00010700: 2020 2020 2020 2020 7073 746f 7265 2862          pstore(b
-00010710: 6c6f 636b 412b 636f 756e 742c 2063 6a2e  lockA+count, cj.
-00010720: 7063 6f6e 6a28 4229 293b 2063 6f75 6e74  pconj(B)); count
-00010730: 2b3d 5061 636b 6574 5369 7a65 3b0a 2020  +=PacketSize;.  
-00010740: 2020 2020 7d0a 2020 2020 2020 6966 2850      }.      if(P
-00010750: 616e 656c 4d6f 6465 2920 636f 756e 7420  anelMode) count 
-00010760: 2b3d 2028 322a 5061 636b 6574 5369 7a65  += (2*PacketSize
-00010770: 2920 2a20 2873 7472 6964 652d 6f66 6673  ) * (stride-offs
-00010780: 6574 2d64 6570 7468 293b 0a20 2020 207d  et-depth);.    }
-00010790: 0a20 207d 0a20 202f 2f20 5061 636b 2031  .  }.  // Pack 1
-000107a0: 2070 6163 6b65 7473 0a20 2069 6628 5061   packets.  if(Pa
-000107b0: 636b 313e 3d31 2a50 6163 6b65 7453 697a  ck1>=1*PacketSiz
-000107c0: 6529 0a20 207b 0a20 2020 2066 6f72 283b  e).  {.    for(;
-000107d0: 2069 3c70 6565 6c65 645f 6d63 313b 2069   i<peeled_mc1; i
-000107e0: 2b3d 312a 5061 636b 6574 5369 7a65 290a  +=1*PacketSize).
-000107f0: 2020 2020 7b0a 2020 2020 2020 6966 2850      {.      if(P
-00010800: 616e 656c 4d6f 6465 2920 636f 756e 7420  anelMode) count 
-00010810: 2b3d 2028 312a 5061 636b 6574 5369 7a65  += (1*PacketSize
-00010820: 2920 2a20 6f66 6673 6574 3b0a 0a20 2020  ) * offset;..   
-00010830: 2020 2066 6f72 2849 6e64 6578 206b 3d30     for(Index k=0
-00010840: 3b20 6b3c 6465 7074 683b 206b 2b2b 290a  ; k<depth; k++).
-00010850: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
-00010860: 5061 636b 6574 2041 3b0a 2020 2020 2020  Packet A;.      
-00010870: 2020 4120 3d20 6c68 732e 6c6f 6164 5061    A = lhs.loadPa
-00010880: 636b 6574 2869 2b30 2a50 6163 6b65 7453  cket(i+0*PacketS
-00010890: 697a 652c 206b 293b 0a20 2020 2020 2020  ize, k);.       
-000108a0: 2070 7374 6f72 6528 626c 6f63 6b41 2b63   pstore(blockA+c
-000108b0: 6f75 6e74 2c20 636a 2e70 636f 6e6a 2841  ount, cj.pconj(A
-000108c0: 2929 3b0a 2020 2020 2020 2020 636f 756e  ));.        coun
-000108d0: 742b 3d50 6163 6b65 7453 697a 653b 0a20  t+=PacketSize;. 
-000108e0: 2020 2020 207d 0a20 2020 2020 2069 6628       }.      if(
-000108f0: 5061 6e65 6c4d 6f64 6529 2063 6f75 6e74  PanelMode) count
-00010900: 202b 3d20 2831 2a50 6163 6b65 7453 697a   += (1*PacketSiz
-00010910: 6529 202a 2028 7374 7269 6465 2d6f 6666  e) * (stride-off
-00010920: 7365 742d 6465 7074 6829 3b0a 2020 2020  set-depth);.    
-00010930: 7d0a 2020 7d0a 2020 2f2f 2050 6163 6b20  }.  }.  // Pack 
-00010940: 7363 616c 6172 730a 2020 6966 2850 6163  scalars.  if(Pac
-00010950: 6b32 3c50 6163 6b65 7453 697a 6520 2626  k2<PacketSize &&
-00010960: 2050 6163 6b32 3e31 290a 2020 7b0a 2020   Pack2>1).  {.  
-00010970: 2020 666f 7228 3b20 693c 7065 656c 6564    for(; i<peeled
-00010980: 5f6d 6330 3b20 692b 3d50 6163 6b32 290a  _mc0; i+=Pack2).
-00010990: 2020 2020 7b0a 2020 2020 2020 6966 2850      {.      if(P
-000109a0: 616e 656c 4d6f 6465 2920 636f 756e 7420  anelMode) count 
-000109b0: 2b3d 2050 6163 6b32 202a 206f 6666 7365  += Pack2 * offse
-000109c0: 743b 0a0a 2020 2020 2020 666f 7228 496e  t;..      for(In
-000109d0: 6465 7820 6b3d 303b 206b 3c64 6570 7468  dex k=0; k<depth
-000109e0: 3b20 6b2b 2b29 0a20 2020 2020 2020 2066  ; k++).        f
-000109f0: 6f72 2849 6e64 6578 2077 3d30 3b20 773c  or(Index w=0; w<
-00010a00: 5061 636b 323b 2077 2b2b 290a 2020 2020  Pack2; w++).    
-00010a10: 2020 2020 2020 626c 6f63 6b41 5b63 6f75        blockA[cou
-00010a20: 6e74 2b2b 5d20 3d20 636a 286c 6873 2869  nt++] = cj(lhs(i
-00010a30: 2b77 2c20 6b29 293b 0a0a 2020 2020 2020  +w, k));..      
-00010a40: 6966 2850 616e 656c 4d6f 6465 2920 636f  if(PanelMode) co
-00010a50: 756e 7420 2b3d 2050 6163 6b32 202a 2028  unt += Pack2 * (
-00010a60: 7374 7269 6465 2d6f 6666 7365 742d 6465  stride-offset-de
-00010a70: 7074 6829 3b0a 2020 2020 7d0a 2020 7d0a  pth);.    }.  }.
-00010a80: 2020 666f 7228 3b20 693c 726f 7773 3b20    for(; i<rows; 
-00010a90: 692b 2b29 0a20 207b 0a20 2020 2069 6628  i++).  {.    if(
-00010aa0: 5061 6e65 6c4d 6f64 6529 2063 6f75 6e74  PanelMode) count
-00010ab0: 202b 3d20 6f66 6673 6574 3b0a 2020 2020   += offset;.    
-00010ac0: 666f 7228 496e 6465 7820 6b3d 303b 206b  for(Index k=0; k
-00010ad0: 3c64 6570 7468 3b20 6b2b 2b29 0a20 2020  <depth; k++).   
-00010ae0: 2020 2062 6c6f 636b 415b 636f 756e 742b     blockA[count+
-00010af0: 2b5d 203d 2063 6a28 6c68 7328 692c 206b  +] = cj(lhs(i, k
-00010b00: 2929 3b0a 2020 2020 6966 2850 616e 656c  ));.    if(Panel
-00010b10: 4d6f 6465 2920 636f 756e 7420 2b3d 2028  Mode) count += (
-00010b20: 7374 7269 6465 2d6f 6666 7365 742d 6465  stride-offset-de
-00010b30: 7074 6829 3b0a 2020 7d0a 7d0a 0a74 656d  pth);.  }.}..tem
-00010b40: 706c 6174 653c 7479 7065 6e61 6d65 2053  plate<typename S
-00010b50: 6361 6c61 722c 2074 7970 656e 616d 6520  calar, typename 
-00010b60: 496e 6465 782c 2074 7970 656e 616d 6520  Index, typename 
-00010b70: 4461 7461 4d61 7070 6572 2c20 696e 7420  DataMapper, int 
-00010b80: 5061 636b 312c 2069 6e74 2050 6163 6b32  Pack1, int Pack2
-00010b90: 2c20 626f 6f6c 2043 6f6e 6a75 6761 7465  , bool Conjugate
-00010ba0: 2c20 626f 6f6c 2050 616e 656c 4d6f 6465  , bool PanelMode
-00010bb0: 3e0a 7374 7275 6374 2067 656d 6d5f 7061  >.struct gemm_pa
-00010bc0: 636b 5f6c 6873 3c53 6361 6c61 722c 2049  ck_lhs<Scalar, I
-00010bd0: 6e64 6578 2c20 4461 7461 4d61 7070 6572  ndex, DataMapper
-00010be0: 2c20 5061 636b 312c 2050 6163 6b32 2c20  , Pack1, Pack2, 
-00010bf0: 526f 774d 616a 6f72 2c20 436f 6e6a 7567  RowMajor, Conjug
-00010c00: 6174 652c 2050 616e 656c 4d6f 6465 3e0a  ate, PanelMode>.
-00010c10: 7b0a 2020 7479 7065 6465 6620 7479 7065  {.  typedef type
-00010c20: 6e61 6d65 2044 6174 614d 6170 7065 723a  name DataMapper:
-00010c30: 3a4c 696e 6561 724d 6170 7065 7220 4c69  :LinearMapper Li
-00010c40: 6e65 6172 4d61 7070 6572 3b0a 2020 4549  nearMapper;.  EI
-00010c50: 4745 4e5f 444f 4e54 5f49 4e4c 494e 4520  GEN_DONT_INLINE 
-00010c60: 766f 6964 206f 7065 7261 746f 7228 2928  void operator()(
-00010c70: 5363 616c 6172 2a20 626c 6f63 6b41 2c20  Scalar* blockA, 
-00010c80: 636f 6e73 7420 4461 7461 4d61 7070 6572  const DataMapper
-00010c90: 2620 6c68 732c 2049 6e64 6578 2064 6570  & lhs, Index dep
-00010ca0: 7468 2c20 496e 6465 7820 726f 7773 2c20  th, Index rows, 
-00010cb0: 496e 6465 7820 7374 7269 6465 3d30 2c20  Index stride=0, 
-00010cc0: 496e 6465 7820 6f66 6673 6574 3d30 293b  Index offset=0);
-00010cd0: 0a7d 3b0a 0a74 656d 706c 6174 653c 7479  .};..template<ty
-00010ce0: 7065 6e61 6d65 2053 6361 6c61 722c 2074  pename Scalar, t
-00010cf0: 7970 656e 616d 6520 496e 6465 782c 2074  ypename Index, t
-00010d00: 7970 656e 616d 6520 4461 7461 4d61 7070  ypename DataMapp
-00010d10: 6572 2c20 696e 7420 5061 636b 312c 2069  er, int Pack1, i
-00010d20: 6e74 2050 6163 6b32 2c20 626f 6f6c 2043  nt Pack2, bool C
-00010d30: 6f6e 6a75 6761 7465 2c20 626f 6f6c 2050  onjugate, bool P
-00010d40: 616e 656c 4d6f 6465 3e0a 4549 4745 4e5f  anelMode>.EIGEN_
-00010d50: 444f 4e54 5f49 4e4c 494e 4520 766f 6964  DONT_INLINE void
-00010d60: 2067 656d 6d5f 7061 636b 5f6c 6873 3c53   gemm_pack_lhs<S
-00010d70: 6361 6c61 722c 2049 6e64 6578 2c20 4461  calar, Index, Da
-00010d80: 7461 4d61 7070 6572 2c20 5061 636b 312c  taMapper, Pack1,
-00010d90: 2050 6163 6b32 2c20 526f 774d 616a 6f72   Pack2, RowMajor
-00010da0: 2c20 436f 6e6a 7567 6174 652c 2050 616e  , Conjugate, Pan
-00010db0: 656c 4d6f 6465 3e0a 2020 3a3a 6f70 6572  elMode>.  ::oper
-00010dc0: 6174 6f72 2829 2853 6361 6c61 722a 2062  ator()(Scalar* b
-00010dd0: 6c6f 636b 412c 2063 6f6e 7374 2044 6174  lockA, const Dat
-00010de0: 614d 6170 7065 7226 206c 6873 2c20 496e  aMapper& lhs, In
-00010df0: 6465 7820 6465 7074 682c 2049 6e64 6578  dex depth, Index
-00010e00: 2072 6f77 732c 2049 6e64 6578 2073 7472   rows, Index str
-00010e10: 6964 652c 2049 6e64 6578 206f 6666 7365  ide, Index offse
-00010e20: 7429 0a7b 0a20 2074 7970 6564 6566 2074  t).{.  typedef t
-00010e30: 7970 656e 616d 6520 7061 636b 6574 5f74  ypename packet_t
-00010e40: 7261 6974 733c 5363 616c 6172 3e3a 3a74  raits<Scalar>::t
-00010e50: 7970 6520 5061 636b 6574 3b0a 2020 656e  ype Packet;.  en
-00010e60: 756d 207b 2050 6163 6b65 7453 697a 6520  um { PacketSize 
-00010e70: 3d20 7061 636b 6574 5f74 7261 6974 733c  = packet_traits<
-00010e80: 5363 616c 6172 3e3a 3a73 697a 6520 7d3b  Scalar>::size };
-00010e90: 0a0a 2020 4549 4745 4e5f 4153 4d5f 434f  ..  EIGEN_ASM_CO
-00010ea0: 4d4d 454e 5428 2245 4947 454e 2050 524f  MMENT("EIGEN PRO
-00010eb0: 4455 4354 2050 4143 4b20 4c48 5322 293b  DUCT PACK LHS");
-00010ec0: 0a20 2045 4947 454e 5f55 4e55 5345 445f  .  EIGEN_UNUSED_
-00010ed0: 5641 5249 4142 4c45 2873 7472 6964 6529  VARIABLE(stride)
-00010ee0: 3b0a 2020 4549 4745 4e5f 554e 5553 4544  ;.  EIGEN_UNUSED
-00010ef0: 5f56 4152 4941 424c 4528 6f66 6673 6574  _VARIABLE(offset
-00010f00: 293b 0a20 2065 6967 656e 5f61 7373 6572  );.  eigen_asser
-00010f10: 7428 2828 2150 616e 656c 4d6f 6465 2920  t(((!PanelMode) 
-00010f20: 2626 2073 7472 6964 653d 3d30 2026 2620  && stride==0 && 
-00010f30: 6f66 6673 6574 3d3d 3029 207c 7c20 2850  offset==0) || (P
-00010f40: 616e 656c 4d6f 6465 2026 2620 7374 7269  anelMode && stri
-00010f50: 6465 3e3d 6465 7074 6820 2626 206f 6666  de>=depth && off
-00010f60: 7365 743c 3d73 7472 6964 6529 293b 0a20  set<=stride));. 
-00010f70: 2063 6f6e 6a5f 6966 3c4e 756d 5472 6169   conj_if<NumTrai
-00010f80: 7473 3c53 6361 6c61 723e 3a3a 4973 436f  ts<Scalar>::IsCo
-00010f90: 6d70 6c65 7820 2626 2043 6f6e 6a75 6761  mplex && Conjuga
-00010fa0: 7465 3e20 636a 3b0a 2020 496e 6465 7820  te> cj;.  Index 
-00010fb0: 636f 756e 7420 3d20 303b 0a0a 2f2f 2020  count = 0;..//  
-00010fc0: 2063 6f6e 7374 2049 6e64 6578 2070 6565   const Index pee
-00010fd0: 6c65 645f 6d63 3320 3d20 5061 636b 313e  led_mc3 = Pack1>
-00010fe0: 3d33 2a50 6163 6b65 7453 697a 6520 3f20  =3*PacketSize ? 
-00010ff0: 2872 6f77 732f 2833 2a50 6163 6b65 7453  (rows/(3*PacketS
-00011000: 697a 6529 292a 2833 2a50 6163 6b65 7453  ize))*(3*PacketS
-00011010: 697a 6529 203a 2030 3b0a 2f2f 2020 2063  ize) : 0;.//   c
-00011020: 6f6e 7374 2049 6e64 6578 2070 6565 6c65  onst Index peele
-00011030: 645f 6d63 3220 3d20 5061 636b 313e 3d32  d_mc2 = Pack1>=2
-00011040: 2a50 6163 6b65 7453 697a 6520 3f20 7065  *PacketSize ? pe
-00011050: 656c 6564 5f6d 6333 2b28 2872 6f77 732d  eled_mc3+((rows-
-00011060: 7065 656c 6564 5f6d 6333 292f 2832 2a50  peeled_mc3)/(2*P
-00011070: 6163 6b65 7453 697a 6529 292a 2832 2a50  acketSize))*(2*P
-00011080: 6163 6b65 7453 697a 6529 203a 2030 3b0a  acketSize) : 0;.
-00011090: 2f2f 2020 2063 6f6e 7374 2049 6e64 6578  //   const Index
-000110a0: 2070 6565 6c65 645f 6d63 3120 3d20 5061   peeled_mc1 = Pa
-000110b0: 636b 313e 3d31 2a50 6163 6b65 7453 697a  ck1>=1*PacketSiz
-000110c0: 6520 3f20 2872 6f77 732f 2831 2a50 6163  e ? (rows/(1*Pac
-000110d0: 6b65 7453 697a 6529 292a 2831 2a50 6163  ketSize))*(1*Pac
-000110e0: 6b65 7453 697a 6529 203a 2030 3b0a 0a20  ketSize) : 0;.. 
-000110f0: 2069 6e74 2070 6163 6b20 3d20 5061 636b   int pack = Pack
-00011100: 313b 0a20 2049 6e64 6578 2069 203d 2030  1;.  Index i = 0
-00011110: 3b0a 2020 7768 696c 6528 7061 636b 3e30  ;.  while(pack>0
-00011120: 290a 2020 7b0a 2020 2020 496e 6465 7820  ).  {.    Index 
-00011130: 7265 6d61 696e 696e 675f 726f 7773 203d  remaining_rows =
-00011140: 2072 6f77 732d 693b 0a20 2020 2049 6e64   rows-i;.    Ind
-00011150: 6578 2070 6565 6c65 645f 6d63 203d 2069  ex peeled_mc = i
-00011160: 2b28 7265 6d61 696e 696e 675f 726f 7773  +(remaining_rows
-00011170: 2f70 6163 6b29 2a70 6163 6b3b 0a20 2020  /pack)*pack;.   
-00011180: 2066 6f72 283b 2069 3c70 6565 6c65 645f   for(; i<peeled_
-00011190: 6d63 3b20 692b 3d70 6163 6b29 0a20 2020  mc; i+=pack).   
-000111a0: 207b 0a20 2020 2020 2069 6628 5061 6e65   {.      if(Pane
-000111b0: 6c4d 6f64 6529 2063 6f75 6e74 202b 3d20  lMode) count += 
-000111c0: 7061 636b 202a 206f 6666 7365 743b 0a0a  pack * offset;..
-000111d0: 2020 2020 2020 636f 6e73 7420 496e 6465        const Inde
-000111e0: 7820 7065 656c 6564 5f6b 203d 2028 6465  x peeled_k = (de
-000111f0: 7074 682f 5061 636b 6574 5369 7a65 292a  pth/PacketSize)*
-00011200: 5061 636b 6574 5369 7a65 3b0a 2020 2020  PacketSize;.    
-00011210: 2020 496e 6465 7820 6b3d 303b 0a20 2020    Index k=0;.   
-00011220: 2020 2069 6628 7061 636b 3e3d 5061 636b     if(pack>=Pack
-00011230: 6574 5369 7a65 290a 2020 2020 2020 7b0a  etSize).      {.
-00011240: 2020 2020 2020 2020 666f 7228 3b20 6b3c          for(; k<
-00011250: 7065 656c 6564 5f6b 3b20 6b2b 3d50 6163  peeled_k; k+=Pac
-00011260: 6b65 7453 697a 6529 0a20 2020 2020 2020  ketSize).       
-00011270: 207b 0a20 2020 2020 2020 2020 2066 6f72   {.          for
-00011280: 2028 496e 6465 7820 6d20 3d20 303b 206d   (Index m = 0; m
-00011290: 203c 2070 6163 6b3b 206d 202b 3d20 5061   < pack; m += Pa
-000112a0: 636b 6574 5369 7a65 290a 2020 2020 2020  cketSize).      
-000112b0: 2020 2020 7b0a 2020 2020 2020 2020 2020      {.          
-000112c0: 2020 5061 636b 6574 426c 6f63 6b3c 5061    PacketBlock<Pa
-000112d0: 636b 6574 3e20 6b65 726e 656c 3b0a 2020  cket> kernel;.  
-000112e0: 2020 2020 2020 2020 2020 666f 7220 2869            for (i
-000112f0: 6e74 2070 203d 2030 3b20 7020 3c20 5061  nt p = 0; p < Pa
-00011300: 636b 6574 5369 7a65 3b20 2b2b 7029 206b  cketSize; ++p) k
-00011310: 6572 6e65 6c2e 7061 636b 6574 5b70 5d20  ernel.packet[p] 
-00011320: 3d20 6c68 732e 6c6f 6164 5061 636b 6574  = lhs.loadPacket
-00011330: 2869 2b70 2b6d 2c20 6b29 3b0a 2020 2020  (i+p+m, k);.    
-00011340: 2020 2020 2020 2020 7074 7261 6e73 706f          ptranspo
-00011350: 7365 286b 6572 6e65 6c29 3b0a 2020 2020  se(kernel);.    
-00011360: 2020 2020 2020 2020 666f 7220 2869 6e74          for (int
-00011370: 2070 203d 2030 3b20 7020 3c20 5061 636b   p = 0; p < Pack
-00011380: 6574 5369 7a65 3b20 2b2b 7029 2070 7374  etSize; ++p) pst
-00011390: 6f72 6528 626c 6f63 6b41 2b63 6f75 6e74  ore(blockA+count
-000113a0: 2b6d 2b28 7061 636b 292a 702c 2063 6a2e  +m+(pack)*p, cj.
-000113b0: 7063 6f6e 6a28 6b65 726e 656c 2e70 6163  pconj(kernel.pac
-000113c0: 6b65 745b 705d 2929 3b0a 2020 2020 2020  ket[p]));.      
-000113d0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
-000113e0: 636f 756e 7420 2b3d 2050 6163 6b65 7453  count += PacketS
-000113f0: 697a 652a 7061 636b 3b0a 2020 2020 2020  ize*pack;.      
-00011400: 2020 7d0a 2020 2020 2020 7d0a 2020 2020    }.      }.    
-00011410: 2020 666f 7228 3b20 6b3c 6465 7074 683b    for(; k<depth;
-00011420: 206b 2b2b 290a 2020 2020 2020 7b0a 2020   k++).      {.  
-00011430: 2020 2020 2020 496e 6465 7820 773d 303b        Index w=0;
-00011440: 0a20 2020 2020 2020 2066 6f72 283b 2077  .        for(; w
-00011450: 3c70 6163 6b2d 333b 2077 2b3d 3429 0a20  <pack-3; w+=4). 
-00011460: 2020 2020 2020 207b 0a20 2020 2020 2020         {.       
-00011470: 2020 2053 6361 6c61 7220 6128 636a 286c     Scalar a(cj(l
-00011480: 6873 2869 2b77 2b30 2c20 6b29 2929 2c0a  hs(i+w+0, k))),.
-00011490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000114a0: 2062 2863 6a28 6c68 7328 692b 772b 312c   b(cj(lhs(i+w+1,
-000114b0: 206b 2929 292c 0a20 2020 2020 2020 2020   k))),.         
-000114c0: 2020 2020 2020 2020 6328 636a 286c 6873          c(cj(lhs
-000114d0: 2869 2b77 2b32 2c20 6b29 2929 2c0a 2020  (i+w+2, k))),.  
-000114e0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-000114f0: 2863 6a28 6c68 7328 692b 772b 332c 206b  (cj(lhs(i+w+3, k
-00011500: 2929 293b 0a20 2020 2020 2020 2020 2062  )));.          b
-00011510: 6c6f 636b 415b 636f 756e 742b 2b5d 203d  lockA[count++] =
-00011520: 2061 3b0a 2020 2020 2020 2020 2020 626c   a;.          bl
-00011530: 6f63 6b41 5b63 6f75 6e74 2b2b 5d20 3d20  ockA[count++] = 
-00011540: 623b 0a20 2020 2020 2020 2020 2062 6c6f  b;.          blo
-00011550: 636b 415b 636f 756e 742b 2b5d 203d 2063  ckA[count++] = c
-00011560: 3b0a 2020 2020 2020 2020 2020 626c 6f63  ;.          bloc
-00011570: 6b41 5b63 6f75 6e74 2b2b 5d20 3d20 643b  kA[count++] = d;
-00011580: 0a20 2020 2020 2020 207d 0a20 2020 2020  .        }.     
-00011590: 2020 2069 6628 7061 636b 2534 290a 2020     if(pack%4).  
-000115a0: 2020 2020 2020 2020 666f 7228 3b77 3c70          for(;w<p
-000115b0: 6163 6b3b 2b2b 7729 0a20 2020 2020 2020  ack;++w).       
-000115c0: 2020 2020 2062 6c6f 636b 415b 636f 756e       blockA[coun
-000115d0: 742b 2b5d 203d 2063 6a28 6c68 7328 692b  t++] = cj(lhs(i+
-000115e0: 772c 206b 2929 3b0a 2020 2020 2020 7d0a  w, k));.      }.
-000115f0: 0a20 2020 2020 2069 6628 5061 6e65 6c4d  .      if(PanelM
-00011600: 6f64 6529 2063 6f75 6e74 202b 3d20 7061  ode) count += pa
-00011610: 636b 202a 2028 7374 7269 6465 2d6f 6666  ck * (stride-off
-00011620: 7365 742d 6465 7074 6829 3b0a 2020 2020  set-depth);.    
-00011630: 7d0a 0a20 2020 2070 6163 6b20 2d3d 2050  }..    pack -= P
-00011640: 6163 6b65 7453 697a 653b 0a20 2020 2069  acketSize;.    i
-00011650: 6628 7061 636b 3c50 6163 6b32 2026 2620  f(pack<Pack2 && 
-00011660: 2870 6163 6b2b 5061 636b 6574 5369 7a65  (pack+PacketSize
-00011670: 2921 3d50 6163 6b32 290a 2020 2020 2020  )!=Pack2).      
-00011680: 7061 636b 203d 2050 6163 6b32 3b0a 2020  pack = Pack2;.  
-00011690: 7d0a 0a20 2066 6f72 283b 2069 3c72 6f77  }..  for(; i<row
-000116a0: 733b 2069 2b2b 290a 2020 7b0a 2020 2020  s; i++).  {.    
-000116b0: 6966 2850 616e 656c 4d6f 6465 2920 636f  if(PanelMode) co
-000116c0: 756e 7420 2b3d 206f 6666 7365 743b 0a20  unt += offset;. 
-000116d0: 2020 2066 6f72 2849 6e64 6578 206b 3d30     for(Index k=0
-000116e0: 3b20 6b3c 6465 7074 683b 206b 2b2b 290a  ; k<depth; k++).
-000116f0: 2020 2020 2020 626c 6f63 6b41 5b63 6f75        blockA[cou
-00011700: 6e74 2b2b 5d20 3d20 636a 286c 6873 2869  nt++] = cj(lhs(i
-00011710: 2c20 6b29 293b 0a20 2020 2069 6628 5061  , k));.    if(Pa
-00011720: 6e65 6c4d 6f64 6529 2063 6f75 6e74 202b  nelMode) count +
-00011730: 3d20 2873 7472 6964 652d 6f66 6673 6574  = (stride-offset
-00011740: 2d64 6570 7468 293b 0a20 207d 0a7d 0a0a  -depth);.  }.}..
-00011750: 2f2f 2063 6f70 7920 6120 636f 6d70 6c65  // copy a comple
-00011760: 7465 2070 616e 656c 206f 6620 7468 6520  te panel of the 
-00011770: 7268 730a 2f2f 2074 6869 7320 7665 7273  rhs.// this vers
-00011780: 696f 6e20 6973 206f 7074 696d 697a 6564  ion is optimized
-00011790: 2066 6f72 2063 6f6c 756d 6e20 6d61 6a6f   for column majo
-000117a0: 7220 6d61 7472 6963 6573 0a2f 2f20 5468  r matrices.// Th
-000117b0: 6520 7472 6176 6572 7361 6c20 6f72 6465  e traversal orde
-000117c0: 7220 6973 2061 7320 666f 6c6c 6f77 3a20  r is as follow: 
-000117d0: 286e 723d 3d34 293a 0a2f 2f20 2030 2020  (nr==4):.//  0  
-000117e0: 3120 2032 2020 3320 2020 3132 2031 3320  1  2  3   12 13 
-000117f0: 3134 2031 3520 2020 3234 2032 370a 2f2f  14 15   24 27.//
-00011800: 2020 3420 2035 2020 3620 2037 2020 2031    4  5  6  7   1
-00011810: 3620 3137 2031 3820 3139 2020 2032 3520  6 17 18 19   25 
-00011820: 3238 0a2f 2f20 2038 2020 3920 3130 2031  28.//  8  9 10 1
-00011830: 3120 2020 3230 2032 3120 3232 2032 3320  1   20 21 22 23 
-00011840: 2020 3236 2032 390a 2f2f 2020 2e20 202e    26 29.//  .  .
-00011850: 2020 2e20 202e 2020 2020 2e20 202e 2020    .  .    .  .  
-00011860: 2e20 202e 2020 2020 2e20 202e 0a74 656d  .  .    .  ..tem
-00011870: 706c 6174 653c 7479 7065 6e61 6d65 2053  plate<typename S
-00011880: 6361 6c61 722c 2074 7970 656e 616d 6520  calar, typename 
-00011890: 496e 6465 782c 2074 7970 656e 616d 6520  Index, typename 
-000118a0: 4461 7461 4d61 7070 6572 2c20 696e 7420  DataMapper, int 
-000118b0: 6e72 2c20 626f 6f6c 2043 6f6e 6a75 6761  nr, bool Conjuga
-000118c0: 7465 2c20 626f 6f6c 2050 616e 656c 4d6f  te, bool PanelMo
-000118d0: 6465 3e0a 7374 7275 6374 2067 656d 6d5f  de>.struct gemm_
-000118e0: 7061 636b 5f72 6873 3c53 6361 6c61 722c  pack_rhs<Scalar,
-000118f0: 2049 6e64 6578 2c20 4461 7461 4d61 7070   Index, DataMapp
-00011900: 6572 2c20 6e72 2c20 436f 6c4d 616a 6f72  er, nr, ColMajor
-00011910: 2c20 436f 6e6a 7567 6174 652c 2050 616e  , Conjugate, Pan
-00011920: 656c 4d6f 6465 3e0a 7b0a 2020 7479 7065  elMode>.{.  type
-00011930: 6465 6620 7479 7065 6e61 6d65 2070 6163  def typename pac
-00011940: 6b65 745f 7472 6169 7473 3c53 6361 6c61  ket_traits<Scala
-00011950: 723e 3a3a 7479 7065 2050 6163 6b65 743b  r>::type Packet;
-00011960: 0a20 2074 7970 6564 6566 2074 7970 656e  .  typedef typen
-00011970: 616d 6520 4461 7461 4d61 7070 6572 3a3a  ame DataMapper::
-00011980: 4c69 6e65 6172 4d61 7070 6572 204c 696e  LinearMapper Lin
-00011990: 6561 724d 6170 7065 723b 0a20 2065 6e75  earMapper;.  enu
-000119a0: 6d20 7b20 5061 636b 6574 5369 7a65 203d  m { PacketSize =
-000119b0: 2070 6163 6b65 745f 7472 6169 7473 3c53   packet_traits<S
-000119c0: 6361 6c61 723e 3a3a 7369 7a65 207d 3b0a  calar>::size };.
-000119d0: 2020 4549 4745 4e5f 444f 4e54 5f49 4e4c    EIGEN_DONT_INL
-000119e0: 494e 4520 766f 6964 206f 7065 7261 746f  INE void operato
-000119f0: 7228 2928 5363 616c 6172 2a20 626c 6f63  r()(Scalar* bloc
-00011a00: 6b42 2c20 636f 6e73 7420 4461 7461 4d61  kB, const DataMa
-00011a10: 7070 6572 2620 7268 732c 2049 6e64 6578  pper& rhs, Index
-00011a20: 2064 6570 7468 2c20 496e 6465 7820 636f   depth, Index co
-00011a30: 6c73 2c20 496e 6465 7820 7374 7269 6465  ls, Index stride
-00011a40: 3d30 2c20 496e 6465 7820 6f66 6673 6574  =0, Index offset
-00011a50: 3d30 293b 0a7d 3b0a 0a74 656d 706c 6174  =0);.};..templat
-00011a60: 653c 7479 7065 6e61 6d65 2053 6361 6c61  e<typename Scala
-00011a70: 722c 2074 7970 656e 616d 6520 496e 6465  r, typename Inde
-00011a80: 782c 2074 7970 656e 616d 6520 4461 7461  x, typename Data
-00011a90: 4d61 7070 6572 2c20 696e 7420 6e72 2c20  Mapper, int nr, 
-00011aa0: 626f 6f6c 2043 6f6e 6a75 6761 7465 2c20  bool Conjugate, 
-00011ab0: 626f 6f6c 2050 616e 656c 4d6f 6465 3e0a  bool PanelMode>.
-00011ac0: 4549 4745 4e5f 444f 4e54 5f49 4e4c 494e  EIGEN_DONT_INLIN
-00011ad0: 4520 766f 6964 2067 656d 6d5f 7061 636b  E void gemm_pack
-00011ae0: 5f72 6873 3c53 6361 6c61 722c 2049 6e64  _rhs<Scalar, Ind
-00011af0: 6578 2c20 4461 7461 4d61 7070 6572 2c20  ex, DataMapper, 
-00011b00: 6e72 2c20 436f 6c4d 616a 6f72 2c20 436f  nr, ColMajor, Co
-00011b10: 6e6a 7567 6174 652c 2050 616e 656c 4d6f  njugate, PanelMo
-00011b20: 6465 3e0a 2020 3a3a 6f70 6572 6174 6f72  de>.  ::operator
-00011b30: 2829 2853 6361 6c61 722a 2062 6c6f 636b  ()(Scalar* block
-00011b40: 422c 2063 6f6e 7374 2044 6174 614d 6170  B, const DataMap
-00011b50: 7065 7226 2072 6873 2c20 496e 6465 7820  per& rhs, Index 
-00011b60: 6465 7074 682c 2049 6e64 6578 2063 6f6c  depth, Index col
-00011b70: 732c 2049 6e64 6578 2073 7472 6964 652c  s, Index stride,
-00011b80: 2049 6e64 6578 206f 6666 7365 7429 0a7b   Index offset).{
-00011b90: 0a20 2045 4947 454e 5f41 534d 5f43 4f4d  .  EIGEN_ASM_COM
-00011ba0: 4d45 4e54 2822 4549 4745 4e20 5052 4f44  MENT("EIGEN PROD
-00011bb0: 5543 5420 5041 434b 2052 4853 2043 4f4c  UCT PACK RHS COL
-00011bc0: 4d41 4a4f 5222 293b 0a20 2045 4947 454e  MAJOR");.  EIGEN
-00011bd0: 5f55 4e55 5345 445f 5641 5249 4142 4c45  _UNUSED_VARIABLE
-00011be0: 2873 7472 6964 6529 3b0a 2020 4549 4745  (stride);.  EIGE
-00011bf0: 4e5f 554e 5553 4544 5f56 4152 4941 424c  N_UNUSED_VARIABL
-00011c00: 4528 6f66 6673 6574 293b 0a20 2065 6967  E(offset);.  eig
-00011c10: 656e 5f61 7373 6572 7428 2828 2150 616e  en_assert(((!Pan
-00011c20: 656c 4d6f 6465 2920 2626 2073 7472 6964  elMode) && strid
-00011c30: 653d 3d30 2026 2620 6f66 6673 6574 3d3d  e==0 && offset==
-00011c40: 3029 207c 7c20 2850 616e 656c 4d6f 6465  0) || (PanelMode
-00011c50: 2026 2620 7374 7269 6465 3e3d 6465 7074   && stride>=dept
-00011c60: 6820 2626 206f 6666 7365 743c 3d73 7472  h && offset<=str
-00011c70: 6964 6529 293b 0a20 2063 6f6e 6a5f 6966  ide));.  conj_if
-00011c80: 3c4e 756d 5472 6169 7473 3c53 6361 6c61  <NumTraits<Scala
-00011c90: 723e 3a3a 4973 436f 6d70 6c65 7820 2626  r>::IsComplex &&
-00011ca0: 2043 6f6e 6a75 6761 7465 3e20 636a 3b0a   Conjugate> cj;.
-00011cb0: 2020 496e 6465 7820 7061 636b 6574 5f63    Index packet_c
-00011cc0: 6f6c 7338 203d 206e 723e 3d38 203f 2028  ols8 = nr>=8 ? (
-00011cd0: 636f 6c73 2f38 2920 2a20 3820 3a20 303b  cols/8) * 8 : 0;
-00011ce0: 0a20 2049 6e64 6578 2070 6163 6b65 745f  .  Index packet_
-00011cf0: 636f 6c73 3420 3d20 6e72 3e3d 3420 3f20  cols4 = nr>=4 ? 
-00011d00: 2863 6f6c 732f 3429 202a 2034 203a 2030  (cols/4) * 4 : 0
-00011d10: 3b0a 2020 496e 6465 7820 636f 756e 7420  ;.  Index count 
-00011d20: 3d20 303b 0a20 2063 6f6e 7374 2049 6e64  = 0;.  const Ind
-00011d30: 6578 2070 6565 6c65 645f 6b20 3d20 2864  ex peeled_k = (d
-00011d40: 6570 7468 2f50 6163 6b65 7453 697a 6529  epth/PacketSize)
-00011d50: 2a50 6163 6b65 7453 697a 653b 0a2f 2f20  *PacketSize;.// 
-00011d60: 2020 6966 286e 723e 3d38 290a 2f2f 2020    if(nr>=8).//  
-00011d70: 207b 0a2f 2f20 2020 2020 666f 7228 496e   {.//     for(In
-00011d80: 6465 7820 6a32 3d30 3b20 6a32 3c70 6163  dex j2=0; j2<pac
-00011d90: 6b65 745f 636f 6c73 383b 206a 322b 3d38  ket_cols8; j2+=8
-00011da0: 290a 2f2f 2020 2020 207b 0a2f 2f20 2020  ).//     {.//   
-00011db0: 2020 2020 2f2f 2073 6b69 7020 7768 6174      // skip what
-00011dc0: 2077 6520 6861 7665 2062 6566 6f72 650a   we have before.
-00011dd0: 2f2f 2020 2020 2020 2069 6628 5061 6e65  //       if(Pane
-00011de0: 6c4d 6f64 6529 2063 6f75 6e74 202b 3d20  lMode) count += 
-00011df0: 3820 2a20 6f66 6673 6574 3b0a 2f2f 2020  8 * offset;.//  
-00011e00: 2020 2020 2063 6f6e 7374 2053 6361 6c61       const Scala
-00011e10: 722a 2062 3020 3d20 2672 6873 5b28 6a32  r* b0 = &rhs[(j2
-00011e20: 2b30 292a 7268 7353 7472 6964 655d 3b0a  +0)*rhsStride];.
-00011e30: 2f2f 2020 2020 2020 2063 6f6e 7374 2053  //       const S
-00011e40: 6361 6c61 722a 2062 3120 3d20 2672 6873  calar* b1 = &rhs
-00011e50: 5b28 6a32 2b31 292a 7268 7353 7472 6964  [(j2+1)*rhsStrid
-00011e60: 655d 3b0a 2f2f 2020 2020 2020 2063 6f6e  e];.//       con
-00011e70: 7374 2053 6361 6c61 722a 2062 3220 3d20  st Scalar* b2 = 
-00011e80: 2672 6873 5b28 6a32 2b32 292a 7268 7353  &rhs[(j2+2)*rhsS
-00011e90: 7472 6964 655d 3b0a 2f2f 2020 2020 2020  tride];.//      
-00011ea0: 2063 6f6e 7374 2053 6361 6c61 722a 2062   const Scalar* b
-00011eb0: 3320 3d20 2672 6873 5b28 6a32 2b33 292a  3 = &rhs[(j2+3)*
-00011ec0: 7268 7353 7472 6964 655d 3b0a 2f2f 2020  rhsStride];.//  
-00011ed0: 2020 2020 2063 6f6e 7374 2053 6361 6c61       const Scala
-00011ee0: 722a 2062 3420 3d20 2672 6873 5b28 6a32  r* b4 = &rhs[(j2
-00011ef0: 2b34 292a 7268 7353 7472 6964 655d 3b0a  +4)*rhsStride];.
-00011f00: 2f2f 2020 2020 2020 2063 6f6e 7374 2053  //       const S
-00011f10: 6361 6c61 722a 2062 3520 3d20 2672 6873  calar* b5 = &rhs
-00011f20: 5b28 6a32 2b35 292a 7268 7353 7472 6964  [(j2+5)*rhsStrid
-00011f30: 655d 3b0a 2f2f 2020 2020 2020 2063 6f6e  e];.//       con
-00011f40: 7374 2053 6361 6c61 722a 2062 3620 3d20  st Scalar* b6 = 
-00011f50: 2672 6873 5b28 6a32 2b36 292a 7268 7353  &rhs[(j2+6)*rhsS
-00011f60: 7472 6964 655d 3b0a 2f2f 2020 2020 2020  tride];.//      
-00011f70: 2063 6f6e 7374 2053 6361 6c61 722a 2062   const Scalar* b
-00011f80: 3720 3d20 2672 6873 5b28 6a32 2b37 292a  7 = &rhs[(j2+7)*
-00011f90: 7268 7353 7472 6964 655d 3b0a 2f2f 2020  rhsStride];.//  
-00011fa0: 2020 2020 2049 6e64 6578 206b 3d30 3b0a       Index k=0;.
-00011fb0: 2f2f 2020 2020 2020 2069 6628 5061 636b  //       if(Pack
-00011fc0: 6574 5369 7a65 3d3d 3829 202f 2f20 544f  etSize==8) // TO
-00011fd0: 444f 2065 6e62 616c 6520 7665 6374 6f72  DO enbale vector
-00011fe0: 697a 6564 2074 7261 6e73 706f 7369 7469  ized transpositi
-00011ff0: 6f6e 2066 6f72 2050 6163 6b65 7453 697a  on for PacketSiz
-00012000: 653d 3d34 0a2f 2f20 2020 2020 2020 7b0a  e==4.//       {.
-00012010: 2f2f 2020 2020 2020 2020 2066 6f72 283b  //         for(;
-00012020: 206b 3c70 6565 6c65 645f 6b3b 206b 2b3d   k<peeled_k; k+=
-00012030: 5061 636b 6574 5369 7a65 2920 7b0a 2f2f  PacketSize) {.//
-00012040: 2020 2020 2020 2020 2020 2050 6163 6b65             Packe
-00012050: 7442 6c6f 636b 3c50 6163 6b65 743e 206b  tBlock<Packet> k
-00012060: 6572 6e65 6c3b 0a2f 2f20 2020 2020 2020  ernel;.//       
-00012070: 2020 2020 666f 7220 2869 6e74 2070 203d      for (int p =
-00012080: 2030 3b20 7020 3c20 5061 636b 6574 5369   0; p < PacketSi
-00012090: 7a65 3b20 2b2b 7029 207b 0a2f 2f20 2020  ze; ++p) {.//   
-000120a0: 2020 2020 2020 2020 2020 6b65 726e 656c            kernel
-000120b0: 2e70 6163 6b65 745b 705d 203d 2070 6c6f  .packet[p] = plo
-000120c0: 6164 753c 5061 636b 6574 3e28 2672 6873  adu<Packet>(&rhs
-000120d0: 5b28 6a32 2b70 292a 7268 7353 7472 6964  [(j2+p)*rhsStrid
-000120e0: 652b 6b5d 293b 0a2f 2f20 2020 2020 2020  e+k]);.//       
-000120f0: 2020 2020 7d0a 2f2f 2020 2020 2020 2020      }.//        
-00012100: 2020 2070 7472 616e 7370 6f73 6528 6b65     ptranspose(ke
-00012110: 726e 656c 293b 0a2f 2f20 2020 2020 2020  rnel);.//       
-00012120: 2020 2020 666f 7220 2869 6e74 2070 203d      for (int p =
-00012130: 2030 3b20 7020 3c20 5061 636b 6574 5369   0; p < PacketSi
-00012140: 7a65 3b20 2b2b 7029 207b 0a2f 2f20 2020  ze; ++p) {.//   
-00012150: 2020 2020 2020 2020 2020 7073 746f 7265            pstore
-00012160: 7528 626c 6f63 6b42 2b63 6f75 6e74 2c20  u(blockB+count, 
-00012170: 636a 2e70 636f 6e6a 286b 6572 6e65 6c2e  cj.pconj(kernel.
-00012180: 7061 636b 6574 5b70 5d29 293b 0a2f 2f20  packet[p]));.// 
-00012190: 2020 2020 2020 2020 2020 2020 636f 756e              coun
-000121a0: 742b 3d50 6163 6b65 7453 697a 653b 0a2f  t+=PacketSize;./
-000121b0: 2f20 2020 2020 2020 2020 2020 7d0a 2f2f  /           }.//
-000121c0: 2020 2020 2020 2020 207d 0a2f 2f20 2020           }.//   
-000121d0: 2020 2020 7d0a 2f2f 2020 2020 2020 2066      }.//       f
-000121e0: 6f72 283b 206b 3c64 6570 7468 3b20 6b2b  or(; k<depth; k+
-000121f0: 2b29 0a2f 2f20 2020 2020 2020 7b0a 2f2f  +).//       {.//
-00012200: 2020 2020 2020 2020 2062 6c6f 636b 425b           blockB[
-00012210: 636f 756e 742b 305d 203d 2063 6a28 6230  count+0] = cj(b0
-00012220: 5b6b 5d29 3b0a 2f2f 2020 2020 2020 2020  [k]);.//        
-00012230: 2062 6c6f 636b 425b 636f 756e 742b 315d   blockB[count+1]
-00012240: 203d 2063 6a28 6231 5b6b 5d29 3b0a 2f2f   = cj(b1[k]);.//
-00012250: 2020 2020 2020 2020 2062 6c6f 636b 425b           blockB[
-00012260: 636f 756e 742b 325d 203d 2063 6a28 6232  count+2] = cj(b2
-00012270: 5b6b 5d29 3b0a 2f2f 2020 2020 2020 2020  [k]);.//        
-00012280: 2062 6c6f 636b 425b 636f 756e 742b 335d   blockB[count+3]
-00012290: 203d 2063 6a28 6233 5b6b 5d29 3b0a 2f2f   = cj(b3[k]);.//
-000122a0: 2020 2020 2020 2020 2062 6c6f 636b 425b           blockB[
-000122b0: 636f 756e 742b 345d 203d 2063 6a28 6234  count+4] = cj(b4
-000122c0: 5b6b 5d29 3b0a 2f2f 2020 2020 2020 2020  [k]);.//        
-000122d0: 2062 6c6f 636b 425b 636f 756e 742b 355d   blockB[count+5]
-000122e0: 203d 2063 6a28 6235 5b6b 5d29 3b0a 2f2f   = cj(b5[k]);.//
-000122f0: 2020 2020 2020 2020 2062 6c6f 636b 425b           blockB[
-00012300: 636f 756e 742b 365d 203d 2063 6a28 6236  count+6] = cj(b6
-00012310: 5b6b 5d29 3b0a 2f2f 2020 2020 2020 2020  [k]);.//        
-00012320: 2062 6c6f 636b 425b 636f 756e 742b 375d   blockB[count+7]
-00012330: 203d 2063 6a28 6237 5b6b 5d29 3b0a 2f2f   = cj(b7[k]);.//
-00012340: 2020 2020 2020 2020 2063 6f75 6e74 202b           count +
-00012350: 3d20 383b 0a2f 2f20 2020 2020 2020 7d0a  = 8;.//       }.
-00012360: 2f2f 2020 2020 2020 202f 2f20 736b 6970  //       // skip
-00012370: 2077 6861 7420 7765 2068 6176 6520 6166   what we have af
-00012380: 7465 720a 2f2f 2020 2020 2020 2069 6628  ter.//       if(
-00012390: 5061 6e65 6c4d 6f64 6529 2063 6f75 6e74  PanelMode) count
-000123a0: 202b 3d20 3820 2a20 2873 7472 6964 652d   += 8 * (stride-
-000123b0: 6f66 6673 6574 2d64 6570 7468 293b 0a2f  offset-depth);./
-000123c0: 2f20 2020 2020 7d0a 2f2f 2020 207d 0a0a  /     }.//   }..
-000123d0: 2020 6966 286e 723e 3d34 290a 2020 7b0a    if(nr>=4).  {.
-000123e0: 2020 2020 666f 7228 496e 6465 7820 6a32      for(Index j2
-000123f0: 3d70 6163 6b65 745f 636f 6c73 383b 206a  =packet_cols8; j
-00012400: 323c 7061 636b 6574 5f63 6f6c 7334 3b20  2<packet_cols4; 
-00012410: 6a32 2b3d 3429 0a20 2020 207b 0a20 2020  j2+=4).    {.   
-00012420: 2020 202f 2f20 736b 6970 2077 6861 7420     // skip what 
-00012430: 7765 2068 6176 6520 6265 666f 7265 0a20  we have before. 
-00012440: 2020 2020 2069 6628 5061 6e65 6c4d 6f64       if(PanelMod
-00012450: 6529 2063 6f75 6e74 202b 3d20 3420 2a20  e) count += 4 * 
-00012460: 6f66 6673 6574 3b0a 2020 2020 2020 636f  offset;.      co
-00012470: 6e73 7420 4c69 6e65 6172 4d61 7070 6572  nst LinearMapper
-00012480: 2064 6d30 203d 2072 6873 2e67 6574 4c69   dm0 = rhs.getLi
-00012490: 6e65 6172 4d61 7070 6572 2830 2c20 6a32  nearMapper(0, j2
-000124a0: 202b 2030 293b 0a20 2020 2020 2063 6f6e   + 0);.      con
-000124b0: 7374 204c 696e 6561 724d 6170 7065 7220  st LinearMapper 
-000124c0: 646d 3120 3d20 7268 732e 6765 744c 696e  dm1 = rhs.getLin
-000124d0: 6561 724d 6170 7065 7228 302c 206a 3220  earMapper(0, j2 
-000124e0: 2b20 3129 3b0a 2020 2020 2020 636f 6e73  + 1);.      cons
-000124f0: 7420 4c69 6e65 6172 4d61 7070 6572 2064  t LinearMapper d
-00012500: 6d32 203d 2072 6873 2e67 6574 4c69 6e65  m2 = rhs.getLine
-00012510: 6172 4d61 7070 6572 2830 2c20 6a32 202b  arMapper(0, j2 +
-00012520: 2032 293b 0a20 2020 2020 2063 6f6e 7374   2);.      const
-00012530: 204c 696e 6561 724d 6170 7065 7220 646d   LinearMapper dm
-00012540: 3320 3d20 7268 732e 6765 744c 696e 6561  3 = rhs.getLinea
-00012550: 724d 6170 7065 7228 302c 206a 3220 2b20  rMapper(0, j2 + 
-00012560: 3329 3b0a 0a20 2020 2020 2049 6e64 6578  3);..      Index
-00012570: 206b 3d30 3b0a 2020 2020 2020 6966 2828   k=0;.      if((
-00012580: 5061 636b 6574 5369 7a65 2534 293d 3d30  PacketSize%4)==0
-00012590: 2920 2f2f 2054 4f44 4f20 656e 6162 6c65  ) // TODO enable
-000125a0: 2076 6563 746f 7269 7a65 6420 7472 616e   vectorized tran
-000125b0: 7370 6f73 6974 696f 6e20 666f 7220 5061  sposition for Pa
-000125c0: 636b 6574 5369 7a65 3d3d 3220 3f3f 0a20  cketSize==2 ??. 
-000125d0: 2020 2020 207b 0a20 2020 2020 2020 2066       {.        f
-000125e0: 6f72 283b 206b 3c70 6565 6c65 645f 6b3b  or(; k<peeled_k;
-000125f0: 206b 2b3d 5061 636b 6574 5369 7a65 2920   k+=PacketSize) 
-00012600: 7b0a 2020 2020 2020 2020 2020 5061 636b  {.          Pack
-00012610: 6574 426c 6f63 6b3c 5061 636b 6574 2c28  etBlock<Packet,(
-00012620: 5061 636b 6574 5369 7a65 2534 293d 3d30  PacketSize%4)==0
-00012630: 3f34 3a50 6163 6b65 7453 697a 653e 206b  ?4:PacketSize> k
-00012640: 6572 6e65 6c3b 0a20 2020 2020 2020 2020  ernel;.         
-00012650: 206b 6572 6e65 6c2e 7061 636b 6574 5b30   kernel.packet[0
-00012660: 5d20 3d20 646d 302e 6c6f 6164 5061 636b  ] = dm0.loadPack
-00012670: 6574 286b 293b 0a20 2020 2020 2020 2020  et(k);.         
-00012680: 206b 6572 6e65 6c2e 7061 636b 6574 5b31   kernel.packet[1
-00012690: 2550 6163 6b65 7453 697a 655d 203d 2064  %PacketSize] = d
-000126a0: 6d31 2e6c 6f61 6450 6163 6b65 7428 6b29  m1.loadPacket(k)
-000126b0: 3b0a 2020 2020 2020 2020 2020 6b65 726e  ;.          kern
-000126c0: 656c 2e70 6163 6b65 745b 3225 5061 636b  el.packet[2%Pack
-000126d0: 6574 5369 7a65 5d20 3d20 646d 322e 6c6f  etSize] = dm2.lo
-000126e0: 6164 5061 636b 6574 286b 293b 0a20 2020  adPacket(k);.   
-000126f0: 2020 2020 2020 206b 6572 6e65 6c2e 7061         kernel.pa
-00012700: 636b 6574 5b33 2550 6163 6b65 7453 697a  cket[3%PacketSiz
-00012710: 655d 203d 2064 6d33 2e6c 6f61 6450 6163  e] = dm3.loadPac
-00012720: 6b65 7428 6b29 3b0a 2020 2020 2020 2020  ket(k);.        
-00012730: 2020 7074 7261 6e73 706f 7365 286b 6572    ptranspose(ker
-00012740: 6e65 6c29 3b0a 2020 2020 2020 2020 2020  nel);.          
-00012750: 7073 746f 7265 7528 626c 6f63 6b42 2b63  pstoreu(blockB+c
-00012760: 6f75 6e74 2b30 2a50 6163 6b65 7453 697a  ount+0*PacketSiz
-00012770: 652c 2063 6a2e 7063 6f6e 6a28 6b65 726e  e, cj.pconj(kern
-00012780: 656c 2e70 6163 6b65 745b 305d 2929 3b0a  el.packet[0]));.
-00012790: 2020 2020 2020 2020 2020 7073 746f 7265            pstore
-000127a0: 7528 626c 6f63 6b42 2b63 6f75 6e74 2b31  u(blockB+count+1
-000127b0: 2a50 6163 6b65 7453 697a 652c 2063 6a2e  *PacketSize, cj.
-000127c0: 7063 6f6e 6a28 6b65 726e 656c 2e70 6163  pconj(kernel.pac
-000127d0: 6b65 745b 3125 5061 636b 6574 5369 7a65  ket[1%PacketSize
-000127e0: 5d29 293b 0a20 2020 2020 2020 2020 2070  ]));.          p
-000127f0: 7374 6f72 6575 2862 6c6f 636b 422b 636f  storeu(blockB+co
-00012800: 756e 742b 322a 5061 636b 6574 5369 7a65  unt+2*PacketSize
-00012810: 2c20 636a 2e70 636f 6e6a 286b 6572 6e65  , cj.pconj(kerne
-00012820: 6c2e 7061 636b 6574 5b32 2550 6163 6b65  l.packet[2%Packe
-00012830: 7453 697a 655d 2929 3b0a 2020 2020 2020  tSize]));.      
-00012840: 2020 2020 7073 746f 7265 7528 626c 6f63      pstoreu(bloc
-00012850: 6b42 2b63 6f75 6e74 2b33 2a50 6163 6b65  kB+count+3*Packe
-00012860: 7453 697a 652c 2063 6a2e 7063 6f6e 6a28  tSize, cj.pconj(
-00012870: 6b65 726e 656c 2e70 6163 6b65 745b 3325  kernel.packet[3%
-00012880: 5061 636b 6574 5369 7a65 5d29 293b 0a20  PacketSize]));. 
-00012890: 2020 2020 2020 2020 2063 6f75 6e74 2b3d           count+=
-000128a0: 342a 5061 636b 6574 5369 7a65 3b0a 2020  4*PacketSize;.  
-000128b0: 2020 2020 2020 7d0a 2020 2020 2020 7d0a        }.      }.
-000128c0: 2020 2020 2020 666f 7228 3b20 6b3c 6465        for(; k<de
-000128d0: 7074 683b 206b 2b2b 290a 2020 2020 2020  pth; k++).      
-000128e0: 7b0a 2020 2020 2020 2020 626c 6f63 6b42  {.        blockB
-000128f0: 5b63 6f75 6e74 2b30 5d20 3d20 636a 2864  [count+0] = cj(d
-00012900: 6d30 286b 2929 3b0a 2020 2020 2020 2020  m0(k));.        
-00012910: 626c 6f63 6b42 5b63 6f75 6e74 2b31 5d20  blockB[count+1] 
-00012920: 3d20 636a 2864 6d31 286b 2929 3b0a 2020  = cj(dm1(k));.  
-00012930: 2020 2020 2020 626c 6f63 6b42 5b63 6f75        blockB[cou
-00012940: 6e74 2b32 5d20 3d20 636a 2864 6d32 286b  nt+2] = cj(dm2(k
-00012950: 2929 3b0a 2020 2020 2020 2020 626c 6f63  ));.        bloc
-00012960: 6b42 5b63 6f75 6e74 2b33 5d20 3d20 636a  kB[count+3] = cj
-00012970: 2864 6d33 286b 2929 3b0a 2020 2020 2020  (dm3(k));.      
-00012980: 2020 636f 756e 7420 2b3d 2034 3b0a 2020    count += 4;.  
-00012990: 2020 2020 7d0a 2020 2020 2020 2f2f 2073      }.      // s
-000129a0: 6b69 7020 7768 6174 2077 6520 6861 7665  kip what we have
-000129b0: 2061 6674 6572 0a20 2020 2020 2069 6628   after.      if(
-000129c0: 5061 6e65 6c4d 6f64 6529 2063 6f75 6e74  PanelMode) count
-000129d0: 202b 3d20 3420 2a20 2873 7472 6964 652d   += 4 * (stride-
-000129e0: 6f66 6673 6574 2d64 6570 7468 293b 0a20  offset-depth);. 
-000129f0: 2020 207d 0a20 207d 0a0a 2020 2f2f 2063     }.  }..  // c
-00012a00: 6f70 7920 7468 6520 7265 6d61 696e 696e  opy the remainin
-00012a10: 6720 636f 6c75 6d6e 7320 6f6e 6520 6174  g columns one at
-00012a20: 2061 2074 696d 6520 286e 723d 3d31 290a   a time (nr==1).
-00012a30: 2020 666f 7228 496e 6465 7820 6a32 3d70    for(Index j2=p
-00012a40: 6163 6b65 745f 636f 6c73 343b 206a 323c  acket_cols4; j2<
-00012a50: 636f 6c73 3b20 2b2b 6a32 290a 2020 7b0a  cols; ++j2).  {.
-00012a60: 2020 2020 6966 2850 616e 656c 4d6f 6465      if(PanelMode
-00012a70: 2920 636f 756e 7420 2b3d 206f 6666 7365  ) count += offse
-00012a80: 743b 0a20 2020 2063 6f6e 7374 204c 696e  t;.    const Lin
-00012a90: 6561 724d 6170 7065 7220 646d 3020 3d20  earMapper dm0 = 
-00012aa0: 7268 732e 6765 744c 696e 6561 724d 6170  rhs.getLinearMap
-00012ab0: 7065 7228 302c 206a 3229 3b0a 2020 2020  per(0, j2);.    
-00012ac0: 666f 7228 496e 6465 7820 6b3d 303b 206b  for(Index k=0; k
-00012ad0: 3c64 6570 7468 3b20 6b2b 2b29 0a20 2020  <depth; k++).   
-00012ae0: 207b 0a20 2020 2020 2062 6c6f 636b 425b   {.      blockB[
-00012af0: 636f 756e 745d 203d 2063 6a28 646d 3028  count] = cj(dm0(
-00012b00: 6b29 293b 0a20 2020 2020 2063 6f75 6e74  k));.      count
-00012b10: 202b 3d20 313b 0a20 2020 207d 0a20 2020   += 1;.    }.   
-00012b20: 2069 6628 5061 6e65 6c4d 6f64 6529 2063   if(PanelMode) c
-00012b30: 6f75 6e74 202b 3d20 2873 7472 6964 652d  ount += (stride-
-00012b40: 6f66 6673 6574 2d64 6570 7468 293b 0a20  offset-depth);. 
-00012b50: 207d 0a7d 0a0a 2f2f 2074 6869 7320 7665   }.}..// this ve
-00012b60: 7273 696f 6e20 6973 206f 7074 696d 697a  rsion is optimiz
-00012b70: 6564 2066 6f72 2072 6f77 206d 616a 6f72  ed for row major
-00012b80: 206d 6174 7269 6365 730a 7465 6d70 6c61   matrices.templa
-00012b90: 7465 3c74 7970 656e 616d 6520 5363 616c  te<typename Scal
-00012ba0: 6172 2c20 7479 7065 6e61 6d65 2049 6e64  ar, typename Ind
-00012bb0: 6578 2c20 7479 7065 6e61 6d65 2044 6174  ex, typename Dat
-00012bc0: 614d 6170 7065 722c 2069 6e74 206e 722c  aMapper, int nr,
-00012bd0: 2062 6f6f 6c20 436f 6e6a 7567 6174 652c   bool Conjugate,
-00012be0: 2062 6f6f 6c20 5061 6e65 6c4d 6f64 653e   bool PanelMode>
-00012bf0: 0a73 7472 7563 7420 6765 6d6d 5f70 6163  .struct gemm_pac
-00012c00: 6b5f 7268 733c 5363 616c 6172 2c20 496e  k_rhs<Scalar, In
-00012c10: 6465 782c 2044 6174 614d 6170 7065 722c  dex, DataMapper,
-00012c20: 206e 722c 2052 6f77 4d61 6a6f 722c 2043   nr, RowMajor, C
-00012c30: 6f6e 6a75 6761 7465 2c20 5061 6e65 6c4d  onjugate, PanelM
-00012c40: 6f64 653e 0a7b 0a20 2074 7970 6564 6566  ode>.{.  typedef
-00012c50: 2074 7970 656e 616d 6520 7061 636b 6574   typename packet
-00012c60: 5f74 7261 6974 733c 5363 616c 6172 3e3a  _traits<Scalar>:
-00012c70: 3a74 7970 6520 5061 636b 6574 3b0a 2020  :type Packet;.  
-00012c80: 7479 7065 6465 6620 7479 7065 6e61 6d65  typedef typename
-00012c90: 2044 6174 614d 6170 7065 723a 3a4c 696e   DataMapper::Lin
-00012ca0: 6561 724d 6170 7065 7220 4c69 6e65 6172  earMapper Linear
-00012cb0: 4d61 7070 6572 3b0a 2020 656e 756d 207b  Mapper;.  enum {
-00012cc0: 2050 6163 6b65 7453 697a 6520 3d20 7061   PacketSize = pa
-00012cd0: 636b 6574 5f74 7261 6974 733c 5363 616c  cket_traits<Scal
-00012ce0: 6172 3e3a 3a73 697a 6520 7d3b 0a20 2045  ar>::size };.  E
-00012cf0: 4947 454e 5f44 4f4e 545f 494e 4c49 4e45  IGEN_DONT_INLINE
-00012d00: 2076 6f69 6420 6f70 6572 6174 6f72 2829   void operator()
-00012d10: 2853 6361 6c61 722a 2062 6c6f 636b 422c  (Scalar* blockB,
-00012d20: 2063 6f6e 7374 2044 6174 614d 6170 7065   const DataMappe
-00012d30: 7226 2072 6873 2c20 496e 6465 7820 6465  r& rhs, Index de
-00012d40: 7074 682c 2049 6e64 6578 2063 6f6c 732c  pth, Index cols,
-00012d50: 2049 6e64 6578 2073 7472 6964 653d 302c   Index stride=0,
-00012d60: 2049 6e64 6578 206f 6666 7365 743d 3029   Index offset=0)
-00012d70: 3b0a 7d3b 0a0a 7465 6d70 6c61 7465 3c74  ;.};..template<t
-00012d80: 7970 656e 616d 6520 5363 616c 6172 2c20  ypename Scalar, 
-00012d90: 7479 7065 6e61 6d65 2049 6e64 6578 2c20  typename Index, 
-00012da0: 7479 7065 6e61 6d65 2044 6174 614d 6170  typename DataMap
-00012db0: 7065 722c 2069 6e74 206e 722c 2062 6f6f  per, int nr, boo
-00012dc0: 6c20 436f 6e6a 7567 6174 652c 2062 6f6f  l Conjugate, boo
-00012dd0: 6c20 5061 6e65 6c4d 6f64 653e 0a45 4947  l PanelMode>.EIG
-00012de0: 454e 5f44 4f4e 545f 494e 4c49 4e45 2076  EN_DONT_INLINE v
-00012df0: 6f69 6420 6765 6d6d 5f70 6163 6b5f 7268  oid gemm_pack_rh
-00012e00: 733c 5363 616c 6172 2c20 496e 6465 782c  s<Scalar, Index,
-00012e10: 2044 6174 614d 6170 7065 722c 206e 722c   DataMapper, nr,
-00012e20: 2052 6f77 4d61 6a6f 722c 2043 6f6e 6a75   RowMajor, Conju
-00012e30: 6761 7465 2c20 5061 6e65 6c4d 6f64 653e  gate, PanelMode>
-00012e40: 0a20 203a 3a6f 7065 7261 746f 7228 2928  .  ::operator()(
-00012e50: 5363 616c 6172 2a20 626c 6f63 6b42 2c20  Scalar* blockB, 
-00012e60: 636f 6e73 7420 4461 7461 4d61 7070 6572  const DataMapper
-00012e70: 2620 7268 732c 2049 6e64 6578 2064 6570  & rhs, Index dep
-00012e80: 7468 2c20 496e 6465 7820 636f 6c73 2c20  th, Index cols, 
-00012e90: 496e 6465 7820 7374 7269 6465 2c20 496e  Index stride, In
-00012ea0: 6465 7820 6f66 6673 6574 290a 7b0a 2020  dex offset).{.  
-00012eb0: 4549 4745 4e5f 4153 4d5f 434f 4d4d 454e  EIGEN_ASM_COMMEN
-00012ec0: 5428 2245 4947 454e 2050 524f 4455 4354  T("EIGEN PRODUCT
-00012ed0: 2050 4143 4b20 5248 5320 524f 574d 414a   PACK RHS ROWMAJ
-00012ee0: 4f52 2229 3b0a 2020 4549 4745 4e5f 554e  OR");.  EIGEN_UN
-00012ef0: 5553 4544 5f56 4152 4941 424c 4528 7374  USED_VARIABLE(st
-00012f00: 7269 6465 293b 0a20 2045 4947 454e 5f55  ride);.  EIGEN_U
-00012f10: 4e55 5345 445f 5641 5249 4142 4c45 286f  NUSED_VARIABLE(o
-00012f20: 6666 7365 7429 3b0a 2020 6569 6765 6e5f  ffset);.  eigen_
-00012f30: 6173 7365 7274 2828 2821 5061 6e65 6c4d  assert(((!PanelM
-00012f40: 6f64 6529 2026 2620 7374 7269 6465 3d3d  ode) && stride==
-00012f50: 3020 2626 206f 6666 7365 743d 3d30 2920  0 && offset==0) 
-00012f60: 7c7c 2028 5061 6e65 6c4d 6f64 6520 2626  || (PanelMode &&
-00012f70: 2073 7472 6964 653e 3d64 6570 7468 2026   stride>=depth &
-00012f80: 2620 6f66 6673 6574 3c3d 7374 7269 6465  & offset<=stride
-00012f90: 2929 3b0a 2020 636f 6e6a 5f69 663c 4e75  ));.  conj_if<Nu
-00012fa0: 6d54 7261 6974 733c 5363 616c 6172 3e3a  mTraits<Scalar>:
-00012fb0: 3a49 7343 6f6d 706c 6578 2026 2620 436f  :IsComplex && Co
-00012fc0: 6e6a 7567 6174 653e 2063 6a3b 0a20 2049  njugate> cj;.  I
-00012fd0: 6e64 6578 2070 6163 6b65 745f 636f 6c73  ndex packet_cols
-00012fe0: 3820 3d20 6e72 3e3d 3820 3f20 2863 6f6c  8 = nr>=8 ? (col
-00012ff0: 732f 3829 202a 2038 203a 2030 3b0a 2020  s/8) * 8 : 0;.  
-00013000: 496e 6465 7820 7061 636b 6574 5f63 6f6c  Index packet_col
-00013010: 7334 203d 206e 723e 3d34 203f 2028 636f  s4 = nr>=4 ? (co
-00013020: 6c73 2f34 2920 2a20 3420 3a20 303b 0a20  ls/4) * 4 : 0;. 
-00013030: 2049 6e64 6578 2063 6f75 6e74 203d 2030   Index count = 0
-00013040: 3b0a 0a2f 2f20 2020 6966 286e 723e 3d38  ;..//   if(nr>=8
-00013050: 290a 2f2f 2020 207b 0a2f 2f20 2020 2020  ).//   {.//     
-00013060: 666f 7228 496e 6465 7820 6a32 3d30 3b20  for(Index j2=0; 
-00013070: 6a32 3c70 6163 6b65 745f 636f 6c73 383b  j2<packet_cols8;
-00013080: 206a 322b 3d38 290a 2f2f 2020 2020 207b   j2+=8).//     {
-00013090: 0a2f 2f20 2020 2020 2020 2f2f 2073 6b69  .//       // ski
-000130a0: 7020 7768 6174 2077 6520 6861 7665 2062  p what we have b
-000130b0: 6566 6f72 650a 2f2f 2020 2020 2020 2069  efore.//       i
-000130c0: 6628 5061 6e65 6c4d 6f64 6529 2063 6f75  f(PanelMode) cou
-000130d0: 6e74 202b 3d20 3820 2a20 6f66 6673 6574  nt += 8 * offset
-000130e0: 3b0a 2f2f 2020 2020 2020 2066 6f72 2849  ;.//       for(I
-000130f0: 6e64 6578 206b 3d30 3b20 6b3c 6465 7074  ndex k=0; k<dept
-00013100: 683b 206b 2b2b 290a 2f2f 2020 2020 2020  h; k++).//      
-00013110: 207b 0a2f 2f20 2020 2020 2020 2020 6966   {.//         if
-00013120: 2028 5061 636b 6574 5369 7a65 3d3d 3829   (PacketSize==8)
-00013130: 207b 0a2f 2f20 2020 2020 2020 2020 2020   {.//           
-00013140: 5061 636b 6574 2041 203d 2070 6c6f 6164  Packet A = pload
-00013150: 753c 5061 636b 6574 3e28 2672 6873 5b6b  u<Packet>(&rhs[k
-00013160: 2a72 6873 5374 7269 6465 202b 206a 325d  *rhsStride + j2]
-00013170: 293b 0a2f 2f20 2020 2020 2020 2020 2020  );.//           
-00013180: 7073 746f 7265 7528 626c 6f63 6b42 2b63  pstoreu(blockB+c
-00013190: 6f75 6e74 2c20 636a 2e70 636f 6e6a 2841  ount, cj.pconj(A
-000131a0: 2929 3b0a 2f2f 2020 2020 2020 2020 207d  ));.//         }
-000131b0: 2065 6c73 6520 6966 2028 5061 636b 6574   else if (Packet
-000131c0: 5369 7a65 3d3d 3429 207b 0a2f 2f20 2020  Size==4) {.//   
-000131d0: 2020 2020 2020 2020 5061 636b 6574 2041          Packet A
-000131e0: 203d 2070 6c6f 6164 753c 5061 636b 6574   = ploadu<Packet
-000131f0: 3e28 2672 6873 5b6b 2a72 6873 5374 7269  >(&rhs[k*rhsStri
-00013200: 6465 202b 206a 325d 293b 0a2f 2f20 2020  de + j2]);.//   
-00013210: 2020 2020 2020 2020 5061 636b 6574 2042          Packet B
-00013220: 203d 2070 6c6f 6164 753c 5061 636b 6574   = ploadu<Packet
-00013230: 3e28 2672 6873 5b6b 2a72 6873 5374 7269  >(&rhs[k*rhsStri
-00013240: 6465 202b 206a 3220 2b20 5061 636b 6574  de + j2 + Packet
-00013250: 5369 7a65 5d29 3b0a 2f2f 2020 2020 2020  Size]);.//      
-00013260: 2020 2020 2070 7374 6f72 6575 2862 6c6f       pstoreu(blo
-00013270: 636b 422b 636f 756e 742c 2063 6a2e 7063  ckB+count, cj.pc
-00013280: 6f6e 6a28 4129 293b 0a2f 2f20 2020 2020  onj(A));.//     
-00013290: 2020 2020 2020 7073 746f 7265 7528 626c        pstoreu(bl
-000132a0: 6f63 6b42 2b63 6f75 6e74 2b50 6163 6b65  ockB+count+Packe
-000132b0: 7453 697a 652c 2063 6a2e 7063 6f6e 6a28  tSize, cj.pconj(
-000132c0: 4229 293b 0a2f 2f20 2020 2020 2020 2020  B));.//         
-000132d0: 7d20 656c 7365 207b 0a2f 2f20 2020 2020  } else {.//     
-000132e0: 2020 2020 2020 636f 6e73 7420 5363 616c        const Scal
-000132f0: 6172 2a20 6230 203d 2026 7268 735b 6b2a  ar* b0 = &rhs[k*
-00013300: 7268 7353 7472 6964 6520 2b20 6a32 5d3b  rhsStride + j2];
-00013310: 0a2f 2f20 2020 2020 2020 2020 2020 626c  .//           bl
-00013320: 6f63 6b42 5b63 6f75 6e74 2b30 5d20 3d20  ockB[count+0] = 
-00013330: 636a 2862 305b 305d 293b 0a2f 2f20 2020  cj(b0[0]);.//   
-00013340: 2020 2020 2020 2020 626c 6f63 6b42 5b63          blockB[c
-00013350: 6f75 6e74 2b31 5d20 3d20 636a 2862 305b  ount+1] = cj(b0[
-00013360: 315d 293b 0a2f 2f20 2020 2020 2020 2020  1]);.//         
-00013370: 2020 626c 6f63 6b42 5b63 6f75 6e74 2b32    blockB[count+2
-00013380: 5d20 3d20 636a 2862 305b 325d 293b 0a2f  ] = cj(b0[2]);./
-00013390: 2f20 2020 2020 2020 2020 2020 626c 6f63  /           bloc
-000133a0: 6b42 5b63 6f75 6e74 2b33 5d20 3d20 636a  kB[count+3] = cj
-000133b0: 2862 305b 335d 293b 0a2f 2f20 2020 2020  (b0[3]);.//     
-000133c0: 2020 2020 2020 626c 6f63 6b42 5b63 6f75        blockB[cou
-000133d0: 6e74 2b34 5d20 3d20 636a 2862 305b 345d  nt+4] = cj(b0[4]
-000133e0: 293b 0a2f 2f20 2020 2020 2020 2020 2020  );.//           
-000133f0: 626c 6f63 6b42 5b63 6f75 6e74 2b35 5d20  blockB[count+5] 
-00013400: 3d20 636a 2862 305b 355d 293b 0a2f 2f20  = cj(b0[5]);.// 
-00013410: 2020 2020 2020 2020 2020 626c 6f63 6b42            blockB
-00013420: 5b63 6f75 6e74 2b36 5d20 3d20 636a 2862  [count+6] = cj(b
-00013430: 305b 365d 293b 0a2f 2f20 2020 2020 2020  0[6]);.//       
-00013440: 2020 2020 626c 6f63 6b42 5b63 6f75 6e74      blockB[count
-00013450: 2b37 5d20 3d20 636a 2862 305b 375d 293b  +7] = cj(b0[7]);
-00013460: 0a2f 2f20 2020 2020 2020 2020 7d0a 2f2f  .//         }.//
-00013470: 2020 2020 2020 2020 2063 6f75 6e74 202b           count +
-00013480: 3d20 383b 0a2f 2f20 2020 2020 2020 7d0a  = 8;.//       }.
-00013490: 2f2f 2020 2020 2020 202f 2f20 736b 6970  //       // skip
-000134a0: 2077 6861 7420 7765 2068 6176 6520 6166   what we have af
-000134b0: 7465 720a 2f2f 2020 2020 2020 2069 6628  ter.//       if(
-000134c0: 5061 6e65 6c4d 6f64 6529 2063 6f75 6e74  PanelMode) count
-000134d0: 202b 3d20 3820 2a20 2873 7472 6964 652d   += 8 * (stride-
-000134e0: 6f66 6673 6574 2d64 6570 7468 293b 0a2f  offset-depth);./
-000134f0: 2f20 2020 2020 7d0a 2f2f 2020 207d 0a20  /     }.//   }. 
-00013500: 2069 6628 6e72 3e3d 3429 0a20 207b 0a20   if(nr>=4).  {. 
-00013510: 2020 2066 6f72 2849 6e64 6578 206a 323d     for(Index j2=
-00013520: 7061 636b 6574 5f63 6f6c 7338 3b20 6a32  packet_cols8; j2
-00013530: 3c70 6163 6b65 745f 636f 6c73 343b 206a  <packet_cols4; j
-00013540: 322b 3d34 290a 2020 2020 7b0a 2020 2020  2+=4).    {.    
-00013550: 2020 2f2f 2073 6b69 7020 7768 6174 2077    // skip what w
-00013560: 6520 6861 7665 2062 6566 6f72 650a 2020  e have before.  
-00013570: 2020 2020 6966 2850 616e 656c 4d6f 6465      if(PanelMode
-00013580: 2920 636f 756e 7420 2b3d 2034 202a 206f  ) count += 4 * o
-00013590: 6666 7365 743b 0a20 2020 2020 2066 6f72  ffset;.      for
-000135a0: 2849 6e64 6578 206b 3d30 3b20 6b3c 6465  (Index k=0; k<de
-000135b0: 7074 683b 206b 2b2b 290a 2020 2020 2020  pth; k++).      
-000135c0: 7b0a 2020 2020 2020 2020 6966 2028 5061  {.        if (Pa
-000135d0: 636b 6574 5369 7a65 3d3d 3429 207b 0a20  cketSize==4) {. 
-000135e0: 2020 2020 2020 2020 2050 6163 6b65 7420           Packet 
-000135f0: 4120 3d20 7268 732e 6c6f 6164 5061 636b  A = rhs.loadPack
-00013600: 6574 286b 2c20 6a32 293b 0a20 2020 2020  et(k, j2);.     
-00013610: 2020 2020 2070 7374 6f72 6575 2862 6c6f       pstoreu(blo
-00013620: 636b 422b 636f 756e 742c 2063 6a2e 7063  ckB+count, cj.pc
-00013630: 6f6e 6a28 4129 293b 0a20 2020 2020 2020  onj(A));.       
-00013640: 2020 2063 6f75 6e74 202b 3d20 5061 636b     count += Pack
-00013650: 6574 5369 7a65 3b0a 2020 2020 2020 2020  etSize;.        
-00013660: 7d20 656c 7365 207b 0a20 2020 2020 2020  } else {.       
-00013670: 2020 2063 6f6e 7374 204c 696e 6561 724d     const LinearM
-00013680: 6170 7065 7220 646d 3020 3d20 7268 732e  apper dm0 = rhs.
-00013690: 6765 744c 696e 6561 724d 6170 7065 7228  getLinearMapper(
-000136a0: 6b2c 206a 3229 3b0a 2020 2020 2020 2020  k, j2);.        
-000136b0: 2020 626c 6f63 6b42 5b63 6f75 6e74 2b30    blockB[count+0
-000136c0: 5d20 3d20 636a 2864 6d30 2830 2929 3b0a  ] = cj(dm0(0));.
-000136d0: 2020 2020 2020 2020 2020 626c 6f63 6b42            blockB
-000136e0: 5b63 6f75 6e74 2b31 5d20 3d20 636a 2864  [count+1] = cj(d
-000136f0: 6d30 2831 2929 3b0a 2020 2020 2020 2020  m0(1));.        
-00013700: 2020 626c 6f63 6b42 5b63 6f75 6e74 2b32    blockB[count+2
-00013710: 5d20 3d20 636a 2864 6d30 2832 2929 3b0a  ] = cj(dm0(2));.
-00013720: 2020 2020 2020 2020 2020 626c 6f63 6b42            blockB
-00013730: 5b63 6f75 6e74 2b33 5d20 3d20 636a 2864  [count+3] = cj(d
-00013740: 6d30 2833 2929 3b0a 2020 2020 2020 2020  m0(3));.        
-00013750: 2020 636f 756e 7420 2b3d 2034 3b0a 2020    count += 4;.  
-00013760: 2020 2020 2020 7d0a 2020 2020 2020 7d0a        }.      }.
-00013770: 2020 2020 2020 2f2f 2073 6b69 7020 7768        // skip wh
-00013780: 6174 2077 6520 6861 7665 2061 6674 6572  at we have after
-00013790: 0a20 2020 2020 2069 6628 5061 6e65 6c4d  .      if(PanelM
-000137a0: 6f64 6529 2063 6f75 6e74 202b 3d20 3420  ode) count += 4 
-000137b0: 2a20 2873 7472 6964 652d 6f66 6673 6574  * (stride-offset
-000137c0: 2d64 6570 7468 293b 0a20 2020 207d 0a20  -depth);.    }. 
-000137d0: 207d 0a20 202f 2f20 636f 7079 2074 6865   }.  // copy the
-000137e0: 2072 656d 6169 6e69 6e67 2063 6f6c 756d   remaining colum
-000137f0: 6e73 206f 6e65 2061 7420 6120 7469 6d65  ns one at a time
-00013800: 2028 6e72 3d3d 3129 0a20 2066 6f72 2849   (nr==1).  for(I
-00013810: 6e64 6578 206a 323d 7061 636b 6574 5f63  ndex j2=packet_c
-00013820: 6f6c 7334 3b20 6a32 3c63 6f6c 733b 202b  ols4; j2<cols; +
-00013830: 2b6a 3229 0a20 207b 0a20 2020 2069 6628  +j2).  {.    if(
-00013840: 5061 6e65 6c4d 6f64 6529 2063 6f75 6e74  PanelMode) count
-00013850: 202b 3d20 6f66 6673 6574 3b0a 2020 2020   += offset;.    
-00013860: 666f 7228 496e 6465 7820 6b3d 303b 206b  for(Index k=0; k
-00013870: 3c64 6570 7468 3b20 6b2b 2b29 0a20 2020  <depth; k++).   
-00013880: 207b 0a20 2020 2020 2062 6c6f 636b 425b   {.      blockB[
-00013890: 636f 756e 745d 203d 2063 6a28 7268 7328  count] = cj(rhs(
-000138a0: 6b2c 206a 3229 293b 0a20 2020 2020 2063  k, j2));.      c
-000138b0: 6f75 6e74 202b 3d20 313b 0a20 2020 207d  ount += 1;.    }
-000138c0: 0a20 2020 2069 6628 5061 6e65 6c4d 6f64  .    if(PanelMod
-000138d0: 6529 2063 6f75 6e74 202b 3d20 7374 7269  e) count += stri
-000138e0: 6465 2d6f 6666 7365 742d 6465 7074 683b  de-offset-depth;
-000138f0: 0a20 207d 0a7d 0a0a 7d20 2f2f 2065 6e64  .  }.}..} // end
-00013900: 206e 616d 6573 7061 6365 2069 6e74 6572   namespace inter
-00013910: 6e61 6c0a 0a2f 2a2a 205c 7265 7475 726e  nal../** \return
-00013920: 7320 7468 6520 6375 7272 656e 746c 7920  s the currently 
-00013930: 7365 7420 6c65 7665 6c20 3120 6370 7520  set level 1 cpu 
-00013940: 6361 6368 6520 7369 7a65 2028 696e 2062  cache size (in b
-00013950: 7974 6573 2920 7573 6564 2074 6f20 6573  ytes) used to es
-00013960: 7469 6d61 7465 2074 6865 2069 6465 616c  timate the ideal
-00013970: 2062 6c6f 636b 696e 6720 7369 7a65 2070   blocking size p
-00013980: 6172 616d 6574 6572 732e 0a20 202a 205c  arameters..  * \
-00013990: 7361 2073 6574 4370 7543 6163 6865 5369  sa setCpuCacheSi
-000139a0: 7a65 202a 2f0a 696e 6c69 6e65 2073 7464  ze */.inline std
-000139b0: 3a3a 7074 7264 6966 665f 7420 6c31 4361  ::ptrdiff_t l1Ca
-000139c0: 6368 6553 697a 6528 290a 7b0a 2020 7374  cheSize().{.  st
-000139d0: 643a 3a70 7472 6469 6666 5f74 206c 312c  d::ptrdiff_t l1,
-000139e0: 206c 322c 206c 333b 0a20 2069 6e74 6572   l2, l3;.  inter
-000139f0: 6e61 6c3a 3a6d 616e 6167 655f 6361 6368  nal::manage_cach
-00013a00: 696e 675f 7369 7a65 7328 4765 7441 6374  ing_sizes(GetAct
-00013a10: 696f 6e2c 2026 6c31 2c20 266c 322c 2026  ion, &l1, &l2, &
-00013a20: 6c33 293b 0a20 2072 6574 7572 6e20 6c31  l3);.  return l1
-00013a30: 3b0a 7d0a 0a2f 2a2a 205c 7265 7475 726e  ;.}../** \return
-00013a40: 7320 7468 6520 6375 7272 656e 746c 7920  s the currently 
-00013a50: 7365 7420 6c65 7665 6c20 3220 6370 7520  set level 2 cpu 
-00013a60: 6361 6368 6520 7369 7a65 2028 696e 2062  cache size (in b
-00013a70: 7974 6573 2920 7573 6564 2074 6f20 6573  ytes) used to es
-00013a80: 7469 6d61 7465 2074 6865 2069 6465 616c  timate the ideal
-00013a90: 2062 6c6f 636b 696e 6720 7369 7a65 2070   blocking size p
-00013aa0: 6172 616d 6574 6572 732e 0a20 202a 205c  arameters..  * \
-00013ab0: 7361 2073 6574 4370 7543 6163 6865 5369  sa setCpuCacheSi
-00013ac0: 7a65 202a 2f0a 696e 6c69 6e65 2073 7464  ze */.inline std
-00013ad0: 3a3a 7074 7264 6966 665f 7420 6c32 4361  ::ptrdiff_t l2Ca
-00013ae0: 6368 6553 697a 6528 290a 7b0a 2020 7374  cheSize().{.  st
-00013af0: 643a 3a70 7472 6469 6666 5f74 206c 312c  d::ptrdiff_t l1,
-00013b00: 206c 322c 206c 333b 0a20 2069 6e74 6572   l2, l3;.  inter
-00013b10: 6e61 6c3a 3a6d 616e 6167 655f 6361 6368  nal::manage_cach
-00013b20: 696e 675f 7369 7a65 7328 4765 7441 6374  ing_sizes(GetAct
-00013b30: 696f 6e2c 2026 6c31 2c20 266c 322c 2026  ion, &l1, &l2, &
-00013b40: 6c33 293b 0a20 2072 6574 7572 6e20 6c32  l3);.  return l2
-00013b50: 3b0a 7d0a 0a2f 2a2a 205c 7265 7475 726e  ;.}../** \return
-00013b60: 7320 7468 6520 6375 7272 656e 746c 7920  s the currently 
-00013b70: 7365 7420 6c65 7665 6c20 3320 6370 7520  set level 3 cpu 
-00013b80: 6361 6368 6520 7369 7a65 2028 696e 2062  cache size (in b
-00013b90: 7974 6573 2920 7573 6564 2074 6f20 6573  ytes) used to es
-00013ba0: 7469 6d61 7465 2074 6865 2069 6465 616c  timate the ideal
-00013bb0: 2062 6c6f 636b 696e 6720 7369 7a65 2070   blocking size p
-00013bc0: 6172 616d 6574 655c 0a72 732e 2020 2020  aramete\.rs.    
-00013bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013c20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013c30: 2020 2020 2020 2020 2020 2020 0a2a 205c              .* \
-00013c40: 7361 2073 6574 4370 7543 6163 6865 5369  sa setCpuCacheSi
-00013c50: 7a65 202a 2f0a 696e 6c69 6e65 2073 7464  ze */.inline std
-00013c60: 3a3a 7074 7264 6966 665f 7420 6c33 4361  ::ptrdiff_t l3Ca
-00013c70: 6368 6553 697a 6528 290a 7b0a 2020 7374  cheSize().{.  st
-00013c80: 643a 3a70 7472 6469 6666 5f74 206c 312c  d::ptrdiff_t l1,
-00013c90: 206c 322c 206c 333b 0a20 2069 6e74 6572   l2, l3;.  inter
-00013ca0: 6e61 6c3a 3a6d 616e 6167 655f 6361 6368  nal::manage_cach
-00013cb0: 696e 675f 7369 7a65 7328 4765 7441 6374  ing_sizes(GetAct
-00013cc0: 696f 6e2c 2026 6c31 2c20 266c 322c 2026  ion, &l1, &l2, &
-00013cd0: 6c33 293b 0a20 2072 6574 7572 6e20 6c33  l3);.  return l3
-00013ce0: 3b0a 7d0a 0a2f 2a2a 2053 6574 2074 6865  ;.}../** Set the
-00013cf0: 2063 7075 204c 3120 616e 6420 4c32 2063   cpu L1 and L2 c
-00013d00: 6163 6865 2073 697a 6573 2028 696e 2062  ache sizes (in b
-00013d10: 7974 6573 292e 0a20 202a 2054 6865 7365  ytes)..  * These
-00013d20: 2076 616c 7565 7320 6172 6520 7573 6520   values are use 
-00013d30: 746f 2061 646a 7573 7420 7468 6520 7369  to adjust the si
-00013d40: 7a65 206f 6620 7468 6520 626c 6f63 6b73  ze of the blocks
-00013d50: 0a20 202a 2066 6f72 2074 6865 2061 6c67  .  * for the alg
-00013d60: 6f72 6974 686d 7320 776f 726b 696e 6720  orithms working 
-00013d70: 7065 7220 626c 6f63 6b73 2e0a 2020 2a0a  per blocks..  *.
-00013d80: 2020 2a20 5c73 6120 636f 6d70 7574 6550    * \sa computeP
-00013d90: 726f 6475 6374 426c 6f63 6b69 6e67 5369  roductBlockingSi
-00013da0: 7a65 7320 2a2f 0a69 6e6c 696e 6520 766f  zes */.inline vo
-00013db0: 6964 2073 6574 4370 7543 6163 6865 5369  id setCpuCacheSi
-00013dc0: 7a65 7328 7374 643a 3a70 7472 6469 6666  zes(std::ptrdiff
-00013dd0: 5f74 206c 312c 2073 7464 3a3a 7074 7264  _t l1, std::ptrd
-00013de0: 6966 665f 7420 6c32 2c20 7374 643a 3a70  iff_t l2, std::p
-00013df0: 7472 6469 6666 5f74 206c 3329 0a7b 0a20  trdiff_t l3).{. 
-00013e00: 2069 6e74 6572 6e61 6c3a 3a6d 616e 6167   internal::manag
-00013e10: 655f 6361 6368 696e 675f 7369 7a65 7328  e_caching_sizes(
-00013e20: 5365 7441 6374 696f 6e2c 2026 6c31 2c20  SetAction, &l1, 
-00013e30: 266c 322c 2026 6c33 293b 0a7d 0a0a 7d20  &l2, &l3);.}..} 
-00013e40: 2f2f 2065 6e64 206e 616d 6573 7061 6365  // end namespace
-00013e50: 2045 6967 656e 0a0a 2365 6e64 6966 202f   Eigen..#endif /
-00013e60: 2f20 4549 4745 4e5f 4745 4e45 5241 4c5f  / EIGEN_GENERAL_
-00013e70: 424c 4f43 4b5f 5041 4e45 4c5f 480a       BLOCK_PANEL_H.
+000001e0: 0a0a 656e 756d 2047 4542 5050 6163 6b65  ..enum GEBPPacke
+000001f0: 7453 697a 6554 7970 6520 7b0a 2020 4745  tSizeType {.  GE
+00000200: 4250 5061 636b 6574 4675 6c6c 203d 2030  BPPacketFull = 0
+00000210: 2c0a 2020 4745 4250 5061 636b 6574 4861  ,.  GEBPPacketHa
+00000220: 6c66 2c0a 2020 4745 4250 5061 636b 6574  lf,.  GEBPPacket
+00000230: 5175 6172 7465 720a 7d3b 0a0a 7465 6d70  Quarter.};..temp
+00000240: 6c61 7465 3c74 7970 656e 616d 6520 5f4c  late<typename _L
+00000250: 6873 5363 616c 6172 2c20 7479 7065 6e61  hsScalar, typena
+00000260: 6d65 205f 5268 7353 6361 6c61 722c 2062  me _RhsScalar, b
+00000270: 6f6f 6c20 5f43 6f6e 6a4c 6873 3d66 616c  ool _ConjLhs=fal
+00000280: 7365 2c20 626f 6f6c 205f 436f 6e6a 5268  se, bool _ConjRh
+00000290: 733d 6661 6c73 652c 2069 6e74 2041 7263  s=false, int Arc
+000002a0: 683d 4172 6368 6974 6563 7475 7265 3a3a  h=Architecture::
+000002b0: 5461 7267 6574 2c20 696e 7420 5f50 6163  Target, int _Pac
+000002c0: 6b65 7453 697a 653d 4745 4250 5061 636b  ketSize=GEBPPack
+000002d0: 6574 4675 6c6c 3e0a 636c 6173 7320 6765  etFull>.class ge
+000002e0: 6270 5f74 7261 6974 733b 0a0a 0a2f 2a2a  bp_traits;.../**
+000002f0: 205c 696e 7465 726e 616c 205c 7265 7475   \internal \retu
+00000300: 726e 7320 6220 6966 2061 3c3d 302c 2061  rns b if a<=0, a
+00000310: 6e64 2072 6574 7572 6e73 2061 206f 7468  nd returns a oth
+00000320: 6572 7769 7365 2e20 2a2f 0a69 6e6c 696e  erwise. */.inlin
+00000330: 6520 7374 643a 3a70 7472 6469 6666 5f74  e std::ptrdiff_t
+00000340: 206d 616e 6167 655f 6361 6368 696e 675f   manage_caching_
+00000350: 7369 7a65 735f 6865 6c70 6572 2873 7464  sizes_helper(std
+00000360: 3a3a 7074 7264 6966 665f 7420 612c 2073  ::ptrdiff_t a, s
+00000370: 7464 3a3a 7074 7264 6966 665f 7420 6229  td::ptrdiff_t b)
+00000380: 0a7b 0a20 2072 6574 7572 6e20 613c 3d30  .{.  return a<=0
+00000390: 203f 2062 203a 2061 3b0a 7d0a 0a23 6966   ? b : a;.}..#if
+000003a0: 2064 6566 696e 6564 2845 4947 454e 5f44   defined(EIGEN_D
+000003b0: 4546 4155 4c54 5f4c 315f 4341 4348 455f  EFAULT_L1_CACHE_
+000003c0: 5349 5a45 290a 2364 6566 696e 6520 4549  SIZE).#define EI
+000003d0: 4745 4e5f 5345 545f 4445 4641 554c 545f  GEN_SET_DEFAULT_
+000003e0: 4c31 5f43 4143 4845 5f53 495a 4528 7661  L1_CACHE_SIZE(va
+000003f0: 6c29 2045 4947 454e 5f44 4546 4155 4c54  l) EIGEN_DEFAULT
+00000400: 5f4c 315f 4341 4348 455f 5349 5a45 0a23  _L1_CACHE_SIZE.#
+00000410: 656c 7365 0a23 6465 6669 6e65 2045 4947  else.#define EIG
+00000420: 454e 5f53 4554 5f44 4546 4155 4c54 5f4c  EN_SET_DEFAULT_L
+00000430: 315f 4341 4348 455f 5349 5a45 2876 616c  1_CACHE_SIZE(val
+00000440: 2920 7661 6c0a 2365 6e64 6966 202f 2f20  ) val.#endif // 
+00000450: 6465 6669 6e65 6428 4549 4745 4e5f 4445  defined(EIGEN_DE
+00000460: 4641 554c 545f 4c31 5f43 4143 4845 5f53  FAULT_L1_CACHE_S
+00000470: 495a 4529 0a0a 2369 6620 6465 6669 6e65  IZE)..#if define
+00000480: 6428 4549 4745 4e5f 4445 4641 554c 545f  d(EIGEN_DEFAULT_
+00000490: 4c32 5f43 4143 4845 5f53 495a 4529 0a23  L2_CACHE_SIZE).#
+000004a0: 6465 6669 6e65 2045 4947 454e 5f53 4554  define EIGEN_SET
+000004b0: 5f44 4546 4155 4c54 5f4c 325f 4341 4348  _DEFAULT_L2_CACH
+000004c0: 455f 5349 5a45 2876 616c 2920 4549 4745  E_SIZE(val) EIGE
+000004d0: 4e5f 4445 4641 554c 545f 4c32 5f43 4143  N_DEFAULT_L2_CAC
+000004e0: 4845 5f53 495a 450a 2365 6c73 650a 2364  HE_SIZE.#else.#d
+000004f0: 6566 696e 6520 4549 4745 4e5f 5345 545f  efine EIGEN_SET_
+00000500: 4445 4641 554c 545f 4c32 5f43 4143 4845  DEFAULT_L2_CACHE
+00000510: 5f53 495a 4528 7661 6c29 2076 616c 0a23  _SIZE(val) val.#
+00000520: 656e 6469 6620 2f2f 2064 6566 696e 6564  endif // defined
+00000530: 2845 4947 454e 5f44 4546 4155 4c54 5f4c  (EIGEN_DEFAULT_L
+00000540: 325f 4341 4348 455f 5349 5a45 290a 0a23  2_CACHE_SIZE)..#
+00000550: 6966 2064 6566 696e 6564 2845 4947 454e  if defined(EIGEN
+00000560: 5f44 4546 4155 4c54 5f4c 335f 4341 4348  _DEFAULT_L3_CACH
+00000570: 455f 5349 5a45 290a 2364 6566 696e 6520  E_SIZE).#define 
+00000580: 4549 4745 4e5f 5345 545f 4445 4641 554c  EIGEN_SET_DEFAUL
+00000590: 545f 4c33 5f43 4143 4845 5f53 495a 4528  T_L3_CACHE_SIZE(
+000005a0: 7661 6c29 2045 4947 454e 5f44 4546 4155  val) EIGEN_DEFAU
+000005b0: 4c54 5f4c 335f 4341 4348 455f 5349 5a45  LT_L3_CACHE_SIZE
+000005c0: 0a23 656c 7365 0a23 6465 6669 6e65 2045  .#else.#define E
+000005d0: 4947 454e 5f53 4554 5f44 4546 4155 4c54  IGEN_SET_DEFAULT
+000005e0: 5f4c 335f 4341 4348 455f 5349 5a45 2876  _L3_CACHE_SIZE(v
+000005f0: 616c 2920 7661 6c0a 2365 6e64 6966 202f  al) val.#endif /
+00000600: 2f20 6465 6669 6e65 6428 4549 4745 4e5f  / defined(EIGEN_
+00000610: 4445 4641 554c 545f 4c33 5f43 4143 4845  DEFAULT_L3_CACHE
+00000620: 5f53 495a 4529 0a20 200a 2369 6620 4549  _SIZE).  .#if EI
+00000630: 4745 4e5f 4152 4348 5f69 3338 365f 4f52  GEN_ARCH_i386_OR
+00000640: 5f78 3836 5f36 340a 636f 6e73 7420 7374  _x86_64.const st
+00000650: 643a 3a70 7472 6469 6666 5f74 2064 6566  d::ptrdiff_t def
+00000660: 6175 6c74 4c31 4361 6368 6553 697a 6520  aultL1CacheSize 
+00000670: 3d20 4549 4745 4e5f 5345 545f 4445 4641  = EIGEN_SET_DEFA
+00000680: 554c 545f 4c31 5f43 4143 4845 5f53 495a  ULT_L1_CACHE_SIZ
+00000690: 4528 3332 2a31 3032 3429 3b0a 636f 6e73  E(32*1024);.cons
+000006a0: 7420 7374 643a 3a70 7472 6469 6666 5f74  t std::ptrdiff_t
+000006b0: 2064 6566 6175 6c74 4c32 4361 6368 6553   defaultL2CacheS
+000006c0: 697a 6520 3d20 4549 4745 4e5f 5345 545f  ize = EIGEN_SET_
+000006d0: 4445 4641 554c 545f 4c32 5f43 4143 4845  DEFAULT_L2_CACHE
+000006e0: 5f53 495a 4528 3235 362a 3130 3234 293b  _SIZE(256*1024);
+000006f0: 0a63 6f6e 7374 2073 7464 3a3a 7074 7264  .const std::ptrd
+00000700: 6966 665f 7420 6465 6661 756c 744c 3343  iff_t defaultL3C
+00000710: 6163 6865 5369 7a65 203d 2045 4947 454e  acheSize = EIGEN
+00000720: 5f53 4554 5f44 4546 4155 4c54 5f4c 335f  _SET_DEFAULT_L3_
+00000730: 4341 4348 455f 5349 5a45 2832 2a31 3032  CACHE_SIZE(2*102
+00000740: 342a 3130 3234 293b 0a23 656c 6966 2045  4*1024);.#elif E
+00000750: 4947 454e 5f41 5243 485f 5050 430a 636f  IGEN_ARCH_PPC.co
+00000760: 6e73 7420 7374 643a 3a70 7472 6469 6666  nst std::ptrdiff
+00000770: 5f74 2064 6566 6175 6c74 4c31 4361 6368  _t defaultL1Cach
+00000780: 6553 697a 6520 3d20 4549 4745 4e5f 5345  eSize = EIGEN_SE
+00000790: 545f 4445 4641 554c 545f 4c31 5f43 4143  T_DEFAULT_L1_CAC
+000007a0: 4845 5f53 495a 4528 3634 2a31 3032 3429  HE_SIZE(64*1024)
+000007b0: 3b0a 636f 6e73 7420 7374 643a 3a70 7472  ;.const std::ptr
+000007c0: 6469 6666 5f74 2064 6566 6175 6c74 4c32  diff_t defaultL2
+000007d0: 4361 6368 6553 697a 6520 3d20 4549 4745  CacheSize = EIGE
+000007e0: 4e5f 5345 545f 4445 4641 554c 545f 4c32  N_SET_DEFAULT_L2
+000007f0: 5f43 4143 4845 5f53 495a 4528 3531 322a  _CACHE_SIZE(512*
+00000800: 3130 3234 293b 0a63 6f6e 7374 2073 7464  1024);.const std
+00000810: 3a3a 7074 7264 6966 665f 7420 6465 6661  ::ptrdiff_t defa
+00000820: 756c 744c 3343 6163 6865 5369 7a65 203d  ultL3CacheSize =
+00000830: 2045 4947 454e 5f53 4554 5f44 4546 4155   EIGEN_SET_DEFAU
+00000840: 4c54 5f4c 335f 4341 4348 455f 5349 5a45  LT_L3_CACHE_SIZE
+00000850: 2834 2a31 3032 342a 3130 3234 293b 0a23  (4*1024*1024);.#
+00000860: 656c 7365 0a63 6f6e 7374 2073 7464 3a3a  else.const std::
+00000870: 7074 7264 6966 665f 7420 6465 6661 756c  ptrdiff_t defaul
+00000880: 744c 3143 6163 6865 5369 7a65 203d 2045  tL1CacheSize = E
+00000890: 4947 454e 5f53 4554 5f44 4546 4155 4c54  IGEN_SET_DEFAULT
+000008a0: 5f4c 315f 4341 4348 455f 5349 5a45 2831  _L1_CACHE_SIZE(1
+000008b0: 362a 3130 3234 293b 0a63 6f6e 7374 2073  6*1024);.const s
+000008c0: 7464 3a3a 7074 7264 6966 665f 7420 6465  td::ptrdiff_t de
+000008d0: 6661 756c 744c 3243 6163 6865 5369 7a65  faultL2CacheSize
+000008e0: 203d 2045 4947 454e 5f53 4554 5f44 4546   = EIGEN_SET_DEF
+000008f0: 4155 4c54 5f4c 325f 4341 4348 455f 5349  AULT_L2_CACHE_SI
+00000900: 5a45 2835 3132 2a31 3032 3429 3b0a 636f  ZE(512*1024);.co
+00000910: 6e73 7420 7374 643a 3a70 7472 6469 6666  nst std::ptrdiff
+00000920: 5f74 2064 6566 6175 6c74 4c33 4361 6368  _t defaultL3Cach
+00000930: 6553 697a 6520 3d20 4549 4745 4e5f 5345  eSize = EIGEN_SE
+00000940: 545f 4445 4641 554c 545f 4c33 5f43 4143  T_DEFAULT_L3_CAC
+00000950: 4845 5f53 495a 4528 3531 322a 3130 3234  HE_SIZE(512*1024
+00000960: 293b 0a23 656e 6469 660a 0a23 756e 6465  );.#endif..#unde
+00000970: 6620 4549 4745 4e5f 5345 545f 4445 4641  f EIGEN_SET_DEFA
+00000980: 554c 545f 4c31 5f43 4143 4845 5f53 495a  ULT_L1_CACHE_SIZ
+00000990: 450a 2375 6e64 6566 2045 4947 454e 5f53  E.#undef EIGEN_S
+000009a0: 4554 5f44 4546 4155 4c54 5f4c 325f 4341  ET_DEFAULT_L2_CA
+000009b0: 4348 455f 5349 5a45 0a23 756e 6465 6620  CHE_SIZE.#undef 
+000009c0: 4549 4745 4e5f 5345 545f 4445 4641 554c  EIGEN_SET_DEFAUL
+000009d0: 545f 4c33 5f43 4143 4845 5f53 495a 450a  T_L3_CACHE_SIZE.
+000009e0: 0a2f 2a2a 205c 696e 7465 726e 616c 202a  ./** \internal *
+000009f0: 2f0a 7374 7275 6374 2043 6163 6865 5369  /.struct CacheSi
+00000a00: 7a65 7320 7b0a 2020 4361 6368 6553 697a  zes {.  CacheSiz
+00000a10: 6573 2829 3a20 6d5f 6c31 282d 3129 2c6d  es(): m_l1(-1),m
+00000a20: 5f6c 3228 2d31 292c 6d5f 6c33 282d 3129  _l2(-1),m_l3(-1)
+00000a30: 207b 0a20 2020 2069 6e74 206c 3143 6163   {.    int l1Cac
+00000a40: 6865 5369 7a65 2c20 6c32 4361 6368 6553  heSize, l2CacheS
+00000a50: 697a 652c 206c 3343 6163 6865 5369 7a65  ize, l3CacheSize
+00000a60: 3b0a 2020 2020 7175 6572 7943 6163 6865  ;.    queryCache
+00000a70: 5369 7a65 7328 6c31 4361 6368 6553 697a  Sizes(l1CacheSiz
+00000a80: 652c 206c 3243 6163 6865 5369 7a65 2c20  e, l2CacheSize, 
+00000a90: 6c33 4361 6368 6553 697a 6529 3b0a 2020  l3CacheSize);.  
+00000aa0: 2020 6d5f 6c31 203d 206d 616e 6167 655f    m_l1 = manage_
+00000ab0: 6361 6368 696e 675f 7369 7a65 735f 6865  caching_sizes_he
+00000ac0: 6c70 6572 286c 3143 6163 6865 5369 7a65  lper(l1CacheSize
+00000ad0: 2c20 6465 6661 756c 744c 3143 6163 6865  , defaultL1Cache
+00000ae0: 5369 7a65 293b 0a20 2020 206d 5f6c 3220  Size);.    m_l2 
+00000af0: 3d20 6d61 6e61 6765 5f63 6163 6869 6e67  = manage_caching
+00000b00: 5f73 697a 6573 5f68 656c 7065 7228 6c32  _sizes_helper(l2
+00000b10: 4361 6368 6553 697a 652c 2064 6566 6175  CacheSize, defau
+00000b20: 6c74 4c32 4361 6368 6553 697a 6529 3b0a  ltL2CacheSize);.
+00000b30: 2020 2020 6d5f 6c33 203d 206d 616e 6167      m_l3 = manag
+00000b40: 655f 6361 6368 696e 675f 7369 7a65 735f  e_caching_sizes_
+00000b50: 6865 6c70 6572 286c 3343 6163 6865 5369  helper(l3CacheSi
+00000b60: 7a65 2c20 6465 6661 756c 744c 3343 6163  ze, defaultL3Cac
+00000b70: 6865 5369 7a65 293b 0a20 207d 0a0a 2020  heSize);.  }..  
+00000b80: 7374 643a 3a70 7472 6469 6666 5f74 206d  std::ptrdiff_t m
+00000b90: 5f6c 313b 0a20 2073 7464 3a3a 7074 7264  _l1;.  std::ptrd
+00000ba0: 6966 665f 7420 6d5f 6c32 3b0a 2020 7374  iff_t m_l2;.  st
+00000bb0: 643a 3a70 7472 6469 6666 5f74 206d 5f6c  d::ptrdiff_t m_l
+00000bc0: 333b 0a7d 3b0a 0a2f 2a2a 205c 696e 7465  3;.};../** \inte
+00000bd0: 726e 616c 202a 2f0a 696e 6c69 6e65 2076  rnal */.inline v
+00000be0: 6f69 6420 6d61 6e61 6765 5f63 6163 6869  oid manage_cachi
+00000bf0: 6e67 5f73 697a 6573 2841 6374 696f 6e20  ng_sizes(Action 
+00000c00: 6163 7469 6f6e 2c20 7374 643a 3a70 7472  action, std::ptr
+00000c10: 6469 6666 5f74 2a20 6c31 2c20 7374 643a  diff_t* l1, std:
+00000c20: 3a70 7472 6469 6666 5f74 2a20 6c32 2c20  :ptrdiff_t* l2, 
+00000c30: 7374 643a 3a70 7472 6469 6666 5f74 2a20  std::ptrdiff_t* 
+00000c40: 6c33 290a 7b0a 2020 7374 6174 6963 2043  l3).{.  static C
+00000c50: 6163 6865 5369 7a65 7320 6d5f 6361 6368  acheSizes m_cach
+00000c60: 6553 697a 6573 3b0a 0a20 2069 6628 6163  eSizes;..  if(ac
+00000c70: 7469 6f6e 3d3d 5365 7441 6374 696f 6e29  tion==SetAction)
+00000c80: 0a20 207b 0a20 2020 202f 2f20 7365 7420  .  {.    // set 
+00000c90: 7468 6520 6370 7520 6361 6368 6520 7369  the cpu cache si
+00000ca0: 7a65 2061 6e64 2063 6163 6865 2061 6c6c  ze and cache all
+00000cb0: 2062 6c6f 636b 2073 697a 6573 2066 726f   block sizes fro
+00000cc0: 6d20 6120 676c 6f62 616c 2063 6163 6865  m a global cache
+00000cd0: 2073 697a 6520 696e 2062 7974 650a 2020   size in byte.  
+00000ce0: 2020 6569 6765 6e5f 696e 7465 726e 616c    eigen_internal
+00000cf0: 5f61 7373 6572 7428 6c31 213d 3020 2626  _assert(l1!=0 &&
+00000d00: 206c 3221 3d30 293b 0a20 2020 206d 5f63   l2!=0);.    m_c
+00000d10: 6163 6865 5369 7a65 732e 6d5f 6c31 203d  acheSizes.m_l1 =
+00000d20: 202a 6c31 3b0a 2020 2020 6d5f 6361 6368   *l1;.    m_cach
+00000d30: 6553 697a 6573 2e6d 5f6c 3220 3d20 2a6c  eSizes.m_l2 = *l
+00000d40: 323b 0a20 2020 206d 5f63 6163 6865 5369  2;.    m_cacheSi
+00000d50: 7a65 732e 6d5f 6c33 203d 202a 6c33 3b0a  zes.m_l3 = *l3;.
+00000d60: 2020 7d0a 2020 656c 7365 2069 6628 6163    }.  else if(ac
+00000d70: 7469 6f6e 3d3d 4765 7441 6374 696f 6e29  tion==GetAction)
+00000d80: 0a20 207b 0a20 2020 2065 6967 656e 5f69  .  {.    eigen_i
+00000d90: 6e74 6572 6e61 6c5f 6173 7365 7274 286c  nternal_assert(l
+00000da0: 3121 3d30 2026 2620 6c32 213d 3029 3b0a  1!=0 && l2!=0);.
+00000db0: 2020 2020 2a6c 3120 3d20 6d5f 6361 6368      *l1 = m_cach
+00000dc0: 6553 697a 6573 2e6d 5f6c 313b 0a20 2020  eSizes.m_l1;.   
+00000dd0: 202a 6c32 203d 206d 5f63 6163 6865 5369   *l2 = m_cacheSi
+00000de0: 7a65 732e 6d5f 6c32 3b0a 2020 2020 2a6c  zes.m_l2;.    *l
+00000df0: 3320 3d20 6d5f 6361 6368 6553 697a 6573  3 = m_cacheSizes
+00000e00: 2e6d 5f6c 333b 0a20 207d 0a20 2065 6c73  .m_l3;.  }.  els
+00000e10: 650a 2020 7b0a 2020 2020 6569 6765 6e5f  e.  {.    eigen_
+00000e20: 696e 7465 726e 616c 5f61 7373 6572 7428  internal_assert(
+00000e30: 6661 6c73 6529 3b0a 2020 7d0a 7d0a 0a2f  false);.  }.}../
+00000e40: 2a20 4865 6c70 6572 2066 6f72 2063 6f6d  * Helper for com
+00000e50: 7075 7465 5072 6f64 7563 7442 6c6f 636b  puteProductBlock
+00000e60: 696e 6753 697a 6573 2e0a 202a 0a20 2a20  ingSizes.. *. * 
+00000e70: 4769 7665 6e20 6120 6d20 7820 6b20 7469  Given a m x k ti
+00000e80: 6d65 7320 6b20 7820 6e20 6d61 7472 6978  mes k x n matrix
+00000e90: 2070 726f 6475 6374 206f 6620 7363 616c   product of scal
+00000ea0: 6172 2074 7970 6573 205c 6320 4c68 7353  ar types \c LhsS
+00000eb0: 6361 6c61 7220 616e 6420 5c63 2052 6873  calar and \c Rhs
+00000ec0: 5363 616c 6172 2c0a 202a 2074 6869 7320  Scalar,. * this 
+00000ed0: 6675 6e63 7469 6f6e 2063 6f6d 7075 7465  function compute
+00000ee0: 7320 7468 6520 626c 6f63 6b69 6e67 2073  s the blocking s
+00000ef0: 697a 6520 7061 7261 6d65 7465 7273 2061  ize parameters a
+00000f00: 6c6f 6e67 2074 6865 2072 6573 7065 6374  long the respect
+00000f10: 6976 6520 6469 6d65 6e73 696f 6e73 0a20  ive dimensions. 
+00000f20: 2a20 666f 7220 6d61 7472 6978 2070 726f  * for matrix pro
+00000f30: 6475 6374 7320 616e 6420 7265 6c61 7465  ducts and relate
+00000f40: 6420 616c 676f 7269 7468 6d73 2e20 5468  d algorithms. Th
+00000f50: 6520 626c 6f63 6b69 6e67 2073 697a 6573  e blocking sizes
+00000f60: 2064 6570 656e 6473 206f 6e20 7661 7269   depends on vari
+00000f70: 6f75 730a 202a 2070 6172 616d 6574 6572  ous. * parameter
+00000f80: 733a 0a20 2a20 2d20 7468 6520 4c31 2061  s:. * - the L1 a
+00000f90: 6e64 204c 3220 6361 6368 6520 7369 7a65  nd L2 cache size
+00000fa0: 732c 0a20 2a20 2d20 7468 6520 7265 6769  s,. * - the regi
+00000fb0: 7374 6572 206c 6576 656c 2062 6c6f 636b  ster level block
+00000fc0: 696e 6720 7369 7a65 7320 6465 6669 6e65  ing sizes define
+00000fd0: 6420 6279 2067 6562 705f 7472 6169 7473  d by gebp_traits
+00000fe0: 2c0a 202a 202d 2074 6865 206e 756d 6265  ,. * - the numbe
+00000ff0: 7220 6f66 2073 6361 6c61 7273 2074 6861  r of scalars tha
+00001000: 7420 6669 7420 696e 746f 2061 2070 6163  t fit into a pac
+00001010: 6b65 7420 2877 6865 6e20 7665 6374 6f72  ket (when vector
+00001020: 697a 6174 696f 6e20 6973 2065 6e61 626c  ization is enabl
+00001030: 6564 292e 0a20 2a0a 202a 205c 7361 2073  ed).. *. * \sa s
+00001040: 6574 4370 7543 6163 6865 5369 7a65 7320  etCpuCacheSizes 
+00001050: 2a2f 0a0a 7465 6d70 6c61 7465 3c74 7970  */..template<typ
+00001060: 656e 616d 6520 4c68 7353 6361 6c61 722c  ename LhsScalar,
+00001070: 2074 7970 656e 616d 6520 5268 7353 6361   typename RhsSca
+00001080: 6c61 722c 2069 6e74 204b 6346 6163 746f  lar, int KcFacto
+00001090: 722c 2074 7970 656e 616d 6520 496e 6465  r, typename Inde
+000010a0: 783e 0a76 6f69 6420 6576 616c 7561 7465  x>.void evaluate
+000010b0: 5072 6f64 7563 7442 6c6f 636b 696e 6753  ProductBlockingS
+000010c0: 697a 6573 4865 7572 6973 7469 6328 496e  izesHeuristic(In
+000010d0: 6465 7826 206b 2c20 496e 6465 7826 206d  dex& k, Index& m
+000010e0: 2c20 496e 6465 7826 206e 2c20 496e 6465  , Index& n, Inde
+000010f0: 7820 6e75 6d5f 7468 7265 6164 7320 3d20  x num_threads = 
+00001100: 3129 0a7b 0a20 2074 7970 6564 6566 2067  1).{.  typedef g
+00001110: 6562 705f 7472 6169 7473 3c4c 6873 5363  ebp_traits<LhsSc
+00001120: 616c 6172 2c52 6873 5363 616c 6172 3e20  alar,RhsScalar> 
+00001130: 5472 6169 7473 3b0a 0a20 202f 2f20 4578  Traits;..  // Ex
+00001140: 706c 616e 6174 696f 6e73 3a0a 2020 2f2f  planations:.  //
+00001150: 204c 6574 2773 2072 6563 616c 6c20 7468   Let's recall th
+00001160: 6174 2074 6865 2070 726f 6475 6374 2061  at the product a
+00001170: 6c67 6f72 6974 686d 7320 666f 726d 206d  lgorithms form m
+00001180: 6320 7820 6b63 2076 6572 7469 6361 6c20  c x kc vertical 
+00001190: 7061 6e65 6c73 2041 2720 6f6e 2074 6865  panels A' on the
+000011a0: 206c 6873 2061 6e64 0a20 202f 2f20 6b63   lhs and.  // kc
+000011b0: 2078 206e 6320 626c 6f63 6b73 2042 2720   x nc blocks B' 
+000011c0: 6f6e 2074 6865 2072 6873 2e20 4227 2068  on the rhs. B' h
+000011d0: 6173 2074 6f20 6669 7420 696e 746f 204c  as to fit into L
+000011e0: 322f 4c33 2063 6163 6865 2e20 4d6f 7265  2/L3 cache. More
+000011f0: 6f76 6572 2c20 4127 2069 7320 7072 6f63  over, A' is proc
+00001200: 6573 7365 640a 2020 2f2f 2070 6572 206d  essed.  // per m
+00001210: 7220 7820 6b63 2068 6f72 697a 6f6e 7461  r x kc horizonta
+00001220: 6c20 736d 616c 6c20 7061 6e65 6c73 2077  l small panels w
+00001230: 6865 7265 206d 7220 6973 2074 6865 2062  here mr is the b
+00001240: 6c6f 636b 696e 6720 7369 7a65 2061 6c6f  locking size alo
+00001250: 6e67 2074 6865 206d 2064 696d 656e 7369  ng the m dimensi
+00001260: 6f6e 0a20 202f 2f20 6174 2074 6865 2072  on.  // at the r
+00001270: 6567 6973 7465 7220 6c65 7665 6c2e 2054  egister level. T
+00001280: 6869 7320 736d 616c 6c20 686f 7269 7a6f  his small horizo
+00001290: 6e74 616c 2070 616e 656c 2068 6173 2074  ntal panel has t
+000012a0: 6f20 7374 6179 2077 6974 6869 6e20 4c31  o stay within L1
+000012b0: 2063 6163 6865 2e0a 2020 7374 643a 3a70   cache..  std::p
+000012c0: 7472 6469 6666 5f74 206c 312c 206c 322c  trdiff_t l1, l2,
+000012d0: 206c 333b 0a20 206d 616e 6167 655f 6361   l3;.  manage_ca
+000012e0: 6368 696e 675f 7369 7a65 7328 4765 7441  ching_sizes(GetA
+000012f0: 6374 696f 6e2c 2026 6c31 2c20 266c 322c  ction, &l1, &l2,
+00001300: 2026 6c33 293b 0a20 2023 6966 6465 6620   &l3);.  #ifdef 
+00001310: 4549 4745 4e5f 5645 4354 4f52 495a 455f  EIGEN_VECTORIZE_
+00001320: 4156 5835 3132 0a20 202f 2f20 5765 206e  AVX512.  // We n
+00001330: 6565 6420 746f 2066 696e 6420 6120 7261  eed to find a ra
+00001340: 7469 6f6e 616c 6520 666f 7220 7468 6174  tionale for that
+00001350: 2c20 6275 7420 7769 7468 6f75 7420 7468  , but without th
+00001360: 6973 2061 646a 7573 746d 656e 742c 0a20  is adjustment,. 
+00001370: 202f 2f20 7065 7266 6f72 6d61 6e63 6520   // performance 
+00001380: 7769 7468 2041 5658 3531 3220 6973 2070  with AVX512 is p
+00001390: 7265 7474 7920 6261 642c 206c 696b 6520  retty bad, like 
+000013a0: 2d32 3025 2073 6c6f 7765 722e 0a20 202f  -20% slower..  /
+000013b0: 2f20 4f6e 6520 7265 6173 6f6e 2069 7320  / One reason is 
+000013c0: 7468 6174 2077 6974 6820 696e 6372 6561  that with increa
+000013d0: 7369 6e67 2070 6163 6b65 742d 7369 7a65  sing packet-size
+000013e0: 2c20 7468 6520 626c 6f63 6b69 6e67 2073  , the blocking s
+000013f0: 697a 6520 6b0a 2020 2f2f 2068 6173 2074  ize k.  // has t
+00001400: 6f20 6265 636f 6d65 2070 7265 7474 7920  o become pretty 
+00001410: 736d 616c 6c20 6966 2077 6520 7761 6e74  small if we want
+00001420: 2074 6861 7420 3120 6c68 7320 7061 6e65   that 1 lhs pane
+00001430: 6c20 6669 7420 7769 7468 696e 204c 312e  l fit within L1.
+00001440: 0a20 202f 2f20 466f 7220 696e 7374 616e  .  // For instan
+00001450: 6365 2c20 7769 7468 2074 6865 2033 7058  ce, with the 3pX
+00001460: 3420 6b65 726e 656c 2061 6e64 2064 6f75  4 kernel and dou
+00001470: 626c 652c 2074 6865 2073 697a 6520 6f66  ble, the size of
+00001480: 2074 6865 206c 6873 2b72 6873 2070 616e   the lhs+rhs pan
+00001490: 656c 7320 6172 653a 0a20 202f 2f20 2020  els are:.  //   
+000014a0: 6b2a 2833 2a36 3420 2b20 342a 3829 2042  k*(3*64 + 4*8) B
+000014b0: 7974 6573 2c20 7769 7468 206c 313d 3332  ytes, with l1=32
+000014c0: 6b42 7974 6573 2c20 616e 6420 6b25 383d  kBytes, and k%8=
+000014d0: 302c 2077 6520 6861 7665 206b 3d31 3434  0, we have k=144
+000014e0: 2e0a 2020 2f2f 2054 6869 7320 6973 2071  ..  // This is q
+000014f0: 7569 7465 2073 6d61 6c6c 2066 6f72 2061  uite small for a
+00001500: 2067 6f6f 6420 7265 7573 6520 6f66 2074   good reuse of t
+00001510: 6865 2061 6363 756d 756c 6174 696f 6e20  he accumulation 
+00001520: 7265 6769 7374 6572 732e 0a20 206c 3120  registers..  l1 
+00001530: 2a3d 2034 3b0a 2020 2365 6e64 6966 0a0a  *= 4;.  #endif..
+00001540: 2020 6966 2028 6e75 6d5f 7468 7265 6164    if (num_thread
+00001550: 7320 3e20 3129 207b 0a20 2020 2074 7970  s > 1) {.    typ
+00001560: 6564 6566 2074 7970 656e 616d 6520 5472  edef typename Tr
+00001570: 6169 7473 3a3a 5265 7353 6361 6c61 7220  aits::ResScalar 
+00001580: 5265 7353 6361 6c61 723b 0a20 2020 2065  ResScalar;.    e
+00001590: 6e75 6d20 7b0a 2020 2020 2020 6b64 6976  num {.      kdiv
+000015a0: 203d 204b 6346 6163 746f 7220 2a20 2854   = KcFactor * (T
+000015b0: 7261 6974 733a 3a6d 7220 2a20 7369 7a65  raits::mr * size
+000015c0: 6f66 284c 6873 5363 616c 6172 2920 2b20  of(LhsScalar) + 
+000015d0: 5472 6169 7473 3a3a 6e72 202a 2073 697a  Traits::nr * siz
+000015e0: 656f 6628 5268 7353 6361 6c61 7229 292c  eof(RhsScalar)),
+000015f0: 0a20 2020 2020 206b 7375 6220 3d20 5472  .      ksub = Tr
+00001600: 6169 7473 3a3a 6d72 202a 2054 7261 6974  aits::mr * Trait
+00001610: 733a 3a6e 7220 2a20 7369 7a65 6f66 2852  s::nr * sizeof(R
+00001620: 6573 5363 616c 6172 292c 0a20 2020 2020  esScalar),.     
+00001630: 206b 7220 3d20 382c 0a20 2020 2020 206d   kr = 8,.      m
+00001640: 7220 3d20 5472 6169 7473 3a3a 6d72 2c0a  r = Traits::mr,.
+00001650: 2020 2020 2020 6e72 203d 2054 7261 6974        nr = Trait
+00001660: 733a 3a6e 720a 2020 2020 7d3b 0a20 2020  s::nr.    };.   
+00001670: 202f 2f20 496e 6372 6561 7369 6e67 206b   // Increasing k
+00001680: 2067 6976 6573 2075 7320 6d6f 7265 2074   gives us more t
+00001690: 696d 6520 746f 2070 7265 6665 7463 6820  ime to prefetch 
+000016a0: 7468 6520 636f 6e74 656e 7420 6f66 2074  the content of t
+000016b0: 6865 2022 4322 0a20 2020 202f 2f20 7265  he "C".    // re
+000016c0: 6769 7374 6572 732e 2048 6f77 6576 6572  gisters. However
+000016d0: 206f 6e63 6520 7468 6520 6c61 7465 6e63   once the latenc
+000016e0: 7920 6973 2068 6964 6465 6e20 7468 6572  y is hidden ther
+000016f0: 6520 6973 206e 6f20 706f 696e 7420 696e  e is no point in
+00001700: 0a20 2020 202f 2f20 696e 6372 6561 7369  .    // increasi
+00001710: 6e67 2074 6865 2076 616c 7565 206f 6620  ng the value of 
+00001720: 6b2c 2073 6f20 7765 276c 6c20 6361 7020  k, so we'll cap 
+00001730: 6974 2061 7420 3332 3020 2876 616c 7565  it at 320 (value
+00001740: 2064 6574 6572 6d69 6e65 640a 2020 2020   determined.    
+00001750: 2f2f 2065 7870 6572 696d 656e 7461 6c6c  // experimentall
+00001760: 7929 2e0a 2020 2020 2f2f 2054 6f20 6176  y)..    // To av
+00001770: 6f69 6420 7468 6174 206b 2076 616e 6973  oid that k vanis
+00001780: 6865 732c 2077 6520 6d61 6b65 206b 5f63  hes, we make k_c
+00001790: 6163 6865 2061 7420 6c65 6173 7420 6173  ache at least as
+000017a0: 2062 6967 2061 7320 6b72 0a20 2020 2063   big as kr.    c
+000017b0: 6f6e 7374 2049 6e64 6578 206b 5f63 6163  onst Index k_cac
+000017c0: 6865 203d 206e 756d 6578 743a 3a6d 6178  he = numext::max
+000017d0: 693c 496e 6465 783e 286b 722c 2028 6e75  i<Index>(kr, (nu
+000017e0: 6d65 7874 3a3a 6d69 6e69 3c49 6e64 6578  mext::mini<Index
+000017f0: 3e29 2828 6c31 2d6b 7375 6229 2f6b 6469  >)((l1-ksub)/kdi
+00001800: 762c 2033 3230 2929 3b0a 2020 2020 6966  v, 320));.    if
+00001810: 2028 6b5f 6361 6368 6520 3c20 6b29 207b   (k_cache < k) {
+00001820: 0a20 2020 2020 206b 203d 206b 5f63 6163  .      k = k_cac
+00001830: 6865 202d 2028 6b5f 6361 6368 6520 2520  he - (k_cache % 
+00001840: 6b72 293b 0a20 2020 2020 2065 6967 656e  kr);.      eigen
+00001850: 5f69 6e74 6572 6e61 6c5f 6173 7365 7274  _internal_assert
+00001860: 286b 203e 2030 293b 0a20 2020 207d 0a0a  (k > 0);.    }..
+00001870: 2020 2020 636f 6e73 7420 496e 6465 7820      const Index 
+00001880: 6e5f 6361 6368 6520 3d20 286c 322d 6c31  n_cache = (l2-l1
+00001890: 2920 2f20 286e 7220 2a20 7369 7a65 6f66  ) / (nr * sizeof
+000018a0: 2852 6873 5363 616c 6172 2920 2a20 6b29  (RhsScalar) * k)
+000018b0: 3b0a 2020 2020 636f 6e73 7420 496e 6465  ;.    const Inde
+000018c0: 7820 6e5f 7065 725f 7468 7265 6164 203d  x n_per_thread =
+000018d0: 206e 756d 6578 743a 3a64 6976 5f63 6569   numext::div_cei
+000018e0: 6c28 6e2c 206e 756d 5f74 6872 6561 6473  l(n, num_threads
+000018f0: 293b 0a20 2020 2069 6620 286e 5f63 6163  );.    if (n_cac
+00001900: 6865 203c 3d20 6e5f 7065 725f 7468 7265  he <= n_per_thre
+00001910: 6164 2920 7b0a 2020 2020 2020 2f2f 2044  ad) {.      // D
+00001920: 6f6e 2774 2065 7863 6565 6420 7468 6520  on't exceed the 
+00001930: 6361 7061 6369 7479 206f 6620 7468 6520  capacity of the 
+00001940: 6c32 2063 6163 6865 2e0a 2020 2020 2020  l2 cache..      
+00001950: 6569 6765 6e5f 696e 7465 726e 616c 5f61  eigen_internal_a
+00001960: 7373 6572 7428 6e5f 6361 6368 6520 3e3d  ssert(n_cache >=
+00001970: 2073 7461 7469 635f 6361 7374 3c49 6e64   static_cast<Ind
+00001980: 6578 3e28 6e72 2929 3b0a 2020 2020 2020  ex>(nr));.      
+00001990: 6e20 3d20 6e5f 6361 6368 6520 2d20 286e  n = n_cache - (n
+000019a0: 5f63 6163 6865 2025 206e 7229 3b0a 2020  _cache % nr);.  
+000019b0: 2020 2020 6569 6765 6e5f 696e 7465 726e      eigen_intern
+000019c0: 616c 5f61 7373 6572 7428 6e20 3e20 3029  al_assert(n > 0)
+000019d0: 3b0a 2020 2020 7d20 656c 7365 207b 0a20  ;.    } else {. 
+000019e0: 2020 2020 206e 203d 2028 6e75 6d65 7874       n = (numext
+000019f0: 3a3a 6d69 6e69 3c49 6e64 6578 3e29 286e  ::mini<Index>)(n
+00001a00: 2c20 286e 5f70 6572 5f74 6872 6561 6420  , (n_per_thread 
+00001a10: 2b20 6e72 202d 2031 2920 2d20 2828 6e5f  + nr - 1) - ((n_
+00001a20: 7065 725f 7468 7265 6164 202b 206e 7220  per_thread + nr 
+00001a30: 2d20 3129 2025 206e 7229 293b 0a20 2020  - 1) % nr));.   
+00001a40: 207d 0a0a 2020 2020 6966 2028 6c33 203e   }..    if (l3 >
+00001a50: 206c 3229 207b 0a20 2020 2020 202f 2f20   l2) {.      // 
+00001a60: 6c33 2069 7320 7368 6172 6564 2062 6574  l3 is shared bet
+00001a70: 7765 656e 2061 6c6c 2063 6f72 6573 2c20  ween all cores, 
+00001a80: 736f 2077 6527 6c6c 2067 6976 6520 6561  so we'll give ea
+00001a90: 6368 2074 6872 6561 6420 6974 7320 6f77  ch thread its ow
+00001aa0: 6e20 6368 756e 6b20 6f66 206c 332e 0a20  n chunk of l3.. 
+00001ab0: 2020 2020 2063 6f6e 7374 2049 6e64 6578       const Index
+00001ac0: 206d 5f63 6163 6865 203d 2028 6c33 2d6c   m_cache = (l3-l
+00001ad0: 3229 202f 2028 7369 7a65 6f66 284c 6873  2) / (sizeof(Lhs
+00001ae0: 5363 616c 6172 2920 2a20 6b20 2a20 6e75  Scalar) * k * nu
+00001af0: 6d5f 7468 7265 6164 7329 3b0a 2020 2020  m_threads);.    
+00001b00: 2020 636f 6e73 7420 496e 6465 7820 6d5f    const Index m_
+00001b10: 7065 725f 7468 7265 6164 203d 206e 756d  per_thread = num
+00001b20: 6578 743a 3a64 6976 5f63 6569 6c28 6d2c  ext::div_ceil(m,
+00001b30: 206e 756d 5f74 6872 6561 6473 293b 0a20   num_threads);. 
+00001b40: 2020 2020 2069 6628 6d5f 6361 6368 6520       if(m_cache 
+00001b50: 3c20 6d5f 7065 725f 7468 7265 6164 2026  < m_per_thread &
+00001b60: 2620 6d5f 6361 6368 6520 3e3d 2073 7461  & m_cache >= sta
+00001b70: 7469 635f 6361 7374 3c49 6e64 6578 3e28  tic_cast<Index>(
+00001b80: 6d72 2929 207b 0a20 2020 2020 2020 206d  mr)) {.        m
+00001b90: 203d 206d 5f63 6163 6865 202d 2028 6d5f   = m_cache - (m_
+00001ba0: 6361 6368 6520 2520 6d72 293b 0a20 2020  cache % mr);.   
+00001bb0: 2020 2020 2065 6967 656e 5f69 6e74 6572       eigen_inter
+00001bc0: 6e61 6c5f 6173 7365 7274 286d 203e 2030  nal_assert(m > 0
+00001bd0: 293b 0a20 2020 2020 207d 2065 6c73 6520  );.      } else 
+00001be0: 7b0a 2020 2020 2020 2020 6d20 3d20 286e  {.        m = (n
+00001bf0: 756d 6578 743a 3a6d 696e 693c 496e 6465  umext::mini<Inde
+00001c00: 783e 2928 6d2c 2028 6d5f 7065 725f 7468  x>)(m, (m_per_th
+00001c10: 7265 6164 202b 206d 7220 2d20 3129 202d  read + mr - 1) -
+00001c20: 2028 286d 5f70 6572 5f74 6872 6561 6420   ((m_per_thread 
+00001c30: 2b20 6d72 202d 2031 2920 2520 6d72 2929  + mr - 1) % mr))
+00001c40: 3b0a 2020 2020 2020 7d0a 2020 2020 7d0a  ;.      }.    }.
+00001c50: 2020 7d0a 2020 656c 7365 207b 0a20 2020    }.  else {.   
+00001c60: 202f 2f20 496e 2075 6e69 7420 7465 7374   // In unit test
+00001c70: 7320 7765 2064 6f20 6e6f 7420 7761 6e74  s we do not want
+00001c80: 2074 6f20 7573 6520 6578 7472 6120 6c61   to use extra la
+00001c90: 7267 6520 6d61 7472 6963 6573 2c0a 2020  rge matrices,.  
+00001ca0: 2020 2f2f 2073 6f20 7765 2072 6564 7563    // so we reduc
+00001cb0: 6520 7468 6520 6361 6368 6520 7369 7a65  e the cache size
+00001cc0: 2074 6f20 6368 6563 6b20 7468 6520 626c   to check the bl
+00001cd0: 6f63 6b69 6e67 2073 7472 6174 6567 7920  ocking strategy 
+00001ce0: 6973 206e 6f74 2066 6c61 7765 640a 2369  is not flawed.#i
+00001cf0: 6664 6566 2045 4947 454e 5f44 4542 5547  fdef EIGEN_DEBUG
+00001d00: 5f53 4d41 4c4c 5f50 524f 4455 4354 5f42  _SMALL_PRODUCT_B
+00001d10: 4c4f 434b 530a 2020 2020 6c31 203d 2039  LOCKS.    l1 = 9
+00001d20: 2a31 3032 343b 0a20 2020 206c 3220 3d20  *1024;.    l2 = 
+00001d30: 3332 2a31 3032 343b 0a20 2020 206c 3320  32*1024;.    l3 
+00001d40: 3d20 3531 322a 3130 3234 3b0a 2365 6e64  = 512*1024;.#end
+00001d50: 6966 0a0a 2020 2020 2f2f 2045 6172 6c79  if..    // Early
+00001d60: 2072 6574 7572 6e20 666f 7220 736d 616c   return for smal
+00001d70: 6c20 7072 6f62 6c65 6d73 2062 6563 6175  l problems becau
+00001d80: 7365 2074 6865 2063 6f6d 7075 7461 7469  se the computati
+00001d90: 6f6e 2062 656c 6f77 2061 7265 2074 696d  on below are tim
+00001da0: 6520 636f 6e73 756d 696e 6720 666f 7220  e consuming for 
+00001db0: 736d 616c 6c20 7072 6f62 6c65 6d73 2e0a  small problems..
+00001dc0: 2020 2020 2f2f 2050 6572 6861 7073 2069      // Perhaps i
+00001dd0: 7420 776f 756c 6420 6d61 6b65 206d 6f72  t would make mor
+00001de0: 6520 7365 6e73 6520 746f 2063 6f6e 7369  e sense to consi
+00001df0: 6465 7220 6b2a 6e2a 6d3f 3f0a 2020 2020  der k*n*m??.    
+00001e00: 2f2f 204e 6f74 6520 7468 6174 2066 6f72  // Note that for
+00001e10: 2076 6572 7920 7469 6e79 2070 726f 626c   very tiny probl
+00001e20: 656d 2c20 7468 6973 2066 756e 6374 696f  em, this functio
+00001e30: 6e20 7368 6f75 6c64 2062 6520 6279 7061  n should be bypa
+00001e40: 7373 6564 2061 6e79 7761 790a 2020 2020  ssed anyway.    
+00001e50: 2f2f 2062 6563 6175 7365 2077 6520 7573  // because we us
+00001e60: 6520 7468 6520 636f 6566 6669 6369 656e  e the coefficien
+00001e70: 742d 6261 7365 6420 696d 706c 656d 656e  t-based implemen
+00001e80: 7461 7469 6f6e 2066 6f72 2074 6865 6d2e  tation for them.
+00001e90: 0a20 2020 2069 6628 286e 756d 6578 743a  .    if((numext:
+00001ea0: 3a6d 6178 6929 286b 2c28 6e75 6d65 7874  :maxi)(k,(numext
+00001eb0: 3a3a 6d61 7869 2928 6d2c 6e29 293c 3438  ::maxi)(m,n))<48
+00001ec0: 290a 2020 2020 2020 7265 7475 726e 3b0a  ).      return;.
+00001ed0: 0a20 2020 2074 7970 6564 6566 2074 7970  .    typedef typ
+00001ee0: 656e 616d 6520 5472 6169 7473 3a3a 5265  ename Traits::Re
+00001ef0: 7353 6361 6c61 7220 5265 7353 6361 6c61  sScalar ResScala
+00001f00: 723b 0a20 2020 2065 6e75 6d20 7b0a 2020  r;.    enum {.  
+00001f10: 2020 2020 6b5f 7065 656c 696e 6720 3d20      k_peeling = 
+00001f20: 382c 0a20 2020 2020 206b 5f64 6976 203d  8,.      k_div =
+00001f30: 204b 6346 6163 746f 7220 2a20 2854 7261   KcFactor * (Tra
+00001f40: 6974 733a 3a6d 7220 2a20 7369 7a65 6f66  its::mr * sizeof
+00001f50: 284c 6873 5363 616c 6172 2920 2b20 5472  (LhsScalar) + Tr
+00001f60: 6169 7473 3a3a 6e72 202a 2073 697a 656f  aits::nr * sizeo
+00001f70: 6628 5268 7353 6361 6c61 7229 292c 0a20  f(RhsScalar)),. 
+00001f80: 2020 2020 206b 5f73 7562 203d 2054 7261       k_sub = Tra
+00001f90: 6974 733a 3a6d 7220 2a20 5472 6169 7473  its::mr * Traits
+00001fa0: 3a3a 6e72 202a 2073 697a 656f 6628 5265  ::nr * sizeof(Re
+00001fb0: 7353 6361 6c61 7229 0a20 2020 207d 3b0a  sScalar).    };.
+00001fc0: 0a20 2020 202f 2f20 2d2d 2d2d 2031 7374  .    // ---- 1st
+00001fd0: 206c 6576 656c 206f 6620 626c 6f63 6b69   level of blocki
+00001fe0: 6e67 206f 6e20 4c31 2c20 7969 656c 6473  ng on L1, yields
+00001ff0: 206b 6320 2d2d 2d2d 0a0a 2020 2020 2f2f   kc ----..    //
+00002000: 2042 6c6f 636b 696e 6720 6f6e 2074 6865   Blocking on the
+00002010: 2074 6869 7264 2064 696d 656e 7369 6f6e   third dimension
+00002020: 2028 692e 652e 2c20 6b29 2069 7320 6368   (i.e., k) is ch
+00002030: 6f73 656e 2073 6f20 7468 6174 2061 6e20  osen so that an 
+00002040: 686f 7269 7a6f 6e74 616c 2070 616e 656c  horizontal panel
+00002050: 0a20 2020 202f 2f20 6f66 2073 697a 6520  .    // of size 
+00002060: 6d72 2078 206b 6320 6f66 2074 6865 206c  mr x kc of the l
+00002070: 6873 2070 6c75 7320 6120 7665 7274 6963  hs plus a vertic
+00002080: 616c 2070 616e 656c 206f 6620 6b63 2078  al panel of kc x
+00002090: 206e 7220 6f66 2074 6865 2072 6873 2062   nr of the rhs b
+000020a0: 6f74 6820 6669 7473 2077 6974 6869 6e20  oth fits within 
+000020b0: 4c31 2063 6163 6865 2e0a 2020 2020 2f2f  L1 cache..    //
+000020c0: 2057 6520 616c 736f 2069 6e63 6c75 6465   We also include
+000020d0: 2061 2072 6567 6973 7465 722d 6c65 7665   a register-leve
+000020e0: 6c20 626c 6f63 6b20 6f66 2074 6865 2072  l block of the r
+000020f0: 6573 756c 7420 286d 7820 7820 6e72 292e  esult (mx x nr).
+00002100: 0a20 2020 202f 2f20 2849 6e20 616e 2069  .    // (In an i
+00002110: 6465 616c 2077 6f72 6c64 206f 6e6c 7920  deal world only 
+00002120: 7468 6520 6c68 7320 7061 6e65 6c20 776f  the lhs panel wo
+00002130: 756c 6420 7374 6179 2069 6e20 4c31 290a  uld stay in L1).
+00002140: 2020 2020 2f2f 204d 6f72 656f 7665 722c      // Moreover,
+00002150: 206b 6320 6861 7320 746f 2062 6520 6120   kc has to be a 
+00002160: 6d75 6c74 6970 6c65 206f 6620 3820 746f  multiple of 8 to
+00002170: 2062 6520 636f 6d70 6174 6962 6c65 2077   be compatible w
+00002180: 6974 6820 6c6f 6f70 2070 6565 6c69 6e67  ith loop peeling
+00002190: 2c20 6c65 6164 696e 6720 746f 2061 206d  , leading to a m
+000021a0: 6178 696d 756d 2062 6c6f 636b 696e 6720  aximum blocking 
+000021b0: 7369 7a65 206f 663a 0a20 2020 2063 6f6e  size of:.    con
+000021c0: 7374 2049 6e64 6578 206d 6178 5f6b 6320  st Index max_kc 
+000021d0: 3d20 6e75 6d65 7874 3a3a 6d61 7869 3c49  = numext::maxi<I
+000021e0: 6e64 6578 3e28 2828 6c31 2d6b 5f73 7562  ndex>(((l1-k_sub
+000021f0: 292f 6b5f 6469 7629 2026 2028 7e28 6b5f  )/k_div) & (~(k_
+00002200: 7065 656c 696e 672d 3129 292c 3129 3b0a  peeling-1)),1);.
+00002210: 2020 2020 636f 6e73 7420 496e 6465 7820      const Index 
+00002220: 6f6c 645f 6b20 3d20 6b3b 0a20 2020 2069  old_k = k;.    i
+00002230: 6628 6b3e 6d61 785f 6b63 290a 2020 2020  f(k>max_kc).    
+00002240: 7b0a 2020 2020 2020 2f2f 2057 6520 6172  {.      // We ar
+00002250: 6520 7265 616c 6c79 2062 6c6f 636b 696e  e really blockin
+00002260: 6720 6f6e 2074 6865 2074 6869 7264 2064  g on the third d
+00002270: 696d 656e 7369 6f6e 3a0a 2020 2020 2020  imension:.      
+00002280: 2f2f 202d 3e20 7265 6475 6365 2062 6c6f  // -> reduce blo
+00002290: 636b 696e 6720 7369 7a65 2074 6f20 6d61  cking size to ma
+000022a0: 6b65 2073 7572 6520 7468 6520 6c61 7374  ke sure the last
+000022b0: 2062 6c6f 636b 2069 7320 6173 206c 6172   block is as lar
+000022c0: 6765 2061 7320 706f 7373 6962 6c65 0a20  ge as possible. 
+000022d0: 2020 2020 202f 2f20 2020 2077 6869 6c65       //    while
+000022e0: 206b 6565 7069 6e67 2074 6865 2073 616d   keeping the sam
+000022f0: 6520 6e75 6d62 6572 206f 6620 7377 6565  e number of swee
+00002300: 7073 206f 7665 7220 7468 6520 7265 7375  ps over the resu
+00002310: 6c74 2e0a 2020 2020 2020 6b20 3d20 286b  lt..      k = (k
+00002320: 256d 6178 5f6b 6329 3d3d 3020 3f20 6d61  %max_kc)==0 ? ma
+00002330: 785f 6b63 0a20 2020 2020 2020 2020 2020  x_kc.           
+00002340: 2020 2020 2020 2020 2020 2020 203a 206d               : m
+00002350: 6178 5f6b 6320 2d20 6b5f 7065 656c 696e  ax_kc - k_peelin
+00002360: 6720 2a20 2828 6d61 785f 6b63 2d31 2d28  g * ((max_kc-1-(
+00002370: 6b25 6d61 785f 6b63 2929 2f28 6b5f 7065  k%max_kc))/(k_pe
+00002380: 656c 696e 672a 286b 2f6d 6178 5f6b 632b  eling*(k/max_kc+
+00002390: 3129 2929 3b0a 0a20 2020 2020 2065 6967  1)));..      eig
+000023a0: 656e 5f69 6e74 6572 6e61 6c5f 6173 7365  en_internal_asse
+000023b0: 7274 2828 286f 6c64 5f6b 2f6b 2920 3d3d  rt(((old_k/k) ==
+000023c0: 2028 6f6c 645f 6b2f 6d61 785f 6b63 2929   (old_k/max_kc))
+000023d0: 2026 2620 2274 6865 206e 756d 6265 7220   && "the number 
+000023e0: 6f66 2073 7765 6570 7320 6861 7320 746f  of sweeps has to
+000023f0: 2072 656d 6169 6e20 7468 6520 7361 6d65   remain the same
+00002400: 2229 3b0a 2020 2020 7d0a 0a20 2020 202f  ");.    }..    /
+00002410: 2f20 2d2d 2d2d 2032 6e64 206c 6576 656c  / ---- 2nd level
+00002420: 206f 6620 626c 6f63 6b69 6e67 206f 6e20   of blocking on 
+00002430: 6d61 7828 4c32 2c4c 3329 2c20 7969 656c  max(L2,L3), yiel
+00002440: 6473 206e 6320 2d2d 2d2d 0a0a 2020 2020  ds nc ----..    
+00002450: 2f2f 2054 4f44 4f20 6669 6e64 2061 2072  // TODO find a r
+00002460: 656c 6961 626c 6520 7761 7920 746f 2067  eliable way to g
+00002470: 6574 2074 6865 2061 6374 7561 6c20 616d  et the actual am
+00002480: 6f75 6e74 206f 6620 6361 6368 6520 7065  ount of cache pe
+00002490: 7220 636f 7265 2074 6f20 7573 6520 666f  r core to use fo
+000024a0: 7220 326e 6420 6c65 7665 6c20 626c 6f63  r 2nd level bloc
+000024b0: 6b69 6e67 2c20 7468 6174 2069 733a 0a20  king, that is:. 
+000024c0: 2020 202f 2f20 2020 2020 2061 6374 7561     //      actua
+000024d0: 6c5f 6c32 203d 206d 6178 286c 322c 206c  l_l2 = max(l2, l
+000024e0: 332f 6e62 5f63 6f72 655f 7368 6172 696e  3/nb_core_sharin
+000024f0: 675f 6c33 290a 2020 2020 2f2f 2054 6865  g_l3).    // The
+00002500: 206e 756d 6265 7220 6265 6c6f 7720 6973   number below is
+00002510: 2071 7569 7465 2063 6f6e 7365 7276 6174   quite conservat
+00002520: 6976 653a 2069 7420 6973 2062 6574 7465  ive: it is bette
+00002530: 7220 746f 2075 6e64 6572 6573 7469 6d61  r to underestima
+00002540: 7465 2074 6865 2063 6163 6865 2073 697a  te the cache siz
+00002550: 6520 7261 7468 6572 2074 6861 6e20 6f76  e rather than ov
+00002560: 6572 6573 7469 6d61 7469 6e67 2069 7429  erestimating it)
+00002570: 0a20 2020 202f 2f20 466f 7220 696e 7374  .    // For inst
+00002580: 616e 6365 2c20 6974 2063 6f72 7265 7370  ance, it corresp
+00002590: 6f6e 6473 2074 6f20 364d 4220 6f66 204c  onds to 6MB of L
+000025a0: 3320 7368 6172 6564 2061 6d6f 6e67 2034  3 shared among 4
+000025b0: 2063 6f72 6573 2e0a 2020 2020 2369 6664   cores..    #ifd
+000025c0: 6566 2045 4947 454e 5f44 4542 5547 5f53  ef EIGEN_DEBUG_S
+000025d0: 4d41 4c4c 5f50 524f 4455 4354 5f42 4c4f  MALL_PRODUCT_BLO
+000025e0: 434b 530a 2020 2020 636f 6e73 7420 496e  CKS.    const In
+000025f0: 6465 7820 6163 7475 616c 5f6c 3220 3d20  dex actual_l2 = 
+00002600: 6c33 3b0a 2020 2020 2365 6c73 650a 2020  l3;.    #else.  
+00002610: 2020 636f 6e73 7420 496e 6465 7820 6163    const Index ac
+00002620: 7475 616c 5f6c 3220 3d20 3135 3732 3836  tual_l2 = 157286
+00002630: 343b 202f 2f20 3d3d 2031 2e35 204d 420a  4; // == 1.5 MB.
+00002640: 2020 2020 2365 6e64 6966 0a0a 2020 2020      #endif..    
+00002650: 2f2f 2048 6572 652c 206e 6320 6973 2063  // Here, nc is c
+00002660: 686f 7365 6e20 7375 6368 2074 6861 7420  hosen such that 
+00002670: 6120 626c 6f63 6b20 6f66 206b 6320 7820  a block of kc x 
+00002680: 6e63 206f 6620 7468 6520 7268 7320 6669  nc of the rhs fi
+00002690: 7420 7769 7468 696e 2068 616c 6620 6f66  t within half of
+000026a0: 204c 322e 0a20 2020 202f 2f20 5468 6520   L2..    // The 
+000026b0: 7365 636f 6e64 2068 616c 6620 6973 2069  second half is i
+000026c0: 6d70 6c69 6369 746c 7920 7265 7365 7276  mplicitly reserv
+000026d0: 6564 2074 6f20 6163 6365 7373 2074 6865  ed to access the
+000026e0: 2072 6573 756c 7420 616e 6420 6c68 7320   result and lhs 
+000026f0: 636f 6566 6669 6369 656e 7473 2e0a 2020  coefficients..  
+00002700: 2020 2f2f 2057 6865 6e20 6b3c 6d61 785f    // When k<max_
+00002710: 6b63 2c20 7468 656e 206e 6320 6361 6e20  kc, then nc can 
+00002720: 6172 6269 7472 6172 696c 7920 6772 6f77  arbitrarily grow
+00002730: 7468 2e20 496e 2070 7261 6374 6963 652c  th. In practice,
+00002740: 2069 7420 7365 656d 7320 746f 2062 6520   it seems to be 
+00002750: 6672 7569 7466 756c 0a20 2020 202f 2f20  fruitful.    // 
+00002760: 746f 206c 696d 6974 2074 6869 7320 6772  to limit this gr
+00002770: 6f77 7468 3a20 7765 2062 6f75 6e64 206e  owth: we bound n
+00002780: 6320 746f 2067 726f 7774 6820 6279 2061  c to growth by a
+00002790: 2066 6163 746f 7220 7831 2e35 2e0a 2020   factor x1.5..  
+000027a0: 2020 2f2f 2048 6f77 6576 6572 2c20 6966    // However, if
+000027b0: 2074 6865 2065 6e74 6972 6520 6c68 7320   the entire lhs 
+000027c0: 626c 6f63 6b20 6669 7420 7769 7468 696e  block fit within
+000027d0: 204c 312c 2074 6865 6e20 7765 2061 7265   L1, then we are
+000027e0: 206e 6f74 2067 6f69 6e67 2074 6f20 626c   not going to bl
+000027f0: 6f63 6b20 6f6e 2074 6865 2072 6f77 7320  ock on the rows 
+00002800: 6174 2061 6c6c 2c0a 2020 2020 2f2f 2061  at all,.    // a
+00002810: 6e64 2069 7420 6265 636f 6d65 7320 6672  nd it becomes fr
+00002820: 7569 7466 756c 2074 6f20 6b65 6570 2074  uitful to keep t
+00002830: 6865 2070 6163 6b65 6420 7268 7320 626c  he packed rhs bl
+00002840: 6f63 6b73 2069 6e20 4c31 2069 6620 7468  ocks in L1 if th
+00002850: 6572 6520 6973 2065 6e6f 7567 6820 7265  ere is enough re
+00002860: 6d61 696e 696e 6720 7370 6163 652e 0a20  maining space.. 
+00002870: 2020 2049 6e64 6578 206d 6178 5f6e 633b     Index max_nc;
+00002880: 0a20 2020 2063 6f6e 7374 2049 6e64 6578  .    const Index
+00002890: 206c 6873 5f62 7974 6573 203d 206d 202a   lhs_bytes = m *
+000028a0: 206b 202a 2073 697a 656f 6628 4c68 7353   k * sizeof(LhsS
+000028b0: 6361 6c61 7229 3b0a 2020 2020 636f 6e73  calar);.    cons
+000028c0: 7420 496e 6465 7820 7265 6d61 696e 696e  t Index remainin
+000028d0: 675f 6c31 203d 206c 312d 206b 5f73 7562  g_l1 = l1- k_sub
+000028e0: 202d 206c 6873 5f62 7974 6573 3b0a 2020   - lhs_bytes;.  
+000028f0: 2020 6966 2872 656d 6169 6e69 6e67 5f6c    if(remaining_l
+00002900: 3120 3e3d 2049 6e64 6578 2854 7261 6974  1 >= Index(Trait
+00002910: 733a 3a6e 722a 7369 7a65 6f66 2852 6873  s::nr*sizeof(Rhs
+00002920: 5363 616c 6172 2929 2a6b 290a 2020 2020  Scalar))*k).    
+00002930: 7b0a 2020 2020 2020 2f2f 204c 3120 626c  {.      // L1 bl
+00002940: 6f63 6b69 6e67 0a20 2020 2020 206d 6178  ocking.      max
+00002950: 5f6e 6320 3d20 7265 6d61 696e 696e 675f  _nc = remaining_
+00002960: 6c31 202f 2028 6b2a 7369 7a65 6f66 2852  l1 / (k*sizeof(R
+00002970: 6873 5363 616c 6172 2929 3b0a 2020 2020  hsScalar));.    
+00002980: 7d0a 2020 2020 656c 7365 0a20 2020 207b  }.    else.    {
+00002990: 0a20 2020 2020 202f 2f20 4c32 2062 6c6f  .      // L2 blo
+000029a0: 636b 696e 670a 2020 2020 2020 6d61 785f  cking.      max_
+000029b0: 6e63 203d 2028 332a 6163 7475 616c 5f6c  nc = (3*actual_l
+000029c0: 3229 2f28 322a 322a 6d61 785f 6b63 2a73  2)/(2*2*max_kc*s
+000029d0: 697a 656f 6628 5268 7353 6361 6c61 7229  izeof(RhsScalar)
+000029e0: 293b 0a20 2020 207d 0a20 2020 202f 2f20  );.    }.    // 
+000029f0: 5741 524e 494e 4720 4265 6c6f 772c 2077  WARNING Below, w
+00002a00: 6520 6173 7375 6d65 2074 6861 7420 5472  e assume that Tr
+00002a10: 6169 7473 3a3a 6e72 2069 7320 6120 706f  aits::nr is a po
+00002a20: 7765 7220 6f66 2074 776f 2e0a 2020 2020  wer of two..    
+00002a30: 496e 6465 7820 6e63 203d 206e 756d 6578  Index nc = numex
+00002a40: 743a 3a6d 696e 693c 496e 6465 783e 2861  t::mini<Index>(a
+00002a50: 6374 7561 6c5f 6c32 2f28 322a 6b2a 7369  ctual_l2/(2*k*si
+00002a60: 7a65 6f66 2852 6873 5363 616c 6172 2929  zeof(RhsScalar))
+00002a70: 2c20 6d61 785f 6e63 2920 2620 287e 2854  , max_nc) & (~(T
+00002a80: 7261 6974 733a 3a6e 722d 3129 293b 0a20  raits::nr-1));. 
+00002a90: 2020 2069 6628 6e3e 6e63 290a 2020 2020     if(n>nc).    
+00002aa0: 7b0a 2020 2020 2020 2f2f 2057 6520 6172  {.      // We ar
+00002ab0: 6520 7265 616c 6c79 2062 6c6f 636b 696e  e really blockin
+00002ac0: 6720 6f76 6572 2074 6865 2063 6f6c 756d  g over the colum
+00002ad0: 6e73 3a0a 2020 2020 2020 2f2f 202d 3e20  ns:.      // -> 
+00002ae0: 7265 6475 6365 2062 6c6f 636b 696e 6720  reduce blocking 
+00002af0: 7369 7a65 2074 6f20 6d61 6b65 2073 7572  size to make sur
+00002b00: 6520 7468 6520 6c61 7374 2062 6c6f 636b  e the last block
+00002b10: 2069 7320 6173 206c 6172 6765 2061 7320   is as large as 
+00002b20: 706f 7373 6962 6c65 0a20 2020 2020 202f  possible.      /
+00002b30: 2f20 2020 2077 6869 6c65 206b 6565 7069  /    while keepi
+00002b40: 6e67 2074 6865 2073 616d 6520 6e75 6d62  ng the same numb
+00002b50: 6572 206f 6620 7377 6565 7073 206f 7665  er of sweeps ove
+00002b60: 7220 7468 6520 7061 636b 6564 206c 6873  r the packed lhs
+00002b70: 2e0a 2020 2020 2020 2f2f 2020 2020 4865  ..      //    He
+00002b80: 7265 2077 6520 616c 6c6f 7720 6f6e 6520  re we allow one 
+00002b90: 6d6f 7265 2073 7765 6570 2069 6620 7468  more sweep if th
+00002ba0: 6973 2067 6976 6573 2075 7320 6120 7065  is gives us a pe
+00002bb0: 7266 6563 7420 6d61 7463 682c 2074 6875  rfect match, thu
+00002bc0: 7320 7468 6520 636f 6d6d 656e 7465 6420  s the commented 
+00002bd0: 222d 3122 0a20 2020 2020 206e 203d 2028  "-1".      n = (
+00002be0: 6e25 6e63 293d 3d30 203f 206e 630a 2020  n%nc)==0 ? nc.  
+00002bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002c00: 2020 3a20 286e 6320 2d20 5472 6169 7473    : (nc - Traits
+00002c10: 3a3a 6e72 202a 2028 286e 632f 2a2d 312a  ::nr * ((nc/*-1*
+00002c20: 2f2d 286e 256e 6329 292f 2854 7261 6974  /-(n%nc))/(Trait
+00002c30: 733a 3a6e 722a 286e 2f6e 632b 3129 2929  s::nr*(n/nc+1)))
+00002c40: 293b 0a20 2020 207d 0a20 2020 2065 6c73  );.    }.    els
+00002c50: 6520 6966 286f 6c64 5f6b 3d3d 6b29 0a20  e if(old_k==k). 
+00002c60: 2020 207b 0a20 2020 2020 202f 2f20 536f     {.      // So
+00002c70: 2066 6172 2c20 6e6f 2062 6c6f 636b 696e   far, no blockin
+00002c80: 6720 6174 2061 6c6c 2c20 692e 652e 2c20  g at all, i.e., 
+00002c90: 6b63 3d3d 6b2c 2061 6e64 206e 633d 3d6e  kc==k, and nc==n
+00002ca0: 2e0a 2020 2020 2020 2f2f 2049 6e20 7468  ..      // In th
+00002cb0: 6973 2063 6173 652c 206c 6574 2773 2070  is case, let's p
+00002cc0: 6572 666f 726d 2061 2062 6c6f 636b 696e  erform a blockin
+00002cd0: 6720 6f76 6572 2074 6865 2072 6f77 7320  g over the rows 
+00002ce0: 7375 6368 2074 6861 7420 7468 6520 7061  such that the pa
+00002cf0: 636b 6564 206c 6873 2064 6174 6120 6973  cked lhs data is
+00002d00: 206b 6570 7420 696e 2063 6163 6865 204c   kept in cache L
+00002d10: 312f 4c32 0a20 2020 2020 202f 2f20 544f  1/L2.      // TO
+00002d20: 444f 3a20 7061 7274 206f 6620 7468 6973  DO: part of this
+00002d30: 2062 6c6f 636b 696e 6720 7374 7261 7465   blocking strate
+00002d40: 6779 2069 7320 6e6f 7720 696d 706c 656d  gy is now implem
+00002d50: 656e 7465 6420 7769 7468 696e 2074 6865  ented within the
+00002d60: 206b 6572 6e65 6c20 6974 7365 6c66 2c20   kernel itself, 
+00002d70: 736f 2074 6865 204c 312d 6261 7365 6420  so the L1-based 
+00002d80: 6865 7572 6973 7469 6320 6865 7265 2073  heuristic here s
+00002d90: 686f 756c 6420 6265 206f 6273 6f6c 6574  hould be obsolet
+00002da0: 652e 0a20 2020 2020 2049 6e64 6578 2070  e..      Index p
+00002db0: 726f 626c 656d 5f73 697a 6520 3d20 6b2a  roblem_size = k*
+00002dc0: 6e2a 7369 7a65 6f66 284c 6873 5363 616c  n*sizeof(LhsScal
+00002dd0: 6172 293b 0a20 2020 2020 2049 6e64 6578  ar);.      Index
+00002de0: 2061 6374 7561 6c5f 6c6d 203d 2061 6374   actual_lm = act
+00002df0: 7561 6c5f 6c32 3b0a 2020 2020 2020 496e  ual_l2;.      In
+00002e00: 6465 7820 6d61 785f 6d63 203d 206d 3b0a  dex max_mc = m;.
+00002e10: 2020 2020 2020 6966 2870 726f 626c 656d        if(problem
+00002e20: 5f73 697a 653c 3d31 3032 3429 0a20 2020  _size<=1024).   
+00002e30: 2020 207b 0a20 2020 2020 2020 202f 2f20     {.        // 
+00002e40: 7072 6f62 6c65 6d20 6973 2073 6d61 6c6c  problem is small
+00002e50: 2065 6e6f 7567 6820 746f 206b 6565 7020   enough to keep 
+00002e60: 696e 204c 310a 2020 2020 2020 2020 2f2f  in L1.        //
+00002e70: 204c 6574 2773 2063 686f 6f73 6520 6d20   Let's choose m 
+00002e80: 7375 6368 2074 6861 7420 6c68 7327 7320  such that lhs's 
+00002e90: 626c 6f63 6b20 6669 7420 696e 2031 2f33  block fit in 1/3
+00002ea0: 206f 6620 4c31 0a20 2020 2020 2020 2061   of L1.        a
+00002eb0: 6374 7561 6c5f 6c6d 203d 206c 313b 0a20  ctual_lm = l1;. 
+00002ec0: 2020 2020 207d 0a20 2020 2020 2065 6c73       }.      els
+00002ed0: 6520 6966 286c 3321 3d30 2026 2620 7072  e if(l3!=0 && pr
+00002ee0: 6f62 6c65 6d5f 7369 7a65 3c3d 3332 3736  oblem_size<=3276
+00002ef0: 3829 0a20 2020 2020 207b 0a20 2020 2020  8).      {.     
+00002f00: 2020 202f 2f20 7765 2068 6176 6520 626f     // we have bo
+00002f10: 7468 204c 3220 616e 6420 4c33 2c20 616e  th L2 and L3, an
+00002f20: 6420 7072 6f62 6c65 6d20 6973 2073 6d61  d problem is sma
+00002f30: 6c6c 2065 6e6f 7567 6820 746f 2062 6520  ll enough to be 
+00002f40: 6b65 7074 2069 6e20 4c32 0a20 2020 2020  kept in L2.     
+00002f50: 2020 202f 2f20 4c65 7427 7320 6368 6f6f     // Let's choo
+00002f60: 7365 206d 2073 7563 6820 7468 6174 206c  se m such that l
+00002f70: 6873 2773 2062 6c6f 636b 2066 6974 2069  hs's block fit i
+00002f80: 6e20 312f 3320 6f66 204c 320a 2020 2020  n 1/3 of L2.    
+00002f90: 2020 2020 6163 7475 616c 5f6c 6d20 3d20      actual_lm = 
+00002fa0: 6c32 3b0a 2020 2020 2020 2020 6d61 785f  l2;.        max_
+00002fb0: 6d63 203d 2028 6e75 6d65 7874 3a3a 6d69  mc = (numext::mi
+00002fc0: 6e69 3c49 6e64 6578 3e29 2835 3736 2c6d  ni<Index>)(576,m
+00002fd0: 6178 5f6d 6329 3b0a 2020 2020 2020 7d0a  ax_mc);.      }.
+00002fe0: 2020 2020 2020 496e 6465 7820 6d63 203d        Index mc =
+00002ff0: 2028 6e75 6d65 7874 3a3a 6d69 6e69 3c49   (numext::mini<I
+00003000: 6e64 6578 3e29 2861 6374 7561 6c5f 6c6d  ndex>)(actual_lm
+00003010: 2f28 332a 6b2a 7369 7a65 6f66 284c 6873  /(3*k*sizeof(Lhs
+00003020: 5363 616c 6172 2929 2c20 6d61 785f 6d63  Scalar)), max_mc
+00003030: 293b 0a20 2020 2020 2069 6620 286d 6320  );.      if (mc 
+00003040: 3e20 5472 6169 7473 3a3a 6d72 2920 6d63  > Traits::mr) mc
+00003050: 202d 3d20 6d63 2025 2054 7261 6974 733a   -= mc % Traits:
+00003060: 3a6d 723b 0a20 2020 2020 2065 6c73 6520  :mr;.      else 
+00003070: 6966 2028 6d63 3d3d 3029 2072 6574 7572  if (mc==0) retur
+00003080: 6e3b 0a20 2020 2020 206d 203d 2028 6d25  n;.      m = (m%
+00003090: 6d63 293d 3d30 203f 206d 630a 2020 2020  mc)==0 ? mc.    
+000030a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000030b0: 3a20 286d 6320 2d20 5472 6169 7473 3a3a  : (mc - Traits::
+000030c0: 6d72 202a 2028 286d 632f 2a2d 312a 2f2d  mr * ((mc/*-1*/-
+000030d0: 286d 256d 6329 292f 2854 7261 6974 733a  (m%mc))/(Traits:
+000030e0: 3a6d 722a 286d 2f6d 632b 3129 2929 293b  :mr*(m/mc+1))));
+000030f0: 0a20 2020 207d 0a20 207d 0a7d 0a0a 7465  .    }.  }.}..te
+00003100: 6d70 6c61 7465 203c 7479 7065 6e61 6d65  mplate <typename
+00003110: 2049 6e64 6578 3e0a 696e 6c69 6e65 2062   Index>.inline b
+00003120: 6f6f 6c20 7573 6553 7065 6369 6669 6342  ool useSpecificB
+00003130: 6c6f 636b 696e 6753 697a 6573 2849 6e64  lockingSizes(Ind
+00003140: 6578 2620 6b2c 2049 6e64 6578 2620 6d2c  ex& k, Index& m,
+00003150: 2049 6e64 6578 2620 6e29 0a7b 0a23 6966   Index& n).{.#if
+00003160: 6465 6620 4549 4745 4e5f 5445 5354 5f53  def EIGEN_TEST_S
+00003170: 5045 4349 4649 435f 424c 4f43 4b49 4e47  PECIFIC_BLOCKING
+00003180: 5f53 495a 4553 0a20 2069 6620 2845 4947  _SIZES.  if (EIG
+00003190: 454e 5f54 4553 545f 5350 4543 4946 4943  EN_TEST_SPECIFIC
+000031a0: 5f42 4c4f 434b 494e 475f 5349 5a45 5329  _BLOCKING_SIZES)
+000031b0: 207b 0a20 2020 206b 203d 206e 756d 6578   {.    k = numex
+000031c0: 743a 3a6d 696e 693c 496e 6465 783e 286b  t::mini<Index>(k
+000031d0: 2c20 4549 4745 4e5f 5445 5354 5f53 5045  , EIGEN_TEST_SPE
+000031e0: 4349 4649 435f 424c 4f43 4b49 4e47 5f53  CIFIC_BLOCKING_S
+000031f0: 495a 455f 4b29 3b0a 2020 2020 6d20 3d20  IZE_K);.    m = 
+00003200: 6e75 6d65 7874 3a3a 6d69 6e69 3c49 6e64  numext::mini<Ind
+00003210: 6578 3e28 6d2c 2045 4947 454e 5f54 4553  ex>(m, EIGEN_TES
+00003220: 545f 5350 4543 4946 4943 5f42 4c4f 434b  T_SPECIFIC_BLOCK
+00003230: 494e 475f 5349 5a45 5f4d 293b 0a20 2020  ING_SIZE_M);.   
+00003240: 206e 203d 206e 756d 6578 743a 3a6d 696e   n = numext::min
+00003250: 693c 496e 6465 783e 286e 2c20 4549 4745  i<Index>(n, EIGE
+00003260: 4e5f 5445 5354 5f53 5045 4349 4649 435f  N_TEST_SPECIFIC_
+00003270: 424c 4f43 4b49 4e47 5f53 495a 455f 4e29  BLOCKING_SIZE_N)
+00003280: 3b0a 2020 2020 7265 7475 726e 2074 7275  ;.    return tru
+00003290: 653b 0a20 207d 0a23 656c 7365 0a20 2045  e;.  }.#else.  E
+000032a0: 4947 454e 5f55 4e55 5345 445f 5641 5249  IGEN_UNUSED_VARI
+000032b0: 4142 4c45 286b 290a 2020 4549 4745 4e5f  ABLE(k).  EIGEN_
+000032c0: 554e 5553 4544 5f56 4152 4941 424c 4528  UNUSED_VARIABLE(
+000032d0: 6d29 0a20 2045 4947 454e 5f55 4e55 5345  m).  EIGEN_UNUSE
+000032e0: 445f 5641 5249 4142 4c45 286e 290a 2365  D_VARIABLE(n).#e
+000032f0: 6e64 6966 0a20 2072 6574 7572 6e20 6661  ndif.  return fa
+00003300: 6c73 653b 0a7d 0a0a 2f2a 2a20 5c62 7269  lse;.}../** \bri
+00003310: 6566 2043 6f6d 7075 7465 7320 7468 6520  ef Computes the 
+00003320: 626c 6f63 6b69 6e67 2070 6172 616d 6574  blocking paramet
+00003330: 6572 7320 666f 7220 6120 6d20 7820 6b20  ers for a m x k 
+00003340: 7469 6d65 7320 6b20 7820 6e20 6d61 7472  times k x n matr
+00003350: 6978 2070 726f 6475 6374 0a20 202a 0a20  ix product.  *. 
+00003360: 202a 205c 7061 7261 6d5b 696e 2c6f 7574   * \param[in,out
+00003370: 5d20 6b20 496e 7075 743a 2074 6865 2074  ] k Input: the t
+00003380: 6869 7264 2064 696d 656e 7369 6f6e 206f  hird dimension o
+00003390: 6620 7468 6520 7072 6f64 7563 742e 204f  f the product. O
+000033a0: 7574 7075 743a 2074 6865 2062 6c6f 636b  utput: the block
+000033b0: 696e 6720 7369 7a65 2061 6c6f 6e67 2074  ing size along t
+000033c0: 6865 2073 616d 6520 6469 6d65 6e73 696f  he same dimensio
+000033d0: 6e2e 0a20 202a 205c 7061 7261 6d5b 696e  n..  * \param[in
+000033e0: 2c6f 7574 5d20 6d20 496e 7075 743a 2074  ,out] m Input: t
+000033f0: 6865 206e 756d 6265 7220 6f66 2072 6f77  he number of row
+00003400: 7320 6f66 2074 6865 206c 6566 7420 6861  s of the left ha
+00003410: 6e64 2073 6964 652e 204f 7574 7075 743a  nd side. Output:
+00003420: 2074 6865 2062 6c6f 636b 696e 6720 7369   the blocking si
+00003430: 7a65 2061 6c6f 6e67 2074 6865 2073 616d  ze along the sam
+00003440: 6520 6469 6d65 6e73 696f 6e2e 0a20 202a  e dimension..  *
+00003450: 205c 7061 7261 6d5b 696e 2c6f 7574 5d20   \param[in,out] 
+00003460: 6e20 496e 7075 743a 2074 6865 206e 756d  n Input: the num
+00003470: 6265 7220 6f66 2063 6f6c 756d 6e73 206f  ber of columns o
+00003480: 6620 7468 6520 7269 6768 7420 6861 6e64  f the right hand
+00003490: 2073 6964 652e 204f 7574 7075 743a 2074   side. Output: t
+000034a0: 6865 2062 6c6f 636b 696e 6720 7369 7a65  he blocking size
+000034b0: 2061 6c6f 6e67 2074 6865 2073 616d 6520   along the same 
+000034c0: 6469 6d65 6e73 696f 6e2e 0a20 202a 0a20  dimension..  *. 
+000034d0: 202a 2047 6976 656e 2061 206d 2078 206b   * Given a m x k
+000034e0: 2074 696d 6573 206b 2078 206e 206d 6174   times k x n mat
+000034f0: 7269 7820 7072 6f64 7563 7420 6f66 2073  rix product of s
+00003500: 6361 6c61 7220 7479 7065 7320 5c63 204c  calar types \c L
+00003510: 6873 5363 616c 6172 2061 6e64 205c 6320  hsScalar and \c 
+00003520: 5268 7353 6361 6c61 722c 0a20 202a 2074  RhsScalar,.  * t
+00003530: 6869 7320 6675 6e63 7469 6f6e 2063 6f6d  his function com
+00003540: 7075 7465 7320 7468 6520 626c 6f63 6b69  putes the blocki
+00003550: 6e67 2073 697a 6520 7061 7261 6d65 7465  ng size paramete
+00003560: 7273 2061 6c6f 6e67 2074 6865 2072 6573  rs along the res
+00003570: 7065 6374 6976 6520 6469 6d65 6e73 696f  pective dimensio
+00003580: 6e73 0a20 202a 2066 6f72 206d 6174 7269  ns.  * for matri
+00003590: 7820 7072 6f64 7563 7473 2061 6e64 2072  x products and r
+000035a0: 656c 6174 6564 2061 6c67 6f72 6974 686d  elated algorithm
+000035b0: 732e 0a20 202a 0a20 202a 2054 6865 2062  s..  *.  * The b
+000035c0: 6c6f 636b 696e 6720 7369 7a65 2070 6172  locking size par
+000035d0: 616d 6574 6572 7320 6d61 7920 6265 2065  ameters may be e
+000035e0: 7661 6c75 6174 6564 3a0a 2020 2a20 2020  valuated:.  *   
+000035f0: 2d20 6569 7468 6572 2062 7920 6120 6865  - either by a he
+00003600: 7572 6973 7469 6320 6261 7365 6420 6f6e  uristic based on
+00003610: 2063 6163 6865 2073 697a 6573 3b0a 2020   cache sizes;.  
+00003620: 2a20 2020 2d20 6f72 2075 7369 6e67 2066  *   - or using f
+00003630: 6978 6564 2070 7265 7363 7269 6265 6420  ixed prescribed 
+00003640: 7661 6c75 6573 2028 666f 7220 7465 7374  values (for test
+00003650: 696e 6720 7075 7270 6f73 6573 292e 0a20  ing purposes).. 
+00003660: 202a 0a20 202a 205c 7361 2073 6574 4370   *.  * \sa setCp
+00003670: 7543 6163 6865 5369 7a65 7320 2a2f 0a0a  uCacheSizes */..
+00003680: 7465 6d70 6c61 7465 3c74 7970 656e 616d  template<typenam
+00003690: 6520 4c68 7353 6361 6c61 722c 2074 7970  e LhsScalar, typ
+000036a0: 656e 616d 6520 5268 7353 6361 6c61 722c  ename RhsScalar,
+000036b0: 2069 6e74 204b 6346 6163 746f 722c 2074   int KcFactor, t
+000036c0: 7970 656e 616d 6520 496e 6465 783e 0a76  ypename Index>.v
+000036d0: 6f69 6420 636f 6d70 7574 6550 726f 6475  oid computeProdu
+000036e0: 6374 426c 6f63 6b69 6e67 5369 7a65 7328  ctBlockingSizes(
+000036f0: 496e 6465 7826 206b 2c20 496e 6465 7826  Index& k, Index&
+00003700: 206d 2c20 496e 6465 7826 206e 2c20 496e   m, Index& n, In
+00003710: 6465 7820 6e75 6d5f 7468 7265 6164 7320  dex num_threads 
+00003720: 3d20 3129 0a7b 0a20 2069 6620 2821 7573  = 1).{.  if (!us
+00003730: 6553 7065 6369 6669 6342 6c6f 636b 696e  eSpecificBlockin
+00003740: 6753 697a 6573 286b 2c20 6d2c 206e 2929  gSizes(k, m, n))
+00003750: 207b 0a20 2020 2065 7661 6c75 6174 6550   {.    evaluateP
+00003760: 726f 6475 6374 426c 6f63 6b69 6e67 5369  roductBlockingSi
+00003770: 7a65 7348 6575 7269 7374 6963 3c4c 6873  zesHeuristic<Lhs
+00003780: 5363 616c 6172 2c20 5268 7353 6361 6c61  Scalar, RhsScala
+00003790: 722c 204b 6346 6163 746f 722c 2049 6e64  r, KcFactor, Ind
+000037a0: 6578 3e28 6b2c 206d 2c20 6e2c 206e 756d  ex>(k, m, n, num
+000037b0: 5f74 6872 6561 6473 293b 0a20 207d 0a7d  _threads);.  }.}
+000037c0: 0a0a 7465 6d70 6c61 7465 3c74 7970 656e  ..template<typen
+000037d0: 616d 6520 4c68 7353 6361 6c61 722c 2074  ame LhsScalar, t
+000037e0: 7970 656e 616d 6520 5268 7353 6361 6c61  ypename RhsScala
+000037f0: 722c 2074 7970 656e 616d 6520 496e 6465  r, typename Inde
+00003800: 783e 0a69 6e6c 696e 6520 766f 6964 2063  x>.inline void c
+00003810: 6f6d 7075 7465 5072 6f64 7563 7442 6c6f  omputeProductBlo
+00003820: 636b 696e 6753 697a 6573 2849 6e64 6578  ckingSizes(Index
+00003830: 2620 6b2c 2049 6e64 6578 2620 6d2c 2049  & k, Index& m, I
+00003840: 6e64 6578 2620 6e2c 2049 6e64 6578 206e  ndex& n, Index n
+00003850: 756d 5f74 6872 6561 6473 203d 2031 290a  um_threads = 1).
+00003860: 7b0a 2020 636f 6d70 7574 6550 726f 6475  {.  computeProdu
+00003870: 6374 426c 6f63 6b69 6e67 5369 7a65 733c  ctBlockingSizes<
+00003880: 4c68 7353 6361 6c61 722c 5268 7353 6361  LhsScalar,RhsSca
+00003890: 6c61 722c 312c 496e 6465 783e 286b 2c20  lar,1,Index>(k, 
+000038a0: 6d2c 206e 2c20 6e75 6d5f 7468 7265 6164  m, n, num_thread
+000038b0: 7329 3b0a 7d0a 0a74 656d 706c 6174 6520  s);.}..template 
+000038c0: 3c74 7970 656e 616d 6520 5268 7350 6163  <typename RhsPac
+000038d0: 6b65 742c 2074 7970 656e 616d 6520 5268  ket, typename Rh
+000038e0: 7350 6163 6b65 7478 342c 2069 6e74 2072  sPacketx4, int r
+000038f0: 6567 6973 7465 7273 5f74 616b 656e 3e0a  egisters_taken>.
+00003900: 7374 7275 6374 2052 6873 5061 6e65 6c48  struct RhsPanelH
+00003910: 656c 7065 7220 7b0a 2070 7269 7661 7465  elper {. private
+00003920: 3a0a 2020 7374 6174 6963 2063 6f6e 7374  :.  static const
+00003930: 2069 6e74 2072 656d 6169 6e69 6e67 5f72   int remaining_r
+00003940: 6567 6973 7465 7273 203d 2045 4947 454e  egisters = EIGEN
+00003950: 5f41 5243 485f 4445 4641 554c 545f 4e55  _ARCH_DEFAULT_NU
+00003960: 4d42 4552 5f4f 465f 5245 4749 5354 4552  MBER_OF_REGISTER
+00003970: 5320 2d20 7265 6769 7374 6572 735f 7461  S - registers_ta
+00003980: 6b65 6e3b 0a20 7075 626c 6963 3a0a 2020  ken;. public:.  
+00003990: 7479 7065 6465 6620 7479 7065 6e61 6d65  typedef typename
+000039a0: 2063 6f6e 6469 7469 6f6e 616c 3c72 656d   conditional<rem
+000039b0: 6169 6e69 6e67 5f72 6567 6973 7465 7273  aining_registers
+000039c0: 3e3d 342c 2052 6873 5061 636b 6574 7834  >=4, RhsPacketx4
+000039d0: 2c20 5268 7350 6163 6b65 743e 3a3a 7479  , RhsPacket>::ty
+000039e0: 7065 2074 7970 653b 0a7d 3b0a 0a74 656d  pe type;.};..tem
+000039f0: 706c 6174 6520 3c74 7970 656e 616d 6520  plate <typename 
+00003a00: 5061 636b 6574 3e0a 7374 7275 6374 2051  Packet>.struct Q
+00003a10: 7561 6450 6163 6b65 740a 7b0a 2020 5061  uadPacket.{.  Pa
+00003a20: 636b 6574 2042 5f30 2c20 4231 2c20 4232  cket B_0, B1, B2
+00003a30: 2c20 4233 3b0a 2020 636f 6e73 7420 5061  , B3;.  const Pa
+00003a40: 636b 6574 2620 6765 7428 636f 6e73 7420  cket& get(const 
+00003a50: 4669 7865 6449 6e74 3c30 3e26 2920 636f  FixedInt<0>&) co
+00003a60: 6e73 7420 7b20 7265 7475 726e 2042 5f30  nst { return B_0
+00003a70: 3b20 7d0a 2020 636f 6e73 7420 5061 636b  ; }.  const Pack
+00003a80: 6574 2620 6765 7428 636f 6e73 7420 4669  et& get(const Fi
+00003a90: 7865 6449 6e74 3c31 3e26 2920 636f 6e73  xedInt<1>&) cons
+00003aa0: 7420 7b20 7265 7475 726e 2042 313b 207d  t { return B1; }
+00003ab0: 0a20 2063 6f6e 7374 2050 6163 6b65 7426  .  const Packet&
+00003ac0: 2067 6574 2863 6f6e 7374 2046 6978 6564   get(const Fixed
+00003ad0: 496e 743c 323e 2629 2063 6f6e 7374 207b  Int<2>&) const {
+00003ae0: 2072 6574 7572 6e20 4232 3b20 7d0a 2020   return B2; }.  
+00003af0: 636f 6e73 7420 5061 636b 6574 2620 6765  const Packet& ge
+00003b00: 7428 636f 6e73 7420 4669 7865 6449 6e74  t(const FixedInt
+00003b10: 3c33 3e26 2920 636f 6e73 7420 7b20 7265  <3>&) const { re
+00003b20: 7475 726e 2042 333b 207d 0a7d 3b0a 0a74  turn B3; }.};..t
+00003b30: 656d 706c 6174 6520 3c69 6e74 204e 2c20  emplate <int N, 
+00003b40: 7479 7065 6e61 6d65 2054 312c 2074 7970  typename T1, typ
+00003b50: 656e 616d 6520 5432 2c20 7479 7065 6e61  ename T2, typena
+00003b60: 6d65 2054 333e 0a73 7472 7563 7420 7061  me T3>.struct pa
+00003b70: 636b 6574 5f63 6f6e 6469 7469 6f6e 616c  cket_conditional
+00003b80: 207b 2074 7970 6564 6566 2054 3320 7479   { typedef T3 ty
+00003b90: 7065 3b20 7d3b 0a0a 7465 6d70 6c61 7465  pe; };..template
+00003ba0: 203c 7479 7065 6e61 6d65 2054 312c 2074   <typename T1, t
+00003bb0: 7970 656e 616d 6520 5432 2c20 7479 7065  ypename T2, type
+00003bc0: 6e61 6d65 2054 333e 0a73 7472 7563 7420  name T3>.struct 
+00003bd0: 7061 636b 6574 5f63 6f6e 6469 7469 6f6e  packet_condition
+00003be0: 616c 3c47 4542 5050 6163 6b65 7446 756c  al<GEBPPacketFul
+00003bf0: 6c2c 2054 312c 2054 322c 2054 333e 207b  l, T1, T2, T3> {
+00003c00: 2074 7970 6564 6566 2054 3120 7479 7065   typedef T1 type
+00003c10: 3b20 7d3b 0a0a 7465 6d70 6c61 7465 203c  ; };..template <
+00003c20: 7479 7065 6e61 6d65 2054 312c 2074 7970  typename T1, typ
+00003c30: 656e 616d 6520 5432 2c20 7479 7065 6e61  ename T2, typena
+00003c40: 6d65 2054 333e 0a73 7472 7563 7420 7061  me T3>.struct pa
+00003c50: 636b 6574 5f63 6f6e 6469 7469 6f6e 616c  cket_conditional
+00003c60: 3c47 4542 5050 6163 6b65 7448 616c 662c  <GEBPPacketHalf,
+00003c70: 2054 312c 2054 322c 2054 333e 207b 2074   T1, T2, T3> { t
+00003c80: 7970 6564 6566 2054 3220 7479 7065 3b20  ypedef T2 type; 
+00003c90: 7d3b 0a0a 2364 6566 696e 6520 5041 434b  };..#define PACK
+00003ca0: 4554 5f44 4543 4c5f 434f 4e44 5f50 5245  ET_DECL_COND_PRE
+00003cb0: 4649 5828 7072 6566 6978 2c20 6e61 6d65  FIX(prefix, name
+00003cc0: 2c20 7061 636b 6574 5f73 697a 6529 2020  , packet_size)  
+00003cd0: 2020 2020 2020 205c 0a20 2074 7970 6564         \.  typed
+00003ce0: 6566 2074 7970 656e 616d 6520 7061 636b  ef typename pack
+00003cf0: 6574 5f63 6f6e 6469 7469 6f6e 616c 3c70  et_conditional<p
+00003d00: 6163 6b65 745f 7369 7a65 2c20 2020 2020  acket_size,     
+00003d10: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
+00003d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003d40: 2020 2020 7479 7065 6e61 6d65 2070 6163      typename pac
+00003d50: 6b65 745f 7472 6169 7473 3c6e 616d 6520  ket_traits<name 
+00003d60: 2323 2053 6361 6c61 723e 3a3a 7479 7065  ## Scalar>::type
+00003d70: 2c20 5c0a 2020 2020 2020 2020 2020 2020  , \.            
+00003d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003d90: 2020 2020 2020 2020 2020 7479 7065 6e61            typena
+00003da0: 6d65 2070 6163 6b65 745f 7472 6169 7473  me packet_traits
+00003db0: 3c6e 616d 6520 2323 2053 6361 6c61 723e  <name ## Scalar>
+00003dc0: 3a3a 6861 6c66 2c20 5c0a 2020 2020 2020  ::half, \.      
+00003dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003df0: 7479 7065 6e61 6d65 2075 6e70 6163 6b65  typename unpacke
+00003e00: 745f 7472 6169 7473 3c74 7970 656e 616d  t_traits<typenam
+00003e10: 6520 7061 636b 6574 5f74 7261 6974 733c  e packet_traits<
+00003e20: 6e61 6d65 2023 2320 5363 616c 6172 3e3a  name ## Scalar>:
+00003e30: 3a68 616c 663e 3a3a 6861 6c66 3e3a 3a74  :half>::half>::t
+00003e40: 7970 6520 5c0a 2020 7072 6566 6978 2023  ype \.  prefix #
+00003e50: 2320 6e61 6d65 2023 2320 5061 636b 6574  # name ## Packet
+00003e60: 0a0a 2364 6566 696e 6520 5041 434b 4554  ..#define PACKET
+00003e70: 5f44 4543 4c5f 434f 4e44 286e 616d 652c  _DECL_COND(name,
+00003e80: 2070 6163 6b65 745f 7369 7a65 2920 2020   packet_size)   
+00003e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003ea0: 2020 2020 205c 0a20 2074 7970 6564 6566       \.  typedef
+00003eb0: 2074 7970 656e 616d 6520 7061 636b 6574   typename packet
+00003ec0: 5f63 6f6e 6469 7469 6f6e 616c 3c70 6163  _conditional<pac
+00003ed0: 6b65 745f 7369 7a65 2c20 2020 2020 2020  ket_size,       
+00003ee0: 2020 2020 2020 2020 2020 5c0a 2020 2020            \.    
+00003ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003f10: 2020 7479 7065 6e61 6d65 2070 6163 6b65    typename packe
+00003f20: 745f 7472 6169 7473 3c6e 616d 6520 2323  t_traits<name ##
+00003f30: 2053 6361 6c61 723e 3a3a 7479 7065 2c20   Scalar>::type, 
+00003f40: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00003f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003f60: 2020 2020 2020 2020 7479 7065 6e61 6d65          typename
+00003f70: 2070 6163 6b65 745f 7472 6169 7473 3c6e   packet_traits<n
+00003f80: 616d 6520 2323 2053 6361 6c61 723e 3a3a  ame ## Scalar>::
+00003f90: 6861 6c66 2c20 5c0a 2020 2020 2020 2020  half, \.        
+00003fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003fb0: 2020 2020 2020 2020 2020 2020 2020 7479                ty
+00003fc0: 7065 6e61 6d65 2075 6e70 6163 6b65 745f  pename unpacket_
+00003fd0: 7472 6169 7473 3c74 7970 656e 616d 6520  traits<typename 
+00003fe0: 7061 636b 6574 5f74 7261 6974 733c 6e61  packet_traits<na
+00003ff0: 6d65 2023 2320 5363 616c 6172 3e3a 3a68  me ## Scalar>::h
+00004000: 616c 663e 3a3a 6861 6c66 3e3a 3a74 7970  alf>::half>::typ
+00004010: 6520 5c0a 2020 6e61 6d65 2023 2320 5061  e \.  name ## Pa
+00004020: 636b 6574 0a0a 2364 6566 696e 6520 5041  cket..#define PA
+00004030: 434b 4554 5f44 4543 4c5f 434f 4e44 5f53  CKET_DECL_COND_S
+00004040: 4341 4c41 525f 5052 4546 4958 2870 7265  CALAR_PREFIX(pre
+00004050: 6669 782c 2070 6163 6b65 745f 7369 7a65  fix, packet_size
+00004060: 2920 2020 2020 2020 205c 0a20 2074 7970  )        \.  typ
+00004070: 6564 6566 2074 7970 656e 616d 6520 7061  edef typename pa
+00004080: 636b 6574 5f63 6f6e 6469 7469 6f6e 616c  cket_conditional
+00004090: 3c70 6163 6b65 745f 7369 7a65 2c20 2020  <packet_size,   
+000040a0: 2020 2020 2020 2020 2020 2020 2020 5c0a                \.
+000040b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000040c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000040d0: 2020 2020 2020 7479 7065 6e61 6d65 2070        typename p
+000040e0: 6163 6b65 745f 7472 6169 7473 3c53 6361  acket_traits<Sca
+000040f0: 6c61 723e 3a3a 7479 7065 2c20 5c0a 2020  lar>::type, \.  
+00004100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004120: 2020 2020 7479 7065 6e61 6d65 2070 6163      typename pac
+00004130: 6b65 745f 7472 6169 7473 3c53 6361 6c61  ket_traits<Scala
+00004140: 723e 3a3a 6861 6c66 2c20 5c0a 2020 2020  r>::half, \.    
+00004150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004170: 2020 7479 7065 6e61 6d65 2075 6e70 6163    typename unpac
+00004180: 6b65 745f 7472 6169 7473 3c74 7970 656e  ket_traits<typen
+00004190: 616d 6520 7061 636b 6574 5f74 7261 6974  ame packet_trait
+000041a0: 733c 5363 616c 6172 3e3a 3a68 616c 663e  s<Scalar>::half>
+000041b0: 3a3a 6861 6c66 3e3a 3a74 7970 6520 5c0a  ::half>::type \.
+000041c0: 2020 7072 6566 6978 2023 2320 5363 616c    prefix ## Scal
+000041d0: 6172 5061 636b 6574 0a0a 2364 6566 696e  arPacket..#defin
+000041e0: 6520 5041 434b 4554 5f44 4543 4c5f 434f  e PACKET_DECL_CO
+000041f0: 4e44 5f53 4341 4c41 5228 7061 636b 6574  ND_SCALAR(packet
+00004200: 5f73 697a 6529 2020 2020 2020 2020 2020  _size)          
+00004210: 2020 2020 2020 2020 2020 2020 205c 0a20               \. 
+00004220: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
+00004230: 6520 7061 636b 6574 5f63 6f6e 6469 7469  e packet_conditi
+00004240: 6f6e 616c 3c70 6163 6b65 745f 7369 7a65  onal<packet_size
+00004250: 2c20 2020 2020 2020 2020 2020 2020 2020  ,               
+00004260: 2020 5c0a 2020 2020 2020 2020 2020 2020    \.            
+00004270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004280: 2020 2020 2020 2020 2020 7479 7065 6e61            typena
+00004290: 6d65 2070 6163 6b65 745f 7472 6169 7473  me packet_traits
+000042a0: 3c53 6361 6c61 723e 3a3a 7479 7065 2c20  <Scalar>::type, 
+000042b0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+000042c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000042d0: 2020 2020 2020 2020 7479 7065 6e61 6d65          typename
+000042e0: 2070 6163 6b65 745f 7472 6169 7473 3c53   packet_traits<S
+000042f0: 6361 6c61 723e 3a3a 6861 6c66 2c20 5c0a  calar>::half, \.
+00004300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004320: 2020 2020 2020 7479 7065 6e61 6d65 2075        typename u
+00004330: 6e70 6163 6b65 745f 7472 6169 7473 3c74  npacket_traits<t
+00004340: 7970 656e 616d 6520 7061 636b 6574 5f74  ypename packet_t
+00004350: 7261 6974 733c 5363 616c 6172 3e3a 3a68  raits<Scalar>::h
+00004360: 616c 663e 3a3a 6861 6c66 3e3a 3a74 7970  alf>::half>::typ
+00004370: 6520 5c0a 2020 5363 616c 6172 5061 636b  e \.  ScalarPack
+00004380: 6574 0a0a 2f2a 2056 6563 746f 7269 7a61  et../* Vectoriza
+00004390: 7469 6f6e 206c 6f67 6963 0a20 2a20 2072  tion logic. *  r
+000043a0: 6561 6c2a 7265 616c 3a20 756e 7061 636b  eal*real: unpack
+000043b0: 2072 6873 2074 6f20 636f 6e73 7461 6e74   rhs to constant
+000043c0: 2070 6163 6b65 7473 2c20 2e2e 2e0a 202a   packets, .... *
+000043d0: 200a 202a 2020 6364 2a63 6420 3a20 756e   . *  cd*cd : un
+000043e0: 7061 636b 2072 6873 2074 6f20 2862 5f72  pack rhs to (b_r
+000043f0: 2c62 5f72 292c 2028 625f 692c 625f 6929  ,b_r), (b_i,b_i)
+00004400: 2c20 6d75 6c20 746f 2067 6574 2028 615f  , mul to get (a_
+00004410: 7220 625f 722c 615f 6920 625f 7229 2028  r b_r,a_i b_r) (
+00004420: 615f 7220 625f 692c 615f 6920 625f 6929  a_r b_i,a_i b_i)
+00004430: 2c0a 202a 2020 2020 2020 2020 2020 7374  ,. *          st
+00004440: 6f72 696e 6720 6561 6368 2072 6573 2070  oring each res p
+00004450: 6163 6b65 7420 696e 746f 2074 776f 2070  acket into two p
+00004460: 6163 6b65 7473 2028 3278 3229 2c0a 202a  ackets (2x2),. *
+00004470: 2020 2020 2020 2020 2020 6174 2074 6865            at the
+00004480: 2065 6e64 2063 6f6d 6269 6e65 2074 6865   end combine the
+00004490: 6d3a 2073 7761 7020 7468 6520 7365 636f  m: swap the seco
+000044a0: 6e64 2061 6e64 2061 6464 7375 6220 7468  nd and addsub th
+000044b0: 656d 200a 202a 2020 6366 2a63 6620 3a20  em . *  cf*cf : 
+000044c0: 7361 6d65 2062 7574 2077 6974 6820 3278  same but with 2x
+000044d0: 3420 626c 6f63 6b73 0a20 2a20 2063 706c  4 blocks. *  cpl
+000044e0: 782a 7265 616c 203a 2075 6e70 6163 6b20  x*real : unpack 
+000044f0: 7268 7320 746f 2063 6f6e 7374 616e 7420  rhs to constant 
+00004500: 7061 636b 6574 732c 202e 2e2e 0a20 2a20  packets, .... * 
+00004510: 2072 6561 6c2a 6370 6c78 203a 206c 6f61   real*cplx : loa
+00004520: 6420 6c68 7320 6173 2028 6130 2c61 302c  d lhs as (a0,a0,
+00004530: 6131 2c61 3129 2c20 616e 6420 6d75 6c20  a1,a1), and mul 
+00004540: 6173 2075 7375 616c 0a20 2a2f 0a74 656d  as usual. */.tem
+00004550: 706c 6174 653c 7479 7065 6e61 6d65 205f  plate<typename _
+00004560: 4c68 7353 6361 6c61 722c 2074 7970 656e  LhsScalar, typen
+00004570: 616d 6520 5f52 6873 5363 616c 6172 2c20  ame _RhsScalar, 
+00004580: 626f 6f6c 205f 436f 6e6a 4c68 732c 2062  bool _ConjLhs, b
+00004590: 6f6f 6c20 5f43 6f6e 6a52 6873 2c20 696e  ool _ConjRhs, in
+000045a0: 7420 4172 6368 2c20 696e 7420 5f50 6163  t Arch, int _Pac
+000045b0: 6b65 7453 697a 653e 0a63 6c61 7373 2067  ketSize>.class g
+000045c0: 6562 705f 7472 6169 7473 0a7b 0a70 7562  ebp_traits.{.pub
+000045d0: 6c69 633a 0a20 2074 7970 6564 6566 205f  lic:.  typedef _
+000045e0: 4c68 7353 6361 6c61 7220 4c68 7353 6361  LhsScalar LhsSca
+000045f0: 6c61 723b 0a20 2074 7970 6564 6566 205f  lar;.  typedef _
+00004600: 5268 7353 6361 6c61 7220 5268 7353 6361  RhsScalar RhsSca
+00004610: 6c61 723b 0a20 2074 7970 6564 6566 2074  lar;.  typedef t
+00004620: 7970 656e 616d 6520 5363 616c 6172 4269  ypename ScalarBi
+00004630: 6e61 7279 4f70 5472 6169 7473 3c4c 6873  naryOpTraits<Lhs
+00004640: 5363 616c 6172 2c20 5268 7353 6361 6c61  Scalar, RhsScala
+00004650: 723e 3a3a 5265 7475 726e 5479 7065 2052  r>::ReturnType R
+00004660: 6573 5363 616c 6172 3b0a 0a20 2050 4143  esScalar;..  PAC
+00004670: 4b45 545f 4445 434c 5f43 4f4e 445f 5052  KET_DECL_COND_PR
+00004680: 4546 4958 285f 2c20 4c68 732c 205f 5061  EFIX(_, Lhs, _Pa
+00004690: 636b 6574 5369 7a65 293b 0a20 2050 4143  cketSize);.  PAC
+000046a0: 4b45 545f 4445 434c 5f43 4f4e 445f 5052  KET_DECL_COND_PR
+000046b0: 4546 4958 285f 2c20 5268 732c 205f 5061  EFIX(_, Rhs, _Pa
+000046c0: 636b 6574 5369 7a65 293b 0a20 2050 4143  cketSize);.  PAC
+000046d0: 4b45 545f 4445 434c 5f43 4f4e 445f 5052  KET_DECL_COND_PR
+000046e0: 4546 4958 285f 2c20 5265 732c 205f 5061  EFIX(_, Res, _Pa
+000046f0: 636b 6574 5369 7a65 293b 0a0a 2020 656e  cketSize);..  en
+00004700: 756d 207b 0a20 2020 2043 6f6e 6a4c 6873  um {.    ConjLhs
+00004710: 203d 205f 436f 6e6a 4c68 732c 0a20 2020   = _ConjLhs,.   
+00004720: 2043 6f6e 6a52 6873 203d 205f 436f 6e6a   ConjRhs = _Conj
+00004730: 5268 732c 0a20 2020 2056 6563 746f 7269  Rhs,.    Vectori
+00004740: 7a61 626c 6520 3d20 756e 7061 636b 6574  zable = unpacket
+00004750: 5f74 7261 6974 733c 5f4c 6873 5061 636b  _traits<_LhsPack
+00004760: 6574 3e3a 3a76 6563 746f 7269 7a61 626c  et>::vectorizabl
+00004770: 6520 2626 2075 6e70 6163 6b65 745f 7472  e && unpacket_tr
+00004780: 6169 7473 3c5f 5268 7350 6163 6b65 743e  aits<_RhsPacket>
+00004790: 3a3a 7665 6374 6f72 697a 6162 6c65 2c0a  ::vectorizable,.
+000047a0: 2020 2020 4c68 7350 6163 6b65 7453 697a      LhsPacketSiz
+000047b0: 6520 3d20 5665 6374 6f72 697a 6162 6c65  e = Vectorizable
+000047c0: 203f 2075 6e70 6163 6b65 745f 7472 6169   ? unpacket_trai
+000047d0: 7473 3c5f 4c68 7350 6163 6b65 743e 3a3a  ts<_LhsPacket>::
+000047e0: 7369 7a65 203a 2031 2c0a 2020 2020 5268  size : 1,.    Rh
+000047f0: 7350 6163 6b65 7453 697a 6520 3d20 5665  sPacketSize = Ve
+00004800: 6374 6f72 697a 6162 6c65 203f 2075 6e70  ctorizable ? unp
+00004810: 6163 6b65 745f 7472 6169 7473 3c5f 5268  acket_traits<_Rh
+00004820: 7350 6163 6b65 743e 3a3a 7369 7a65 203a  sPacket>::size :
+00004830: 2031 2c0a 2020 2020 5265 7350 6163 6b65   1,.    ResPacke
+00004840: 7453 697a 6520 3d20 5665 6374 6f72 697a  tSize = Vectoriz
+00004850: 6162 6c65 203f 2075 6e70 6163 6b65 745f  able ? unpacket_
+00004860: 7472 6169 7473 3c5f 5265 7350 6163 6b65  traits<_ResPacke
+00004870: 743e 3a3a 7369 7a65 203a 2031 2c0a 2020  t>::size : 1,.  
+00004880: 2020 0a20 2020 204e 756d 6265 724f 6652    .    NumberOfR
+00004890: 6567 6973 7465 7273 203d 2045 4947 454e  egisters = EIGEN
+000048a0: 5f41 5243 485f 4445 4641 554c 545f 4e55  _ARCH_DEFAULT_NU
+000048b0: 4d42 4552 5f4f 465f 5245 4749 5354 4552  MBER_OF_REGISTER
+000048c0: 532c 0a0a 2020 2020 2f2f 2072 6567 6973  S,..    // regis
+000048d0: 7465 7220 626c 6f63 6b20 7369 7a65 2061  ter block size a
+000048e0: 6c6f 6e67 2074 6865 204e 2064 6972 6563  long the N direc
+000048f0: 7469 6f6e 206d 7573 7420 6265 2031 206f  tion must be 1 o
+00004900: 7220 340a 2020 2020 6e72 203d 2034 2c0a  r 4.    nr = 4,.
+00004910: 0a20 2020 202f 2f20 7265 6769 7374 6572  .    // register
+00004920: 2062 6c6f 636b 2073 697a 6520 616c 6f6e   block size alon
+00004930: 6720 7468 6520 4d20 6469 7265 6374 696f  g the M directio
+00004940: 6e20 2863 7572 7265 6e74 6c79 2c20 7468  n (currently, th
+00004950: 6973 206f 6e65 2063 616e 6e6f 7420 6265  is one cannot be
+00004960: 206d 6f64 6966 6965 6429 0a20 2020 2064   modified).    d
+00004970: 6566 6175 6c74 5f6d 7220 3d20 2845 4947  efault_mr = (EIG
+00004980: 454e 5f50 4c41 494e 5f45 4e55 4d5f 4d49  EN_PLAIN_ENUM_MI
+00004990: 4e28 3136 2c4e 756d 6265 724f 6652 6567  N(16,NumberOfReg
+000049a0: 6973 7465 7273 292f 322f 6e72 292a 4c68  isters)/2/nr)*Lh
+000049b0: 7350 6163 6b65 7453 697a 652c 0a23 6966  sPacketSize,.#if
+000049c0: 2064 6566 696e 6564 2845 4947 454e 5f48   defined(EIGEN_H
+000049d0: 4153 5f53 494e 474c 455f 494e 5354 5255  AS_SINGLE_INSTRU
+000049e0: 4354 494f 4e5f 4d41 4444 2920 2626 2021  CTION_MADD) && !
+000049f0: 6465 6669 6e65 6428 4549 4745 4e5f 5645  defined(EIGEN_VE
+00004a00: 4354 4f52 495a 455f 414c 5449 5645 4329  CTORIZE_ALTIVEC)
+00004a10: 2026 2620 2164 6566 696e 6564 2845 4947   && !defined(EIG
+00004a20: 454e 5f56 4543 544f 5249 5a45 5f56 5358  EN_VECTORIZE_VSX
+00004a30: 2920 5c0a 2020 2020 2626 2028 2821 4549  ) \.    && ((!EI
+00004a40: 4745 4e5f 434f 4d50 5f4d 5356 4329 207c  GEN_COMP_MSVC) |
+00004a50: 7c20 2845 4947 454e 5f43 4f4d 505f 4d53  | (EIGEN_COMP_MS
+00004a60: 5643 3e3d 3139 3134 2929 0a20 2020 202f  VC>=1914)).    /
+00004a70: 2f20 7765 2061 7373 756d 6520 3136 2072  / we assume 16 r
+00004a80: 6567 6973 7465 7273 206f 7220 6d6f 7265  egisters or more
+00004a90: 0a20 2020 202f 2f20 5365 6520 6275 6720  .    // See bug 
+00004aa0: 3939 322c 2069 6620 7468 6520 7363 616c  992, if the scal
+00004ab0: 6172 2074 7970 6520 6973 206e 6f74 2076  ar type is not v
+00004ac0: 6563 746f 7269 7a61 626c 6520 6275 7420  ectorizable but 
+00004ad0: 7468 6174 2045 4947 454e 5f48 4153 5f53  that EIGEN_HAS_S
+00004ae0: 494e 474c 455f 494e 5354 5255 4354 494f  INGLE_INSTRUCTIO
+00004af0: 4e5f 4d41 4444 2069 7320 6465 6669 6e65  N_MADD is define
+00004b00: 642c 0a20 2020 202f 2f20 7468 656e 2075  d,.    // then u
+00004b10: 7369 6e67 2033 2a4c 6873 5061 636b 6574  sing 3*LhsPacket
+00004b20: 5369 7a65 2074 7269 6767 6572 7320 6e6f  Size triggers no
+00004b30: 6e2d 696d 706c 656d 656e 7465 6420 7061  n-implemented pa
+00004b40: 7468 7320 696e 2073 7972 6b2e 0a20 2020  ths in syrk..   
+00004b50: 202f 2f20 4275 6720 3135 3135 3a20 4d53   // Bug 1515: MS
+00004b60: 5643 2070 7269 6f72 2074 6f20 7631 392e  VC prior to v19.
+00004b70: 3134 2079 6965 6c64 7320 746f 2072 6567  14 yields to reg
+00004b80: 6973 7465 7220 7370 696c 6c69 6e67 2e0a  ister spilling..
+00004b90: 2020 2020 6d72 203d 2056 6563 746f 7269      mr = Vectori
+00004ba0: 7a61 626c 6520 3f20 332a 4c68 7350 6163  zable ? 3*LhsPac
+00004bb0: 6b65 7453 697a 6520 3a20 6465 6661 756c  ketSize : defaul
+00004bc0: 745f 6d72 2c0a 2365 6c73 650a 2020 2020  t_mr,.#else.    
+00004bd0: 6d72 203d 2064 6566 6175 6c74 5f6d 722c  mr = default_mr,
+00004be0: 0a23 656e 6469 660a 2020 2020 0a20 2020  .#endif.    .   
+00004bf0: 204c 6873 5072 6f67 7265 7373 203d 204c   LhsProgress = L
+00004c00: 6873 5061 636b 6574 5369 7a65 2c0a 2020  hsPacketSize,.  
+00004c10: 2020 5268 7350 726f 6772 6573 7320 3d20    RhsProgress = 
+00004c20: 310a 2020 7d3b 0a0a 0a20 2074 7970 6564  1.  };...  typed
+00004c30: 6566 2074 7970 656e 616d 6520 636f 6e64  ef typename cond
+00004c40: 6974 696f 6e61 6c3c 5665 6374 6f72 697a  itional<Vectoriz
+00004c50: 6162 6c65 2c5f 4c68 7350 6163 6b65 742c  able,_LhsPacket,
+00004c60: 4c68 7353 6361 6c61 723e 3a3a 7479 7065  LhsScalar>::type
+00004c70: 204c 6873 5061 636b 6574 3b0a 2020 7479   LhsPacket;.  ty
+00004c80: 7065 6465 6620 7479 7065 6e61 6d65 2063  pedef typename c
+00004c90: 6f6e 6469 7469 6f6e 616c 3c56 6563 746f  onditional<Vecto
+00004ca0: 7269 7a61 626c 652c 5f52 6873 5061 636b  rizable,_RhsPack
+00004cb0: 6574 2c52 6873 5363 616c 6172 3e3a 3a74  et,RhsScalar>::t
+00004cc0: 7970 6520 5268 7350 6163 6b65 743b 0a20  ype RhsPacket;. 
+00004cd0: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
+00004ce0: 6520 636f 6e64 6974 696f 6e61 6c3c 5665  e conditional<Ve
+00004cf0: 6374 6f72 697a 6162 6c65 2c5f 5265 7350  ctorizable,_ResP
+00004d00: 6163 6b65 742c 5265 7353 6361 6c61 723e  acket,ResScalar>
+00004d10: 3a3a 7479 7065 2052 6573 5061 636b 6574  ::type ResPacket
+00004d20: 3b0a 2020 7479 7065 6465 6620 4c68 7350  ;.  typedef LhsP
+00004d30: 6163 6b65 7420 4c68 7350 6163 6b65 7434  acket LhsPacket4
+00004d40: 5061 636b 696e 673b 0a0a 2020 7479 7065  Packing;..  type
+00004d50: 6465 6620 5175 6164 5061 636b 6574 3c52  def QuadPacket<R
+00004d60: 6873 5061 636b 6574 3e20 5268 7350 6163  hsPacket> RhsPac
+00004d70: 6b65 7478 343b 0a20 2074 7970 6564 6566  ketx4;.  typedef
+00004d80: 2052 6573 5061 636b 6574 2041 6363 5061   ResPacket AccPa
+00004d90: 636b 6574 3b0a 2020 0a20 2045 4947 454e  cket;.  .  EIGEN
+00004da0: 5f53 5452 4f4e 475f 494e 4c49 4e45 2076  _STRONG_INLINE v
+00004db0: 6f69 6420 696e 6974 4163 6328 4163 6350  oid initAcc(AccP
+00004dc0: 6163 6b65 7426 2070 290a 2020 7b0a 2020  acket& p).  {.  
+00004dd0: 2020 7020 3d20 7073 6574 313c 5265 7350    p = pset1<ResP
+00004de0: 6163 6b65 743e 2852 6573 5363 616c 6172  acket>(ResScalar
+00004df0: 2830 2929 3b0a 2020 7d0a 0a20 2074 656d  (0));.  }..  tem
+00004e00: 706c 6174 653c 7479 7065 6e61 6d65 2052  plate<typename R
+00004e10: 6873 5061 636b 6574 5479 7065 3e0a 2020  hsPacketType>.  
+00004e20: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+00004e30: 494e 4520 766f 6964 206c 6f61 6452 6873  INE void loadRhs
+00004e40: 2863 6f6e 7374 2052 6873 5363 616c 6172  (const RhsScalar
+00004e50: 2a20 622c 2052 6873 5061 636b 6574 5479  * b, RhsPacketTy
+00004e60: 7065 2620 6465 7374 2920 636f 6e73 740a  pe& dest) const.
+00004e70: 2020 7b0a 2020 2020 6465 7374 203d 2070    {.    dest = p
+00004e80: 7365 7431 3c52 6873 5061 636b 6574 5479  set1<RhsPacketTy
+00004e90: 7065 3e28 2a62 293b 0a20 207d 0a0a 2020  pe>(*b);.  }..  
+00004ea0: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+00004eb0: 494e 4520 766f 6964 206c 6f61 6452 6873  INE void loadRhs
+00004ec0: 2863 6f6e 7374 2052 6873 5363 616c 6172  (const RhsScalar
+00004ed0: 2a20 622c 2052 6873 5061 636b 6574 7834  * b, RhsPacketx4
+00004ee0: 2620 6465 7374 2920 636f 6e73 740a 2020  & dest) const.  
+00004ef0: 7b0a 2020 2020 7062 726f 6164 6361 7374  {.    pbroadcast
+00004f00: 3428 622c 2064 6573 742e 425f 302c 2064  4(b, dest.B_0, d
+00004f10: 6573 742e 4231 2c20 6465 7374 2e42 322c  est.B1, dest.B2,
+00004f20: 2064 6573 742e 4233 293b 0a20 207d 0a0a   dest.B3);.  }..
+00004f30: 2020 7465 6d70 6c61 7465 3c74 7970 656e    template<typen
+00004f40: 616d 6520 5268 7350 6163 6b65 7454 7970  ame RhsPacketTyp
+00004f50: 653e 0a20 2045 4947 454e 5f53 5452 4f4e  e>.  EIGEN_STRON
+00004f60: 475f 494e 4c49 4e45 2076 6f69 6420 7570  G_INLINE void up
+00004f70: 6461 7465 5268 7328 636f 6e73 7420 5268  dateRhs(const Rh
+00004f80: 7353 6361 6c61 722a 2062 2c20 5268 7350  sScalar* b, RhsP
+00004f90: 6163 6b65 7454 7970 6526 2064 6573 7429  acketType& dest)
+00004fa0: 2063 6f6e 7374 0a20 207b 0a20 2020 206c   const.  {.    l
+00004fb0: 6f61 6452 6873 2862 2c20 6465 7374 293b  oadRhs(b, dest);
+00004fc0: 0a20 207d 0a0a 2020 4549 4745 4e5f 5354  .  }..  EIGEN_ST
+00004fd0: 524f 4e47 5f49 4e4c 494e 4520 766f 6964  RONG_INLINE void
+00004fe0: 2075 7064 6174 6552 6873 2863 6f6e 7374   updateRhs(const
+00004ff0: 2052 6873 5363 616c 6172 2a2c 2052 6873   RhsScalar*, Rhs
+00005000: 5061 636b 6574 7834 2629 2063 6f6e 7374  Packetx4&) const
+00005010: 0a20 207b 0a20 207d 0a0a 2020 4549 4745  .  {.  }..  EIGE
+00005020: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
+00005030: 766f 6964 206c 6f61 6452 6873 5175 6164  void loadRhsQuad
+00005040: 2863 6f6e 7374 2052 6873 5363 616c 6172  (const RhsScalar
+00005050: 2a20 622c 2052 6873 5061 636b 6574 2620  * b, RhsPacket& 
+00005060: 6465 7374 2920 636f 6e73 740a 2020 7b0a  dest) const.  {.
+00005070: 2020 2020 6465 7374 203d 2070 6c6f 6164      dest = pload
+00005080: 7175 6164 3c52 6873 5061 636b 6574 3e28  quad<RhsPacket>(
+00005090: 6229 3b0a 2020 7d0a 0a20 2074 656d 706c  b);.  }..  templ
+000050a0: 6174 653c 7479 7065 6e61 6d65 204c 6873  ate<typename Lhs
+000050b0: 5061 636b 6574 5479 7065 3e0a 2020 4549  PacketType>.  EI
+000050c0: 4745 4e5f 5354 524f 4e47 5f49 4e4c 494e  GEN_STRONG_INLIN
+000050d0: 4520 766f 6964 206c 6f61 644c 6873 2863  E void loadLhs(c
+000050e0: 6f6e 7374 204c 6873 5363 616c 6172 2a20  onst LhsScalar* 
+000050f0: 612c 204c 6873 5061 636b 6574 5479 7065  a, LhsPacketType
+00005100: 2620 6465 7374 2920 636f 6e73 740a 2020  & dest) const.  
+00005110: 7b0a 2020 2020 6465 7374 203d 2070 6c6f  {.    dest = plo
+00005120: 6164 3c4c 6873 5061 636b 6574 5479 7065  ad<LhsPacketType
+00005130: 3e28 6129 3b0a 2020 7d0a 0a20 2074 656d  >(a);.  }..  tem
+00005140: 706c 6174 653c 7479 7065 6e61 6d65 204c  plate<typename L
+00005150: 6873 5061 636b 6574 5479 7065 3e0a 2020  hsPacketType>.  
+00005160: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+00005170: 494e 4520 766f 6964 206c 6f61 644c 6873  INE void loadLhs
+00005180: 556e 616c 6967 6e65 6428 636f 6e73 7420  Unaligned(const 
+00005190: 4c68 7353 6361 6c61 722a 2061 2c20 4c68  LhsScalar* a, Lh
+000051a0: 7350 6163 6b65 7454 7970 6526 2064 6573  sPacketType& des
+000051b0: 7429 2063 6f6e 7374 0a20 207b 0a20 2020  t) const.  {.   
+000051c0: 2064 6573 7420 3d20 706c 6f61 6475 3c4c   dest = ploadu<L
+000051d0: 6873 5061 636b 6574 5479 7065 3e28 6129  hsPacketType>(a)
+000051e0: 3b0a 2020 7d0a 0a20 2074 656d 706c 6174  ;.  }..  templat
+000051f0: 653c 7479 7065 6e61 6d65 204c 6873 5061  e<typename LhsPa
+00005200: 636b 6574 5479 7065 2c20 7479 7065 6e61  cketType, typena
+00005210: 6d65 2052 6873 5061 636b 6574 5479 7065  me RhsPacketType
+00005220: 2c20 7479 7065 6e61 6d65 2041 6363 5061  , typename AccPa
+00005230: 636b 6574 5479 7065 2c20 7479 7065 6e61  cketType, typena
+00005240: 6d65 204c 616e 6549 6454 7970 653e 0a20  me LaneIdType>. 
+00005250: 2045 4947 454e 5f53 5452 4f4e 475f 494e   EIGEN_STRONG_IN
+00005260: 4c49 4e45 2076 6f69 6420 6d61 6464 2863  LINE void madd(c
+00005270: 6f6e 7374 204c 6873 5061 636b 6574 5479  onst LhsPacketTy
+00005280: 7065 2620 612c 2063 6f6e 7374 2052 6873  pe& a, const Rhs
+00005290: 5061 636b 6574 5479 7065 2620 622c 2041  PacketType& b, A
+000052a0: 6363 5061 636b 6574 5479 7065 2620 632c  ccPacketType& c,
+000052b0: 2052 6873 5061 636b 6574 5479 7065 2620   RhsPacketType& 
+000052c0: 746d 702c 2063 6f6e 7374 204c 616e 6549  tmp, const LaneI
+000052d0: 6454 7970 6526 2920 636f 6e73 740a 2020  dType&) const.  
+000052e0: 7b0a 2020 2020 636f 6e6a 5f68 656c 7065  {.    conj_helpe
+000052f0: 723c 4c68 7350 6163 6b65 7454 7970 652c  r<LhsPacketType,
+00005300: 5268 7350 6163 6b65 7454 7970 652c 436f  RhsPacketType,Co
+00005310: 6e6a 4c68 732c 436f 6e6a 5268 733e 2063  njLhs,ConjRhs> c
+00005320: 6a3b 0a20 2020 202f 2f20 4974 2077 6f75  j;.    // It wou
+00005330: 6c64 2062 6520 6120 6c6f 7420 636c 6561  ld be a lot clea
+00005340: 6e65 7220 746f 2063 616c 6c20 706d 6164  ner to call pmad
+00005350: 6420 616c 6c20 7468 6520 7469 6d65 2e20  d all the time. 
+00005360: 556e 666f 7274 756e 6174 656c 7920 6966  Unfortunately if
+00005370: 2077 650a 2020 2020 2f2f 206c 6574 2067   we.    // let g
+00005380: 6363 2061 6c6c 6f63 6174 6520 7468 6520  cc allocate the 
+00005390: 7265 6769 7374 6572 2069 6e20 7768 6963  register in whic
+000053a0: 6820 746f 2073 746f 7265 2074 6865 2072  h to store the r
+000053b0: 6573 756c 7420 6f66 2074 6865 2070 6d75  esult of the pmu
+000053c0: 6c0a 2020 2020 2f2f 2028 696e 2074 6865  l.    // (in the
+000053d0: 2063 6173 6520 7768 6572 6520 7468 6572   case where ther
+000053e0: 6520 6973 206e 6f20 464d 4129 2067 6363  e is no FMA) gcc
+000053f0: 2066 6169 6c73 2074 6f20 6669 6775 7265   fails to figure
+00005400: 206f 7574 2068 6f77 2074 6f20 6176 6f69   out how to avoi
+00005410: 640a 2020 2020 2f2f 2073 7069 6c6c 696e  d.    // spillin
+00005420: 6720 7265 6769 7374 6572 2e0a 2369 6664  g register..#ifd
+00005430: 6566 2045 4947 454e 5f48 4153 5f53 494e  ef EIGEN_HAS_SIN
+00005440: 474c 455f 494e 5354 5255 4354 494f 4e5f  GLE_INSTRUCTION_
+00005450: 4d41 4444 0a20 2020 2045 4947 454e 5f55  MADD.    EIGEN_U
+00005460: 4e55 5345 445f 5641 5249 4142 4c45 2874  NUSED_VARIABLE(t
+00005470: 6d70 293b 0a20 2020 2063 203d 2063 6a2e  mp);.    c = cj.
+00005480: 706d 6164 6428 612c 622c 6329 3b0a 2365  pmadd(a,b,c);.#e
+00005490: 6c73 650a 2020 2020 746d 7020 3d20 623b  lse.    tmp = b;
+000054a0: 2074 6d70 203d 2063 6a2e 706d 756c 2861   tmp = cj.pmul(a
+000054b0: 2c74 6d70 293b 2063 203d 2070 6164 6428  ,tmp); c = padd(
+000054c0: 632c 746d 7029 3b0a 2365 6e64 6966 0a20  c,tmp);.#endif. 
+000054d0: 207d 0a0a 2020 7465 6d70 6c61 7465 3c74   }..  template<t
+000054e0: 7970 656e 616d 6520 4c68 7350 6163 6b65  ypename LhsPacke
+000054f0: 7454 7970 652c 2074 7970 656e 616d 6520  tType, typename 
+00005500: 4163 6350 6163 6b65 7454 7970 652c 2074  AccPacketType, t
+00005510: 7970 656e 616d 6520 4c61 6e65 4964 5479  ypename LaneIdTy
+00005520: 7065 3e0a 2020 4549 4745 4e5f 5354 524f  pe>.  EIGEN_STRO
+00005530: 4e47 5f49 4e4c 494e 4520 766f 6964 206d  NG_INLINE void m
+00005540: 6164 6428 636f 6e73 7420 4c68 7350 6163  add(const LhsPac
+00005550: 6b65 7454 7970 6526 2061 2c20 636f 6e73  ketType& a, cons
+00005560: 7420 5268 7350 6163 6b65 7478 3426 2062  t RhsPacketx4& b
+00005570: 2c20 4163 6350 6163 6b65 7454 7970 6526  , AccPacketType&
+00005580: 2063 2c20 5268 7350 6163 6b65 7426 2074   c, RhsPacket& t
+00005590: 6d70 2c20 636f 6e73 7420 4c61 6e65 4964  mp, const LaneId
+000055a0: 5479 7065 2620 6c61 6e65 2920 636f 6e73  Type& lane) cons
+000055b0: 740a 2020 7b0a 2020 2020 6d61 6464 2861  t.  {.    madd(a
+000055c0: 2c20 622e 6765 7428 6c61 6e65 292c 2063  , b.get(lane), c
+000055d0: 2c20 746d 702c 206c 616e 6529 3b0a 2020  , tmp, lane);.  
+000055e0: 7d0a 0a20 2045 4947 454e 5f53 5452 4f4e  }..  EIGEN_STRON
+000055f0: 475f 494e 4c49 4e45 2076 6f69 6420 6163  G_INLINE void ac
+00005600: 6328 636f 6e73 7420 4163 6350 6163 6b65  c(const AccPacke
+00005610: 7426 2063 2c20 636f 6e73 7420 5265 7350  t& c, const ResP
+00005620: 6163 6b65 7426 2061 6c70 6861 2c20 5265  acket& alpha, Re
+00005630: 7350 6163 6b65 7426 2072 2920 636f 6e73  sPacket& r) cons
+00005640: 740a 2020 7b0a 2020 2020 7220 3d20 706d  t.  {.    r = pm
+00005650: 6164 6428 632c 616c 7068 612c 7229 3b0a  add(c,alpha,r);.
+00005660: 2020 7d0a 2020 0a20 2074 656d 706c 6174    }.  .  templat
+00005670: 653c 7479 7065 6e61 6d65 2052 6573 5061  e<typename ResPa
+00005680: 636b 6574 4861 6c66 3e0a 2020 4549 4745  cketHalf>.  EIGE
+00005690: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
+000056a0: 766f 6964 2061 6363 2863 6f6e 7374 2052  void acc(const R
+000056b0: 6573 5061 636b 6574 4861 6c66 2620 632c  esPacketHalf& c,
+000056c0: 2063 6f6e 7374 2052 6573 5061 636b 6574   const ResPacket
+000056d0: 4861 6c66 2620 616c 7068 612c 2052 6573  Half& alpha, Res
+000056e0: 5061 636b 6574 4861 6c66 2620 7229 2063  PacketHalf& r) c
+000056f0: 6f6e 7374 0a20 207b 0a20 2020 2072 203d  onst.  {.    r =
+00005700: 2070 6d61 6464 2863 2c61 6c70 6861 2c72   pmadd(c,alpha,r
+00005710: 293b 0a20 207d 0a0a 7d3b 0a0a 7465 6d70  );.  }..};..temp
+00005720: 6c61 7465 3c74 7970 656e 616d 6520 5265  late<typename Re
+00005730: 616c 5363 616c 6172 2c20 626f 6f6c 205f  alScalar, bool _
+00005740: 436f 6e6a 4c68 732c 2069 6e74 2041 7263  ConjLhs, int Arc
+00005750: 682c 2069 6e74 205f 5061 636b 6574 5369  h, int _PacketSi
+00005760: 7a65 3e0a 636c 6173 7320 6765 6270 5f74  ze>.class gebp_t
+00005770: 7261 6974 733c 7374 643a 3a63 6f6d 706c  raits<std::compl
+00005780: 6578 3c52 6561 6c53 6361 6c61 723e 2c20  ex<RealScalar>, 
+00005790: 5265 616c 5363 616c 6172 2c20 5f43 6f6e  RealScalar, _Con
+000057a0: 6a4c 6873 2c20 6661 6c73 652c 2041 7263  jLhs, false, Arc
+000057b0: 682c 205f 5061 636b 6574 5369 7a65 3e0a  h, _PacketSize>.
+000057c0: 7b0a 7075 626c 6963 3a0a 2020 7479 7065  {.public:.  type
+000057d0: 6465 6620 7374 643a 3a63 6f6d 706c 6578  def std::complex
+000057e0: 3c52 6561 6c53 6361 6c61 723e 204c 6873  <RealScalar> Lhs
+000057f0: 5363 616c 6172 3b0a 2020 7479 7065 6465  Scalar;.  typede
+00005800: 6620 5265 616c 5363 616c 6172 2052 6873  f RealScalar Rhs
+00005810: 5363 616c 6172 3b0a 2020 7479 7065 6465  Scalar;.  typede
+00005820: 6620 7479 7065 6e61 6d65 2053 6361 6c61  f typename Scala
+00005830: 7242 696e 6172 794f 7054 7261 6974 733c  rBinaryOpTraits<
+00005840: 4c68 7353 6361 6c61 722c 2052 6873 5363  LhsScalar, RhsSc
+00005850: 616c 6172 3e3a 3a52 6574 7572 6e54 7970  alar>::ReturnTyp
+00005860: 6520 5265 7353 6361 6c61 723b 0a0a 2020  e ResScalar;..  
+00005870: 5041 434b 4554 5f44 4543 4c5f 434f 4e44  PACKET_DECL_COND
+00005880: 5f50 5245 4649 5828 5f2c 204c 6873 2c20  _PREFIX(_, Lhs, 
+00005890: 5f50 6163 6b65 7453 697a 6529 3b0a 2020  _PacketSize);.  
+000058a0: 5041 434b 4554 5f44 4543 4c5f 434f 4e44  PACKET_DECL_COND
+000058b0: 5f50 5245 4649 5828 5f2c 2052 6873 2c20  _PREFIX(_, Rhs, 
+000058c0: 5f50 6163 6b65 7453 697a 6529 3b0a 2020  _PacketSize);.  
+000058d0: 5041 434b 4554 5f44 4543 4c5f 434f 4e44  PACKET_DECL_COND
+000058e0: 5f50 5245 4649 5828 5f2c 2052 6573 2c20  _PREFIX(_, Res, 
+000058f0: 5f50 6163 6b65 7453 697a 6529 3b0a 0a20  _PacketSize);.. 
+00005900: 2065 6e75 6d20 7b0a 2020 2020 436f 6e6a   enum {.    Conj
+00005910: 4c68 7320 3d20 5f43 6f6e 6a4c 6873 2c0a  Lhs = _ConjLhs,.
+00005920: 2020 2020 436f 6e6a 5268 7320 3d20 6661      ConjRhs = fa
+00005930: 6c73 652c 0a20 2020 2056 6563 746f 7269  lse,.    Vectori
+00005940: 7a61 626c 6520 3d20 756e 7061 636b 6574  zable = unpacket
+00005950: 5f74 7261 6974 733c 5f4c 6873 5061 636b  _traits<_LhsPack
+00005960: 6574 3e3a 3a76 6563 746f 7269 7a61 626c  et>::vectorizabl
+00005970: 6520 2626 2075 6e70 6163 6b65 745f 7472  e && unpacket_tr
+00005980: 6169 7473 3c5f 5268 7350 6163 6b65 743e  aits<_RhsPacket>
+00005990: 3a3a 7665 6374 6f72 697a 6162 6c65 2c0a  ::vectorizable,.
+000059a0: 2020 2020 4c68 7350 6163 6b65 7453 697a      LhsPacketSiz
+000059b0: 6520 3d20 5665 6374 6f72 697a 6162 6c65  e = Vectorizable
+000059c0: 203f 2075 6e70 6163 6b65 745f 7472 6169   ? unpacket_trai
+000059d0: 7473 3c5f 4c68 7350 6163 6b65 743e 3a3a  ts<_LhsPacket>::
+000059e0: 7369 7a65 203a 2031 2c0a 2020 2020 5268  size : 1,.    Rh
+000059f0: 7350 6163 6b65 7453 697a 6520 3d20 5665  sPacketSize = Ve
+00005a00: 6374 6f72 697a 6162 6c65 203f 2075 6e70  ctorizable ? unp
+00005a10: 6163 6b65 745f 7472 6169 7473 3c5f 5268  acket_traits<_Rh
+00005a20: 7350 6163 6b65 743e 3a3a 7369 7a65 203a  sPacket>::size :
+00005a30: 2031 2c0a 2020 2020 5265 7350 6163 6b65   1,.    ResPacke
+00005a40: 7453 697a 6520 3d20 5665 6374 6f72 697a  tSize = Vectoriz
+00005a50: 6162 6c65 203f 2075 6e70 6163 6b65 745f  able ? unpacket_
+00005a60: 7472 6169 7473 3c5f 5265 7350 6163 6b65  traits<_ResPacke
+00005a70: 743e 3a3a 7369 7a65 203a 2031 2c0a 2020  t>::size : 1,.  
+00005a80: 2020 0a20 2020 204e 756d 6265 724f 6652    .    NumberOfR
+00005a90: 6567 6973 7465 7273 203d 2045 4947 454e  egisters = EIGEN
+00005aa0: 5f41 5243 485f 4445 4641 554c 545f 4e55  _ARCH_DEFAULT_NU
+00005ab0: 4d42 4552 5f4f 465f 5245 4749 5354 4552  MBER_OF_REGISTER
+00005ac0: 532c 0a20 2020 206e 7220 3d20 342c 0a23  S,.    nr = 4,.#
+00005ad0: 6966 2064 6566 696e 6564 2845 4947 454e  if defined(EIGEN
+00005ae0: 5f48 4153 5f53 494e 474c 455f 494e 5354  _HAS_SINGLE_INST
+00005af0: 5255 4354 494f 4e5f 4d41 4444 2920 2626  RUCTION_MADD) &&
+00005b00: 2021 6465 6669 6e65 6428 4549 4745 4e5f   !defined(EIGEN_
+00005b10: 5645 4354 4f52 495a 455f 414c 5449 5645  VECTORIZE_ALTIVE
+00005b20: 4329 2026 2620 2164 6566 696e 6564 2845  C) && !defined(E
+00005b30: 4947 454e 5f56 4543 544f 5249 5a45 5f56  IGEN_VECTORIZE_V
+00005b40: 5358 290a 2020 2020 2f2f 2077 6520 6173  SX).    // we as
+00005b50: 7375 6d65 2031 3620 7265 6769 7374 6572  sume 16 register
+00005b60: 730a 2020 2020 6d72 203d 2033 2a4c 6873  s.    mr = 3*Lhs
+00005b70: 5061 636b 6574 5369 7a65 2c0a 2365 6c73  PacketSize,.#els
+00005b80: 650a 2020 2020 6d72 203d 2028 4549 4745  e.    mr = (EIGE
+00005b90: 4e5f 504c 4149 4e5f 454e 554d 5f4d 494e  N_PLAIN_ENUM_MIN
+00005ba0: 2831 362c 4e75 6d62 6572 4f66 5265 6769  (16,NumberOfRegi
+00005bb0: 7374 6572 7329 2f32 2f6e 7229 2a4c 6873  sters)/2/nr)*Lhs
+00005bc0: 5061 636b 6574 5369 7a65 2c0a 2365 6e64  PacketSize,.#end
+00005bd0: 6966 0a0a 2020 2020 4c68 7350 726f 6772  if..    LhsProgr
+00005be0: 6573 7320 3d20 4c68 7350 6163 6b65 7453  ess = LhsPacketS
+00005bf0: 697a 652c 0a20 2020 2052 6873 5072 6f67  ize,.    RhsProg
+00005c00: 7265 7373 203d 2031 0a20 207d 3b0a 0a20  ress = 1.  };.. 
+00005c10: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
+00005c20: 6520 636f 6e64 6974 696f 6e61 6c3c 5665  e conditional<Ve
+00005c30: 6374 6f72 697a 6162 6c65 2c5f 4c68 7350  ctorizable,_LhsP
+00005c40: 6163 6b65 742c 4c68 7353 6361 6c61 723e  acket,LhsScalar>
+00005c50: 3a3a 7479 7065 204c 6873 5061 636b 6574  ::type LhsPacket
+00005c60: 3b0a 2020 7479 7065 6465 6620 7479 7065  ;.  typedef type
+00005c70: 6e61 6d65 2063 6f6e 6469 7469 6f6e 616c  name conditional
+00005c80: 3c56 6563 746f 7269 7a61 626c 652c 5f52  <Vectorizable,_R
+00005c90: 6873 5061 636b 6574 2c52 6873 5363 616c  hsPacket,RhsScal
+00005ca0: 6172 3e3a 3a74 7970 6520 5268 7350 6163  ar>::type RhsPac
+00005cb0: 6b65 743b 0a20 2074 7970 6564 6566 2074  ket;.  typedef t
+00005cc0: 7970 656e 616d 6520 636f 6e64 6974 696f  ypename conditio
+00005cd0: 6e61 6c3c 5665 6374 6f72 697a 6162 6c65  nal<Vectorizable
+00005ce0: 2c5f 5265 7350 6163 6b65 742c 5265 7353  ,_ResPacket,ResS
+00005cf0: 6361 6c61 723e 3a3a 7479 7065 2052 6573  calar>::type Res
+00005d00: 5061 636b 6574 3b0a 2020 7479 7065 6465  Packet;.  typede
+00005d10: 6620 4c68 7350 6163 6b65 7420 4c68 7350  f LhsPacket LhsP
+00005d20: 6163 6b65 7434 5061 636b 696e 673b 0a0a  acket4Packing;..
+00005d30: 2020 7479 7065 6465 6620 5175 6164 5061    typedef QuadPa
+00005d40: 636b 6574 3c52 6873 5061 636b 6574 3e20  cket<RhsPacket> 
+00005d50: 5268 7350 6163 6b65 7478 343b 0a0a 2020  RhsPacketx4;..  
+00005d60: 7479 7065 6465 6620 5265 7350 6163 6b65  typedef ResPacke
+00005d70: 7420 4163 6350 6163 6b65 743b 0a0a 2020  t AccPacket;..  
+00005d80: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+00005d90: 494e 4520 766f 6964 2069 6e69 7441 6363  INE void initAcc
+00005da0: 2841 6363 5061 636b 6574 2620 7029 0a20  (AccPacket& p). 
+00005db0: 207b 0a20 2020 2070 203d 2070 7365 7431   {.    p = pset1
+00005dc0: 3c52 6573 5061 636b 6574 3e28 5265 7353  <ResPacket>(ResS
+00005dd0: 6361 6c61 7228 3029 293b 0a20 207d 0a0a  calar(0));.  }..
+00005de0: 2020 7465 6d70 6c61 7465 3c74 7970 656e    template<typen
+00005df0: 616d 6520 5268 7350 6163 6b65 7454 7970  ame RhsPacketTyp
+00005e00: 653e 0a20 2045 4947 454e 5f53 5452 4f4e  e>.  EIGEN_STRON
+00005e10: 475f 494e 4c49 4e45 2076 6f69 6420 6c6f  G_INLINE void lo
+00005e20: 6164 5268 7328 636f 6e73 7420 5268 7353  adRhs(const RhsS
+00005e30: 6361 6c61 722a 2062 2c20 5268 7350 6163  calar* b, RhsPac
+00005e40: 6b65 7454 7970 6526 2064 6573 7429 2063  ketType& dest) c
+00005e50: 6f6e 7374 0a20 207b 0a20 2020 2064 6573  onst.  {.    des
+00005e60: 7420 3d20 7073 6574 313c 5268 7350 6163  t = pset1<RhsPac
+00005e70: 6b65 7454 7970 653e 282a 6229 3b0a 2020  ketType>(*b);.  
+00005e80: 7d0a 0a20 2045 4947 454e 5f53 5452 4f4e  }..  EIGEN_STRON
+00005e90: 475f 494e 4c49 4e45 2076 6f69 6420 6c6f  G_INLINE void lo
+00005ea0: 6164 5268 7328 636f 6e73 7420 5268 7353  adRhs(const RhsS
+00005eb0: 6361 6c61 722a 2062 2c20 5268 7350 6163  calar* b, RhsPac
+00005ec0: 6b65 7478 3426 2064 6573 7429 2063 6f6e  ketx4& dest) con
+00005ed0: 7374 0a20 207b 0a20 2020 2070 6272 6f61  st.  {.    pbroa
+00005ee0: 6463 6173 7434 2862 2c20 6465 7374 2e42  dcast4(b, dest.B
+00005ef0: 5f30 2c20 6465 7374 2e42 312c 2064 6573  _0, dest.B1, des
+00005f00: 742e 4232 2c20 6465 7374 2e42 3329 3b0a  t.B2, dest.B3);.
+00005f10: 2020 7d0a 0a20 2074 656d 706c 6174 653c    }..  template<
+00005f20: 7479 7065 6e61 6d65 2052 6873 5061 636b  typename RhsPack
+00005f30: 6574 5479 7065 3e0a 2020 4549 4745 4e5f  etType>.  EIGEN_
+00005f40: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
+00005f50: 6964 2075 7064 6174 6552 6873 2863 6f6e  id updateRhs(con
+00005f60: 7374 2052 6873 5363 616c 6172 2a20 622c  st RhsScalar* b,
+00005f70: 2052 6873 5061 636b 6574 5479 7065 2620   RhsPacketType& 
+00005f80: 6465 7374 2920 636f 6e73 740a 2020 7b0a  dest) const.  {.
+00005f90: 2020 2020 6c6f 6164 5268 7328 622c 2064      loadRhs(b, d
+00005fa0: 6573 7429 3b0a 2020 7d0a 0a20 2045 4947  est);.  }..  EIG
+00005fb0: 454e 5f53 5452 4f4e 475f 494e 4c49 4e45  EN_STRONG_INLINE
+00005fc0: 2076 6f69 6420 7570 6461 7465 5268 7328   void updateRhs(
+00005fd0: 636f 6e73 7420 5268 7353 6361 6c61 722a  const RhsScalar*
+00005fe0: 2c20 5268 7350 6163 6b65 7478 3426 2920  , RhsPacketx4&) 
+00005ff0: 636f 6e73 740a 2020 7b7d 0a20 200a 2020  const.  {}.  .  
+00006000: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+00006010: 494e 4520 766f 6964 206c 6f61 6452 6873  INE void loadRhs
+00006020: 5175 6164 2863 6f6e 7374 2052 6873 5363  Quad(const RhsSc
+00006030: 616c 6172 2a20 622c 2052 6873 5061 636b  alar* b, RhsPack
+00006040: 6574 2620 6465 7374 2920 636f 6e73 740a  et& dest) const.
+00006050: 2020 7b0a 2020 2020 6c6f 6164 5268 7351    {.    loadRhsQ
+00006060: 7561 645f 696d 706c 2862 2c64 6573 742c  uad_impl(b,dest,
+00006070: 2074 7970 656e 616d 6520 636f 6e64 6974   typename condit
+00006080: 696f 6e61 6c3c 5268 7350 6163 6b65 7453  ional<RhsPacketS
+00006090: 697a 653d 3d31 362c 7472 7565 5f74 7970  ize==16,true_typ
+000060a0: 652c 6661 6c73 655f 7479 7065 3e3a 3a74  e,false_type>::t
+000060b0: 7970 6528 2929 3b0a 2020 7d0a 0a20 2045  ype());.  }..  E
+000060c0: 4947 454e 5f53 5452 4f4e 475f 494e 4c49  IGEN_STRONG_INLI
+000060d0: 4e45 2076 6f69 6420 6c6f 6164 5268 7351  NE void loadRhsQ
+000060e0: 7561 645f 696d 706c 2863 6f6e 7374 2052  uad_impl(const R
+000060f0: 6873 5363 616c 6172 2a20 622c 2052 6873  hsScalar* b, Rhs
+00006100: 5061 636b 6574 2620 6465 7374 2c20 636f  Packet& dest, co
+00006110: 6e73 7420 7472 7565 5f74 7970 6526 2920  nst true_type&) 
+00006120: 636f 6e73 740a 2020 7b0a 2020 2020 2f2f  const.  {.    //
+00006130: 2046 4958 4d45 2077 6520 6361 6e20 646f   FIXME we can do
+00006140: 2062 6574 7465 7221 0a20 2020 202f 2f20   better!.    // 
+00006150: 7768 6174 2077 6520 7761 6e74 2068 6572  what we want her
+00006160: 6520 6973 2061 2070 6c6f 6164 6865 6967  e is a ploadheig
+00006170: 6874 0a20 2020 2052 6873 5363 616c 6172  ht.    RhsScalar
+00006180: 2074 6d70 5b34 5d20 3d20 7b62 5b30 5d2c   tmp[4] = {b[0],
+00006190: 625b 305d 2c62 5b31 5d2c 625b 315d 7d3b  b[0],b[1],b[1]};
+000061a0: 0a20 2020 2064 6573 7420 3d20 706c 6f61  .    dest = ploa
+000061b0: 6471 7561 643c 5268 7350 6163 6b65 743e  dquad<RhsPacket>
+000061c0: 2874 6d70 293b 0a20 207d 0a0a 2020 4549  (tmp);.  }..  EI
+000061d0: 4745 4e5f 5354 524f 4e47 5f49 4e4c 494e  GEN_STRONG_INLIN
+000061e0: 4520 766f 6964 206c 6f61 6452 6873 5175  E void loadRhsQu
+000061f0: 6164 5f69 6d70 6c28 636f 6e73 7420 5268  ad_impl(const Rh
+00006200: 7353 6361 6c61 722a 2062 2c20 5268 7350  sScalar* b, RhsP
+00006210: 6163 6b65 7426 2064 6573 742c 2063 6f6e  acket& dest, con
+00006220: 7374 2066 616c 7365 5f74 7970 6526 2920  st false_type&) 
+00006230: 636f 6e73 740a 2020 7b0a 2020 2020 6569  const.  {.    ei
+00006240: 6765 6e5f 696e 7465 726e 616c 5f61 7373  gen_internal_ass
+00006250: 6572 7428 5268 7350 6163 6b65 7453 697a  ert(RhsPacketSiz
+00006260: 653c 3d38 293b 0a20 2020 2064 6573 7420  e<=8);.    dest 
+00006270: 3d20 7073 6574 313c 5268 7350 6163 6b65  = pset1<RhsPacke
+00006280: 743e 282a 6229 3b0a 2020 7d0a 0a20 2045  t>(*b);.  }..  E
+00006290: 4947 454e 5f53 5452 4f4e 475f 494e 4c49  IGEN_STRONG_INLI
+000062a0: 4e45 2076 6f69 6420 6c6f 6164 4c68 7328  NE void loadLhs(
+000062b0: 636f 6e73 7420 4c68 7353 6361 6c61 722a  const LhsScalar*
+000062c0: 2061 2c20 4c68 7350 6163 6b65 7426 2064   a, LhsPacket& d
+000062d0: 6573 7429 2063 6f6e 7374 0a20 207b 0a20  est) const.  {. 
+000062e0: 2020 2064 6573 7420 3d20 706c 6f61 643c     dest = pload<
+000062f0: 4c68 7350 6163 6b65 743e 2861 293b 0a20  LhsPacket>(a);. 
+00006300: 207d 0a0a 2020 7465 6d70 6c61 7465 3c74   }..  template<t
+00006310: 7970 656e 616d 6520 4c68 7350 6163 6b65  ypename LhsPacke
+00006320: 7454 7970 653e 0a20 2045 4947 454e 5f53  tType>.  EIGEN_S
+00006330: 5452 4f4e 475f 494e 4c49 4e45 2076 6f69  TRONG_INLINE voi
+00006340: 6420 6c6f 6164 4c68 7355 6e61 6c69 676e  d loadLhsUnalign
+00006350: 6564 2863 6f6e 7374 204c 6873 5363 616c  ed(const LhsScal
+00006360: 6172 2a20 612c 204c 6873 5061 636b 6574  ar* a, LhsPacket
+00006370: 5479 7065 2620 6465 7374 2920 636f 6e73  Type& dest) cons
+00006380: 740a 2020 7b0a 2020 2020 6465 7374 203d  t.  {.    dest =
+00006390: 2070 6c6f 6164 753c 4c68 7350 6163 6b65   ploadu<LhsPacke
+000063a0: 7454 7970 653e 2861 293b 0a20 207d 0a0a  tType>(a);.  }..
+000063b0: 2020 7465 6d70 6c61 7465 203c 7479 7065    template <type
+000063c0: 6e61 6d65 204c 6873 5061 636b 6574 5479  name LhsPacketTy
+000063d0: 7065 2c20 7479 7065 6e61 6d65 2052 6873  pe, typename Rhs
+000063e0: 5061 636b 6574 5479 7065 2c20 7479 7065  PacketType, type
+000063f0: 6e61 6d65 2041 6363 5061 636b 6574 5479  name AccPacketTy
+00006400: 7065 2c20 7479 7065 6e61 6d65 204c 616e  pe, typename Lan
+00006410: 6549 6454 7970 653e 0a20 2045 4947 454e  eIdType>.  EIGEN
+00006420: 5f53 5452 4f4e 475f 494e 4c49 4e45 2076  _STRONG_INLINE v
+00006430: 6f69 6420 6d61 6464 2863 6f6e 7374 204c  oid madd(const L
+00006440: 6873 5061 636b 6574 5479 7065 2620 612c  hsPacketType& a,
+00006450: 2063 6f6e 7374 2052 6873 5061 636b 6574   const RhsPacket
+00006460: 5479 7065 2620 622c 2041 6363 5061 636b  Type& b, AccPack
+00006470: 6574 5479 7065 2620 632c 2052 6873 5061  etType& c, RhsPa
+00006480: 636b 6574 5479 7065 2620 746d 702c 2063  cketType& tmp, c
+00006490: 6f6e 7374 204c 616e 6549 6454 7970 6526  onst LaneIdType&
+000064a0: 2920 636f 6e73 740a 2020 7b0a 2020 2020  ) const.  {.    
+000064b0: 6d61 6464 5f69 6d70 6c28 612c 2062 2c20  madd_impl(a, b, 
+000064c0: 632c 2074 6d70 2c20 7479 7065 6e61 6d65  c, tmp, typename
+000064d0: 2063 6f6e 6469 7469 6f6e 616c 3c56 6563   conditional<Vec
+000064e0: 746f 7269 7a61 626c 652c 7472 7565 5f74  torizable,true_t
+000064f0: 7970 652c 6661 6c73 655f 7479 7065 3e3a  ype,false_type>:
+00006500: 3a74 7970 6528 2929 3b0a 2020 7d0a 0a20  :type());.  }.. 
+00006510: 2074 656d 706c 6174 6520 3c74 7970 656e   template <typen
+00006520: 616d 6520 4c68 7350 6163 6b65 7454 7970  ame LhsPacketTyp
+00006530: 652c 2074 7970 656e 616d 6520 5268 7350  e, typename RhsP
+00006540: 6163 6b65 7454 7970 652c 2074 7970 656e  acketType, typen
+00006550: 616d 6520 4163 6350 6163 6b65 7454 7970  ame AccPacketTyp
+00006560: 653e 0a20 2045 4947 454e 5f53 5452 4f4e  e>.  EIGEN_STRON
+00006570: 475f 494e 4c49 4e45 2076 6f69 6420 6d61  G_INLINE void ma
+00006580: 6464 5f69 6d70 6c28 636f 6e73 7420 4c68  dd_impl(const Lh
+00006590: 7350 6163 6b65 7454 7970 6526 2061 2c20  sPacketType& a, 
+000065a0: 636f 6e73 7420 5268 7350 6163 6b65 7454  const RhsPacketT
+000065b0: 7970 6526 2062 2c20 4163 6350 6163 6b65  ype& b, AccPacke
+000065c0: 7454 7970 6526 2063 2c20 5268 7350 6163  tType& c, RhsPac
+000065d0: 6b65 7454 7970 6526 2074 6d70 2c20 636f  ketType& tmp, co
+000065e0: 6e73 7420 7472 7565 5f74 7970 6526 2920  nst true_type&) 
+000065f0: 636f 6e73 740a 2020 7b0a 2369 6664 6566  const.  {.#ifdef
+00006600: 2045 4947 454e 5f48 4153 5f53 494e 474c   EIGEN_HAS_SINGL
+00006610: 455f 494e 5354 5255 4354 494f 4e5f 4d41  E_INSTRUCTION_MA
+00006620: 4444 0a20 2020 2045 4947 454e 5f55 4e55  DD.    EIGEN_UNU
+00006630: 5345 445f 5641 5249 4142 4c45 2874 6d70  SED_VARIABLE(tmp
+00006640: 293b 0a20 2020 2063 2e76 203d 2070 6d61  );.    c.v = pma
+00006650: 6464 2861 2e76 2c62 2c63 2e76 293b 0a23  dd(a.v,b,c.v);.#
+00006660: 656c 7365 0a20 2020 2074 6d70 203d 2062  else.    tmp = b
+00006670: 3b20 746d 7020 3d20 706d 756c 2861 2e76  ; tmp = pmul(a.v
+00006680: 2c74 6d70 293b 2063 2e76 203d 2070 6164  ,tmp); c.v = pad
+00006690: 6428 632e 762c 746d 7029 3b0a 2365 6e64  d(c.v,tmp);.#end
+000066a0: 6966 0a20 207d 0a0a 2020 4549 4745 4e5f  if.  }..  EIGEN_
+000066b0: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
+000066c0: 6964 206d 6164 645f 696d 706c 2863 6f6e  id madd_impl(con
+000066d0: 7374 204c 6873 5363 616c 6172 2620 612c  st LhsScalar& a,
+000066e0: 2063 6f6e 7374 2052 6873 5363 616c 6172   const RhsScalar
+000066f0: 2620 622c 2052 6573 5363 616c 6172 2620  & b, ResScalar& 
+00006700: 632c 2052 6873 5363 616c 6172 2620 2f2a  c, RhsScalar& /*
+00006710: 746d 702a 2f2c 2063 6f6e 7374 2066 616c  tmp*/, const fal
+00006720: 7365 5f74 7970 6526 2920 636f 6e73 740a  se_type&) const.
+00006730: 2020 7b0a 2020 2020 6320 2b3d 2061 202a    {.    c += a *
+00006740: 2062 3b0a 2020 7d0a 0a20 2074 656d 706c   b;.  }..  templ
+00006750: 6174 653c 7479 7065 6e61 6d65 204c 6873  ate<typename Lhs
+00006760: 5061 636b 6574 5479 7065 2c20 7479 7065  PacketType, type
+00006770: 6e61 6d65 2041 6363 5061 636b 6574 5479  name AccPacketTy
+00006780: 7065 2c20 7479 7065 6e61 6d65 204c 616e  pe, typename Lan
+00006790: 6549 6454 7970 653e 0a20 2045 4947 454e  eIdType>.  EIGEN
+000067a0: 5f53 5452 4f4e 475f 494e 4c49 4e45 2076  _STRONG_INLINE v
+000067b0: 6f69 6420 6d61 6464 2863 6f6e 7374 204c  oid madd(const L
+000067c0: 6873 5061 636b 6574 5479 7065 2620 612c  hsPacketType& a,
+000067d0: 2063 6f6e 7374 2052 6873 5061 636b 6574   const RhsPacket
+000067e0: 7834 2620 622c 2041 6363 5061 636b 6574  x4& b, AccPacket
+000067f0: 5479 7065 2620 632c 2052 6873 5061 636b  Type& c, RhsPack
+00006800: 6574 2620 746d 702c 2063 6f6e 7374 204c  et& tmp, const L
+00006810: 616e 6549 6454 7970 6526 206c 616e 6529  aneIdType& lane)
+00006820: 2063 6f6e 7374 0a20 207b 0a20 2020 206d   const.  {.    m
+00006830: 6164 6428 612c 2062 2e67 6574 286c 616e  add(a, b.get(lan
+00006840: 6529 2c20 632c 2074 6d70 2c20 6c61 6e65  e), c, tmp, lane
+00006850: 293b 0a20 207d 0a0a 2020 7465 6d70 6c61  );.  }..  templa
+00006860: 7465 203c 7479 7065 6e61 6d65 2052 6573  te <typename Res
+00006870: 5061 636b 6574 5479 7065 2c20 7479 7065  PacketType, type
+00006880: 6e61 6d65 2041 6363 5061 636b 6574 5479  name AccPacketTy
+00006890: 7065 3e0a 2020 4549 4745 4e5f 5354 524f  pe>.  EIGEN_STRO
+000068a0: 4e47 5f49 4e4c 494e 4520 766f 6964 2061  NG_INLINE void a
+000068b0: 6363 2863 6f6e 7374 2041 6363 5061 636b  cc(const AccPack
+000068c0: 6574 5479 7065 2620 632c 2063 6f6e 7374  etType& c, const
+000068d0: 2052 6573 5061 636b 6574 5479 7065 2620   ResPacketType& 
+000068e0: 616c 7068 612c 2052 6573 5061 636b 6574  alpha, ResPacket
+000068f0: 5479 7065 2620 7229 2063 6f6e 7374 0a20  Type& r) const. 
+00006900: 207b 0a20 2020 2063 6f6e 6a5f 6865 6c70   {.    conj_help
+00006910: 6572 3c52 6573 5061 636b 6574 5479 7065  er<ResPacketType
+00006920: 2c52 6573 5061 636b 6574 5479 7065 2c43  ,ResPacketType,C
+00006930: 6f6e 6a4c 6873 2c66 616c 7365 3e20 636a  onjLhs,false> cj
+00006940: 3b0a 2020 2020 7220 3d20 636a 2e70 6d61  ;.    r = cj.pma
+00006950: 6464 2863 2c61 6c70 6861 2c72 293b 0a20  dd(c,alpha,r);. 
+00006960: 207d 0a0a 7072 6f74 6563 7465 643a 0a7d   }..protected:.}
+00006970: 3b0a 0a74 656d 706c 6174 653c 7479 7065  ;..template<type
+00006980: 6e61 6d65 2050 6163 6b65 743e 0a73 7472  name Packet>.str
+00006990: 7563 7420 446f 7562 6c65 5061 636b 6574  uct DoublePacket
+000069a0: 0a7b 0a20 2050 6163 6b65 7420 6669 7273  .{.  Packet firs
+000069b0: 743b 0a20 2050 6163 6b65 7420 7365 636f  t;.  Packet seco
+000069c0: 6e64 3b0a 7d3b 0a0a 7465 6d70 6c61 7465  nd;.};..template
+000069d0: 3c74 7970 656e 616d 6520 5061 636b 6574  <typename Packet
+000069e0: 3e0a 446f 7562 6c65 5061 636b 6574 3c50  >.DoublePacket<P
+000069f0: 6163 6b65 743e 2070 6164 6428 636f 6e73  acket> padd(cons
+00006a00: 7420 446f 7562 6c65 5061 636b 6574 3c50  t DoublePacket<P
+00006a10: 6163 6b65 743e 2026 612c 2063 6f6e 7374  acket> &a, const
+00006a20: 2044 6f75 626c 6550 6163 6b65 743c 5061   DoublePacket<Pa
+00006a30: 636b 6574 3e20 2662 290a 7b0a 2020 446f  cket> &b).{.  Do
+00006a40: 7562 6c65 5061 636b 6574 3c50 6163 6b65  ublePacket<Packe
+00006a50: 743e 2072 6573 3b0a 2020 7265 732e 6669  t> res;.  res.fi
+00006a60: 7273 7420 203d 2070 6164 6428 612e 6669  rst  = padd(a.fi
+00006a70: 7273 742c 2062 2e66 6972 7374 293b 0a20  rst, b.first);. 
+00006a80: 2072 6573 2e73 6563 6f6e 6420 3d20 7061   res.second = pa
+00006a90: 6464 2861 2e73 6563 6f6e 642c 622e 7365  dd(a.second,b.se
+00006aa0: 636f 6e64 293b 0a20 2072 6574 7572 6e20  cond);.  return 
+00006ab0: 7265 733b 0a7d 0a0a 2f2f 206e 6f74 6520  res;.}..// note 
+00006ac0: 7468 6174 2066 6f72 2044 6f75 626c 6550  that for DoubleP
+00006ad0: 6163 6b65 743c 5265 616c 5061 636b 6574  acket<RealPacket
+00006ae0: 3e20 7468 6520 2234 2220 696e 2022 646f  > the "4" in "do
+00006af0: 776e 746f 3422 0a2f 2f20 636f 7272 6573  wnto4".// corres
+00006b00: 706f 6e64 7320 746f 2074 6865 206e 756d  ponds to the num
+00006b10: 6265 7220 6f66 2063 6f6d 706c 6578 6573  ber of complexes
+00006b20: 2c20 736f 2069 7420 6d65 616e 7320 2238  , so it means "8
+00006b30: 220a 2f2f 2069 7420 7465 726d 7320 6f66  ".// it terms of
+00006b40: 2072 6561 6c20 636f 6566 6669 6369 656e   real coefficien
+00006b50: 7473 2e0a 0a74 656d 706c 6174 653c 7479  ts...template<ty
+00006b60: 7065 6e61 6d65 2050 6163 6b65 743e 0a63  pename Packet>.c
+00006b70: 6f6e 7374 2044 6f75 626c 6550 6163 6b65  onst DoublePacke
+00006b80: 743c 5061 636b 6574 3e26 0a70 7265 6475  t<Packet>&.predu
+00006b90: 785f 6861 6c66 5f64 6f77 746f 3428 636f  x_half_dowto4(co
+00006ba0: 6e73 7420 446f 7562 6c65 5061 636b 6574  nst DoublePacket
+00006bb0: 3c50 6163 6b65 743e 2026 612c 0a20 2020  <Packet> &a,.   
+00006bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006bd0: 7479 7065 6e61 6d65 2065 6e61 626c 655f  typename enable_
+00006be0: 6966 3c75 6e70 6163 6b65 745f 7472 6169  if<unpacket_trai
+00006bf0: 7473 3c50 6163 6b65 743e 3a3a 7369 7a65  ts<Packet>::size
+00006c00: 3c3d 383e 3a3a 7479 7065 2a20 3d20 3029  <=8>::type* = 0)
+00006c10: 0a7b 0a20 2072 6574 7572 6e20 613b 0a7d  .{.  return a;.}
+00006c20: 0a0a 7465 6d70 6c61 7465 3c74 7970 656e  ..template<typen
+00006c30: 616d 6520 5061 636b 6574 3e0a 446f 7562  ame Packet>.Doub
+00006c40: 6c65 5061 636b 6574 3c74 7970 656e 616d  lePacket<typenam
+00006c50: 6520 756e 7061 636b 6574 5f74 7261 6974  e unpacket_trait
+00006c60: 733c 5061 636b 6574 3e3a 3a68 616c 663e  s<Packet>::half>
+00006c70: 0a70 7265 6475 785f 6861 6c66 5f64 6f77  .predux_half_dow
+00006c80: 746f 3428 636f 6e73 7420 446f 7562 6c65  to4(const Double
+00006c90: 5061 636b 6574 3c50 6163 6b65 743e 2026  Packet<Packet> &
+00006ca0: 612c 0a20 2020 2020 2020 2020 2020 2020  a,.             
+00006cb0: 2020 2020 2020 7479 7065 6e61 6d65 2065        typename e
+00006cc0: 6e61 626c 655f 6966 3c75 6e70 6163 6b65  nable_if<unpacke
+00006cd0: 745f 7472 6169 7473 3c50 6163 6b65 743e  t_traits<Packet>
+00006ce0: 3a3a 7369 7a65 3d3d 3136 3e3a 3a74 7970  ::size==16>::typ
+00006cf0: 652a 203d 2030 290a 7b0a 2020 2f2f 2079  e* = 0).{.  // y
+00006d00: 6573 2c20 7468 6174 2773 2070 7265 7474  es, that's prett
+00006d10: 7920 6861 636b 6973 6820 3a28 0a20 2044  y hackish :(.  D
+00006d20: 6f75 626c 6550 6163 6b65 743c 7479 7065  oublePacket<type
+00006d30: 6e61 6d65 2075 6e70 6163 6b65 745f 7472  name unpacket_tr
+00006d40: 6169 7473 3c50 6163 6b65 743e 3a3a 6861  aits<Packet>::ha
+00006d50: 6c66 3e20 7265 733b 0a20 2074 7970 6564  lf> res;.  typed
+00006d60: 6566 2073 7464 3a3a 636f 6d70 6c65 783c  ef std::complex<
+00006d70: 7479 7065 6e61 6d65 2075 6e70 6163 6b65  typename unpacke
+00006d80: 745f 7472 6169 7473 3c50 6163 6b65 743e  t_traits<Packet>
+00006d90: 3a3a 7479 7065 3e20 4370 6c78 3b0a 2020  ::type> Cplx;.  
+00006da0: 7479 7065 6465 6620 7479 7065 6e61 6d65  typedef typename
+00006db0: 2070 6163 6b65 745f 7472 6169 7473 3c43   packet_traits<C
+00006dc0: 706c 783e 3a3a 7479 7065 2043 706c 7850  plx>::type CplxP
+00006dd0: 6163 6b65 743b 0a20 2072 6573 2e66 6972  acket;.  res.fir
+00006de0: 7374 2020 3d20 7072 6564 7578 5f68 616c  st  = predux_hal
+00006df0: 665f 646f 7774 6f34 2843 706c 7850 6163  f_dowto4(CplxPac
+00006e00: 6b65 7428 612e 6669 7273 7429 292e 763b  ket(a.first)).v;
+00006e10: 0a20 2072 6573 2e73 6563 6f6e 6420 3d20  .  res.second = 
+00006e20: 7072 6564 7578 5f68 616c 665f 646f 7774  predux_half_dowt
+00006e30: 6f34 2843 706c 7850 6163 6b65 7428 612e  o4(CplxPacket(a.
+00006e40: 7365 636f 6e64 2929 2e76 3b0a 2020 7265  second)).v;.  re
+00006e50: 7475 726e 2072 6573 3b0a 7d0a 0a2f 2f20  turn res;.}..// 
+00006e60: 7361 6d65 2068 6572 652c 2022 7175 6164  same here, "quad
+00006e70: 2220 6163 7475 616c 6c79 206d 6561 6e73  " actually means
+00006e80: 2022 3822 2069 6e20 7465 726d 7320 6f66   "8" in terms of
+00006e90: 2072 6561 6c20 636f 6566 6669 6369 656e   real coefficien
+00006ea0: 7473 0a74 656d 706c 6174 653c 7479 7065  ts.template<type
+00006eb0: 6e61 6d65 2053 6361 6c61 722c 2074 7970  name Scalar, typ
+00006ec0: 656e 616d 6520 5265 616c 5061 636b 6574  ename RealPacket
+00006ed0: 3e0a 766f 6964 206c 6f61 6451 7561 6454  >.void loadQuadT
+00006ee0: 6f44 6f75 626c 6550 6163 6b65 7428 636f  oDoublePacket(co
+00006ef0: 6e73 7420 5363 616c 6172 2a20 622c 2044  nst Scalar* b, D
+00006f00: 6f75 626c 6550 6163 6b65 743c 5265 616c  oublePacket<Real
+00006f10: 5061 636b 6574 3e26 2064 6573 742c 0a20  Packet>& dest,. 
+00006f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006f30: 2020 2020 2020 2020 2020 2074 7970 656e             typen
+00006f40: 616d 6520 656e 6162 6c65 5f69 663c 756e  ame enable_if<un
+00006f50: 7061 636b 6574 5f74 7261 6974 733c 5265  packet_traits<Re
+00006f60: 616c 5061 636b 6574 3e3a 3a73 697a 653c  alPacket>::size<
+00006f70: 3d38 3e3a 3a74 7970 652a 203d 2030 290a  =8>::type* = 0).
+00006f80: 7b0a 2020 6465 7374 2e66 6972 7374 2020  {.  dest.first  
+00006f90: 3d20 7073 6574 313c 5265 616c 5061 636b  = pset1<RealPack
+00006fa0: 6574 3e28 6e75 6d65 7874 3a3a 7265 616c  et>(numext::real
+00006fb0: 282a 6229 293b 0a20 2064 6573 742e 7365  (*b));.  dest.se
+00006fc0: 636f 6e64 203d 2070 7365 7431 3c52 6561  cond = pset1<Rea
+00006fd0: 6c50 6163 6b65 743e 286e 756d 6578 743a  lPacket>(numext:
+00006fe0: 3a69 6d61 6728 2a62 2929 3b0a 7d0a 0a74  :imag(*b));.}..t
+00006ff0: 656d 706c 6174 653c 7479 7065 6e61 6d65  emplate<typename
+00007000: 2053 6361 6c61 722c 2074 7970 656e 616d   Scalar, typenam
+00007010: 6520 5265 616c 5061 636b 6574 3e0a 766f  e RealPacket>.vo
+00007020: 6964 206c 6f61 6451 7561 6454 6f44 6f75  id loadQuadToDou
+00007030: 626c 6550 6163 6b65 7428 636f 6e73 7420  blePacket(const 
+00007040: 5363 616c 6172 2a20 622c 2044 6f75 626c  Scalar* b, Doubl
+00007050: 6550 6163 6b65 743c 5265 616c 5061 636b  ePacket<RealPack
+00007060: 6574 3e26 2064 6573 742c 0a20 2020 2020  et>& dest,.     
+00007070: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007080: 2020 2020 2020 2074 7970 656e 616d 6520         typename 
+00007090: 656e 6162 6c65 5f69 663c 756e 7061 636b  enable_if<unpack
+000070a0: 6574 5f74 7261 6974 733c 5265 616c 5061  et_traits<RealPa
+000070b0: 636b 6574 3e3a 3a73 697a 653d 3d31 363e  cket>::size==16>
+000070c0: 3a3a 7479 7065 2a20 3d20 3029 0a7b 0a20  ::type* = 0).{. 
+000070d0: 202f 2f20 7965 732c 2074 6861 7427 7320   // yes, that's 
+000070e0: 7072 6574 7479 2068 6163 6b69 7368 2074  pretty hackish t
+000070f0: 6f6f 203a 280a 2020 7479 7065 6465 6620  oo :(.  typedef 
+00007100: 7479 7065 6e61 6d65 204e 756d 5472 6169  typename NumTrai
+00007110: 7473 3c53 6361 6c61 723e 3a3a 5265 616c  ts<Scalar>::Real
+00007120: 2052 6561 6c53 6361 6c61 723b 0a20 2052   RealScalar;.  R
+00007130: 6561 6c53 6361 6c61 7220 725b 345d 203d  ealScalar r[4] =
+00007140: 207b 6e75 6d65 7874 3a3a 7265 616c 2862   {numext::real(b
+00007150: 5b30 5d29 2c20 6e75 6d65 7874 3a3a 7265  [0]), numext::re
+00007160: 616c 2862 5b30 5d29 2c20 6e75 6d65 7874  al(b[0]), numext
+00007170: 3a3a 7265 616c 2862 5b31 5d29 2c20 6e75  ::real(b[1]), nu
+00007180: 6d65 7874 3a3a 7265 616c 2862 5b31 5d29  mext::real(b[1])
+00007190: 7d3b 0a20 2052 6561 6c53 6361 6c61 7220  };.  RealScalar 
+000071a0: 695b 345d 203d 207b 6e75 6d65 7874 3a3a  i[4] = {numext::
+000071b0: 696d 6167 2862 5b30 5d29 2c20 6e75 6d65  imag(b[0]), nume
+000071c0: 7874 3a3a 696d 6167 2862 5b30 5d29 2c20  xt::imag(b[0]), 
+000071d0: 6e75 6d65 7874 3a3a 696d 6167 2862 5b31  numext::imag(b[1
+000071e0: 5d29 2c20 6e75 6d65 7874 3a3a 696d 6167  ]), numext::imag
+000071f0: 2862 5b31 5d29 7d3b 0a20 2064 6573 742e  (b[1])};.  dest.
+00007200: 6669 7273 7420 203d 2070 6c6f 6164 7175  first  = ploadqu
+00007210: 6164 3c52 6561 6c50 6163 6b65 743e 2872  ad<RealPacket>(r
+00007220: 293b 0a20 2064 6573 742e 7365 636f 6e64  );.  dest.second
+00007230: 203d 2070 6c6f 6164 7175 6164 3c52 6561   = ploadquad<Rea
+00007240: 6c50 6163 6b65 743e 2869 293b 0a7d 0a0a  lPacket>(i);.}..
+00007250: 0a74 656d 706c 6174 653c 7479 7065 6e61  .template<typena
+00007260: 6d65 2050 6163 6b65 743e 2073 7472 7563  me Packet> struc
+00007270: 7420 756e 7061 636b 6574 5f74 7261 6974  t unpacket_trait
+00007280: 733c 446f 7562 6c65 5061 636b 6574 3c50  s<DoublePacket<P
+00007290: 6163 6b65 743e 203e 207b 0a20 2074 7970  acket> > {.  typ
+000072a0: 6564 6566 2044 6f75 626c 6550 6163 6b65  edef DoublePacke
+000072b0: 743c 7479 7065 6e61 6d65 2075 6e70 6163  t<typename unpac
+000072c0: 6b65 745f 7472 6169 7473 3c50 6163 6b65  ket_traits<Packe
+000072d0: 743e 3a3a 6861 6c66 3e20 6861 6c66 3b0a  t>::half> half;.
+000072e0: 7d3b 0a2f 2f20 7465 6d70 6c61 7465 3c74  };.// template<t
+000072f0: 7970 656e 616d 6520 5061 636b 6574 3e0a  ypename Packet>.
+00007300: 2f2f 2044 6f75 626c 6550 6163 6b65 743c  // DoublePacket<
+00007310: 5061 636b 6574 3e20 706d 6164 6428 636f  Packet> pmadd(co
+00007320: 6e73 7420 446f 7562 6c65 5061 636b 6574  nst DoublePacket
+00007330: 3c50 6163 6b65 743e 2026 612c 2063 6f6e  <Packet> &a, con
+00007340: 7374 2044 6f75 626c 6550 6163 6b65 743c  st DoublePacket<
+00007350: 5061 636b 6574 3e20 2662 290a 2f2f 207b  Packet> &b).// {
+00007360: 0a2f 2f20 2020 446f 7562 6c65 5061 636b  .//   DoublePack
+00007370: 6574 3c50 6163 6b65 743e 2072 6573 3b0a  et<Packet> res;.
+00007380: 2f2f 2020 2072 6573 2e66 6972 7374 2020  //   res.first  
+00007390: 3d20 7061 6464 2861 2e66 6972 7374 2c20  = padd(a.first, 
+000073a0: 622e 6669 7273 7429 3b0a 2f2f 2020 2072  b.first);.//   r
+000073b0: 6573 2e73 6563 6f6e 6420 3d20 7061 6464  es.second = padd
+000073c0: 2861 2e73 6563 6f6e 642c 622e 7365 636f  (a.second,b.seco
+000073d0: 6e64 293b 0a2f 2f20 2020 7265 7475 726e  nd);.//   return
+000073e0: 2072 6573 3b0a 2f2f 207d 0a0a 7465 6d70   res;.// }..temp
+000073f0: 6c61 7465 3c74 7970 656e 616d 6520 5265  late<typename Re
+00007400: 616c 5363 616c 6172 2c20 626f 6f6c 205f  alScalar, bool _
+00007410: 436f 6e6a 4c68 732c 2062 6f6f 6c20 5f43  ConjLhs, bool _C
+00007420: 6f6e 6a52 6873 2c20 696e 7420 4172 6368  onjRhs, int Arch
+00007430: 2c20 696e 7420 5f50 6163 6b65 7453 697a  , int _PacketSiz
+00007440: 653e 0a63 6c61 7373 2067 6562 705f 7472  e>.class gebp_tr
+00007450: 6169 7473 3c73 7464 3a3a 636f 6d70 6c65  aits<std::comple
+00007460: 783c 5265 616c 5363 616c 6172 3e2c 2073  x<RealScalar>, s
+00007470: 7464 3a3a 636f 6d70 6c65 783c 5265 616c  td::complex<Real
+00007480: 5363 616c 6172 3e2c 205f 436f 6e6a 4c68  Scalar>, _ConjLh
+00007490: 732c 205f 436f 6e6a 5268 732c 2041 7263  s, _ConjRhs, Arc
+000074a0: 682c 205f 5061 636b 6574 5369 7a65 203e  h, _PacketSize >
+000074b0: 0a7b 0a70 7562 6c69 633a 0a20 2074 7970  .{.public:.  typ
+000074c0: 6564 6566 2073 7464 3a3a 636f 6d70 6c65  edef std::comple
+000074d0: 783c 5265 616c 5363 616c 6172 3e20 2053  x<RealScalar>  S
+000074e0: 6361 6c61 723b 0a20 2074 7970 6564 6566  calar;.  typedef
+000074f0: 2073 7464 3a3a 636f 6d70 6c65 783c 5265   std::complex<Re
+00007500: 616c 5363 616c 6172 3e20 204c 6873 5363  alScalar>  LhsSc
+00007510: 616c 6172 3b0a 2020 7479 7065 6465 6620  alar;.  typedef 
+00007520: 7374 643a 3a63 6f6d 706c 6578 3c52 6561  std::complex<Rea
+00007530: 6c53 6361 6c61 723e 2020 5268 7353 6361  lScalar>  RhsSca
+00007540: 6c61 723b 0a20 2074 7970 6564 6566 2073  lar;.  typedef s
+00007550: 7464 3a3a 636f 6d70 6c65 783c 5265 616c  td::complex<Real
+00007560: 5363 616c 6172 3e20 2052 6573 5363 616c  Scalar>  ResScal
+00007570: 6172 3b0a 2020 0a20 2050 4143 4b45 545f  ar;.  .  PACKET_
+00007580: 4445 434c 5f43 4f4e 445f 5052 4546 4958  DECL_COND_PREFIX
+00007590: 285f 2c20 4c68 732c 205f 5061 636b 6574  (_, Lhs, _Packet
+000075a0: 5369 7a65 293b 0a20 2050 4143 4b45 545f  Size);.  PACKET_
+000075b0: 4445 434c 5f43 4f4e 445f 5052 4546 4958  DECL_COND_PREFIX
+000075c0: 285f 2c20 5268 732c 205f 5061 636b 6574  (_, Rhs, _Packet
+000075d0: 5369 7a65 293b 0a20 2050 4143 4b45 545f  Size);.  PACKET_
+000075e0: 4445 434c 5f43 4f4e 445f 5052 4546 4958  DECL_COND_PREFIX
+000075f0: 285f 2c20 5265 732c 205f 5061 636b 6574  (_, Res, _Packet
+00007600: 5369 7a65 293b 0a20 2050 4143 4b45 545f  Size);.  PACKET_
+00007610: 4445 434c 5f43 4f4e 4428 5265 616c 2c20  DECL_COND(Real, 
+00007620: 5f50 6163 6b65 7453 697a 6529 3b0a 2020  _PacketSize);.  
+00007630: 5041 434b 4554 5f44 4543 4c5f 434f 4e44  PACKET_DECL_COND
+00007640: 5f53 4341 4c41 5228 5f50 6163 6b65 7453  _SCALAR(_PacketS
+00007650: 697a 6529 3b0a 0a20 2065 6e75 6d20 7b0a  ize);..  enum {.
+00007660: 2020 2020 436f 6e6a 4c68 7320 3d20 5f43      ConjLhs = _C
+00007670: 6f6e 6a4c 6873 2c0a 2020 2020 436f 6e6a  onjLhs,.    Conj
+00007680: 5268 7320 3d20 5f43 6f6e 6a52 6873 2c0a  Rhs = _ConjRhs,.
+00007690: 2020 2020 5665 6374 6f72 697a 6162 6c65      Vectorizable
+000076a0: 203d 2075 6e70 6163 6b65 745f 7472 6169   = unpacket_trai
+000076b0: 7473 3c52 6561 6c50 6163 6b65 743e 3a3a  ts<RealPacket>::
+000076c0: 7665 6374 6f72 697a 6162 6c65 0a20 2020  vectorizable.   
+000076d0: 2020 2020 2020 2020 2020 2020 2026 2620               && 
+000076e0: 756e 7061 636b 6574 5f74 7261 6974 733c  unpacket_traits<
+000076f0: 5363 616c 6172 5061 636b 6574 3e3a 3a76  ScalarPacket>::v
+00007700: 6563 746f 7269 7a61 626c 652c 0a20 2020  ectorizable,.   
+00007710: 2052 6573 5061 636b 6574 5369 7a65 2020   ResPacketSize  
+00007720: 203d 2056 6563 746f 7269 7a61 626c 6520   = Vectorizable 
+00007730: 3f20 756e 7061 636b 6574 5f74 7261 6974  ? unpacket_trait
+00007740: 733c 5f52 6573 5061 636b 6574 3e3a 3a73  s<_ResPacket>::s
+00007750: 697a 6520 3a20 312c 0a20 2020 204c 6873  ize : 1,.    Lhs
+00007760: 5061 636b 6574 5369 7a65 203d 2056 6563  PacketSize = Vec
+00007770: 746f 7269 7a61 626c 6520 3f20 756e 7061  torizable ? unpa
+00007780: 636b 6574 5f74 7261 6974 733c 5f4c 6873  cket_traits<_Lhs
+00007790: 5061 636b 6574 3e3a 3a73 697a 6520 3a20  Packet>::size : 
+000077a0: 312c 0a20 2020 2052 6873 5061 636b 6574  1,.    RhsPacket
+000077b0: 5369 7a65 203d 2056 6563 746f 7269 7a61  Size = Vectoriza
+000077c0: 626c 6520 3f20 756e 7061 636b 6574 5f74  ble ? unpacket_t
+000077d0: 7261 6974 733c 5268 7353 6361 6c61 723e  raits<RhsScalar>
+000077e0: 3a3a 7369 7a65 203a 2031 2c0a 2020 2020  ::size : 1,.    
+000077f0: 5265 616c 5061 636b 6574 5369 7a65 2020  RealPacketSize  
+00007800: 3d20 5665 6374 6f72 697a 6162 6c65 203f  = Vectorizable ?
+00007810: 2075 6e70 6163 6b65 745f 7472 6169 7473   unpacket_traits
+00007820: 3c52 6561 6c50 6163 6b65 743e 3a3a 7369  <RealPacket>::si
+00007830: 7a65 203a 2031 2c0a 0a20 2020 202f 2f20  ze : 1,..    // 
+00007840: 4649 584d 453a 2073 686f 756c 6420 6465  FIXME: should de
+00007850: 7065 6e64 206f 6e20 4e75 6d62 6572 4f66  pend on NumberOf
+00007860: 5265 6769 7374 6572 730a 2020 2020 6e72  Registers.    nr
+00007870: 203d 2034 2c0a 2020 2020 6d72 203d 2052   = 4,.    mr = R
+00007880: 6573 5061 636b 6574 5369 7a65 2c0a 0a20  esPacketSize,.. 
+00007890: 2020 204c 6873 5072 6f67 7265 7373 203d     LhsProgress =
+000078a0: 2052 6573 5061 636b 6574 5369 7a65 2c0a   ResPacketSize,.
+000078b0: 2020 2020 5268 7350 726f 6772 6573 7320      RhsProgress 
+000078c0: 3d20 310a 2020 7d3b 0a20 200a 2020 7479  = 1.  };.  .  ty
+000078d0: 7065 6465 6620 446f 7562 6c65 5061 636b  pedef DoublePack
+000078e0: 6574 3c52 6561 6c50 6163 6b65 743e 2020  et<RealPacket>  
+000078f0: 2020 2020 2020 2020 2020 2020 2020 2044                 D
+00007900: 6f75 626c 6550 6163 6b65 7454 7970 653b  oublePacketType;
+00007910: 0a0a 2020 7479 7065 6465 6620 7479 7065  ..  typedef type
+00007920: 6e61 6d65 2063 6f6e 6469 7469 6f6e 616c  name conditional
+00007930: 3c56 6563 746f 7269 7a61 626c 652c 5363  <Vectorizable,Sc
+00007940: 616c 6172 5061 636b 6574 2c53 6361 6c61  alarPacket,Scala
+00007950: 723e 3a3a 7479 7065 204c 6873 5061 636b  r>::type LhsPack
+00007960: 6574 3450 6163 6b69 6e67 3b0a 2020 7479  et4Packing;.  ty
+00007970: 7065 6465 6620 7479 7065 6e61 6d65 2063  pedef typename c
+00007980: 6f6e 6469 7469 6f6e 616c 3c56 6563 746f  onditional<Vecto
+00007990: 7269 7a61 626c 652c 5265 616c 5061 636b  rizable,RealPack
+000079a0: 6574 2c20 2053 6361 6c61 723e 3a3a 7479  et,  Scalar>::ty
+000079b0: 7065 204c 6873 5061 636b 6574 3b0a 2020  pe LhsPacket;.  
+000079c0: 7479 7065 6465 6620 7479 7065 6e61 6d65  typedef typename
+000079d0: 2063 6f6e 6469 7469 6f6e 616c 3c56 6563   conditional<Vec
+000079e0: 746f 7269 7a61 626c 652c 446f 7562 6c65  torizable,Double
+000079f0: 5061 636b 6574 5479 7065 2c53 6361 6c61  PacketType,Scala
+00007a00: 723e 3a3a 7479 7065 2052 6873 5061 636b  r>::type RhsPack
+00007a10: 6574 3b0a 2020 7479 7065 6465 6620 7479  et;.  typedef ty
+00007a20: 7065 6e61 6d65 2063 6f6e 6469 7469 6f6e  pename condition
+00007a30: 616c 3c56 6563 746f 7269 7a61 626c 652c  al<Vectorizable,
+00007a40: 5363 616c 6172 5061 636b 6574 2c53 6361  ScalarPacket,Sca
+00007a50: 6c61 723e 3a3a 7479 7065 2052 6573 5061  lar>::type ResPa
+00007a60: 636b 6574 3b0a 2020 7479 7065 6465 6620  cket;.  typedef 
+00007a70: 7479 7065 6e61 6d65 2063 6f6e 6469 7469  typename conditi
+00007a80: 6f6e 616c 3c56 6563 746f 7269 7a61 626c  onal<Vectorizabl
+00007a90: 652c 446f 7562 6c65 5061 636b 6574 5479  e,DoublePacketTy
+00007aa0: 7065 2c53 6361 6c61 723e 3a3a 7479 7065  pe,Scalar>::type
+00007ab0: 2041 6363 5061 636b 6574 3b0a 0a20 202f   AccPacket;..  /
+00007ac0: 2f20 7468 6973 2061 6374 7561 6c79 2068  / this actualy h
+00007ad0: 6f6c 6473 2038 2070 6163 6b65 7473 210a  olds 8 packets!.
+00007ae0: 2020 7479 7065 6465 6620 5175 6164 5061    typedef QuadPa
+00007af0: 636b 6574 3c52 6873 5061 636b 6574 3e20  cket<RhsPacket> 
+00007b00: 5268 7350 6163 6b65 7478 343b 0a20 200a  RhsPacketx4;.  .
+00007b10: 2020 4549 4745 4e5f 5354 524f 4e47 5f49    EIGEN_STRONG_I
+00007b20: 4e4c 494e 4520 766f 6964 2069 6e69 7441  NLINE void initA
+00007b30: 6363 2853 6361 6c61 7226 2070 2920 7b20  cc(Scalar& p) { 
+00007b40: 7020 3d20 5363 616c 6172 2830 293b 207d  p = Scalar(0); }
+00007b50: 0a0a 2020 4549 4745 4e5f 5354 524f 4e47  ..  EIGEN_STRONG
+00007b60: 5f49 4e4c 494e 4520 766f 6964 2069 6e69  _INLINE void ini
+00007b70: 7441 6363 2844 6f75 626c 6550 6163 6b65  tAcc(DoublePacke
+00007b80: 7454 7970 6526 2070 290a 2020 7b0a 2020  tType& p).  {.  
+00007b90: 2020 702e 6669 7273 7420 2020 3d20 7073    p.first   = ps
+00007ba0: 6574 313c 5265 616c 5061 636b 6574 3e28  et1<RealPacket>(
+00007bb0: 5265 616c 5363 616c 6172 2830 2929 3b0a  RealScalar(0));.
+00007bc0: 2020 2020 702e 7365 636f 6e64 2020 3d20      p.second  = 
+00007bd0: 7073 6574 313c 5265 616c 5061 636b 6574  pset1<RealPacket
+00007be0: 3e28 5265 616c 5363 616c 6172 2830 2929  >(RealScalar(0))
+00007bf0: 3b0a 2020 7d0a 0a20 202f 2f20 5363 616c  ;.  }..  // Scal
+00007c00: 6172 2070 6174 680a 2020 4549 4745 4e5f  ar path.  EIGEN_
+00007c10: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
+00007c20: 6964 206c 6f61 6452 6873 2863 6f6e 7374  id loadRhs(const
+00007c30: 2052 6873 5363 616c 6172 2a20 622c 2053   RhsScalar* b, S
+00007c40: 6361 6c61 7250 6163 6b65 7426 2064 6573  calarPacket& des
+00007c50: 7429 2063 6f6e 7374 0a20 207b 0a20 2020  t) const.  {.   
+00007c60: 2064 6573 7420 3d20 7073 6574 313c 5363   dest = pset1<Sc
+00007c70: 616c 6172 5061 636b 6574 3e28 2a62 293b  alarPacket>(*b);
+00007c80: 0a20 207d 0a0a 2020 2f2f 2056 6563 746f  .  }..  // Vecto
+00007c90: 7269 7a65 6420 7061 7468 0a20 2074 656d  rized path.  tem
+00007ca0: 706c 6174 653c 7479 7065 6e61 6d65 2052  plate<typename R
+00007cb0: 6561 6c50 6163 6b65 7454 7970 653e 0a20  ealPacketType>. 
+00007cc0: 2045 4947 454e 5f53 5452 4f4e 475f 494e   EIGEN_STRONG_IN
+00007cd0: 4c49 4e45 2076 6f69 6420 6c6f 6164 5268  LINE void loadRh
+00007ce0: 7328 636f 6e73 7420 5268 7353 6361 6c61  s(const RhsScala
+00007cf0: 722a 2062 2c20 446f 7562 6c65 5061 636b  r* b, DoublePack
+00007d00: 6574 3c52 6561 6c50 6163 6b65 7454 7970  et<RealPacketTyp
+00007d10: 653e 2620 6465 7374 2920 636f 6e73 740a  e>& dest) const.
+00007d20: 2020 7b0a 2020 2020 6465 7374 2e66 6972    {.    dest.fir
+00007d30: 7374 2020 3d20 7073 6574 313c 5265 616c  st  = pset1<Real
+00007d40: 5061 636b 6574 5479 7065 3e28 6e75 6d65  PacketType>(nume
+00007d50: 7874 3a3a 7265 616c 282a 6229 293b 0a20  xt::real(*b));. 
+00007d60: 2020 2064 6573 742e 7365 636f 6e64 203d     dest.second =
+00007d70: 2070 7365 7431 3c52 6561 6c50 6163 6b65   pset1<RealPacke
+00007d80: 7454 7970 653e 286e 756d 6578 743a 3a69  tType>(numext::i
+00007d90: 6d61 6728 2a62 2929 3b0a 2020 7d0a 0a20  mag(*b));.  }.. 
+00007da0: 2045 4947 454e 5f53 5452 4f4e 475f 494e   EIGEN_STRONG_IN
+00007db0: 4c49 4e45 2076 6f69 6420 6c6f 6164 5268  LINE void loadRh
+00007dc0: 7328 636f 6e73 7420 5268 7353 6361 6c61  s(const RhsScala
+00007dd0: 722a 2062 2c20 5268 7350 6163 6b65 7478  r* b, RhsPacketx
+00007de0: 3426 2064 6573 7429 2063 6f6e 7374 0a20  4& dest) const. 
+00007df0: 207b 0a20 2020 206c 6f61 6452 6873 2862   {.    loadRhs(b
+00007e00: 2c20 6465 7374 2e42 5f30 293b 0a20 2020  , dest.B_0);.   
+00007e10: 206c 6f61 6452 6873 2862 202b 2031 2c20   loadRhs(b + 1, 
+00007e20: 6465 7374 2e42 3129 3b0a 2020 2020 6c6f  dest.B1);.    lo
+00007e30: 6164 5268 7328 6220 2b20 322c 2064 6573  adRhs(b + 2, des
+00007e40: 742e 4232 293b 0a20 2020 206c 6f61 6452  t.B2);.    loadR
+00007e50: 6873 2862 202b 2033 2c20 6465 7374 2e42  hs(b + 3, dest.B
+00007e60: 3329 3b0a 2020 7d0a 0a20 202f 2f20 5363  3);.  }..  // Sc
+00007e70: 616c 6172 2070 6174 680a 2020 4549 4745  alar path.  EIGE
+00007e80: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
+00007e90: 766f 6964 2075 7064 6174 6552 6873 2863  void updateRhs(c
+00007ea0: 6f6e 7374 2052 6873 5363 616c 6172 2a20  onst RhsScalar* 
+00007eb0: 622c 2053 6361 6c61 7250 6163 6b65 7426  b, ScalarPacket&
+00007ec0: 2064 6573 7429 2063 6f6e 7374 0a20 207b   dest) const.  {
+00007ed0: 0a20 2020 206c 6f61 6452 6873 2862 2c20  .    loadRhs(b, 
+00007ee0: 6465 7374 293b 0a20 207d 0a0a 2020 2f2f  dest);.  }..  //
+00007ef0: 2056 6563 746f 7269 7a65 6420 7061 7468   Vectorized path
+00007f00: 0a20 2074 656d 706c 6174 653c 7479 7065  .  template<type
+00007f10: 6e61 6d65 2052 6561 6c50 6163 6b65 7454  name RealPacketT
+00007f20: 7970 653e 0a20 2045 4947 454e 5f53 5452  ype>.  EIGEN_STR
+00007f30: 4f4e 475f 494e 4c49 4e45 2076 6f69 6420  ONG_INLINE void 
+00007f40: 7570 6461 7465 5268 7328 636f 6e73 7420  updateRhs(const 
+00007f50: 5268 7353 6361 6c61 722a 2062 2c20 446f  RhsScalar* b, Do
+00007f60: 7562 6c65 5061 636b 6574 3c52 6561 6c50  ublePacket<RealP
+00007f70: 6163 6b65 7454 7970 653e 2620 6465 7374  acketType>& dest
+00007f80: 2920 636f 6e73 740a 2020 7b0a 2020 2020  ) const.  {.    
+00007f90: 6c6f 6164 5268 7328 622c 2064 6573 7429  loadRhs(b, dest)
+00007fa0: 3b0a 2020 7d0a 0a20 2045 4947 454e 5f53  ;.  }..  EIGEN_S
+00007fb0: 5452 4f4e 475f 494e 4c49 4e45 2076 6f69  TRONG_INLINE voi
+00007fc0: 6420 7570 6461 7465 5268 7328 636f 6e73  d updateRhs(cons
+00007fd0: 7420 5268 7353 6361 6c61 722a 2c20 5268  t RhsScalar*, Rh
+00007fe0: 7350 6163 6b65 7478 3426 2920 636f 6e73  sPacketx4&) cons
+00007ff0: 7420 7b7d 0a20 200a 2020 4549 4745 4e5f  t {}.  .  EIGEN_
+00008000: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
+00008010: 6964 206c 6f61 6452 6873 5175 6164 2863  id loadRhsQuad(c
+00008020: 6f6e 7374 2052 6873 5363 616c 6172 2a20  onst RhsScalar* 
+00008030: 622c 2052 6573 5061 636b 6574 2620 6465  b, ResPacket& de
+00008040: 7374 2920 636f 6e73 740a 2020 7b0a 2020  st) const.  {.  
+00008050: 2020 6c6f 6164 5268 7328 622c 6465 7374    loadRhs(b,dest
+00008060: 293b 0a20 207d 0a20 2045 4947 454e 5f53  );.  }.  EIGEN_S
+00008070: 5452 4f4e 475f 494e 4c49 4e45 2076 6f69  TRONG_INLINE voi
+00008080: 6420 6c6f 6164 5268 7351 7561 6428 636f  d loadRhsQuad(co
+00008090: 6e73 7420 5268 7353 6361 6c61 722a 2062  nst RhsScalar* b
+000080a0: 2c20 446f 7562 6c65 5061 636b 6574 5479  , DoublePacketTy
+000080b0: 7065 2620 6465 7374 2920 636f 6e73 740a  pe& dest) const.
+000080c0: 2020 7b0a 2020 2020 6c6f 6164 5175 6164    {.    loadQuad
+000080d0: 546f 446f 7562 6c65 5061 636b 6574 2862  ToDoublePacket(b
+000080e0: 2c64 6573 7429 3b0a 2020 7d0a 0a20 202f  ,dest);.  }..  /
+000080f0: 2f20 6e6f 7468 696e 6720 7370 6563 6961  / nothing specia
+00008100: 6c20 6865 7265 0a20 2045 4947 454e 5f53  l here.  EIGEN_S
+00008110: 5452 4f4e 475f 494e 4c49 4e45 2076 6f69  TRONG_INLINE voi
+00008120: 6420 6c6f 6164 4c68 7328 636f 6e73 7420  d loadLhs(const 
+00008130: 4c68 7353 6361 6c61 722a 2061 2c20 4c68  LhsScalar* a, Lh
+00008140: 7350 6163 6b65 7426 2064 6573 7429 2063  sPacket& dest) c
+00008150: 6f6e 7374 0a20 207b 0a20 2020 2064 6573  onst.  {.    des
+00008160: 7420 3d20 706c 6f61 643c 4c68 7350 6163  t = pload<LhsPac
+00008170: 6b65 743e 2828 636f 6e73 7420 7479 7065  ket>((const type
+00008180: 6e61 6d65 2075 6e70 6163 6b65 745f 7472  name unpacket_tr
+00008190: 6169 7473 3c4c 6873 5061 636b 6574 3e3a  aits<LhsPacket>:
+000081a0: 3a74 7970 652a 2928 6129 293b 0a20 207d  :type*)(a));.  }
+000081b0: 0a0a 2020 7465 6d70 6c61 7465 3c74 7970  ..  template<typ
+000081c0: 656e 616d 6520 4c68 7350 6163 6b65 7454  ename LhsPacketT
+000081d0: 7970 653e 0a20 2045 4947 454e 5f53 5452  ype>.  EIGEN_STR
+000081e0: 4f4e 475f 494e 4c49 4e45 2076 6f69 6420  ONG_INLINE void 
+000081f0: 6c6f 6164 4c68 7355 6e61 6c69 676e 6564  loadLhsUnaligned
+00008200: 2863 6f6e 7374 204c 6873 5363 616c 6172  (const LhsScalar
+00008210: 2a20 612c 204c 6873 5061 636b 6574 5479  * a, LhsPacketTy
+00008220: 7065 2620 6465 7374 2920 636f 6e73 740a  pe& dest) const.
+00008230: 2020 7b0a 2020 2020 6465 7374 203d 2070    {.    dest = p
+00008240: 6c6f 6164 753c 4c68 7350 6163 6b65 7454  loadu<LhsPacketT
+00008250: 7970 653e 2828 636f 6e73 7420 7479 7065  ype>((const type
+00008260: 6e61 6d65 2075 6e70 6163 6b65 745f 7472  name unpacket_tr
+00008270: 6169 7473 3c4c 6873 5061 636b 6574 5479  aits<LhsPacketTy
+00008280: 7065 3e3a 3a74 7970 652a 2928 6129 293b  pe>::type*)(a));
+00008290: 0a20 207d 0a0a 2020 7465 6d70 6c61 7465  .  }..  template
+000082a0: 3c74 7970 656e 616d 6520 4c68 7350 6163  <typename LhsPac
+000082b0: 6b65 7454 7970 652c 2074 7970 656e 616d  ketType, typenam
+000082c0: 6520 5268 7350 6163 6b65 7454 7970 652c  e RhsPacketType,
+000082d0: 2074 7970 656e 616d 6520 5265 7350 6163   typename ResPac
+000082e0: 6b65 7454 7970 652c 2074 7970 656e 616d  ketType, typenam
+000082f0: 6520 546d 7054 7970 652c 2074 7970 656e  e TmpType, typen
+00008300: 616d 6520 4c61 6e65 4964 5479 7065 3e0a  ame LaneIdType>.
+00008310: 2020 4549 4745 4e5f 5354 524f 4e47 5f49    EIGEN_STRONG_I
+00008320: 4e4c 494e 450a 2020 7479 7065 6e61 6d65  NLINE.  typename
+00008330: 2065 6e61 626c 655f 6966 3c21 6973 5f73   enable_if<!is_s
+00008340: 616d 653c 5268 7350 6163 6b65 7454 7970  ame<RhsPacketTyp
+00008350: 652c 5268 7350 6163 6b65 7478 343e 3a3a  e,RhsPacketx4>::
+00008360: 7661 6c75 653e 3a3a 7479 7065 0a20 206d  value>::type.  m
+00008370: 6164 6428 636f 6e73 7420 4c68 7350 6163  add(const LhsPac
+00008380: 6b65 7454 7970 6526 2061 2c20 636f 6e73  ketType& a, cons
+00008390: 7420 5268 7350 6163 6b65 7454 7970 6526  t RhsPacketType&
+000083a0: 2062 2c20 446f 7562 6c65 5061 636b 6574   b, DoublePacket
+000083b0: 3c52 6573 5061 636b 6574 5479 7065 3e26  <ResPacketType>&
+000083c0: 2063 2c20 546d 7054 7970 6526 202f 2a74   c, TmpType& /*t
+000083d0: 6d70 2a2f 2c20 636f 6e73 7420 4c61 6e65  mp*/, const Lane
+000083e0: 4964 5479 7065 2629 2063 6f6e 7374 0a20  IdType&) const. 
+000083f0: 207b 0a20 2020 2063 2e66 6972 7374 2020   {.    c.first  
+00008400: 203d 2070 6164 6428 706d 756c 2861 2c62   = padd(pmul(a,b
+00008410: 2e66 6972 7374 292c 2063 2e66 6972 7374  .first), c.first
+00008420: 293b 0a20 2020 2063 2e73 6563 6f6e 6420  );.    c.second 
+00008430: 203d 2070 6164 6428 706d 756c 2861 2c62   = padd(pmul(a,b
+00008440: 2e73 6563 6f6e 6429 2c63 2e73 6563 6f6e  .second),c.secon
+00008450: 6429 3b0a 2020 7d0a 0a20 2074 656d 706c  d);.  }..  templ
+00008460: 6174 653c 7479 7065 6e61 6d65 204c 616e  ate<typename Lan
+00008470: 6549 6454 7970 653e 0a20 2045 4947 454e  eIdType>.  EIGEN
+00008480: 5f53 5452 4f4e 475f 494e 4c49 4e45 2076  _STRONG_INLINE v
+00008490: 6f69 6420 6d61 6464 2863 6f6e 7374 204c  oid madd(const L
+000084a0: 6873 5061 636b 6574 2620 612c 2063 6f6e  hsPacket& a, con
+000084b0: 7374 2052 6873 5061 636b 6574 2620 622c  st RhsPacket& b,
+000084c0: 2052 6573 5061 636b 6574 2620 632c 2052   ResPacket& c, R
+000084d0: 6873 5061 636b 6574 2620 2f2a 746d 702a  hsPacket& /*tmp*
+000084e0: 2f2c 2063 6f6e 7374 204c 616e 6549 6454  /, const LaneIdT
+000084f0: 7970 6526 2920 636f 6e73 740a 2020 7b0a  ype&) const.  {.
+00008500: 2020 2020 6320 3d20 636a 2e70 6d61 6464      c = cj.pmadd
+00008510: 2861 2c62 2c63 293b 0a20 207d 0a0a 2020  (a,b,c);.  }..  
+00008520: 7465 6d70 6c61 7465 3c74 7970 656e 616d  template<typenam
+00008530: 6520 4c68 7350 6163 6b65 7454 7970 652c  e LhsPacketType,
+00008540: 2074 7970 656e 616d 6520 4163 6350 6163   typename AccPac
+00008550: 6b65 7454 7970 652c 2074 7970 656e 616d  ketType, typenam
+00008560: 6520 4c61 6e65 4964 5479 7065 3e0a 2020  e LaneIdType>.  
+00008570: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+00008580: 494e 4520 766f 6964 206d 6164 6428 636f  INE void madd(co
+00008590: 6e73 7420 4c68 7350 6163 6b65 7454 7970  nst LhsPacketTyp
+000085a0: 6526 2061 2c20 636f 6e73 7420 5268 7350  e& a, const RhsP
+000085b0: 6163 6b65 7478 3426 2062 2c20 4163 6350  acketx4& b, AccP
+000085c0: 6163 6b65 7454 7970 6526 2063 2c20 5268  acketType& c, Rh
+000085d0: 7350 6163 6b65 7426 2074 6d70 2c20 636f  sPacket& tmp, co
+000085e0: 6e73 7420 4c61 6e65 4964 5479 7065 2620  nst LaneIdType& 
+000085f0: 6c61 6e65 2920 636f 6e73 740a 2020 7b0a  lane) const.  {.
+00008600: 2020 2020 6d61 6464 2861 2c20 622e 6765      madd(a, b.ge
+00008610: 7428 6c61 6e65 292c 2063 2c20 746d 702c  t(lane), c, tmp,
+00008620: 206c 616e 6529 3b0a 2020 7d0a 2020 0a20   lane);.  }.  . 
+00008630: 2045 4947 454e 5f53 5452 4f4e 475f 494e   EIGEN_STRONG_IN
+00008640: 4c49 4e45 2076 6f69 6420 6163 6328 636f  LINE void acc(co
+00008650: 6e73 7420 5363 616c 6172 2620 632c 2063  nst Scalar& c, c
+00008660: 6f6e 7374 2053 6361 6c61 7226 2061 6c70  onst Scalar& alp
+00008670: 6861 2c20 5363 616c 6172 2620 7229 2063  ha, Scalar& r) c
+00008680: 6f6e 7374 207b 2072 202b 3d20 616c 7068  onst { r += alph
+00008690: 6120 2a20 633b 207d 0a20 200a 2020 7465  a * c; }.  .  te
+000086a0: 6d70 6c61 7465 3c74 7970 656e 616d 6520  mplate<typename 
+000086b0: 5265 616c 5061 636b 6574 5479 7065 2c20  RealPacketType, 
+000086c0: 7479 7065 6e61 6d65 2052 6573 5061 636b  typename ResPack
+000086d0: 6574 5479 7065 3e0a 2020 4549 4745 4e5f  etType>.  EIGEN_
+000086e0: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
+000086f0: 6964 2061 6363 2863 6f6e 7374 2044 6f75  id acc(const Dou
+00008700: 626c 6550 6163 6b65 743c 5265 616c 5061  blePacket<RealPa
+00008710: 636b 6574 5479 7065 3e26 2063 2c20 636f  cketType>& c, co
+00008720: 6e73 7420 5265 7350 6163 6b65 7454 7970  nst ResPacketTyp
+00008730: 6526 2061 6c70 6861 2c20 5265 7350 6163  e& alpha, ResPac
+00008740: 6b65 7454 7970 6526 2072 2920 636f 6e73  ketType& r) cons
+00008750: 740a 2020 7b0a 2020 2020 2f2f 2061 7373  t.  {.    // ass
+00008760: 656d 626c 6520 630a 2020 2020 5265 7350  emble c.    ResP
+00008770: 6163 6b65 7454 7970 6520 746d 703b 0a20  acketType tmp;. 
+00008780: 2020 2069 6628 2821 436f 6e6a 4c68 7329     if((!ConjLhs)
+00008790: 2626 2821 436f 6e6a 5268 7329 290a 2020  &&(!ConjRhs)).  
+000087a0: 2020 7b0a 2020 2020 2020 746d 7020 3d20    {.      tmp = 
+000087b0: 7063 706c 7866 6c69 7028 7063 6f6e 6a28  pcplxflip(pconj(
+000087c0: 5265 7350 6163 6b65 7454 7970 6528 632e  ResPacketType(c.
+000087d0: 7365 636f 6e64 2929 293b 0a20 2020 2020  second)));.     
+000087e0: 2074 6d70 203d 2070 6164 6428 5265 7350   tmp = padd(ResP
+000087f0: 6163 6b65 7454 7970 6528 632e 6669 7273  acketType(c.firs
+00008800: 7429 2c74 6d70 293b 0a20 2020 207d 0a20  t),tmp);.    }. 
+00008810: 2020 2065 6c73 6520 6966 2828 2143 6f6e     else if((!Con
+00008820: 6a4c 6873 2926 2628 436f 6e6a 5268 7329  jLhs)&&(ConjRhs)
+00008830: 290a 2020 2020 7b0a 2020 2020 2020 746d  ).    {.      tm
+00008840: 7020 3d20 7063 6f6e 6a28 7063 706c 7866  p = pconj(pcplxf
+00008850: 6c69 7028 5265 7350 6163 6b65 7454 7970  lip(ResPacketTyp
+00008860: 6528 632e 7365 636f 6e64 2929 293b 0a20  e(c.second)));. 
+00008870: 2020 2020 2074 6d70 203d 2070 6164 6428       tmp = padd(
+00008880: 5265 7350 6163 6b65 7454 7970 6528 632e  ResPacketType(c.
+00008890: 6669 7273 7429 2c74 6d70 293b 0a20 2020  first),tmp);.   
+000088a0: 207d 0a20 2020 2065 6c73 6520 6966 2828   }.    else if((
+000088b0: 436f 6e6a 4c68 7329 2626 2821 436f 6e6a  ConjLhs)&&(!Conj
+000088c0: 5268 7329 290a 2020 2020 7b0a 2020 2020  Rhs)).    {.    
+000088d0: 2020 746d 7020 3d20 7063 706c 7866 6c69    tmp = pcplxfli
+000088e0: 7028 5265 7350 6163 6b65 7454 7970 6528  p(ResPacketType(
+000088f0: 632e 7365 636f 6e64 2929 3b0a 2020 2020  c.second));.    
+00008900: 2020 746d 7020 3d20 7061 6464 2870 636f    tmp = padd(pco
+00008910: 6e6a 2852 6573 5061 636b 6574 5479 7065  nj(ResPacketType
+00008920: 2863 2e66 6972 7374 2929 2c74 6d70 293b  (c.first)),tmp);
+00008930: 0a20 2020 207d 0a20 2020 2065 6c73 6520  .    }.    else 
+00008940: 6966 2828 436f 6e6a 4c68 7329 2626 2843  if((ConjLhs)&&(C
+00008950: 6f6e 6a52 6873 2929 0a20 2020 207b 0a20  onjRhs)).    {. 
+00008960: 2020 2020 2074 6d70 203d 2070 6370 6c78       tmp = pcplx
+00008970: 666c 6970 2852 6573 5061 636b 6574 5479  flip(ResPacketTy
+00008980: 7065 2863 2e73 6563 6f6e 6429 293b 0a20  pe(c.second));. 
+00008990: 2020 2020 2074 6d70 203d 2070 7375 6228       tmp = psub(
+000089a0: 7063 6f6e 6a28 5265 7350 6163 6b65 7454  pconj(ResPacketT
+000089b0: 7970 6528 632e 6669 7273 7429 292c 746d  ype(c.first)),tm
+000089c0: 7029 3b0a 2020 2020 7d0a 2020 2020 0a20  p);.    }.    . 
+000089d0: 2020 2072 203d 2070 6d61 6464 2874 6d70     r = pmadd(tmp
+000089e0: 2c61 6c70 6861 2c72 293b 0a20 207d 0a0a  ,alpha,r);.  }..
+000089f0: 7072 6f74 6563 7465 643a 0a20 2063 6f6e  protected:.  con
+00008a00: 6a5f 6865 6c70 6572 3c4c 6873 5363 616c  j_helper<LhsScal
+00008a10: 6172 2c52 6873 5363 616c 6172 2c43 6f6e  ar,RhsScalar,Con
+00008a20: 6a4c 6873 2c43 6f6e 6a52 6873 3e20 636a  jLhs,ConjRhs> cj
+00008a30: 3b0a 7d3b 0a0a 7465 6d70 6c61 7465 3c74  ;.};..template<t
+00008a40: 7970 656e 616d 6520 5265 616c 5363 616c  ypename RealScal
+00008a50: 6172 2c20 626f 6f6c 205f 436f 6e6a 5268  ar, bool _ConjRh
+00008a60: 732c 2069 6e74 2041 7263 682c 2069 6e74  s, int Arch, int
+00008a70: 205f 5061 636b 6574 5369 7a65 3e0a 636c   _PacketSize>.cl
+00008a80: 6173 7320 6765 6270 5f74 7261 6974 733c  ass gebp_traits<
+00008a90: 5265 616c 5363 616c 6172 2c20 7374 643a  RealScalar, std:
+00008aa0: 3a63 6f6d 706c 6578 3c52 6561 6c53 6361  :complex<RealSca
+00008ab0: 6c61 723e 2c20 6661 6c73 652c 205f 436f  lar>, false, _Co
+00008ac0: 6e6a 5268 732c 2041 7263 682c 205f 5061  njRhs, Arch, _Pa
+00008ad0: 636b 6574 5369 7a65 203e 0a7b 0a70 7562  cketSize >.{.pub
+00008ae0: 6c69 633a 0a20 2074 7970 6564 6566 2073  lic:.  typedef s
+00008af0: 7464 3a3a 636f 6d70 6c65 783c 5265 616c  td::complex<Real
+00008b00: 5363 616c 6172 3e20 2053 6361 6c61 723b  Scalar>  Scalar;
+00008b10: 0a20 2074 7970 6564 6566 2052 6561 6c53  .  typedef RealS
+00008b20: 6361 6c61 7220 204c 6873 5363 616c 6172  calar  LhsScalar
+00008b30: 3b0a 2020 7479 7065 6465 6620 5363 616c  ;.  typedef Scal
+00008b40: 6172 2020 2020 2020 5268 7353 6361 6c61  ar      RhsScala
+00008b50: 723b 0a20 2074 7970 6564 6566 2053 6361  r;.  typedef Sca
+00008b60: 6c61 7220 2020 2020 2052 6573 5363 616c  lar      ResScal
+00008b70: 6172 3b0a 0a20 2050 4143 4b45 545f 4445  ar;..  PACKET_DE
+00008b80: 434c 5f43 4f4e 445f 5052 4546 4958 285f  CL_COND_PREFIX(_
+00008b90: 2c20 4c68 732c 205f 5061 636b 6574 5369  , Lhs, _PacketSi
+00008ba0: 7a65 293b 0a20 2050 4143 4b45 545f 4445  ze);.  PACKET_DE
+00008bb0: 434c 5f43 4f4e 445f 5052 4546 4958 285f  CL_COND_PREFIX(_
+00008bc0: 2c20 5268 732c 205f 5061 636b 6574 5369  , Rhs, _PacketSi
+00008bd0: 7a65 293b 0a20 2050 4143 4b45 545f 4445  ze);.  PACKET_DE
+00008be0: 434c 5f43 4f4e 445f 5052 4546 4958 285f  CL_COND_PREFIX(_
+00008bf0: 2c20 5265 732c 205f 5061 636b 6574 5369  , Res, _PacketSi
+00008c00: 7a65 293b 0a20 2050 4143 4b45 545f 4445  ze);.  PACKET_DE
+00008c10: 434c 5f43 4f4e 445f 5052 4546 4958 285f  CL_COND_PREFIX(_
+00008c20: 2c20 5265 616c 2c20 5f50 6163 6b65 7453  , Real, _PacketS
+00008c30: 697a 6529 3b0a 2020 5041 434b 4554 5f44  ize);.  PACKET_D
+00008c40: 4543 4c5f 434f 4e44 5f53 4341 4c41 525f  ECL_COND_SCALAR_
+00008c50: 5052 4546 4958 285f 2c20 5f50 6163 6b65  PREFIX(_, _Packe
+00008c60: 7453 697a 6529 3b0a 0a23 756e 6465 6620  tSize);..#undef 
+00008c70: 5041 434b 4554 5f44 4543 4c5f 434f 4e44  PACKET_DECL_COND
+00008c80: 5f53 4341 4c41 525f 5052 4546 4958 0a23  _SCALAR_PREFIX.#
+00008c90: 756e 6465 6620 5041 434b 4554 5f44 4543  undef PACKET_DEC
+00008ca0: 4c5f 434f 4e44 5f50 5245 4649 580a 2375  L_COND_PREFIX.#u
+00008cb0: 6e64 6566 2050 4143 4b45 545f 4445 434c  ndef PACKET_DECL
+00008cc0: 5f43 4f4e 445f 5343 414c 4152 0a23 756e  _COND_SCALAR.#un
+00008cd0: 6465 6620 5041 434b 4554 5f44 4543 4c5f  def PACKET_DECL_
+00008ce0: 434f 4e44 0a0a 2020 656e 756d 207b 0a20  COND..  enum {. 
+00008cf0: 2020 2043 6f6e 6a4c 6873 203d 2066 616c     ConjLhs = fal
+00008d00: 7365 2c0a 2020 2020 436f 6e6a 5268 7320  se,.    ConjRhs 
+00008d10: 3d20 5f43 6f6e 6a52 6873 2c0a 2020 2020  = _ConjRhs,.    
+00008d20: 5665 6374 6f72 697a 6162 6c65 203d 2075  Vectorizable = u
+00008d30: 6e70 6163 6b65 745f 7472 6169 7473 3c5f  npacket_traits<_
+00008d40: 5265 616c 5061 636b 6574 3e3a 3a76 6563  RealPacket>::vec
+00008d50: 746f 7269 7a61 626c 650a 2020 2020 2020  torizable.      
+00008d60: 2020 2020 2020 2020 2020 2626 2075 6e70            && unp
+00008d70: 6163 6b65 745f 7472 6169 7473 3c5f 5363  acket_traits<_Sc
+00008d80: 616c 6172 5061 636b 6574 3e3a 3a76 6563  alarPacket>::vec
+00008d90: 746f 7269 7a61 626c 652c 0a20 2020 204c  torizable,.    L
+00008da0: 6873 5061 636b 6574 5369 7a65 203d 2056  hsPacketSize = V
+00008db0: 6563 746f 7269 7a61 626c 6520 3f20 756e  ectorizable ? un
+00008dc0: 7061 636b 6574 5f74 7261 6974 733c 5f4c  packet_traits<_L
+00008dd0: 6873 5061 636b 6574 3e3a 3a73 697a 6520  hsPacket>::size 
+00008de0: 3a20 312c 0a20 2020 2052 6873 5061 636b  : 1,.    RhsPack
+00008df0: 6574 5369 7a65 203d 2056 6563 746f 7269  etSize = Vectori
+00008e00: 7a61 626c 6520 3f20 756e 7061 636b 6574  zable ? unpacket
+00008e10: 5f74 7261 6974 733c 5f52 6873 5061 636b  _traits<_RhsPack
+00008e20: 6574 3e3a 3a73 697a 6520 3a20 312c 0a20  et>::size : 1,. 
+00008e30: 2020 2052 6573 5061 636b 6574 5369 7a65     ResPacketSize
+00008e40: 203d 2056 6563 746f 7269 7a61 626c 6520   = Vectorizable 
+00008e50: 3f20 756e 7061 636b 6574 5f74 7261 6974  ? unpacket_trait
+00008e60: 733c 5f52 6573 5061 636b 6574 3e3a 3a73  s<_ResPacket>::s
+00008e70: 697a 6520 3a20 312c 0a20 2020 200a 2020  ize : 1,.    .  
+00008e80: 2020 4e75 6d62 6572 4f66 5265 6769 7374    NumberOfRegist
+00008e90: 6572 7320 3d20 4549 4745 4e5f 4152 4348  ers = EIGEN_ARCH
+00008ea0: 5f44 4546 4155 4c54 5f4e 554d 4245 525f  _DEFAULT_NUMBER_
+00008eb0: 4f46 5f52 4547 4953 5445 5253 2c0a 2020  OF_REGISTERS,.  
+00008ec0: 2020 2f2f 2046 4958 4d45 3a20 7368 6f75    // FIXME: shou
+00008ed0: 6c64 2064 6570 656e 6420 6f6e 204e 756d  ld depend on Num
+00008ee0: 6265 724f 6652 6567 6973 7465 7273 0a20  berOfRegisters. 
+00008ef0: 2020 206e 7220 3d20 342c 0a20 2020 206d     nr = 4,.    m
+00008f00: 7220 3d20 2845 4947 454e 5f50 4c41 494e  r = (EIGEN_PLAIN
+00008f10: 5f45 4e55 4d5f 4d49 4e28 3136 2c4e 756d  _ENUM_MIN(16,Num
+00008f20: 6265 724f 6652 6567 6973 7465 7273 292f  berOfRegisters)/
+00008f30: 322f 6e72 292a 5265 7350 6163 6b65 7453  2/nr)*ResPacketS
+00008f40: 697a 652c 0a0a 2020 2020 4c68 7350 726f  ize,..    LhsPro
+00008f50: 6772 6573 7320 3d20 5265 7350 6163 6b65  gress = ResPacke
+00008f60: 7453 697a 652c 0a20 2020 2052 6873 5072  tSize,.    RhsPr
+00008f70: 6f67 7265 7373 203d 2031 0a20 207d 3b0a  ogress = 1.  };.
+00008f80: 0a20 2074 7970 6564 6566 2074 7970 656e  .  typedef typen
+00008f90: 616d 6520 636f 6e64 6974 696f 6e61 6c3c  ame conditional<
+00008fa0: 5665 6374 6f72 697a 6162 6c65 2c5f 4c68  Vectorizable,_Lh
+00008fb0: 7350 6163 6b65 742c 4c68 7353 6361 6c61  sPacket,LhsScala
+00008fc0: 723e 3a3a 7479 7065 204c 6873 5061 636b  r>::type LhsPack
+00008fd0: 6574 3b0a 2020 7479 7065 6465 6620 7479  et;.  typedef ty
+00008fe0: 7065 6e61 6d65 2063 6f6e 6469 7469 6f6e  pename condition
+00008ff0: 616c 3c56 6563 746f 7269 7a61 626c 652c  al<Vectorizable,
+00009000: 5f52 6873 5061 636b 6574 2c52 6873 5363  _RhsPacket,RhsSc
+00009010: 616c 6172 3e3a 3a74 7970 6520 5268 7350  alar>::type RhsP
+00009020: 6163 6b65 743b 0a20 2074 7970 6564 6566  acket;.  typedef
+00009030: 2074 7970 656e 616d 6520 636f 6e64 6974   typename condit
+00009040: 696f 6e61 6c3c 5665 6374 6f72 697a 6162  ional<Vectorizab
+00009050: 6c65 2c5f 5265 7350 6163 6b65 742c 5265  le,_ResPacket,Re
+00009060: 7353 6361 6c61 723e 3a3a 7479 7065 2052  sScalar>::type R
+00009070: 6573 5061 636b 6574 3b0a 2020 7479 7065  esPacket;.  type
+00009080: 6465 6620 4c68 7350 6163 6b65 7420 4c68  def LhsPacket Lh
+00009090: 7350 6163 6b65 7434 5061 636b 696e 673b  sPacket4Packing;
+000090a0: 0a20 2074 7970 6564 6566 2051 7561 6450  .  typedef QuadP
+000090b0: 6163 6b65 743c 5268 7350 6163 6b65 743e  acket<RhsPacket>
+000090c0: 2052 6873 5061 636b 6574 7834 3b0a 2020   RhsPacketx4;.  
+000090d0: 7479 7065 6465 6620 5265 7350 6163 6b65  typedef ResPacke
+000090e0: 7420 4163 6350 6163 6b65 743b 0a0a 2020  t AccPacket;..  
+000090f0: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+00009100: 494e 4520 766f 6964 2069 6e69 7441 6363  INE void initAcc
+00009110: 2841 6363 5061 636b 6574 2620 7029 0a20  (AccPacket& p). 
+00009120: 207b 0a20 2020 2070 203d 2070 7365 7431   {.    p = pset1
+00009130: 3c52 6573 5061 636b 6574 3e28 5265 7353  <ResPacket>(ResS
+00009140: 6361 6c61 7228 3029 293b 0a20 207d 0a0a  calar(0));.  }..
+00009150: 2020 7465 6d70 6c61 7465 3c74 7970 656e    template<typen
+00009160: 616d 6520 5268 7350 6163 6b65 7454 7970  ame RhsPacketTyp
+00009170: 653e 0a20 2045 4947 454e 5f53 5452 4f4e  e>.  EIGEN_STRON
+00009180: 475f 494e 4c49 4e45 2076 6f69 6420 6c6f  G_INLINE void lo
+00009190: 6164 5268 7328 636f 6e73 7420 5268 7353  adRhs(const RhsS
+000091a0: 6361 6c61 722a 2062 2c20 5268 7350 6163  calar* b, RhsPac
+000091b0: 6b65 7454 7970 6526 2064 6573 7429 2063  ketType& dest) c
+000091c0: 6f6e 7374 0a20 207b 0a20 2020 2064 6573  onst.  {.    des
+000091d0: 7420 3d20 7073 6574 313c 5268 7350 6163  t = pset1<RhsPac
+000091e0: 6b65 7454 7970 653e 282a 6229 3b0a 2020  ketType>(*b);.  
+000091f0: 7d0a 0a20 2045 4947 454e 5f53 5452 4f4e  }..  EIGEN_STRON
+00009200: 475f 494e 4c49 4e45 2076 6f69 6420 6c6f  G_INLINE void lo
+00009210: 6164 5268 7328 636f 6e73 7420 5268 7353  adRhs(const RhsS
+00009220: 6361 6c61 722a 2062 2c20 5268 7350 6163  calar* b, RhsPac
+00009230: 6b65 7478 3426 2064 6573 7429 2063 6f6e  ketx4& dest) con
+00009240: 7374 0a20 207b 0a20 2020 2070 6272 6f61  st.  {.    pbroa
+00009250: 6463 6173 7434 2862 2c20 6465 7374 2e42  dcast4(b, dest.B
+00009260: 5f30 2c20 6465 7374 2e42 312c 2064 6573  _0, dest.B1, des
+00009270: 742e 4232 2c20 6465 7374 2e42 3329 3b0a  t.B2, dest.B3);.
+00009280: 2020 7d0a 0a20 2074 656d 706c 6174 653c    }..  template<
+00009290: 7479 7065 6e61 6d65 2052 6873 5061 636b  typename RhsPack
+000092a0: 6574 5479 7065 3e0a 2020 4549 4745 4e5f  etType>.  EIGEN_
+000092b0: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
+000092c0: 6964 2075 7064 6174 6552 6873 2863 6f6e  id updateRhs(con
+000092d0: 7374 2052 6873 5363 616c 6172 2a20 622c  st RhsScalar* b,
+000092e0: 2052 6873 5061 636b 6574 5479 7065 2620   RhsPacketType& 
+000092f0: 6465 7374 2920 636f 6e73 740a 2020 7b0a  dest) const.  {.
+00009300: 2020 2020 6c6f 6164 5268 7328 622c 2064      loadRhs(b, d
+00009310: 6573 7429 3b0a 2020 7d0a 0a20 2045 4947  est);.  }..  EIG
+00009320: 454e 5f53 5452 4f4e 475f 494e 4c49 4e45  EN_STRONG_INLINE
+00009330: 2076 6f69 6420 7570 6461 7465 5268 7328   void updateRhs(
+00009340: 636f 6e73 7420 5268 7353 6361 6c61 722a  const RhsScalar*
+00009350: 2c20 5268 7350 6163 6b65 7478 3426 2920  , RhsPacketx4&) 
+00009360: 636f 6e73 740a 2020 7b7d 0a0a 2020 4549  const.  {}..  EI
+00009370: 4745 4e5f 5354 524f 4e47 5f49 4e4c 494e  GEN_STRONG_INLIN
+00009380: 4520 766f 6964 206c 6f61 644c 6873 2863  E void loadLhs(c
+00009390: 6f6e 7374 204c 6873 5363 616c 6172 2a20  onst LhsScalar* 
+000093a0: 612c 204c 6873 5061 636b 6574 2620 6465  a, LhsPacket& de
+000093b0: 7374 2920 636f 6e73 740a 2020 7b0a 2020  st) const.  {.  
+000093c0: 2020 6465 7374 203d 2070 6c6f 6164 6475    dest = ploaddu
+000093d0: 703c 4c68 7350 6163 6b65 743e 2861 293b  p<LhsPacket>(a);
+000093e0: 0a20 207d 0a20 200a 2020 4549 4745 4e5f  .  }.  .  EIGEN_
+000093f0: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
+00009400: 6964 206c 6f61 6452 6873 5175 6164 2863  id loadRhsQuad(c
+00009410: 6f6e 7374 2052 6873 5363 616c 6172 2a20  onst RhsScalar* 
+00009420: 622c 2052 6873 5061 636b 6574 2620 6465  b, RhsPacket& de
+00009430: 7374 2920 636f 6e73 740a 2020 7b0a 2020  st) const.  {.  
+00009440: 2020 6465 7374 203d 2070 6c6f 6164 7175    dest = ploadqu
+00009450: 6164 3c52 6873 5061 636b 6574 3e28 6229  ad<RhsPacket>(b)
+00009460: 3b0a 2020 7d0a 0a20 2074 656d 706c 6174  ;.  }..  templat
+00009470: 653c 7479 7065 6e61 6d65 204c 6873 5061  e<typename LhsPa
+00009480: 636b 6574 5479 7065 3e0a 2020 4549 4745  cketType>.  EIGE
+00009490: 4e5f 5354 524f 4e47 5f49 4e4c 494e 4520  N_STRONG_INLINE 
+000094a0: 766f 6964 206c 6f61 644c 6873 556e 616c  void loadLhsUnal
+000094b0: 6967 6e65 6428 636f 6e73 7420 4c68 7353  igned(const LhsS
+000094c0: 6361 6c61 722a 2061 2c20 4c68 7350 6163  calar* a, LhsPac
+000094d0: 6b65 7454 7970 6526 2064 6573 7429 2063  ketType& dest) c
+000094e0: 6f6e 7374 0a20 207b 0a20 2020 2064 6573  onst.  {.    des
+000094f0: 7420 3d20 706c 6f61 6464 7570 3c4c 6873  t = ploaddup<Lhs
+00009500: 5061 636b 6574 5479 7065 3e28 6129 3b0a  PacketType>(a);.
+00009510: 2020 7d0a 0a20 2074 656d 706c 6174 6520    }..  template 
+00009520: 3c74 7970 656e 616d 6520 4c68 7350 6163  <typename LhsPac
+00009530: 6b65 7454 7970 652c 2074 7970 656e 616d  ketType, typenam
+00009540: 6520 5268 7350 6163 6b65 7454 7970 652c  e RhsPacketType,
+00009550: 2074 7970 656e 616d 6520 4163 6350 6163   typename AccPac
+00009560: 6b65 7454 7970 652c 2074 7970 656e 616d  ketType, typenam
+00009570: 6520 4c61 6e65 4964 5479 7065 3e0a 2020  e LaneIdType>.  
+00009580: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+00009590: 494e 4520 766f 6964 206d 6164 6428 636f  INE void madd(co
+000095a0: 6e73 7420 4c68 7350 6163 6b65 7454 7970  nst LhsPacketTyp
+000095b0: 6526 2061 2c20 636f 6e73 7420 5268 7350  e& a, const RhsP
+000095c0: 6163 6b65 7454 7970 6526 2062 2c20 4163  acketType& b, Ac
+000095d0: 6350 6163 6b65 7454 7970 6526 2063 2c20  cPacketType& c, 
+000095e0: 5268 7350 6163 6b65 7454 7970 6526 2074  RhsPacketType& t
+000095f0: 6d70 2c20 636f 6e73 7420 4c61 6e65 4964  mp, const LaneId
+00009600: 5479 7065 2629 2063 6f6e 7374 0a20 207b  Type&) const.  {
+00009610: 0a20 2020 206d 6164 645f 696d 706c 2861  .    madd_impl(a
+00009620: 2c20 622c 2063 2c20 746d 702c 2074 7970  , b, c, tmp, typ
+00009630: 656e 616d 6520 636f 6e64 6974 696f 6e61  ename conditiona
+00009640: 6c3c 5665 6374 6f72 697a 6162 6c65 2c74  l<Vectorizable,t
+00009650: 7275 655f 7479 7065 2c66 616c 7365 5f74  rue_type,false_t
+00009660: 7970 653e 3a3a 7479 7065 2829 293b 0a20  ype>::type());. 
+00009670: 207d 0a0a 2020 7465 6d70 6c61 7465 203c   }..  template <
+00009680: 7479 7065 6e61 6d65 204c 6873 5061 636b  typename LhsPack
+00009690: 6574 5479 7065 2c20 7479 7065 6e61 6d65  etType, typename
+000096a0: 2052 6873 5061 636b 6574 5479 7065 2c20   RhsPacketType, 
+000096b0: 7479 7065 6e61 6d65 2041 6363 5061 636b  typename AccPack
+000096c0: 6574 5479 7065 3e0a 2020 4549 4745 4e5f  etType>.  EIGEN_
+000096d0: 5354 524f 4e47 5f49 4e4c 494e 4520 766f  STRONG_INLINE vo
+000096e0: 6964 206d 6164 645f 696d 706c 2863 6f6e  id madd_impl(con
+000096f0: 7374 204c 6873 5061 636b 6574 5479 7065  st LhsPacketType
+00009700: 2620 612c 2063 6f6e 7374 2052 6873 5061  & a, const RhsPa
+00009710: 636b 6574 5479 7065 2620 622c 2041 6363  cketType& b, Acc
+00009720: 5061 636b 6574 5479 7065 2620 632c 2052  PacketType& c, R
+00009730: 6873 5061 636b 6574 5479 7065 2620 746d  hsPacketType& tm
+00009740: 702c 2063 6f6e 7374 2074 7275 655f 7479  p, const true_ty
+00009750: 7065 2629 2063 6f6e 7374 0a20 207b 0a23  pe&) const.  {.#
+00009760: 6966 6465 6620 4549 4745 4e5f 4841 535f  ifdef EIGEN_HAS_
+00009770: 5349 4e47 4c45 5f49 4e53 5452 5543 5449  SINGLE_INSTRUCTI
+00009780: 4f4e 5f4d 4144 440a 2020 2020 4549 4745  ON_MADD.    EIGE
+00009790: 4e5f 554e 5553 4544 5f56 4152 4941 424c  N_UNUSED_VARIABL
+000097a0: 4528 746d 7029 3b0a 2020 2020 632e 7620  E(tmp);.    c.v 
+000097b0: 3d20 706d 6164 6428 612c 622e 762c 632e  = pmadd(a,b.v,c.
+000097c0: 7629 3b0a 2365 6c73 650a 2020 2020 746d  v);.#else.    tm
+000097d0: 7020 3d20 623b 2074 6d70 2e76 203d 2070  p = b; tmp.v = p
+000097e0: 6d75 6c28 612c 746d 702e 7629 3b20 6320  mul(a,tmp.v); c 
+000097f0: 3d20 7061 6464 2863 2c74 6d70 293b 0a23  = padd(c,tmp);.#
+00009800: 656e 6469 660a 2020 2020 0a20 207d 0a0a  endif.    .  }..
+00009810: 2020 4549 4745 4e5f 5354 524f 4e47 5f49    EIGEN_STRONG_I
+00009820: 4e4c 494e 4520 766f 6964 206d 6164 645f  NLINE void madd_
+00009830: 696d 706c 2863 6f6e 7374 204c 6873 5363  impl(const LhsSc
+00009840: 616c 6172 2620 612c 2063 6f6e 7374 2052  alar& a, const R
+00009850: 6873 5363 616c 6172 2620 622c 2052 6573  hsScalar& b, Res
+00009860: 5363 616c 6172 2620 632c 2052 6873 5363  Scalar& c, RhsSc
+00009870: 616c 6172 2620 2f2a 746d 702a 2f2c 2063  alar& /*tmp*/, c
+00009880: 6f6e 7374 2066 616c 7365 5f74 7970 6526  onst false_type&
+00009890: 2920 636f 6e73 740a 2020 7b0a 2020 2020  ) const.  {.    
+000098a0: 6320 2b3d 2061 202a 2062 3b0a 2020 7d0a  c += a * b;.  }.
+000098b0: 0a20 2074 656d 706c 6174 653c 7479 7065  .  template<type
+000098c0: 6e61 6d65 204c 6873 5061 636b 6574 5479  name LhsPacketTy
+000098d0: 7065 2c20 7479 7065 6e61 6d65 2041 6363  pe, typename Acc
+000098e0: 5061 636b 6574 5479 7065 2c20 7479 7065  PacketType, type
+000098f0: 6e61 6d65 204c 616e 6549 6454 7970 653e  name LaneIdType>
+00009900: 0a20 2045 4947 454e 5f53 5452 4f4e 475f  .  EIGEN_STRONG_
+00009910: 494e 4c49 4e45 2076 6f69 6420 6d61 6464  INLINE void madd
+00009920: 2863 6f6e 7374 204c 6873 5061 636b 6574  (const LhsPacket
+00009930: 5479 7065 2620 612c 2063 6f6e 7374 2052  Type& a, const R
+00009940: 6873 5061 636b 6574 7834 2620 622c 2041  hsPacketx4& b, A
+00009950: 6363 5061 636b 6574 5479 7065 2620 632c  ccPacketType& c,
+00009960: 2052 6873 5061 636b 6574 2620 746d 702c   RhsPacket& tmp,
+00009970: 2063 6f6e 7374 204c 616e 6549 6454 7970   const LaneIdTyp
+00009980: 6526 206c 616e 6529 2063 6f6e 7374 0a20  e& lane) const. 
+00009990: 207b 0a20 2020 206d 6164 6428 612c 2062   {.    madd(a, b
+000099a0: 2e67 6574 286c 616e 6529 2c20 632c 2074  .get(lane), c, t
+000099b0: 6d70 2c20 6c61 6e65 293b 0a20 207d 0a0a  mp, lane);.  }..
+000099c0: 2020 7465 6d70 6c61 7465 203c 7479 7065    template <type
+000099d0: 6e61 6d65 2052 6573 5061 636b 6574 5479  name ResPacketTy
+000099e0: 7065 2c20 7479 7065 6e61 6d65 2041 6363  pe, typename Acc
+000099f0: 5061 636b 6574 5479 7065 3e0a 2020 4549  PacketType>.  EI
+00009a00: 4745 4e5f 5354 524f 4e47 5f49 4e4c 494e  GEN_STRONG_INLIN
+00009a10: 4520 766f 6964 2061 6363 2863 6f6e 7374  E void acc(const
+00009a20: 2041 6363 5061 636b 6574 5479 7065 2620   AccPacketType& 
+00009a30: 632c 2063 6f6e 7374 2052 6573 5061 636b  c, const ResPack
+00009a40: 6574 5479 7065 2620 616c 7068 612c 2052  etType& alpha, R
+00009a50: 6573 5061 636b 6574 5479 7065 2620 7229  esPacketType& r)
+00009a60: 2063 6f6e 7374 0a20 207b 0a20 2020 2063   const.  {.    c
+00009a70: 6f6e 6a5f 6865 6c70 6572 3c52 6573 5061  onj_helper<ResPa
+00009a80: 636b 6574 5479 7065 2c52 6573 5061 636b  cketType,ResPack
+00009a90: 6574 5479 7065 2c66 616c 7365 2c43 6f6e  etType,false,Con
+00009aa0: 6a52 6873 3e20 636a 3b0a 2020 2020 7220  jRhs> cj;.    r 
+00009ab0: 3d20 636a 2e70 6d61 6464 2861 6c70 6861  = cj.pmadd(alpha
+00009ac0: 2c63 2c72 293b 0a20 207d 0a0a 7072 6f74  ,c,r);.  }..prot
+00009ad0: 6563 7465 643a 0a0a 7d3b 0a0a 2f2a 206f  ected:..};../* o
+00009ae0: 7074 696d 697a 6564 2047 656e 6572 616c  ptimized General
+00009af0: 2070 6163 6b65 6420 426c 6f63 6b20 2a20   packed Block * 
+00009b00: 7061 636b 6564 2050 616e 656c 2070 726f  packed Panel pro
+00009b10: 6475 6374 206b 6572 6e65 6c0a 202a 0a20  duct kernel. *. 
+00009b20: 2a20 4d69 7869 6e67 2074 7970 6520 6c6f  * Mixing type lo
+00009b30: 6769 633a 2043 202b 3d20 4120 2a20 420a  gic: C += A * B.
+00009b40: 202a 2020 7c20 2041 2020 7c20 2042 2020   *  |  A  |  B  
+00009b50: 7c20 636f 6d6d 656e 7473 0a20 2a20 207c  | comments. *  |
+00009b60: 7265 616c 207c 6370 6c78 207c 206e 6f20  real |cplx | no 
+00009b70: 7665 6374 6f72 697a 6174 696f 6e20 7965  vectorization ye
+00009b80: 742c 2077 6f75 6c64 2072 6571 7569 7265  t, would require
+00009b90: 2074 6f20 7061 636b 2041 2077 6974 6820   to pack A with 
+00009ba0: 6475 706c 6963 6174 696f 6e0a 202a 2020  duplication. *  
+00009bb0: 7c63 706c 7820 7c72 6561 6c20 7c20 6561  |cplx |real | ea
+00009bc0: 7379 2076 6563 746f 7269 7a61 7469 6f6e  sy vectorization
+00009bd0: 0a20 2a2f 0a74 656d 706c 6174 653c 7479  . */.template<ty
+00009be0: 7065 6e61 6d65 204c 6873 5363 616c 6172  pename LhsScalar
+00009bf0: 2c20 7479 7065 6e61 6d65 2052 6873 5363  , typename RhsSc
+00009c00: 616c 6172 2c20 7479 7065 6e61 6d65 2049  alar, typename I
+00009c10: 6e64 6578 2c20 7479 7065 6e61 6d65 2044  ndex, typename D
+00009c20: 6174 614d 6170 7065 722c 2069 6e74 206d  ataMapper, int m
+00009c30: 722c 2069 6e74 206e 722c 2062 6f6f 6c20  r, int nr, bool 
+00009c40: 436f 6e6a 7567 6174 654c 6873 2c20 626f  ConjugateLhs, bo
+00009c50: 6f6c 2043 6f6e 6a75 6761 7465 5268 733e  ol ConjugateRhs>
+00009c60: 0a73 7472 7563 7420 6765 6270 5f6b 6572  .struct gebp_ker
+00009c70: 6e65 6c0a 7b0a 2020 7479 7065 6465 6620  nel.{.  typedef 
+00009c80: 6765 6270 5f74 7261 6974 733c 4c68 7353  gebp_traits<LhsS
+00009c90: 6361 6c61 722c 5268 7353 6361 6c61 722c  calar,RhsScalar,
+00009ca0: 436f 6e6a 7567 6174 654c 6873 2c43 6f6e  ConjugateLhs,Con
+00009cb0: 6a75 6761 7465 5268 732c 4172 6368 6974  jugateRhs,Archit
+00009cc0: 6563 7475 7265 3a3a 5461 7267 6574 3e20  ecture::Target> 
+00009cd0: 5472 6169 7473 3b0a 2020 7479 7065 6465  Traits;.  typede
+00009ce0: 6620 6765 6270 5f74 7261 6974 733c 4c68  f gebp_traits<Lh
+00009cf0: 7353 6361 6c61 722c 5268 7353 6361 6c61  sScalar,RhsScala
+00009d00: 722c 436f 6e6a 7567 6174 654c 6873 2c43  r,ConjugateLhs,C
+00009d10: 6f6e 6a75 6761 7465 5268 732c 4172 6368  onjugateRhs,Arch
+00009d20: 6974 6563 7475 7265 3a3a 5461 7267 6574  itecture::Target
+00009d30: 2c47 4542 5050 6163 6b65 7448 616c 663e  ,GEBPPacketHalf>
+00009d40: 2048 616c 6654 7261 6974 733b 0a20 2074   HalfTraits;.  t
+00009d50: 7970 6564 6566 2067 6562 705f 7472 6169  ypedef gebp_trai
+00009d60: 7473 3c4c 6873 5363 616c 6172 2c52 6873  ts<LhsScalar,Rhs
+00009d70: 5363 616c 6172 2c43 6f6e 6a75 6761 7465  Scalar,Conjugate
+00009d80: 4c68 732c 436f 6e6a 7567 6174 6552 6873  Lhs,ConjugateRhs
+00009d90: 2c41 7263 6869 7465 6374 7572 653a 3a54  ,Architecture::T
+00009da0: 6172 6765 742c 4745 4250 5061 636b 6574  arget,GEBPPacket
+00009db0: 5175 6172 7465 723e 2051 7561 7274 6572  Quarter> Quarter
+00009dc0: 5472 6169 7473 3b0a 2020 0a20 2074 7970  Traits;.  .  typ
+00009dd0: 6564 6566 2074 7970 656e 616d 6520 5472  edef typename Tr
+00009de0: 6169 7473 3a3a 5265 7353 6361 6c61 7220  aits::ResScalar 
+00009df0: 5265 7353 6361 6c61 723b 0a20 2074 7970  ResScalar;.  typ
+00009e00: 6564 6566 2074 7970 656e 616d 6520 5472  edef typename Tr
+00009e10: 6169 7473 3a3a 4c68 7350 6163 6b65 7420  aits::LhsPacket 
+00009e20: 4c68 7350 6163 6b65 743b 0a20 2074 7970  LhsPacket;.  typ
+00009e30: 6564 6566 2074 7970 656e 616d 6520 5472  edef typename Tr
+00009e40: 6169 7473 3a3a 5268 7350 6163 6b65 7420  aits::RhsPacket 
+00009e50: 5268 7350 6163 6b65 743b 0a20 2074 7970  RhsPacket;.  typ
+00009e60: 6564 6566 2074 7970 656e 616d 6520 5472  edef typename Tr
+00009e70: 6169 7473 3a3a 5265 7350 6163 6b65 7420  aits::ResPacket 
+00009e80: 5265 7350 6163 6b65 743b 0a20 2074 7970  ResPacket;.  typ
+00009e90: 6564 6566 2074 7970 656e 616d 6520 5472  edef typename Tr
+00009ea0: 6169 7473 3a3a 4163 6350 6163 6b65 7420  aits::AccPacket 
+00009eb0: 4163 6350 6163 6b65 743b 0a20 2074 7970  AccPacket;.  typ
+00009ec0: 6564 6566 2074 7970 656e 616d 6520 5472  edef typename Tr
+00009ed0: 6169 7473 3a3a 5268 7350 6163 6b65 7478  aits::RhsPacketx
+00009ee0: 3420 5268 7350 6163 6b65 7478 343b 0a0a  4 RhsPacketx4;..
+00009ef0: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
+00009f00: 6d65 2052 6873 5061 6e65 6c48 656c 7065  me RhsPanelHelpe
+00009f10: 723c 5268 7350 6163 6b65 742c 2052 6873  r<RhsPacket, Rhs
+00009f20: 5061 636b 6574 7834 2c20 3135 3e3a 3a74  Packetx4, 15>::t
+00009f30: 7970 6520 5268 7350 616e 656c 3135 3b0a  ype RhsPanel15;.
+00009f40: 0a20 2074 7970 6564 6566 2067 6562 705f  .  typedef gebp_
+00009f50: 7472 6169 7473 3c52 6873 5363 616c 6172  traits<RhsScalar
+00009f60: 2c4c 6873 5363 616c 6172 2c43 6f6e 6a75  ,LhsScalar,Conju
+00009f70: 6761 7465 5268 732c 436f 6e6a 7567 6174  gateRhs,Conjugat
+00009f80: 654c 6873 2c41 7263 6869 7465 6374 7572  eLhs,Architectur
+00009f90: 653a 3a54 6172 6765 743e 2053 7761 7070  e::Target> Swapp
+00009fa0: 6564 5472 6169 7473 3b0a 0a20 2074 7970  edTraits;..  typ
+00009fb0: 6564 6566 2074 7970 656e 616d 6520 5377  edef typename Sw
+00009fc0: 6170 7065 6454 7261 6974 733a 3a52 6573  appedTraits::Res
+00009fd0: 5363 616c 6172 2053 5265 7353 6361 6c61  Scalar SResScala
+00009fe0: 723b 0a20 2074 7970 6564 6566 2074 7970  r;.  typedef typ
+00009ff0: 656e 616d 6520 5377 6170 7065 6454 7261  ename SwappedTra
+0000a000: 6974 733a 3a4c 6873 5061 636b 6574 2053  its::LhsPacket S
+0000a010: 4c68 7350 6163 6b65 743b 0a20 2074 7970  LhsPacket;.  typ
+0000a020: 6564 6566 2074 7970 656e 616d 6520 5377  edef typename Sw
+0000a030: 6170 7065 6454 7261 6974 733a 3a52 6873  appedTraits::Rhs
+0000a040: 5061 636b 6574 2053 5268 7350 6163 6b65  Packet SRhsPacke
+0000a050: 743b 0a20 2074 7970 6564 6566 2074 7970  t;.  typedef typ
+0000a060: 656e 616d 6520 5377 6170 7065 6454 7261  ename SwappedTra
+0000a070: 6974 733a 3a52 6573 5061 636b 6574 2053  its::ResPacket S
+0000a080: 5265 7350 6163 6b65 743b 0a20 2074 7970  ResPacket;.  typ
+0000a090: 6564 6566 2074 7970 656e 616d 6520 5377  edef typename Sw
+0000a0a0: 6170 7065 6454 7261 6974 733a 3a41 6363  appedTraits::Acc
+0000a0b0: 5061 636b 6574 2053 4163 6350 6163 6b65  Packet SAccPacke
+0000a0c0: 743b 0a0a 2020 7479 7065 6465 6620 7479  t;..  typedef ty
+0000a0d0: 7065 6e61 6d65 2048 616c 6654 7261 6974  pename HalfTrait
+0000a0e0: 733a 3a4c 6873 5061 636b 6574 204c 6873  s::LhsPacket Lhs
+0000a0f0: 5061 636b 6574 4861 6c66 3b0a 2020 7479  PacketHalf;.  ty
+0000a100: 7065 6465 6620 7479 7065 6e61 6d65 2048  pedef typename H
+0000a110: 616c 6654 7261 6974 733a 3a52 6873 5061  alfTraits::RhsPa
+0000a120: 636b 6574 2052 6873 5061 636b 6574 4861  cket RhsPacketHa
+0000a130: 6c66 3b0a 2020 7479 7065 6465 6620 7479  lf;.  typedef ty
+0000a140: 7065 6e61 6d65 2048 616c 6654 7261 6974  pename HalfTrait
+0000a150: 733a 3a52 6573 5061 636b 6574 2052 6573  s::ResPacket Res
+0000a160: 5061 636b 6574 4861 6c66 3b0a 2020 7479  PacketHalf;.  ty
+0000a170: 7065 6465 6620 7479 7065 6e61 6d65 2048  pedef typename H
+0000a180: 616c 6654 7261 6974 733a 3a41 6363 5061  alfTraits::AccPa
+0000a190: 636b 6574 2041 6363 5061 636b 6574 4861  cket AccPacketHa
+0000a1a0: 6c66 3b0a 0a20 2074 7970 6564 6566 2074  lf;..  typedef t
+0000a1b0: 7970 656e 616d 6520 5175 6172 7465 7254  ypename QuarterT
+0000a1c0: 7261 6974 733a 3a4c 6873 5061 636b 6574  raits::LhsPacket
+0000a1d0: 204c 6873 5061 636b 6574 5175 6172 7465   LhsPacketQuarte
+0000a1e0: 723b 0a20 2074 7970 6564 6566 2074 7970  r;.  typedef typ
+0000a1f0: 656e 616d 6520 5175 6172 7465 7254 7261  ename QuarterTra
+0000a200: 6974 733a 3a52 6873 5061 636b 6574 2052  its::RhsPacket R
+0000a210: 6873 5061 636b 6574 5175 6172 7465 723b  hsPacketQuarter;
+0000a220: 0a20 2074 7970 6564 6566 2074 7970 656e  .  typedef typen
+0000a230: 616d 6520 5175 6172 7465 7254 7261 6974  ame QuarterTrait
+0000a240: 733a 3a52 6573 5061 636b 6574 2052 6573  s::ResPacket Res
+0000a250: 5061 636b 6574 5175 6172 7465 723b 0a20  PacketQuarter;. 
+0000a260: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
+0000a270: 6520 5175 6172 7465 7254 7261 6974 733a  e QuarterTraits:
+0000a280: 3a41 6363 5061 636b 6574 2041 6363 5061  :AccPacket AccPa
+0000a290: 636b 6574 5175 6172 7465 723b 0a0a 2020  cketQuarter;..  
+0000a2a0: 7479 7065 6465 6620 7479 7065 6e61 6d65  typedef typename
+0000a2b0: 2044 6174 614d 6170 7065 723a 3a4c 696e   DataMapper::Lin
+0000a2c0: 6561 724d 6170 7065 7220 4c69 6e65 6172  earMapper Linear
+0000a2d0: 4d61 7070 6572 3b0a 0a20 2065 6e75 6d20  Mapper;..  enum 
+0000a2e0: 7b0a 2020 2020 5665 6374 6f72 697a 6162  {.    Vectorizab
+0000a2f0: 6c65 2020 3d20 5472 6169 7473 3a3a 5665  le  = Traits::Ve
+0000a300: 6374 6f72 697a 6162 6c65 2c0a 2020 2020  ctorizable,.    
+0000a310: 4c68 7350 726f 6772 6573 7320 2020 3d20  LhsProgress   = 
+0000a320: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
+0000a330: 6573 732c 0a20 2020 204c 6873 5072 6f67  ess,.    LhsProg
+0000a340: 7265 7373 4861 6c66 2020 2020 2020 3d20  ressHalf      = 
+0000a350: 4861 6c66 5472 6169 7473 3a3a 4c68 7350  HalfTraits::LhsP
+0000a360: 726f 6772 6573 732c 0a20 2020 204c 6873  rogress,.    Lhs
+0000a370: 5072 6f67 7265 7373 5175 6172 7465 7220  ProgressQuarter 
+0000a380: 2020 3d20 5175 6172 7465 7254 7261 6974    = QuarterTrait
+0000a390: 733a 3a4c 6873 5072 6f67 7265 7373 2c0a  s::LhsProgress,.
+0000a3a0: 2020 2020 5268 7350 726f 6772 6573 7320      RhsProgress 
+0000a3b0: 2020 3d20 5472 6169 7473 3a3a 5268 7350    = Traits::RhsP
+0000a3c0: 726f 6772 6573 732c 0a20 2020 2052 6873  rogress,.    Rhs
+0000a3d0: 5072 6f67 7265 7373 4861 6c66 2020 2020  ProgressHalf    
+0000a3e0: 2020 3d20 4861 6c66 5472 6169 7473 3a3a    = HalfTraits::
+0000a3f0: 5268 7350 726f 6772 6573 732c 0a20 2020  RhsProgress,.   
+0000a400: 2052 6873 5072 6f67 7265 7373 5175 6172   RhsProgressQuar
+0000a410: 7465 7220 2020 3d20 5175 6172 7465 7254  ter   = QuarterT
+0000a420: 7261 6974 733a 3a52 6873 5072 6f67 7265  raits::RhsProgre
+0000a430: 7373 2c0a 2020 2020 5265 7350 6163 6b65  ss,.    ResPacke
+0000a440: 7453 697a 6520 3d20 5472 6169 7473 3a3a  tSize = Traits::
+0000a450: 5265 7350 6163 6b65 7453 697a 650a 2020  ResPacketSize.  
+0000a460: 7d3b 0a0a 2020 4549 4745 4e5f 444f 4e54  };..  EIGEN_DONT
+0000a470: 5f49 4e4c 494e 450a 2020 766f 6964 206f  _INLINE.  void o
+0000a480: 7065 7261 746f 7228 2928 636f 6e73 7420  perator()(const 
+0000a490: 4461 7461 4d61 7070 6572 2620 7265 732c  DataMapper& res,
+0000a4a0: 2063 6f6e 7374 204c 6873 5363 616c 6172   const LhsScalar
+0000a4b0: 2a20 626c 6f63 6b41 2c20 636f 6e73 7420  * blockA, const 
+0000a4c0: 5268 7353 6361 6c61 722a 2062 6c6f 636b  RhsScalar* block
+0000a4d0: 422c 0a20 2020 2020 2020 2020 2020 2020  B,.             
+0000a4e0: 2020 2020 2049 6e64 6578 2072 6f77 732c       Index rows,
+0000a4f0: 2049 6e64 6578 2064 6570 7468 2c20 496e   Index depth, In
+0000a500: 6465 7820 636f 6c73 2c20 5265 7353 6361  dex cols, ResSca
+0000a510: 6c61 7220 616c 7068 612c 0a20 2020 2020  lar alpha,.     
+0000a520: 2020 2020 2020 2020 2020 2020 2049 6e64               Ind
+0000a530: 6578 2073 7472 6964 6541 3d2d 312c 2049  ex strideA=-1, I
+0000a540: 6e64 6578 2073 7472 6964 6542 3d2d 312c  ndex strideB=-1,
+0000a550: 2049 6e64 6578 206f 6666 7365 7441 3d30   Index offsetA=0
+0000a560: 2c20 496e 6465 7820 6f66 6673 6574 423d  , Index offsetB=
+0000a570: 3029 3b0a 7d3b 0a0a 7465 6d70 6c61 7465  0);.};..template
+0000a580: 3c74 7970 656e 616d 6520 4c68 7353 6361  <typename LhsSca
+0000a590: 6c61 722c 2074 7970 656e 616d 6520 5268  lar, typename Rh
+0000a5a0: 7353 6361 6c61 722c 2074 7970 656e 616d  sScalar, typenam
+0000a5b0: 6520 496e 6465 782c 2074 7970 656e 616d  e Index, typenam
+0000a5c0: 6520 4461 7461 4d61 7070 6572 2c20 696e  e DataMapper, in
+0000a5d0: 7420 6d72 2c20 696e 7420 6e72 2c20 626f  t mr, int nr, bo
+0000a5e0: 6f6c 2043 6f6e 6a75 6761 7465 4c68 732c  ol ConjugateLhs,
+0000a5f0: 2062 6f6f 6c20 436f 6e6a 7567 6174 6552   bool ConjugateR
+0000a600: 6873 2c0a 696e 7420 5377 6170 7065 644c  hs,.int SwappedL
+0000a610: 6873 5072 6f67 7265 7373 203d 2067 6562  hsProgress = geb
+0000a620: 705f 7472 6169 7473 3c52 6873 5363 616c  p_traits<RhsScal
+0000a630: 6172 2c4c 6873 5363 616c 6172 2c43 6f6e  ar,LhsScalar,Con
+0000a640: 6a75 6761 7465 5268 732c 436f 6e6a 7567  jugateRhs,Conjug
+0000a650: 6174 654c 6873 2c41 7263 6869 7465 6374  ateLhs,Architect
+0000a660: 7572 653a 3a54 6172 6765 743e 3a3a 4c68  ure::Target>::Lh
+0000a670: 7350 726f 6772 6573 733e 0a73 7472 7563  sProgress>.struc
+0000a680: 7420 6c61 7374 5f72 6f77 5f70 726f 6365  t last_row_proce
+0000a690: 7373 5f31 365f 7061 636b 6574 730a 7b0a  ss_16_packets.{.
+0000a6a0: 2020 7479 7065 6465 6620 6765 6270 5f74    typedef gebp_t
+0000a6b0: 7261 6974 733c 4c68 7353 6361 6c61 722c  raits<LhsScalar,
+0000a6c0: 5268 7353 6361 6c61 722c 436f 6e6a 7567  RhsScalar,Conjug
+0000a6d0: 6174 654c 6873 2c43 6f6e 6a75 6761 7465  ateLhs,Conjugate
+0000a6e0: 5268 732c 4172 6368 6974 6563 7475 7265  Rhs,Architecture
+0000a6f0: 3a3a 5461 7267 6574 3e20 5472 6169 7473  ::Target> Traits
+0000a700: 3b0a 2020 7479 7065 6465 6620 6765 6270  ;.  typedef gebp
+0000a710: 5f74 7261 6974 733c 5268 7353 6361 6c61  _traits<RhsScala
+0000a720: 722c 4c68 7353 6361 6c61 722c 436f 6e6a  r,LhsScalar,Conj
+0000a730: 7567 6174 6552 6873 2c43 6f6e 6a75 6761  ugateRhs,Conjuga
+0000a740: 7465 4c68 732c 4172 6368 6974 6563 7475  teLhs,Architectu
+0000a750: 7265 3a3a 5461 7267 6574 3e20 5377 6170  re::Target> Swap
+0000a760: 7065 6454 7261 6974 733b 0a0a 2020 7479  pedTraits;..  ty
+0000a770: 7065 6465 6620 7479 7065 6e61 6d65 2054  pedef typename T
+0000a780: 7261 6974 733a 3a52 6573 5363 616c 6172  raits::ResScalar
+0000a790: 2052 6573 5363 616c 6172 3b0a 2020 7479   ResScalar;.  ty
+0000a7a0: 7065 6465 6620 7479 7065 6e61 6d65 2053  pedef typename S
+0000a7b0: 7761 7070 6564 5472 6169 7473 3a3a 4c68  wappedTraits::Lh
+0000a7c0: 7350 6163 6b65 7420 534c 6873 5061 636b  sPacket SLhsPack
+0000a7d0: 6574 3b0a 2020 7479 7065 6465 6620 7479  et;.  typedef ty
+0000a7e0: 7065 6e61 6d65 2053 7761 7070 6564 5472  pename SwappedTr
+0000a7f0: 6169 7473 3a3a 5268 7350 6163 6b65 7420  aits::RhsPacket 
+0000a800: 5352 6873 5061 636b 6574 3b0a 2020 7479  SRhsPacket;.  ty
+0000a810: 7065 6465 6620 7479 7065 6e61 6d65 2053  pedef typename S
+0000a820: 7761 7070 6564 5472 6169 7473 3a3a 5265  wappedTraits::Re
+0000a830: 7350 6163 6b65 7420 5352 6573 5061 636b  sPacket SResPack
+0000a840: 6574 3b0a 2020 7479 7065 6465 6620 7479  et;.  typedef ty
+0000a850: 7065 6e61 6d65 2053 7761 7070 6564 5472  pename SwappedTr
+0000a860: 6169 7473 3a3a 4163 6350 6163 6b65 7420  aits::AccPacket 
+0000a870: 5341 6363 5061 636b 6574 3b0a 0a20 2045  SAccPacket;..  E
+0000a880: 4947 454e 5f53 5452 4f4e 475f 494e 4c49  IGEN_STRONG_INLI
+0000a890: 4e45 2076 6f69 6420 6f70 6572 6174 6f72  NE void operator
+0000a8a0: 2829 2863 6f6e 7374 2044 6174 614d 6170  ()(const DataMap
+0000a8b0: 7065 7226 2072 6573 2c20 5377 6170 7065  per& res, Swappe
+0000a8c0: 6454 7261 6974 7320 2673 7472 6169 7473  dTraits &straits
+0000a8d0: 2c20 636f 6e73 7420 4c68 7353 6361 6c61  , const LhsScala
+0000a8e0: 722a 2062 6c41 2c0a 2020 2020 2020 2020  r* blA,.        
+0000a8f0: 2020 2020 2020 2020 2020 636f 6e73 7420            const 
+0000a900: 5268 7353 6361 6c61 722a 2062 6c42 2c20  RhsScalar* blB, 
+0000a910: 496e 6465 7820 6465 7074 682c 2063 6f6e  Index depth, con
+0000a920: 7374 2049 6e64 6578 2065 6e64 6b2c 2049  st Index endk, I
+0000a930: 6e64 6578 2069 2c20 496e 6465 7820 6a32  ndex i, Index j2
+0000a940: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000a950: 2020 2020 5265 7353 6361 6c61 7220 616c      ResScalar al
+0000a960: 7068 612c 2053 4163 6350 6163 6b65 7420  pha, SAccPacket 
+0000a970: 2643 3029 0a20 2020 207b 0a20 2020 2020  &C0).    {.     
+0000a980: 2045 4947 454e 5f55 4e55 5345 445f 5641   EIGEN_UNUSED_VA
+0000a990: 5249 4142 4c45 2872 6573 293b 0a20 2020  RIABLE(res);.   
+0000a9a0: 2020 2045 4947 454e 5f55 4e55 5345 445f     EIGEN_UNUSED_
+0000a9b0: 5641 5249 4142 4c45 2873 7472 6169 7473  VARIABLE(straits
+0000a9c0: 293b 0a20 2020 2020 2045 4947 454e 5f55  );.      EIGEN_U
+0000a9d0: 4e55 5345 445f 5641 5249 4142 4c45 2862  NUSED_VARIABLE(b
+0000a9e0: 6c41 293b 0a20 2020 2020 2045 4947 454e  lA);.      EIGEN
+0000a9f0: 5f55 4e55 5345 445f 5641 5249 4142 4c45  _UNUSED_VARIABLE
+0000aa00: 2862 6c42 293b 0a20 2020 2020 2045 4947  (blB);.      EIG
+0000aa10: 454e 5f55 4e55 5345 445f 5641 5249 4142  EN_UNUSED_VARIAB
+0000aa20: 4c45 2864 6570 7468 293b 0a20 2020 2020  LE(depth);.     
+0000aa30: 2045 4947 454e 5f55 4e55 5345 445f 5641   EIGEN_UNUSED_VA
+0000aa40: 5249 4142 4c45 2865 6e64 6b29 3b0a 2020  RIABLE(endk);.  
+0000aa50: 2020 2020 4549 4745 4e5f 554e 5553 4544      EIGEN_UNUSED
+0000aa60: 5f56 4152 4941 424c 4528 6929 3b0a 2020  _VARIABLE(i);.  
+0000aa70: 2020 2020 4549 4745 4e5f 554e 5553 4544      EIGEN_UNUSED
+0000aa80: 5f56 4152 4941 424c 4528 6a32 293b 0a20  _VARIABLE(j2);. 
+0000aa90: 2020 2020 2045 4947 454e 5f55 4e55 5345       EIGEN_UNUSE
+0000aaa0: 445f 5641 5249 4142 4c45 2861 6c70 6861  D_VARIABLE(alpha
+0000aab0: 293b 0a20 2020 2020 2045 4947 454e 5f55  );.      EIGEN_U
+0000aac0: 4e55 5345 445f 5641 5249 4142 4c45 2843  NUSED_VARIABLE(C
+0000aad0: 3029 3b0a 2020 2020 7d0a 7d3b 0a0a 0a74  0);.    }.};...t
+0000aae0: 656d 706c 6174 653c 7479 7065 6e61 6d65  emplate<typename
+0000aaf0: 204c 6873 5363 616c 6172 2c20 7479 7065   LhsScalar, type
+0000ab00: 6e61 6d65 2052 6873 5363 616c 6172 2c20  name RhsScalar, 
+0000ab10: 7479 7065 6e61 6d65 2049 6e64 6578 2c20  typename Index, 
+0000ab20: 7479 7065 6e61 6d65 2044 6174 614d 6170  typename DataMap
+0000ab30: 7065 722c 2069 6e74 206d 722c 2069 6e74  per, int mr, int
+0000ab40: 206e 722c 2062 6f6f 6c20 436f 6e6a 7567   nr, bool Conjug
+0000ab50: 6174 654c 6873 2c20 626f 6f6c 2043 6f6e  ateLhs, bool Con
+0000ab60: 6a75 6761 7465 5268 733e 0a73 7472 7563  jugateRhs>.struc
+0000ab70: 7420 6c61 7374 5f72 6f77 5f70 726f 6365  t last_row_proce
+0000ab80: 7373 5f31 365f 7061 636b 6574 733c 4c68  ss_16_packets<Lh
+0000ab90: 7353 6361 6c61 722c 2052 6873 5363 616c  sScalar, RhsScal
+0000aba0: 6172 2c20 496e 6465 782c 2044 6174 614d  ar, Index, DataM
+0000abb0: 6170 7065 722c 2020 6d72 2c20 206e 722c  apper,  mr,  nr,
+0000abc0: 2043 6f6e 6a75 6761 7465 4c68 732c 2020   ConjugateLhs,  
+0000abd0: 436f 6e6a 7567 6174 6552 6873 2c20 3136  ConjugateRhs, 16
+0000abe0: 3e20 7b0a 2020 7479 7065 6465 6620 6765  > {.  typedef ge
+0000abf0: 6270 5f74 7261 6974 733c 4c68 7353 6361  bp_traits<LhsSca
+0000ac00: 6c61 722c 5268 7353 6361 6c61 722c 436f  lar,RhsScalar,Co
+0000ac10: 6e6a 7567 6174 654c 6873 2c43 6f6e 6a75  njugateLhs,Conju
+0000ac20: 6761 7465 5268 732c 4172 6368 6974 6563  gateRhs,Architec
+0000ac30: 7475 7265 3a3a 5461 7267 6574 3e20 5472  ture::Target> Tr
+0000ac40: 6169 7473 3b0a 2020 7479 7065 6465 6620  aits;.  typedef 
+0000ac50: 6765 6270 5f74 7261 6974 733c 5268 7353  gebp_traits<RhsS
+0000ac60: 6361 6c61 722c 4c68 7353 6361 6c61 722c  calar,LhsScalar,
+0000ac70: 436f 6e6a 7567 6174 6552 6873 2c43 6f6e  ConjugateRhs,Con
+0000ac80: 6a75 6761 7465 4c68 732c 4172 6368 6974  jugateLhs,Archit
+0000ac90: 6563 7475 7265 3a3a 5461 7267 6574 3e20  ecture::Target> 
+0000aca0: 5377 6170 7065 6454 7261 6974 733b 0a0a  SwappedTraits;..
+0000acb0: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
+0000acc0: 6d65 2054 7261 6974 733a 3a52 6573 5363  me Traits::ResSc
+0000acd0: 616c 6172 2052 6573 5363 616c 6172 3b0a  alar ResScalar;.
+0000ace0: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
+0000acf0: 6d65 2053 7761 7070 6564 5472 6169 7473  me SwappedTraits
+0000ad00: 3a3a 4c68 7350 6163 6b65 7420 534c 6873  ::LhsPacket SLhs
+0000ad10: 5061 636b 6574 3b0a 2020 7479 7065 6465  Packet;.  typede
+0000ad20: 6620 7479 7065 6e61 6d65 2053 7761 7070  f typename Swapp
+0000ad30: 6564 5472 6169 7473 3a3a 5268 7350 6163  edTraits::RhsPac
+0000ad40: 6b65 7420 5352 6873 5061 636b 6574 3b0a  ket SRhsPacket;.
+0000ad50: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
+0000ad60: 6d65 2053 7761 7070 6564 5472 6169 7473  me SwappedTraits
+0000ad70: 3a3a 5265 7350 6163 6b65 7420 5352 6573  ::ResPacket SRes
+0000ad80: 5061 636b 6574 3b0a 2020 7479 7065 6465  Packet;.  typede
+0000ad90: 6620 7479 7065 6e61 6d65 2053 7761 7070  f typename Swapp
+0000ada0: 6564 5472 6169 7473 3a3a 4163 6350 6163  edTraits::AccPac
+0000adb0: 6b65 7420 5341 6363 5061 636b 6574 3b0a  ket SAccPacket;.
+0000adc0: 0a20 2045 4947 454e 5f53 5452 4f4e 475f  .  EIGEN_STRONG_
+0000add0: 494e 4c49 4e45 2076 6f69 6420 6f70 6572  INLINE void oper
+0000ade0: 6174 6f72 2829 2863 6f6e 7374 2044 6174  ator()(const Dat
+0000adf0: 614d 6170 7065 7226 2072 6573 2c20 5377  aMapper& res, Sw
+0000ae00: 6170 7065 6454 7261 6974 7320 2673 7472  appedTraits &str
+0000ae10: 6169 7473 2c20 636f 6e73 7420 4c68 7353  aits, const LhsS
+0000ae20: 6361 6c61 722a 2062 6c41 2c0a 2020 2020  calar* blA,.    
+0000ae30: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0000ae40: 6e73 7420 5268 7353 6361 6c61 722a 2062  nst RhsScalar* b
+0000ae50: 6c42 2c20 496e 6465 7820 6465 7074 682c  lB, Index depth,
+0000ae60: 2063 6f6e 7374 2049 6e64 6578 2065 6e64   const Index end
+0000ae70: 6b2c 2049 6e64 6578 2069 2c20 496e 6465  k, Index i, Inde
+0000ae80: 7820 6a32 2c0a 2020 2020 2020 2020 2020  x j2,.          
+0000ae90: 2020 2020 2020 2020 5265 7353 6361 6c61          ResScala
+0000aea0: 7220 616c 7068 612c 2053 4163 6350 6163  r alpha, SAccPac
+0000aeb0: 6b65 7420 2643 3029 0a20 207b 0a20 2020  ket &C0).  {.   
+0000aec0: 2074 7970 6564 6566 2074 7970 656e 616d   typedef typenam
+0000aed0: 6520 756e 7061 636b 6574 5f74 7261 6974  e unpacket_trait
+0000aee0: 733c 7479 7065 6e61 6d65 2075 6e70 6163  s<typename unpac
+0000aef0: 6b65 745f 7472 6169 7473 3c53 5265 7350  ket_traits<SResP
+0000af00: 6163 6b65 743e 3a3a 6861 6c66 3e3a 3a68  acket>::half>::h
+0000af10: 616c 6620 5352 6573 5061 636b 6574 5175  alf SResPacketQu
+0000af20: 6172 7465 723b 0a20 2020 2074 7970 6564  arter;.    typed
+0000af30: 6566 2074 7970 656e 616d 6520 756e 7061  ef typename unpa
+0000af40: 636b 6574 5f74 7261 6974 733c 7479 7065  cket_traits<type
+0000af50: 6e61 6d65 2075 6e70 6163 6b65 745f 7472  name unpacket_tr
+0000af60: 6169 7473 3c53 4c68 7350 6163 6b65 743e  aits<SLhsPacket>
+0000af70: 3a3a 6861 6c66 3e3a 3a68 616c 6620 534c  ::half>::half SL
+0000af80: 6873 5061 636b 6574 5175 6172 7465 723b  hsPacketQuarter;
+0000af90: 0a20 2020 2074 7970 6564 6566 2074 7970  .    typedef typ
+0000afa0: 656e 616d 6520 756e 7061 636b 6574 5f74  ename unpacket_t
+0000afb0: 7261 6974 733c 7479 7065 6e61 6d65 2075  raits<typename u
+0000afc0: 6e70 6163 6b65 745f 7472 6169 7473 3c53  npacket_traits<S
+0000afd0: 5268 7350 6163 6b65 743e 3a3a 6861 6c66  RhsPacket>::half
+0000afe0: 3e3a 3a68 616c 6620 5352 6873 5061 636b  >::half SRhsPack
+0000aff0: 6574 5175 6172 7465 723b 0a20 2020 2074  etQuarter;.    t
+0000b000: 7970 6564 6566 2074 7970 656e 616d 6520  ypedef typename 
+0000b010: 756e 7061 636b 6574 5f74 7261 6974 733c  unpacket_traits<
+0000b020: 7479 7065 6e61 6d65 2075 6e70 6163 6b65  typename unpacke
+0000b030: 745f 7472 6169 7473 3c53 4163 6350 6163  t_traits<SAccPac
+0000b040: 6b65 743e 3a3a 6861 6c66 3e3a 3a68 616c  ket>::half>::hal
+0000b050: 6620 5341 6363 5061 636b 6574 5175 6172  f SAccPacketQuar
+0000b060: 7465 723b 0a0a 2020 2020 5352 6573 5061  ter;..    SResPa
+0000b070: 636b 6574 5175 6172 7465 7220 5220 3d20  cketQuarter R = 
+0000b080: 7265 732e 7465 6d70 6c61 7465 2067 6174  res.template gat
+0000b090: 6865 7250 6163 6b65 743c 5352 6573 5061  herPacket<SResPa
+0000b0a0: 636b 6574 5175 6172 7465 723e 2869 2c20  cketQuarter>(i, 
+0000b0b0: 6a32 293b 0a20 2020 2053 5265 7350 6163  j2);.    SResPac
+0000b0c0: 6b65 7451 7561 7274 6572 2061 6c70 6861  ketQuarter alpha
+0000b0d0: 7620 3d20 7073 6574 313c 5352 6573 5061  v = pset1<SResPa
+0000b0e0: 636b 6574 5175 6172 7465 723e 2861 6c70  cketQuarter>(alp
+0000b0f0: 6861 293b 0a0a 2020 2020 6966 2028 6465  ha);..    if (de
+0000b100: 7074 6820 2d20 656e 646b 203e 2030 290a  pth - endk > 0).
+0000b110: 2020 2020 2020 7b0a 092f 2f20 5765 2068        {..// We h
+0000b120: 6176 6520 746f 2068 616e 646c 6520 7468  ave to handle th
+0000b130: 6520 6c61 7374 2072 6f77 2873 2920 6f66  e last row(s) of
+0000b140: 2074 6865 2072 6873 2c20 7768 6963 680a   the rhs, which.
+0000b150: 092f 2f20 636f 7272 6573 706f 6e64 2074  .// correspond t
+0000b160: 6f20 6120 6861 6c66 2d70 6163 6b65 740a  o a half-packet.
+0000b170: 0953 4163 6350 6163 6b65 7451 7561 7274  .SAccPacketQuart
+0000b180: 6572 2063 3020 3d20 7072 6564 7578 5f68  er c0 = predux_h
+0000b190: 616c 665f 646f 7774 6f34 2870 7265 6475  alf_dowto4(predu
+0000b1a0: 785f 6861 6c66 5f64 6f77 746f 3428 4330  x_half_dowto4(C0
+0000b1b0: 2929 3b0a 0a09 666f 7220 2849 6e64 6578  ));...for (Index
+0000b1c0: 206b 6b20 3d20 656e 646b 3b20 6b6b 203c   kk = endk; kk <
+0000b1d0: 2064 6570 7468 3b20 6b6b 2b2b 290a 0920   depth; kk++).. 
+0000b1e0: 207b 0a09 2020 2020 534c 6873 5061 636b   {..    SLhsPack
+0000b1f0: 6574 5175 6172 7465 7220 6130 3b0a 0920  etQuarter a0;.. 
+0000b200: 2020 2053 5268 7350 6163 6b65 7451 7561     SRhsPacketQua
+0000b210: 7274 6572 2062 303b 0a09 2020 2020 7374  rter b0;..    st
+0000b220: 7261 6974 732e 6c6f 6164 4c68 7355 6e61  raits.loadLhsUna
+0000b230: 6c69 676e 6564 2862 6c42 2c20 6130 293b  ligned(blB, a0);
+0000b240: 0a09 2020 2020 7374 7261 6974 732e 6c6f  ..    straits.lo
+0000b250: 6164 5268 7328 626c 412c 2062 3029 3b0a  adRhs(blA, b0);.
+0000b260: 0920 2020 2073 7472 6169 7473 2e6d 6164  .    straits.mad
+0000b270: 6428 6130 2c62 302c 6330 2c62 302c 2066  d(a0,b0,c0,b0, f
+0000b280: 6978 3c30 3e29 3b0a 0920 2020 2062 6c42  ix<0>);..    blB
+0000b290: 202b 3d20 5377 6170 7065 6454 7261 6974   += SwappedTrait
+0000b2a0: 733a 3a4c 6873 5072 6f67 7265 7373 2f34  s::LhsProgress/4
+0000b2b0: 3b0a 0920 2020 2062 6c41 202b 3d20 313b  ;..    blA += 1;
+0000b2c0: 0a09 2020 7d0a 0973 7472 6169 7473 2e61  ..  }..straits.a
+0000b2d0: 6363 2863 302c 2061 6c70 6861 762c 2052  cc(c0, alphav, R
+0000b2e0: 293b 0a20 2020 2020 207d 0a20 2020 2065  );.      }.    e
+0000b2f0: 6c73 650a 2020 2020 2020 7b0a 0973 7472  lse.      {..str
+0000b300: 6169 7473 2e61 6363 2870 7265 6475 785f  aits.acc(predux_
+0000b310: 6861 6c66 5f64 6f77 746f 3428 7072 6564  half_dowto4(pred
+0000b320: 7578 5f68 616c 665f 646f 7774 6f34 2843  ux_half_dowto4(C
+0000b330: 3029 292c 2061 6c70 6861 762c 2052 293b  0)), alphav, R);
+0000b340: 0a20 2020 2020 207d 0a20 2020 2072 6573  .      }.    res
+0000b350: 2e73 6361 7474 6572 5061 636b 6574 2869  .scatterPacket(i
+0000b360: 2c20 6a32 2c20 5229 3b0a 2020 7d0a 7d3b  , j2, R);.  }.};
+0000b370: 0a0a 7465 6d70 6c61 7465 3c69 6e74 206e  ..template<int n
+0000b380: 722c 2049 6e64 6578 204c 6873 5072 6f67  r, Index LhsProg
+0000b390: 7265 7373 2c20 496e 6465 7820 5268 7350  ress, Index RhsP
+0000b3a0: 726f 6772 6573 732c 2074 7970 656e 616d  rogress, typenam
+0000b3b0: 6520 4c68 7353 6361 6c61 722c 2074 7970  e LhsScalar, typ
+0000b3c0: 656e 616d 6520 5268 7353 6361 6c61 722c  ename RhsScalar,
+0000b3d0: 2074 7970 656e 616d 6520 5265 7353 6361   typename ResSca
+0000b3e0: 6c61 722c 2074 7970 656e 616d 6520 4163  lar, typename Ac
+0000b3f0: 6350 6163 6b65 742c 2074 7970 656e 616d  cPacket, typenam
+0000b400: 6520 4c68 7350 6163 6b65 742c 2074 7970  e LhsPacket, typ
+0000b410: 656e 616d 6520 5268 7350 6163 6b65 742c  ename RhsPacket,
+0000b420: 2074 7970 656e 616d 6520 5265 7350 6163   typename ResPac
+0000b430: 6b65 742c 2074 7970 656e 616d 6520 4745  ket, typename GE
+0000b440: 4250 5472 6169 7473 2c20 7479 7065 6e61  BPTraits, typena
+0000b450: 6d65 204c 696e 6561 724d 6170 7065 722c  me LinearMapper,
+0000b460: 2074 7970 656e 616d 6520 4461 7461 4d61   typename DataMa
+0000b470: 7070 6572 3e0a 7374 7275 6374 206c 6873  pper>.struct lhs
+0000b480: 5f70 726f 6365 7373 5f6f 6e65 5f70 6163  _process_one_pac
+0000b490: 6b65 740a 7b0a 2020 7479 7065 6465 6620  ket.{.  typedef 
+0000b4a0: 7479 7065 6e61 6d65 2047 4542 5054 7261  typename GEBPTra
+0000b4b0: 6974 733a 3a52 6873 5061 636b 6574 7834  its::RhsPacketx4
+0000b4c0: 2052 6873 5061 636b 6574 7834 3b0a 0a20   RhsPacketx4;.. 
+0000b4d0: 2045 4947 454e 5f53 5452 4f4e 475f 494e   EIGEN_STRONG_IN
+0000b4e0: 4c49 4e45 2076 6f69 6420 7065 656c 6564  LINE void peeled
+0000b4f0: 5f6b 635f 6f6e 6573 7465 7028 496e 6465  _kc_onestep(Inde
+0000b500: 7820 4b2c 2063 6f6e 7374 204c 6873 5363  x K, const LhsSc
+0000b510: 616c 6172 2a20 626c 412c 2063 6f6e 7374  alar* blA, const
+0000b520: 2052 6873 5363 616c 6172 2a20 626c 422c   RhsScalar* blB,
+0000b530: 2047 4542 5054 7261 6974 7320 7472 6169   GEBPTraits trai
+0000b540: 7473 2c20 4c68 7350 6163 6b65 7420 2a41  ts, LhsPacket *A
+0000b550: 302c 2052 6873 5061 636b 6574 7834 202a  0, RhsPacketx4 *
+0000b560: 7268 735f 7061 6e65 6c2c 2052 6873 5061  rhs_panel, RhsPa
+0000b570: 636b 6574 202a 5430 2c20 4163 6350 6163  cket *T0, AccPac
+0000b580: 6b65 7420 2a43 302c 2041 6363 5061 636b  ket *C0, AccPack
+0000b590: 6574 202a 4331 2c20 4163 6350 6163 6b65  et *C1, AccPacke
+0000b5a0: 7420 2a43 322c 2041 6363 5061 636b 6574  t *C2, AccPacket
+0000b5b0: 202a 4333 290a 2020 7b0a 2020 2020 4549   *C3).  {.    EI
+0000b5c0: 4745 4e5f 4153 4d5f 434f 4d4d 454e 5428  GEN_ASM_COMMENT(
+0000b5d0: 2262 6567 696e 2073 7465 7020 6f66 2067  "begin step of g
+0000b5e0: 6562 7020 6d69 6372 6f20 6b65 726e 656c  ebp micro kernel
+0000b5f0: 2031 5834 2229 3b0a 2020 2020 4549 4745   1X4");.    EIGE
+0000b600: 4e5f 4153 4d5f 434f 4d4d 454e 5428 224e  N_ASM_COMMENT("N
+0000b610: 6f74 653a 2074 6865 7365 2061 736d 2063  ote: these asm c
+0000b620: 6f6d 6d65 6e74 7320 776f 726b 2061 726f  omments work aro
+0000b630: 756e 6420 6275 6720 3933 3521 2229 3b0a  und bug 935!");.
+0000b640: 2020 2020 7472 6169 7473 2e6c 6f61 644c      traits.loadL
+0000b650: 6873 2826 626c 415b 2830 2b31 2a4b 292a  hs(&blA[(0+1*K)*
+0000b660: 4c68 7350 726f 6772 6573 735d 2c20 2a41  LhsProgress], *A
+0000b670: 3029 3b0a 2020 2020 7472 6169 7473 2e6c  0);.    traits.l
+0000b680: 6f61 6452 6873 2826 626c 425b 2830 2b34  oadRhs(&blB[(0+4
+0000b690: 2a4b 292a 5268 7350 726f 6772 6573 735d  *K)*RhsProgress]
+0000b6a0: 2c20 2a72 6873 5f70 616e 656c 293b 0a20  , *rhs_panel);. 
+0000b6b0: 2020 2074 7261 6974 732e 6d61 6464 282a     traits.madd(*
+0000b6c0: 4130 2c20 2a72 6873 5f70 616e 656c 2c20  A0, *rhs_panel, 
+0000b6d0: 2a43 302c 202a 5430 2c20 6669 783c 303e  *C0, *T0, fix<0>
+0000b6e0: 293b 0a20 2020 2074 7261 6974 732e 6d61  );.    traits.ma
+0000b6f0: 6464 282a 4130 2c20 2a72 6873 5f70 616e  dd(*A0, *rhs_pan
+0000b700: 656c 2c20 2a43 312c 202a 5430 2c20 6669  el, *C1, *T0, fi
+0000b710: 783c 313e 293b 0a20 2020 2074 7261 6974  x<1>);.    trait
+0000b720: 732e 6d61 6464 282a 4130 2c20 2a72 6873  s.madd(*A0, *rhs
+0000b730: 5f70 616e 656c 2c20 2a43 322c 202a 5430  _panel, *C2, *T0
+0000b740: 2c20 6669 783c 323e 293b 0a20 2020 2074  , fix<2>);.    t
+0000b750: 7261 6974 732e 6d61 6464 282a 4130 2c20  raits.madd(*A0, 
+0000b760: 2a72 6873 5f70 616e 656c 2c20 2a43 332c  *rhs_panel, *C3,
+0000b770: 202a 5430 2c20 6669 783c 333e 293b 0a20   *T0, fix<3>);. 
+0000b780: 2020 2023 6966 2045 4947 454e 5f47 4e55     #if EIGEN_GNU
+0000b790: 435f 4154 5f4c 4541 5354 2836 2c30 2920  C_AT_LEAST(6,0) 
+0000b7a0: 2626 2064 6566 696e 6564 2845 4947 454e  && defined(EIGEN
+0000b7b0: 5f56 4543 544f 5249 5a45 5f53 5345 290a  _VECTORIZE_SSE).
+0000b7c0: 2020 2020 5f5f 6173 6d5f 5f20 2028 2222      __asm__  (""
+0000b7d0: 203a 2022 2b78 2c6d 2220 282a 4130 2929   : "+x,m" (*A0))
+0000b7e0: 3b0a 2020 2020 2365 6e64 6966 0a20 2020  ;.    #endif.   
+0000b7f0: 2045 4947 454e 5f41 534d 5f43 4f4d 4d45   EIGEN_ASM_COMME
+0000b800: 4e54 2822 656e 6420 7374 6570 206f 6620  NT("end step of 
+0000b810: 6765 6270 206d 6963 726f 206b 6572 6e65  gebp micro kerne
+0000b820: 6c20 3158 3422 293b 0a20 207d 0a0a 2020  l 1X4");.  }..  
+0000b830: 4549 4745 4e5f 5354 524f 4e47 5f49 4e4c  EIGEN_STRONG_INL
+0000b840: 494e 4520 766f 6964 206f 7065 7261 746f  INE void operato
+0000b850: 7228 2928 0a20 2020 2063 6f6e 7374 2044  r()(.    const D
+0000b860: 6174 614d 6170 7065 7226 2072 6573 2c20  ataMapper& res, 
+0000b870: 636f 6e73 7420 4c68 7353 6361 6c61 722a  const LhsScalar*
+0000b880: 2062 6c6f 636b 412c 2063 6f6e 7374 2052   blockA, const R
+0000b890: 6873 5363 616c 6172 2a20 626c 6f63 6b42  hsScalar* blockB
+0000b8a0: 2c20 5265 7353 6361 6c61 7220 616c 7068  , ResScalar alph
+0000b8b0: 612c 0a20 2020 2049 6e64 6578 2070 6565  a,.    Index pee
+0000b8c0: 6c53 7461 7274 2c20 496e 6465 7820 7065  lStart, Index pe
+0000b8d0: 656c 456e 642c 2049 6e64 6578 2073 7472  elEnd, Index str
+0000b8e0: 6964 6541 2c20 496e 6465 7820 7374 7269  ideA, Index stri
+0000b8f0: 6465 422c 2049 6e64 6578 206f 6666 7365  deB, Index offse
+0000b900: 7441 2c20 496e 6465 7820 6f66 6673 6574  tA, Index offset
+0000b910: 422c 0a20 2020 2069 6e74 2070 7265 6665  B,.    int prefe
+0000b920: 7463 685f 7265 735f 6f66 6673 6574 2c20  tch_res_offset, 
+0000b930: 496e 6465 7820 7065 656c 6564 5f6b 632c  Index peeled_kc,
+0000b940: 2049 6e64 6578 2070 6b2c 2049 6e64 6578   Index pk, Index
+0000b950: 2063 6f6c 732c 2049 6e64 6578 2064 6570   cols, Index dep
+0000b960: 7468 2c20 496e 6465 7820 7061 636b 6574  th, Index packet
+0000b970: 5f63 6f6c 7334 290a 2020 7b0a 2020 2020  _cols4).  {.    
+0000b980: 4745 4250 5472 6169 7473 2074 7261 6974  GEBPTraits trait
+0000b990: 733b 0a0a 2020 2020 2f2f 206c 6f6f 7073  s;..    // loops
+0000b9a0: 206f 6e20 6561 6368 206c 6172 6765 7374   on each largest
+0000b9b0: 206d 6963 726f 2068 6f72 697a 6f6e 7461   micro horizonta
+0000b9c0: 6c20 7061 6e65 6c20 6f66 206c 6873 0a20  l panel of lhs. 
+0000b9d0: 2020 202f 2f20 284c 6873 5072 6f67 7265     // (LhsProgre
+0000b9e0: 7373 2078 2064 6570 7468 290a 2020 2020  ss x depth).    
+0000b9f0: 666f 7228 496e 6465 7820 693d 7065 656c  for(Index i=peel
+0000ba00: 5374 6172 743b 2069 3c70 6565 6c45 6e64  Start; i<peelEnd
+0000ba10: 3b20 692b 3d4c 6873 5072 6f67 7265 7373  ; i+=LhsProgress
+0000ba20: 290a 2020 2020 7b0a 2020 2020 2020 2f2f  ).    {.      //
+0000ba30: 206c 6f6f 7073 206f 6e20 6561 6368 206c   loops on each l
+0000ba40: 6172 6765 7374 206d 6963 726f 2076 6572  argest micro ver
+0000ba50: 7469 6361 6c20 7061 6e65 6c20 6f66 2072  tical panel of r
+0000ba60: 6873 2028 6465 7074 6820 2a20 6e72 290a  hs (depth * nr).
+0000ba70: 2020 2020 2020 666f 7228 496e 6465 7820        for(Index 
+0000ba80: 6a32 3d30 3b20 6a32 3c70 6163 6b65 745f  j2=0; j2<packet_
+0000ba90: 636f 6c73 343b 206a 322b 3d6e 7229 0a20  cols4; j2+=nr). 
+0000baa0: 2020 2020 207b 0a20 2020 2020 2020 202f       {.        /
+0000bab0: 2f20 5765 2073 656c 6563 7420 6120 4c68  / We select a Lh
+0000bac0: 7350 726f 6772 6573 7320 7820 6e72 206d  sProgress x nr m
+0000bad0: 6963 726f 2062 6c6f 636b 206f 6620 7265  icro block of re
+0000bae0: 730a 2020 2020 2020 2020 2f2f 2077 6869  s.        // whi
+0000baf0: 6368 2069 7320 656e 7469 7265 6c79 2073  ch is entirely s
+0000bb00: 746f 7265 6420 696e 746f 2031 2078 206e  tored into 1 x n
+0000bb10: 7220 7265 6769 7374 6572 732e 0a0a 2020  r registers...  
+0000bb20: 2020 2020 2020 636f 6e73 7420 4c68 7353        const LhsS
+0000bb30: 6361 6c61 722a 2062 6c41 203d 2026 626c  calar* blA = &bl
+0000bb40: 6f63 6b41 5b69 2a73 7472 6964 6541 2b6f  ockA[i*strideA+o
+0000bb50: 6666 7365 7441 2a28 4c68 7350 726f 6772  ffsetA*(LhsProgr
+0000bb60: 6573 7329 5d3b 0a20 2020 2020 2020 2070  ess)];.        p
+0000bb70: 7265 6665 7463 6828 2662 6c41 5b30 5d29  refetch(&blA[0])
+0000bb80: 3b0a 0a20 2020 2020 2020 202f 2f20 6765  ;..        // ge
+0000bb90: 7473 2072 6573 2062 6c6f 636b 2061 7320  ts res block as 
+0000bba0: 7265 6769 7374 6572 0a20 2020 2020 2020  register.       
+0000bbb0: 2041 6363 5061 636b 6574 2043 302c 2043   AccPacket C0, C
+0000bbc0: 312c 2043 322c 2043 333b 0a20 2020 2020  1, C2, C3;.     
+0000bbd0: 2020 2074 7261 6974 732e 696e 6974 4163     traits.initAc
+0000bbe0: 6328 4330 293b 0a20 2020 2020 2020 2074  c(C0);.        t
+0000bbf0: 7261 6974 732e 696e 6974 4163 6328 4331  raits.initAcc(C1
+0000bc00: 293b 0a20 2020 2020 2020 2074 7261 6974  );.        trait
+0000bc10: 732e 696e 6974 4163 6328 4332 293b 0a20  s.initAcc(C2);. 
+0000bc20: 2020 2020 2020 2074 7261 6974 732e 696e         traits.in
+0000bc30: 6974 4163 6328 4333 293b 0a20 2020 2020  itAcc(C3);.     
+0000bc40: 2020 202f 2f20 546f 2069 6d70 726f 7665     // To improve
+0000bc50: 2069 6e73 7472 7563 7469 6f6e 2070 6970   instruction pip
+0000bc60: 656c 696e 696e 672c 206c 6574 2773 2064  elining, let's d
+0000bc70: 6f75 626c 6520 7468 6520 6163 6375 6d75  ouble the accumu
+0000bc80: 6c61 7469 6f6e 2072 6567 6973 7465 7273  lation registers
+0000bc90: 3a0a 2020 2020 2020 2020 2f2f 2020 6576  :.        //  ev
+0000bca0: 656e 206b 2077 696c 6c20 6163 6375 6d75  en k will accumu
+0000bcb0: 6c61 7465 2069 6e20 432a 2c20 7768 696c  late in C*, whil
+0000bcc0: 6520 6f64 6420 6b20 7769 6c6c 2061 6363  e odd k will acc
+0000bcd0: 756d 756c 6174 6520 696e 2044 2a2e 0a20  umulate in D*.. 
+0000bce0: 2020 2020 2020 202f 2f20 5468 6973 2074         // This t
+0000bcf0: 7269 636b 2069 7320 6372 7574 6961 6c20  rick is crutial 
+0000bd00: 746f 2067 6574 2067 6f6f 6420 7065 7266  to get good perf
+0000bd10: 6f72 6d61 6e63 6520 7769 7468 2046 4d41  ormance with FMA
+0000bd20: 2c20 6f74 6865 7277 6973 6520 6974 2069  , otherwise it i
+0000bd30: 7320 0a20 2020 2020 2020 202f 2f20 6163  s .        // ac
+0000bd40: 7475 616c 6c79 2066 6173 7465 7220 746f  tually faster to
+0000bd50: 2070 6572 666f 726d 2073 6570 6172 6174   perform separat
+0000bd60: 6564 204d 554c 2b41 4444 2062 6563 6175  ed MUL+ADD becau
+0000bd70: 7365 206f 6620 6120 6e61 7475 7261 6c6c  se of a naturall
+0000bd80: 790a 2020 2020 2020 2020 2f2f 2062 6574  y.        // bet
+0000bd90: 7465 7220 696e 7374 7275 6374 696f 6e2d  ter instruction-
+0000bda0: 6c65 7665 6c20 7061 7261 6c6c 656c 6973  level parallelis
+0000bdb0: 6d2e 0a20 2020 2020 2020 2041 6363 5061  m..        AccPa
+0000bdc0: 636b 6574 2044 302c 2044 312c 2044 322c  cket D0, D1, D2,
+0000bdd0: 2044 333b 0a20 2020 2020 2020 2074 7261   D3;.        tra
+0000bde0: 6974 732e 696e 6974 4163 6328 4430 293b  its.initAcc(D0);
+0000bdf0: 0a20 2020 2020 2020 2074 7261 6974 732e  .        traits.
+0000be00: 696e 6974 4163 6328 4431 293b 0a20 2020  initAcc(D1);.   
+0000be10: 2020 2020 2074 7261 6974 732e 696e 6974       traits.init
+0000be20: 4163 6328 4432 293b 0a20 2020 2020 2020  Acc(D2);.       
+0000be30: 2074 7261 6974 732e 696e 6974 4163 6328   traits.initAcc(
+0000be40: 4433 293b 0a0a 2020 2020 2020 2020 4c69  D3);..        Li
+0000be50: 6e65 6172 4d61 7070 6572 2072 3020 3d20  nearMapper r0 = 
+0000be60: 7265 732e 6765 744c 696e 6561 724d 6170  res.getLinearMap
+0000be70: 7065 7228 692c 206a 3220 2b20 3029 3b0a  per(i, j2 + 0);.
+0000be80: 2020 2020 2020 2020 4c69 6e65 6172 4d61          LinearMa
+0000be90: 7070 6572 2072 3120 3d20 7265 732e 6765  pper r1 = res.ge
+0000bea0: 744c 696e 6561 724d 6170 7065 7228 692c  tLinearMapper(i,
+0000beb0: 206a 3220 2b20 3129 3b0a 2020 2020 2020   j2 + 1);.      
+0000bec0: 2020 4c69 6e65 6172 4d61 7070 6572 2072    LinearMapper r
+0000bed0: 3220 3d20 7265 732e 6765 744c 696e 6561  2 = res.getLinea
+0000bee0: 724d 6170 7065 7228 692c 206a 3220 2b20  rMapper(i, j2 + 
+0000bef0: 3229 3b0a 2020 2020 2020 2020 4c69 6e65  2);.        Line
+0000bf00: 6172 4d61 7070 6572 2072 3320 3d20 7265  arMapper r3 = re
+0000bf10: 732e 6765 744c 696e 6561 724d 6170 7065  s.getLinearMappe
+0000bf20: 7228 692c 206a 3220 2b20 3329 3b0a 0a20  r(i, j2 + 3);.. 
+0000bf30: 2020 2020 2020 2072 302e 7072 6566 6574         r0.prefet
+0000bf40: 6368 2870 7265 6665 7463 685f 7265 735f  ch(prefetch_res_
+0000bf50: 6f66 6673 6574 293b 0a20 2020 2020 2020  offset);.       
+0000bf60: 2072 312e 7072 6566 6574 6368 2870 7265   r1.prefetch(pre
+0000bf70: 6665 7463 685f 7265 735f 6f66 6673 6574  fetch_res_offset
+0000bf80: 293b 0a20 2020 2020 2020 2072 322e 7072  );.        r2.pr
+0000bf90: 6566 6574 6368 2870 7265 6665 7463 685f  efetch(prefetch_
+0000bfa0: 7265 735f 6f66 6673 6574 293b 0a20 2020  res_offset);.   
+0000bfb0: 2020 2020 2072 332e 7072 6566 6574 6368       r3.prefetch
+0000bfc0: 2870 7265 6665 7463 685f 7265 735f 6f66  (prefetch_res_of
+0000bfd0: 6673 6574 293b 0a0a 2020 2020 2020 2020  fset);..        
+0000bfe0: 2f2f 2070 6572 666f 726d 7320 2269 6e6e  // performs "inn
+0000bff0: 6572 2220 7072 6f64 7563 7473 0a20 2020  er" products.   
+0000c000: 2020 2020 2063 6f6e 7374 2052 6873 5363       const RhsSc
+0000c010: 616c 6172 2a20 626c 4220 3d20 2662 6c6f  alar* blB = &blo
+0000c020: 636b 425b 6a32 2a73 7472 6964 6542 2b6f  ckB[j2*strideB+o
+0000c030: 6666 7365 7442 2a6e 725d 3b0a 2020 2020  ffsetB*nr];.    
+0000c040: 2020 2020 7072 6566 6574 6368 2826 626c      prefetch(&bl
+0000c050: 425b 305d 293b 0a20 2020 2020 2020 204c  B[0]);.        L
+0000c060: 6873 5061 636b 6574 2041 302c 2041 313b  hsPacket A0, A1;
+0000c070: 0a0a 2020 2020 2020 2020 666f 7228 496e  ..        for(In
+0000c080: 6465 7820 6b3d 303b 206b 3c70 6565 6c65  dex k=0; k<peele
+0000c090: 645f 6b63 3b20 6b2b 3d70 6b29 0a20 2020  d_kc; k+=pk).   
+0000c0a0: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+0000c0b0: 2045 4947 454e 5f41 534d 5f43 4f4d 4d45   EIGEN_ASM_COMME
+0000c0c0: 4e54 2822 6265 6769 6e20 6765 6270 206d  NT("begin gebp m
+0000c0d0: 6963 726f 206b 6572 6e65 6c20 312f 6861  icro kernel 1/ha
+0000c0e0: 6c66 2f71 7561 7274 6572 5834 2229 3b0a  lf/quarterX4");.
+0000c0f0: 2020 2020 2020 2020 2020 5268 7350 6163            RhsPac
+0000c100: 6b65 7478 3420 7268 735f 7061 6e65 6c3b  ketx4 rhs_panel;
+0000c110: 0a20 2020 2020 2020 2020 2052 6873 5061  .          RhsPa
+0000c120: 636b 6574 2054 303b 0a0a 2020 2020 2020  cket T0;..      
+0000c130: 2020 2020 696e 7465 726e 616c 3a3a 7072      internal::pr
+0000c140: 6566 6574 6368 2862 6c42 2b28 3438 2b30  efetch(blB+(48+0
+0000c150: 2929 3b0a 2020 2020 2020 2020 2020 7065  ));.          pe
+0000c160: 656c 6564 5f6b 635f 6f6e 6573 7465 7028  eled_kc_onestep(
+0000c170: 302c 2062 6c41 2c20 626c 422c 2074 7261  0, blA, blB, tra
+0000c180: 6974 732c 2026 4130 2c20 2672 6873 5f70  its, &A0, &rhs_p
+0000c190: 616e 656c 2c20 2654 302c 2026 4330 2c20  anel, &T0, &C0, 
+0000c1a0: 2643 312c 2026 4332 2c20 2643 3329 3b0a  &C1, &C2, &C3);.
+0000c1b0: 2020 2020 2020 2020 2020 7065 656c 6564            peeled
+0000c1c0: 5f6b 635f 6f6e 6573 7465 7028 312c 2062  _kc_onestep(1, b
+0000c1d0: 6c41 2c20 626c 422c 2074 7261 6974 732c  lA, blB, traits,
+0000c1e0: 2026 4131 2c20 2672 6873 5f70 616e 656c   &A1, &rhs_panel
+0000c1f0: 2c20 2654 302c 2026 4430 2c20 2644 312c  , &T0, &D0, &D1,
+0000c200: 2026 4432 2c20 2644 3329 3b0a 2020 2020   &D2, &D3);.    
+0000c210: 2020 2020 2020 7065 656c 6564 5f6b 635f        peeled_kc_
+0000c220: 6f6e 6573 7465 7028 322c 2062 6c41 2c20  onestep(2, blA, 
+0000c230: 626c 422c 2074 7261 6974 732c 2026 4130  blB, traits, &A0
+0000c240: 2c20 2672 6873 5f70 616e 656c 2c20 2654  , &rhs_panel, &T
+0000c250: 302c 2026 4330 2c20 2643 312c 2026 4332  0, &C0, &C1, &C2
+0000c260: 2c20 2643 3329 3b0a 2020 2020 2020 2020  , &C3);.        
+0000c270: 2020 7065 656c 6564 5f6b 635f 6f6e 6573    peeled_kc_ones
+0000c280: 7465 7028 332c 2062 6c41 2c20 626c 422c  tep(3, blA, blB,
+0000c290: 2074 7261 6974 732c 2026 4131 2c20 2672   traits, &A1, &r
+0000c2a0: 6873 5f70 616e 656c 2c20 2654 302c 2026  hs_panel, &T0, &
+0000c2b0: 4430 2c20 2644 312c 2026 4432 2c20 2644  D0, &D1, &D2, &D
+0000c2c0: 3329 3b0a 2020 2020 2020 2020 2020 696e  3);.          in
+0000c2d0: 7465 726e 616c 3a3a 7072 6566 6574 6368  ternal::prefetch
+0000c2e0: 2862 6c42 2b28 3438 2b31 3629 293b 0a20  (blB+(48+16));. 
+0000c2f0: 2020 2020 2020 2020 2070 6565 6c65 645f           peeled_
+0000c300: 6b63 5f6f 6e65 7374 6570 2834 2c20 626c  kc_onestep(4, bl
+0000c310: 412c 2062 6c42 2c20 7472 6169 7473 2c20  A, blB, traits, 
+0000c320: 2641 302c 2026 7268 735f 7061 6e65 6c2c  &A0, &rhs_panel,
+0000c330: 2026 5430 2c20 2643 302c 2026 4331 2c20   &T0, &C0, &C1, 
+0000c340: 2643 322c 2026 4333 293b 0a20 2020 2020  &C2, &C3);.     
+0000c350: 2020 2020 2070 6565 6c65 645f 6b63 5f6f       peeled_kc_o
+0000c360: 6e65 7374 6570 2835 2c20 626c 412c 2062  nestep(5, blA, b
+0000c370: 6c42 2c20 7472 6169 7473 2c20 2641 312c  lB, traits, &A1,
+0000c380: 2026 7268 735f 7061 6e65 6c2c 2026 5430   &rhs_panel, &T0
+0000c390: 2c20 2644 302c 2026 4431 2c20 2644 322c  , &D0, &D1, &D2,
+0000c3a0: 2026 4433 293b 0a20 2020 2020 2020 2020   &D3);.         
+0000c3b0: 2070 6565 6c65 645f 6b63 5f6f 6e65 7374   peeled_kc_onest
+0000c3c0: 6570 2836 2c20 626c 412c 2062 6c42 2c20  ep(6, blA, blB, 
+0000c3d0: 7472 6169 7473 2c20 2641 302c 2026 7268  traits, &A0, &rh
+0000c3e0: 735f 7061 6e65 6c2c 2026 5430 2c20 2643  s_panel, &T0, &C
+0000c3f0: 302c 2026 4331 2c20 2643 322c 2026 4333  0, &C1, &C2, &C3
+0000c400: 293b 0a20 2020 2020 2020 2020 2070 6565  );.          pee
+0000c410: 6c65 645f 6b63 5f6f 6e65 7374 6570 2837  led_kc_onestep(7
+0000c420: 2c20 626c 412c 2062 6c42 2c20 7472 6169  , blA, blB, trai
+0000c430: 7473 2c20 2641 312c 2026 7268 735f 7061  ts, &A1, &rhs_pa
+0000c440: 6e65 6c2c 2026 5430 2c20 2644 302c 2026  nel, &T0, &D0, &
+0000c450: 4431 2c20 2644 322c 2026 4433 293b 0a0a  D1, &D2, &D3);..
+0000c460: 2020 2020 2020 2020 2020 626c 4220 2b3d            blB +=
+0000c470: 2070 6b2a 342a 5268 7350 726f 6772 6573   pk*4*RhsProgres
+0000c480: 733b 0a20 2020 2020 2020 2020 2062 6c41  s;.          blA
+0000c490: 202b 3d20 706b 2a4c 6873 5072 6f67 7265   += pk*LhsProgre
+0000c4a0: 7373 3b0a 0a20 2020 2020 2020 2020 2045  ss;..          E
+0000c4b0: 4947 454e 5f41 534d 5f43 4f4d 4d45 4e54  IGEN_ASM_COMMENT
+0000c4c0: 2822 656e 6420 6765 6270 206d 6963 726f  ("end gebp micro
+0000c4d0: 206b 6572 6e65 6c20 312f 6861 6c66 2f71   kernel 1/half/q
+0000c4e0: 7561 7274 6572 5834 2229 3b0a 2020 2020  uarterX4");.    
+0000c4f0: 2020 2020 7d0a 2020 2020 2020 2020 4330      }.        C0
+0000c500: 203d 2070 6164 6428 4330 2c44 3029 3b0a   = padd(C0,D0);.
+0000c510: 2020 2020 2020 2020 4331 203d 2070 6164          C1 = pad
+0000c520: 6428 4331 2c44 3129 3b0a 2020 2020 2020  d(C1,D1);.      
+0000c530: 2020 4332 203d 2070 6164 6428 4332 2c44    C2 = padd(C2,D
+0000c540: 3229 3b0a 2020 2020 2020 2020 4333 203d  2);.        C3 =
+0000c550: 2070 6164 6428 4333 2c44 3329 3b0a 0a20   padd(C3,D3);.. 
+0000c560: 2020 2020 2020 202f 2f20 7072 6f63 6573         // proces
+0000c570: 7320 7265 6d61 696e 696e 6720 7065 656c  s remaining peel
+0000c580: 6564 206c 6f6f 700a 2020 2020 2020 2020  ed loop.        
+0000c590: 666f 7228 496e 6465 7820 6b3d 7065 656c  for(Index k=peel
+0000c5a0: 6564 5f6b 633b 206b 3c64 6570 7468 3b20  ed_kc; k<depth; 
+0000c5b0: 6b2b 2b29 0a20 2020 2020 2020 207b 0a20  k++).        {. 
+0000c5c0: 2020 2020 2020 2020 2052 6873 5061 636b           RhsPack
+0000c5d0: 6574 7834 2072 6873 5f70 616e 656c 3b0a  etx4 rhs_panel;.
+0000c5e0: 2020 2020 2020 2020 2020 5268 7350 6163            RhsPac
+0000c5f0: 6b65 7420 5430 3b0a 2020 2020 2020 2020  ket T0;.        
+0000c600: 2020 7065 656c 6564 5f6b 635f 6f6e 6573    peeled_kc_ones
+0000c610: 7465 7028 302c 2062 6c41 2c20 626c 422c  tep(0, blA, blB,
+0000c620: 2074 7261 6974 732c 2026 4130 2c20 2672   traits, &A0, &r
+0000c630: 6873 5f70 616e 656c 2c20 2654 302c 2026  hs_panel, &T0, &
+0000c640: 4330 2c20 2643 312c 2026 4332 2c20 2643  C0, &C1, &C2, &C
+0000c650: 3329 3b0a 2020 2020 2020 2020 2020 626c  3);.          bl
+0000c660: 4220 2b3d 2034 2a52 6873 5072 6f67 7265  B += 4*RhsProgre
+0000c670: 7373 3b0a 2020 2020 2020 2020 2020 626c  ss;.          bl
+0000c680: 4120 2b3d 204c 6873 5072 6f67 7265 7373  A += LhsProgress
+0000c690: 3b0a 2020 2020 2020 2020 7d0a 0a20 2020  ;.        }..   
+0000c6a0: 2020 2020 2052 6573 5061 636b 6574 2052       ResPacket R
+0000c6b0: 302c 2052 313b 0a20 2020 2020 2020 2052  0, R1;.        R
+0000c6c0: 6573 5061 636b 6574 2061 6c70 6861 7620  esPacket alphav 
+0000c6d0: 3d20 7073 6574 313c 5265 7350 6163 6b65  = pset1<ResPacke
+0000c6e0: 743e 2861 6c70 6861 293b 0a0a 2020 2020  t>(alpha);..    
+0000c6f0: 2020 2020 5230 203d 2072 302e 7465 6d70      R0 = r0.temp
+0000c700: 6c61 7465 206c 6f61 6450 6163 6b65 743c  late loadPacket<
+0000c710: 5265 7350 6163 6b65 743e 2830 293b 0a20  ResPacket>(0);. 
+0000c720: 2020 2020 2020 2052 3120 3d20 7231 2e74         R1 = r1.t
+0000c730: 656d 706c 6174 6520 6c6f 6164 5061 636b  emplate loadPack
+0000c740: 6574 3c52 6573 5061 636b 6574 3e28 3029  et<ResPacket>(0)
+0000c750: 3b0a 2020 2020 2020 2020 7472 6169 7473  ;.        traits
+0000c760: 2e61 6363 2843 302c 2061 6c70 6861 762c  .acc(C0, alphav,
+0000c770: 2052 3029 3b0a 2020 2020 2020 2020 7472   R0);.        tr
+0000c780: 6169 7473 2e61 6363 2843 312c 2020 616c  aits.acc(C1,  al
+0000c790: 7068 6176 2c20 5231 293b 0a20 2020 2020  phav, R1);.     
+0000c7a0: 2020 2072 302e 7374 6f72 6550 6163 6b65     r0.storePacke
+0000c7b0: 7428 302c 2052 3029 3b0a 2020 2020 2020  t(0, R0);.      
+0000c7c0: 2020 7231 2e73 746f 7265 5061 636b 6574    r1.storePacket
+0000c7d0: 2830 2c20 5231 293b 0a0a 2020 2020 2020  (0, R1);..      
+0000c7e0: 2020 5230 203d 2072 322e 7465 6d70 6c61    R0 = r2.templa
+0000c7f0: 7465 206c 6f61 6450 6163 6b65 743c 5265  te loadPacket<Re
+0000c800: 7350 6163 6b65 743e 2830 293b 0a20 2020  sPacket>(0);.   
+0000c810: 2020 2020 2052 3120 3d20 7233 2e74 656d       R1 = r3.tem
+0000c820: 706c 6174 6520 6c6f 6164 5061 636b 6574  plate loadPacket
+0000c830: 3c52 6573 5061 636b 6574 3e28 3029 3b0a  <ResPacket>(0);.
+0000c840: 2020 2020 2020 2020 7472 6169 7473 2e61          traits.a
+0000c850: 6363 2843 322c 2020 616c 7068 6176 2c20  cc(C2,  alphav, 
+0000c860: 5230 293b 0a20 2020 2020 2020 2074 7261  R0);.        tra
+0000c870: 6974 732e 6163 6328 4333 2c20 2061 6c70  its.acc(C3,  alp
+0000c880: 6861 762c 2052 3129 3b0a 2020 2020 2020  hav, R1);.      
+0000c890: 2020 7232 2e73 746f 7265 5061 636b 6574    r2.storePacket
+0000c8a0: 2830 2c20 5230 293b 0a20 2020 2020 2020  (0, R0);.       
+0000c8b0: 2072 332e 7374 6f72 6550 6163 6b65 7428   r3.storePacket(
+0000c8c0: 302c 2052 3129 3b0a 2020 2020 2020 7d0a  0, R1);.      }.
+0000c8d0: 0a20 2020 2020 202f 2f20 4465 616c 2077  .      // Deal w
+0000c8e0: 6974 6820 7265 6d61 696e 696e 6720 636f  ith remaining co
+0000c8f0: 6c75 6d6e 7320 6f66 2074 6865 2072 6873  lumns of the rhs
+0000c900: 0a20 2020 2020 2066 6f72 2849 6e64 6578  .      for(Index
+0000c910: 206a 323d 7061 636b 6574 5f63 6f6c 7334   j2=packet_cols4
+0000c920: 3b20 6a32 3c63 6f6c 733b 206a 322b 2b29  ; j2<cols; j2++)
+0000c930: 0a20 2020 2020 207b 0a20 2020 2020 2020  .      {.       
+0000c940: 202f 2f20 4f6e 6520 636f 6c75 6d6e 2061   // One column a
+0000c950: 7420 6120 7469 6d65 0a20 2020 2020 2020  t a time.       
+0000c960: 2063 6f6e 7374 204c 6873 5363 616c 6172   const LhsScalar
+0000c970: 2a20 626c 4120 3d20 2662 6c6f 636b 415b  * blA = &blockA[
+0000c980: 692a 7374 7269 6465 412b 6f66 6673 6574  i*strideA+offset
+0000c990: 412a 284c 6873 5072 6f67 7265 7373 295d  A*(LhsProgress)]
+0000c9a0: 3b0a 2020 2020 2020 2020 7072 6566 6574  ;.        prefet
+0000c9b0: 6368 2826 626c 415b 305d 293b 0a0a 2020  ch(&blA[0]);..  
+0000c9c0: 2020 2020 2020 2f2f 2067 6574 7320 7265        // gets re
+0000c9d0: 7320 626c 6f63 6b20 6173 2072 6567 6973  s block as regis
+0000c9e0: 7465 720a 2020 2020 2020 2020 4163 6350  ter.        AccP
+0000c9f0: 6163 6b65 7420 4330 3b0a 2020 2020 2020  acket C0;.      
+0000ca00: 2020 7472 6169 7473 2e69 6e69 7441 6363    traits.initAcc
+0000ca10: 2843 3029 3b0a 0a20 2020 2020 2020 204c  (C0);..        L
+0000ca20: 696e 6561 724d 6170 7065 7220 7230 203d  inearMapper r0 =
+0000ca30: 2072 6573 2e67 6574 4c69 6e65 6172 4d61   res.getLinearMa
+0000ca40: 7070 6572 2869 2c20 6a32 293b 0a0a 2020  pper(i, j2);..  
+0000ca50: 2020 2020 2020 2f2f 2070 6572 666f 726d        // perform
+0000ca60: 7320 2269 6e6e 6572 2220 7072 6f64 7563  s "inner" produc
+0000ca70: 7473 0a20 2020 2020 2020 2063 6f6e 7374  ts.        const
+0000ca80: 2052 6873 5363 616c 6172 2a20 626c 4220   RhsScalar* blB 
+0000ca90: 3d20 2662 6c6f 636b 425b 6a32 2a73 7472  = &blockB[j2*str
+0000caa0: 6964 6542 2b6f 6666 7365 7442 5d3b 0a20  ideB+offsetB];. 
+0000cab0: 2020 2020 2020 204c 6873 5061 636b 6574         LhsPacket
+0000cac0: 2041 303b 0a0a 2020 2020 2020 2020 666f   A0;..        fo
+0000cad0: 7228 496e 6465 7820 6b3d 2030 3b20 6b3c  r(Index k= 0; k<
+0000cae0: 7065 656c 6564 5f6b 633b 206b 2b3d 706b  peeled_kc; k+=pk
+0000caf0: 290a 2020 2020 2020 2020 7b0a 2020 2020  ).        {.    
+0000cb00: 2020 2020 2020 4549 4745 4e5f 4153 4d5f        EIGEN_ASM_
+0000cb10: 434f 4d4d 454e 5428 2262 6567 696e 2067  COMMENT("begin g
+0000cb20: 6562 7020 6d69 6372 6f20 6b65 726e 656c  ebp micro kernel
+0000cb30: 2031 2f68 616c 662f 7175 6172 7465 7258   1/half/quarterX
+0000cb40: 3122 293b 0a20 2020 2020 2020 2020 2052  1");.          R
+0000cb50: 6873 5061 636b 6574 2042 5f30 3b0a 0a23  hsPacket B_0;..#
+0000cb60: 6465 6669 6e65 2045 4947 454e 5f47 4542  define EIGEN_GEB
+0000cb70: 4750 5f4f 4e45 5354 4550 284b 2920 2020  GP_ONESTEP(K)   
+0000cb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cba0: 2020 2020 2020 205c 0a09 2020 2020 2020         \..      
+0000cbb0: 646f 207b 2020 2020 2020 2020 2020 2020  do {            
+0000cbc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbe0: 2020 2020 2020 2020 2020 5c0a 0909 4549            \...EI
+0000cbf0: 4745 4e5f 4153 4d5f 434f 4d4d 454e 5428  GEN_ASM_COMMENT(
+0000cc00: 2262 6567 696e 2073 7465 7020 6f66 2067  "begin step of g
+0000cc10: 6562 7020 6d69 6372 6f20 6b65 726e 656c  ebp micro kernel
+0000cc20: 2031 2f68 616c 662f 7175 6172 7465 7258   1/half/quarterX
+0000cc30: 3122 293b 205c 0a09 0945 4947 454e 5f41  1"); \...EIGEN_A
+0000cc40: 534d 5f43 4f4d 4d45 4e54 2822 4e6f 7465  SM_COMMENT("Note
+0000cc50: 3a20 7468 6573 6520 6173 6d20 636f 6d6d  : these asm comm
+0000cc60: 656e 7473 2077 6f72 6b20 6172 6f75 6e64  ents work around
+0000cc70: 2062 7567 2039 3335 2122 293b 205c 0a20   bug 935!"); \. 
+0000cc80: 2020 202f 2a20 4649 584d 453a 2077 6879     /* FIXME: why
+0000cc90: 2075 6e61 6c69 676e 6564 3f3f 3f3f 202a   unaligned???? *
+0000cca0: 2f20 5c0a 0909 7472 6169 7473 2e6c 6f61  / \...traits.loa
+0000ccb0: 644c 6873 556e 616c 6967 6e65 6428 2662  dLhsUnaligned(&b
+0000ccc0: 6c41 5b28 302b 312a 4b29 2a4c 6873 5072  lA[(0+1*K)*LhsPr
+0000ccd0: 6f67 7265 7373 5d2c 2041 3029 3b20 5c0a  ogress], A0); \.
+0000cce0: 0909 7472 6169 7473 2e6c 6f61 6452 6873  ..traits.loadRhs
+0000ccf0: 2826 626c 425b 2830 2b4b 292a 5268 7350  (&blB[(0+K)*RhsP
+0000cd00: 726f 6772 6573 735d 2c20 425f 3029 3b09  rogress], B_0);.
+0000cd10: 095c 0a09 0974 7261 6974 732e 6d61 6464  .\...traits.madd
+0000cd20: 2841 302c 2042 5f30 2c20 4330 2c20 425f  (A0, B_0, C0, B_
+0000cd30: 302c 2066 6978 3c30 3e29 3b09 0909 095c  0, fix<0>);....\
+0000cd40: 0a09 0945 4947 454e 5f41 534d 5f43 4f4d  ...EIGEN_ASM_COM
+0000cd50: 4d45 4e54 2822 656e 6420 7374 6570 206f  MENT("end step o
+0000cd60: 6620 6765 6270 206d 6963 726f 206b 6572  f gebp micro ker
+0000cd70: 6e65 6c20 312f 6861 6c66 2f71 7561 7274  nel 1/half/quart
+0000cd80: 6572 5831 2229 3b20 5c0a 0920 2020 2020  erX1"); \..     
+0000cd90: 207d 2077 6869 6c65 2866 616c 7365 293b   } while(false);
+0000cda0: 0a0a 2020 2020 2020 2020 2020 4549 4745  ..          EIGE
+0000cdb0: 4e5f 4745 4247 505f 4f4e 4553 5445 5028  N_GEBGP_ONESTEP(
+0000cdc0: 3029 3b0a 2020 2020 2020 2020 2020 4549  0);.          EI
+0000cdd0: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
+0000cde0: 5028 3129 3b0a 2020 2020 2020 2020 2020  P(1);.          
+0000cdf0: 4549 4745 4e5f 4745 4247 505f 4f4e 4553  EIGEN_GEBGP_ONES
+0000ce00: 5445 5028 3229 3b0a 2020 2020 2020 2020  TEP(2);.        
+0000ce10: 2020 4549 4745 4e5f 4745 4247 505f 4f4e    EIGEN_GEBGP_ON
+0000ce20: 4553 5445 5028 3329 3b0a 2020 2020 2020  ESTEP(3);.      
+0000ce30: 2020 2020 4549 4745 4e5f 4745 4247 505f      EIGEN_GEBGP_
+0000ce40: 4f4e 4553 5445 5028 3429 3b0a 2020 2020  ONESTEP(4);.    
+0000ce50: 2020 2020 2020 4549 4745 4e5f 4745 4247        EIGEN_GEBG
+0000ce60: 505f 4f4e 4553 5445 5028 3529 3b0a 2020  P_ONESTEP(5);.  
+0000ce70: 2020 2020 2020 2020 4549 4745 4e5f 4745          EIGEN_GE
+0000ce80: 4247 505f 4f4e 4553 5445 5028 3629 3b0a  BGP_ONESTEP(6);.
+0000ce90: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
+0000cea0: 4745 4247 505f 4f4e 4553 5445 5028 3729  GEBGP_ONESTEP(7)
+0000ceb0: 3b0a 0a20 2020 2020 2020 2020 2062 6c42  ;..          blB
+0000cec0: 202b 3d20 706b 2a52 6873 5072 6f67 7265   += pk*RhsProgre
+0000ced0: 7373 3b0a 2020 2020 2020 2020 2020 626c  ss;.          bl
+0000cee0: 4120 2b3d 2070 6b2a 4c68 7350 726f 6772  A += pk*LhsProgr
+0000cef0: 6573 733b 0a0a 2020 2020 2020 2020 2020  ess;..          
+0000cf00: 4549 4745 4e5f 4153 4d5f 434f 4d4d 454e  EIGEN_ASM_COMMEN
+0000cf10: 5428 2265 6e64 2067 6562 7020 6d69 6372  T("end gebp micr
+0000cf20: 6f20 6b65 726e 656c 2031 2f68 616c 662f  o kernel 1/half/
+0000cf30: 7175 6172 7465 7258 3122 293b 0a20 2020  quarterX1");.   
+0000cf40: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+0000cf50: 2f2f 2070 726f 6365 7373 2072 656d 6169  // process remai
+0000cf60: 6e69 6e67 2070 6565 6c65 6420 6c6f 6f70  ning peeled loop
+0000cf70: 0a20 2020 2020 2020 2066 6f72 2849 6e64  .        for(Ind
+0000cf80: 6578 206b 3d70 6565 6c65 645f 6b63 3b20  ex k=peeled_kc; 
+0000cf90: 6b3c 6465 7074 683b 206b 2b2b 290a 2020  k<depth; k++).  
+0000cfa0: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
+0000cfb0: 2020 5268 7350 6163 6b65 7420 425f 303b    RhsPacket B_0;
+0000cfc0: 0a20 2020 2020 2020 2020 2045 4947 454e  .          EIGEN
+0000cfd0: 5f47 4542 4750 5f4f 4e45 5354 4550 2830  _GEBGP_ONESTEP(0
+0000cfe0: 293b 0a20 2020 2020 2020 2020 2062 6c42  );.          blB
+0000cff0: 202b 3d20 5268 7350 726f 6772 6573 733b   += RhsProgress;
+0000d000: 0a20 2020 2020 2020 2020 2062 6c41 202b  .          blA +
+0000d010: 3d20 4c68 7350 726f 6772 6573 733b 0a20  = LhsProgress;. 
+0000d020: 2020 2020 2020 207d 0a23 756e 6465 6620         }.#undef 
+0000d030: 4549 4745 4e5f 4745 4247 505f 4f4e 4553  EIGEN_GEBGP_ONES
+0000d040: 5445 500a 2020 2020 2020 2020 5265 7350  TEP.        ResP
+0000d050: 6163 6b65 7420 5230 3b0a 2020 2020 2020  acket R0;.      
+0000d060: 2020 5265 7350 6163 6b65 7420 616c 7068    ResPacket alph
+0000d070: 6176 203d 2070 7365 7431 3c52 6573 5061  av = pset1<ResPa
+0000d080: 636b 6574 3e28 616c 7068 6129 3b0a 2020  cket>(alpha);.  
+0000d090: 2020 2020 2020 5230 203d 2072 302e 7465        R0 = r0.te
+0000d0a0: 6d70 6c61 7465 206c 6f61 6450 6163 6b65  mplate loadPacke
+0000d0b0: 743c 5265 7350 6163 6b65 743e 2830 293b  t<ResPacket>(0);
+0000d0c0: 0a20 2020 2020 2020 2074 7261 6974 732e  .        traits.
+0000d0d0: 6163 6328 4330 2c20 616c 7068 6176 2c20  acc(C0, alphav, 
+0000d0e0: 5230 293b 0a20 2020 2020 2020 2072 302e  R0);.        r0.
+0000d0f0: 7374 6f72 6550 6163 6b65 7428 302c 2052  storePacket(0, R
+0000d100: 3029 3b0a 2020 2020 2020 7d0a 2020 2020  0);.      }.    
+0000d110: 7d0a 2020 7d0a 7d3b 0a0a 7465 6d70 6c61  }.  }.};..templa
+0000d120: 7465 3c69 6e74 206e 722c 2049 6e64 6578  te<int nr, Index
+0000d130: 204c 6873 5072 6f67 7265 7373 2c20 496e   LhsProgress, In
+0000d140: 6465 7820 5268 7350 726f 6772 6573 732c  dex RhsProgress,
+0000d150: 2074 7970 656e 616d 6520 4c68 7353 6361   typename LhsSca
+0000d160: 6c61 722c 2074 7970 656e 616d 6520 5268  lar, typename Rh
+0000d170: 7353 6361 6c61 722c 2074 7970 656e 616d  sScalar, typenam
+0000d180: 6520 5265 7353 6361 6c61 722c 2074 7970  e ResScalar, typ
+0000d190: 656e 616d 6520 4163 6350 6163 6b65 742c  ename AccPacket,
+0000d1a0: 2074 7970 656e 616d 6520 4c68 7350 6163   typename LhsPac
+0000d1b0: 6b65 742c 2074 7970 656e 616d 6520 5268  ket, typename Rh
+0000d1c0: 7350 6163 6b65 742c 2074 7970 656e 616d  sPacket, typenam
+0000d1d0: 6520 5265 7350 6163 6b65 742c 2074 7970  e ResPacket, typ
+0000d1e0: 656e 616d 6520 4745 4250 5472 6169 7473  ename GEBPTraits
+0000d1f0: 2c20 7479 7065 6e61 6d65 204c 696e 6561  , typename Linea
+0000d200: 724d 6170 7065 722c 2074 7970 656e 616d  rMapper, typenam
+0000d210: 6520 4461 7461 4d61 7070 6572 3e0a 7374  e DataMapper>.st
+0000d220: 7275 6374 206c 6873 5f70 726f 6365 7373  ruct lhs_process
+0000d230: 5f66 7261 6374 696f 6e5f 6f66 5f70 6163  _fraction_of_pac
+0000d240: 6b65 7420 3a20 6c68 735f 7072 6f63 6573  ket : lhs_proces
+0000d250: 735f 6f6e 655f 7061 636b 6574 3c6e 722c  s_one_packet<nr,
+0000d260: 204c 6873 5072 6f67 7265 7373 2c20 5268   LhsProgress, Rh
+0000d270: 7350 726f 6772 6573 732c 204c 6873 5363  sProgress, LhsSc
+0000d280: 616c 6172 2c20 5268 7353 6361 6c61 722c  alar, RhsScalar,
+0000d290: 2052 6573 5363 616c 6172 2c20 4163 6350   ResScalar, AccP
+0000d2a0: 6163 6b65 742c 204c 6873 5061 636b 6574  acket, LhsPacket
+0000d2b0: 2c20 5268 7350 6163 6b65 742c 2052 6573  , RhsPacket, Res
+0000d2c0: 5061 636b 6574 2c20 4745 4250 5472 6169  Packet, GEBPTrai
+0000d2d0: 7473 2c20 4c69 6e65 6172 4d61 7070 6572  ts, LinearMapper
+0000d2e0: 2c20 4461 7461 4d61 7070 6572 3e0a 7b0a  , DataMapper>.{.
+0000d2f0: 0a45 4947 454e 5f53 5452 4f4e 475f 494e  .EIGEN_STRONG_IN
+0000d300: 4c49 4e45 2076 6f69 6420 7065 656c 6564  LINE void peeled
+0000d310: 5f6b 635f 6f6e 6573 7465 7028 496e 6465  _kc_onestep(Inde
+0000d320: 7820 4b2c 2063 6f6e 7374 204c 6873 5363  x K, const LhsSc
+0000d330: 616c 6172 2a20 626c 412c 2063 6f6e 7374  alar* blA, const
+0000d340: 2052 6873 5363 616c 6172 2a20 626c 422c   RhsScalar* blB,
+0000d350: 2047 4542 5054 7261 6974 7320 7472 6169   GEBPTraits trai
+0000d360: 7473 2c20 4c68 7350 6163 6b65 7420 2a41  ts, LhsPacket *A
+0000d370: 302c 2052 6873 5061 636b 6574 202a 425f  0, RhsPacket *B_
+0000d380: 302c 2052 6873 5061 636b 6574 202a 4231  0, RhsPacket *B1
+0000d390: 2c20 5268 7350 6163 6b65 7420 2a42 322c  , RhsPacket *B2,
+0000d3a0: 2052 6873 5061 636b 6574 202a 4233 2c20   RhsPacket *B3, 
+0000d3b0: 4163 6350 6163 6b65 7420 2a43 302c 2041  AccPacket *C0, A
+0000d3c0: 6363 5061 636b 6574 202a 4331 2c20 4163  ccPacket *C1, Ac
+0000d3d0: 6350 6163 6b65 7420 2a43 322c 2041 6363  cPacket *C2, Acc
+0000d3e0: 5061 636b 6574 202a 4333 290a 2020 7b0a  Packet *C3).  {.
+0000d3f0: 2020 2020 2020 2020 4549 4745 4e5f 4153          EIGEN_AS
+0000d400: 4d5f 434f 4d4d 454e 5428 2262 6567 696e  M_COMMENT("begin
+0000d410: 2073 7465 7020 6f66 2067 6562 7020 6d69   step of gebp mi
+0000d420: 6372 6f20 6b65 726e 656c 2031 5834 2229  cro kernel 1X4")
+0000d430: 3b0a 2020 2020 2020 2020 4549 4745 4e5f  ;.        EIGEN_
+0000d440: 4153 4d5f 434f 4d4d 454e 5428 224e 6f74  ASM_COMMENT("Not
+0000d450: 653a 2074 6865 7365 2061 736d 2063 6f6d  e: these asm com
+0000d460: 6d65 6e74 7320 776f 726b 2061 726f 756e  ments work aroun
+0000d470: 6420 6275 6720 3933 3521 2229 3b0a 2020  d bug 935!");.  
+0000d480: 2020 2020 2020 7472 6169 7473 2e6c 6f61        traits.loa
+0000d490: 644c 6873 556e 616c 6967 6e65 6428 2662  dLhsUnaligned(&b
+0000d4a0: 6c41 5b28 302b 312a 4b29 2a28 4c68 7350  lA[(0+1*K)*(LhsP
+0000d4b0: 726f 6772 6573 7329 5d2c 202a 4130 293b  rogress)], *A0);
+0000d4c0: 0a20 2020 2020 2020 2074 7261 6974 732e  .        traits.
+0000d4d0: 6272 6f61 6463 6173 7452 6873 2826 626c  broadcastRhs(&bl
+0000d4e0: 425b 2830 2b34 2a4b 292a 5268 7350 726f  B[(0+4*K)*RhsPro
+0000d4f0: 6772 6573 735d 2c20 2a42 5f30 2c20 2a42  gress], *B_0, *B
+0000d500: 312c 202a 4232 2c20 2a42 3329 3b0a 2020  1, *B2, *B3);.  
+0000d510: 2020 2020 2020 7472 6169 7473 2e6d 6164        traits.mad
+0000d520: 6428 2a41 302c 202a 425f 302c 202a 4330  d(*A0, *B_0, *C0
+0000d530: 2c20 2a42 5f30 293b 0a20 2020 2020 2020  , *B_0);.       
+0000d540: 2074 7261 6974 732e 6d61 6464 282a 4130   traits.madd(*A0
+0000d550: 2c20 2a42 312c 2020 2a43 312c 202a 4231  , *B1,  *C1, *B1
+0000d560: 293b 0a20 2020 2020 2020 2074 7261 6974  );.        trait
+0000d570: 732e 6d61 6464 282a 4130 2c20 2a42 322c  s.madd(*A0, *B2,
+0000d580: 2020 2a43 322c 202a 4232 293b 0a20 2020    *C2, *B2);.   
+0000d590: 2020 2020 2074 7261 6974 732e 6d61 6464       traits.madd
+0000d5a0: 282a 4130 2c20 2a42 332c 2020 2a43 332c  (*A0, *B3,  *C3,
+0000d5b0: 202a 4233 293b 0a20 2020 2020 2020 2045   *B3);.        E
+0000d5c0: 4947 454e 5f41 534d 5f43 4f4d 4d45 4e54  IGEN_ASM_COMMENT
+0000d5d0: 2822 656e 6420 7374 6570 206f 6620 6765  ("end step of ge
+0000d5e0: 6270 206d 6963 726f 206b 6572 6e65 6c20  bp micro kernel 
+0000d5f0: 3158 3422 293b 0a20 207d 0a7d 3b0a 0a74  1X4");.  }.};..t
+0000d600: 656d 706c 6174 653c 7479 7065 6e61 6d65  emplate<typename
+0000d610: 204c 6873 5363 616c 6172 2c20 7479 7065   LhsScalar, type
+0000d620: 6e61 6d65 2052 6873 5363 616c 6172 2c20  name RhsScalar, 
+0000d630: 7479 7065 6e61 6d65 2049 6e64 6578 2c20  typename Index, 
+0000d640: 7479 7065 6e61 6d65 2044 6174 614d 6170  typename DataMap
+0000d650: 7065 722c 2069 6e74 206d 722c 2069 6e74  per, int mr, int
+0000d660: 206e 722c 2062 6f6f 6c20 436f 6e6a 7567   nr, bool Conjug
+0000d670: 6174 654c 6873 2c20 626f 6f6c 2043 6f6e  ateLhs, bool Con
+0000d680: 6a75 6761 7465 5268 733e 0a45 4947 454e  jugateRhs>.EIGEN
+0000d690: 5f44 4f4e 545f 494e 4c49 4e45 0a76 6f69  _DONT_INLINE.voi
+0000d6a0: 6420 6765 6270 5f6b 6572 6e65 6c3c 4c68  d gebp_kernel<Lh
+0000d6b0: 7353 6361 6c61 722c 5268 7353 6361 6c61  sScalar,RhsScala
+0000d6c0: 722c 496e 6465 782c 4461 7461 4d61 7070  r,Index,DataMapp
+0000d6d0: 6572 2c6d 722c 6e72 2c43 6f6e 6a75 6761  er,mr,nr,Conjuga
+0000d6e0: 7465 4c68 732c 436f 6e6a 7567 6174 6552  teLhs,ConjugateR
+0000d6f0: 6873 3e0a 2020 3a3a 6f70 6572 6174 6f72  hs>.  ::operator
+0000d700: 2829 2863 6f6e 7374 2044 6174 614d 6170  ()(const DataMap
+0000d710: 7065 7226 2072 6573 2c20 636f 6e73 7420  per& res, const 
+0000d720: 4c68 7353 6361 6c61 722a 2062 6c6f 636b  LhsScalar* block
+0000d730: 412c 2063 6f6e 7374 2052 6873 5363 616c  A, const RhsScal
+0000d740: 6172 2a20 626c 6f63 6b42 2c0a 2020 2020  ar* blockB,.    
+0000d750: 2020 2020 2020 2020 2020 2049 6e64 6578             Index
+0000d760: 2072 6f77 732c 2049 6e64 6578 2064 6570   rows, Index dep
+0000d770: 7468 2c20 496e 6465 7820 636f 6c73 2c20  th, Index cols, 
+0000d780: 5265 7353 6361 6c61 7220 616c 7068 612c  ResScalar alpha,
+0000d790: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d7a0: 496e 6465 7820 7374 7269 6465 412c 2049  Index strideA, I
+0000d7b0: 6e64 6578 2073 7472 6964 6542 2c20 496e  ndex strideB, In
+0000d7c0: 6465 7820 6f66 6673 6574 412c 2049 6e64  dex offsetA, Ind
+0000d7d0: 6578 206f 6666 7365 7442 290a 2020 7b0a  ex offsetB).  {.
+0000d7e0: 2020 2020 5472 6169 7473 2074 7261 6974      Traits trait
+0000d7f0: 733b 0a20 2020 2053 7761 7070 6564 5472  s;.    SwappedTr
+0000d800: 6169 7473 2073 7472 6169 7473 3b0a 2020  aits straits;.  
+0000d810: 2020 0a20 2020 2069 6628 7374 7269 6465    .    if(stride
+0000d820: 413d 3d2d 3129 2073 7472 6964 6541 203d  A==-1) strideA =
+0000d830: 2064 6570 7468 3b0a 2020 2020 6966 2873   depth;.    if(s
+0000d840: 7472 6964 6542 3d3d 2d31 2920 7374 7269  trideB==-1) stri
+0000d850: 6465 4220 3d20 6465 7074 683b 0a20 2020  deB = depth;.   
+0000d860: 2063 6f6e 6a5f 6865 6c70 6572 3c4c 6873   conj_helper<Lhs
+0000d870: 5363 616c 6172 2c52 6873 5363 616c 6172  Scalar,RhsScalar
+0000d880: 2c43 6f6e 6a75 6761 7465 4c68 732c 436f  ,ConjugateLhs,Co
+0000d890: 6e6a 7567 6174 6552 6873 3e20 636a 3b0a  njugateRhs> cj;.
+0000d8a0: 2020 2020 496e 6465 7820 7061 636b 6574      Index packet
+0000d8b0: 5f63 6f6c 7334 203d 206e 723e 3d34 203f  _cols4 = nr>=4 ?
+0000d8c0: 2028 636f 6c73 2f34 2920 2a20 3420 3a20   (cols/4) * 4 : 
+0000d8d0: 303b 0a20 2020 2063 6f6e 7374 2049 6e64  0;.    const Ind
+0000d8e0: 6578 2070 6565 6c65 645f 6d63 3320 3d20  ex peeled_mc3 = 
+0000d8f0: 6d72 3e3d 332a 5472 6169 7473 3a3a 4c68  mr>=3*Traits::Lh
+0000d900: 7350 726f 6772 6573 7320 3f20 2872 6f77  sProgress ? (row
+0000d910: 732f 2833 2a4c 6873 5072 6f67 7265 7373  s/(3*LhsProgress
+0000d920: 2929 2a28 332a 4c68 7350 726f 6772 6573  ))*(3*LhsProgres
+0000d930: 7329 203a 2030 3b0a 2020 2020 636f 6e73  s) : 0;.    cons
+0000d940: 7420 496e 6465 7820 7065 656c 6564 5f6d  t Index peeled_m
+0000d950: 6332 203d 206d 723e 3d32 2a54 7261 6974  c2 = mr>=2*Trait
+0000d960: 733a 3a4c 6873 5072 6f67 7265 7373 203f  s::LhsProgress ?
+0000d970: 2070 6565 6c65 645f 6d63 332b 2828 726f   peeled_mc3+((ro
+0000d980: 7773 2d70 6565 6c65 645f 6d63 3329 2f28  ws-peeled_mc3)/(
+0000d990: 322a 4c68 7350 726f 6772 6573 7329 292a  2*LhsProgress))*
+0000d9a0: 2832 2a4c 6873 5072 6f67 7265 7373 2920  (2*LhsProgress) 
+0000d9b0: 3a20 303b 0a20 2020 2063 6f6e 7374 2049  : 0;.    const I
+0000d9c0: 6e64 6578 2070 6565 6c65 645f 6d63 3120  ndex peeled_mc1 
+0000d9d0: 3d20 6d72 3e3d 312a 5472 6169 7473 3a3a  = mr>=1*Traits::
+0000d9e0: 4c68 7350 726f 6772 6573 7320 3f20 7065  LhsProgress ? pe
+0000d9f0: 656c 6564 5f6d 6332 2b28 2872 6f77 732d  eled_mc2+((rows-
+0000da00: 7065 656c 6564 5f6d 6332 292f 2831 2a4c  peeled_mc2)/(1*L
+0000da10: 6873 5072 6f67 7265 7373 2929 2a28 312a  hsProgress))*(1*
+0000da20: 4c68 7350 726f 6772 6573 7329 203a 2030  LhsProgress) : 0
+0000da30: 3b0a 2020 2020 636f 6e73 7420 496e 6465  ;.    const Inde
+0000da40: 7820 7065 656c 6564 5f6d 635f 6861 6c66  x peeled_mc_half
+0000da50: 203d 206d 723e 3d4c 6873 5072 6f67 7265   = mr>=LhsProgre
+0000da60: 7373 4861 6c66 203f 2070 6565 6c65 645f  ssHalf ? peeled_
+0000da70: 6d63 312b 2828 726f 7773 2d70 6565 6c65  mc1+((rows-peele
+0000da80: 645f 6d63 3129 2f28 4c68 7350 726f 6772  d_mc1)/(LhsProgr
+0000da90: 6573 7348 616c 6629 292a 284c 6873 5072  essHalf))*(LhsPr
+0000daa0: 6f67 7265 7373 4861 6c66 2920 3a20 303b  ogressHalf) : 0;
+0000dab0: 0a20 2020 2063 6f6e 7374 2049 6e64 6578  .    const Index
+0000dac0: 2070 6565 6c65 645f 6d63 5f71 7561 7274   peeled_mc_quart
+0000dad0: 6572 203d 206d 723e 3d4c 6873 5072 6f67  er = mr>=LhsProg
+0000dae0: 7265 7373 5175 6172 7465 7220 3f20 7065  ressQuarter ? pe
+0000daf0: 656c 6564 5f6d 635f 6861 6c66 2b28 2872  eled_mc_half+((r
+0000db00: 6f77 732d 7065 656c 6564 5f6d 635f 6861  ows-peeled_mc_ha
+0000db10: 6c66 292f 284c 6873 5072 6f67 7265 7373  lf)/(LhsProgress
+0000db20: 5175 6172 7465 7229 292a 284c 6873 5072  Quarter))*(LhsPr
+0000db30: 6f67 7265 7373 5175 6172 7465 7229 203a  ogressQuarter) :
+0000db40: 2030 3b0a 2020 2020 656e 756d 207b 2070   0;.    enum { p
+0000db50: 6b20 3d20 3820 7d3b 202f 2f20 4e4f 5445  k = 8 }; // NOTE
+0000db60: 2053 7563 6820 6120 6c61 7267 6520 7065   Such a large pe
+0000db70: 656c 696e 6720 6661 6374 6f72 2069 7320  eling factor is 
+0000db80: 696d 706f 7274 616e 7420 666f 7220 6c61  important for la
+0000db90: 7267 6520 6d61 7472 6963 6573 2028 7e20  rge matrices (~ 
+0000dba0: 2b35 2520 7768 656e 203e 3130 3030 206f  +5% when >1000 o
+0000dbb0: 6e20 4861 7377 656c 6c29 0a20 2020 2063  n Haswell).    c
+0000dbc0: 6f6e 7374 2049 6e64 6578 2070 6565 6c65  onst Index peele
+0000dbd0: 645f 6b63 2020 3d20 6465 7074 6820 2620  d_kc  = depth & 
+0000dbe0: 7e28 706b 2d31 293b 0a20 2020 2063 6f6e  ~(pk-1);.    con
+0000dbf0: 7374 2069 6e74 2070 7265 6665 7463 685f  st int prefetch_
+0000dc00: 7265 735f 6f66 6673 6574 203d 2033 322f  res_offset = 32/
+0000dc10: 7369 7a65 6f66 2852 6573 5363 616c 6172  sizeof(ResScalar
+0000dc20: 293b 2020 2020 0a2f 2f20 2020 2020 636f  );    .//     co
+0000dc30: 6e73 7420 496e 6465 7820 6465 7074 6832  nst Index depth2
+0000dc40: 2020 2020 203d 2064 6570 7468 2026 207e       = depth & ~
+0000dc50: 313b 0a0a 2020 2020 2f2f 2d2d 2d2d 2d2d  1;..    //------
+0000dc60: 2d2d 2d2d 2050 726f 6365 7373 2033 202a  ---- Process 3 *
+0000dc70: 204c 6873 5072 6f67 7265 7373 2072 6f77   LhsProgress row
+0000dc80: 7320 6174 206f 6e63 6520 2d2d 2d2d 2d2d  s at once ------
+0000dc90: 2d2d 2d2d 0a20 2020 202f 2f20 5468 6973  ----.    // This
+0000dca0: 2063 6f72 7265 7370 6f6e 6473 2074 6f20   corresponds to 
+0000dcb0: 332a 4c68 7350 726f 6772 6573 7320 7820  3*LhsProgress x 
+0000dcc0: 6e72 2072 6567 6973 7465 7220 626c 6f63  nr register bloc
+0000dcd0: 6b73 2e0a 2020 2020 2f2f 2055 7375 616c  ks..    // Usual
+0000dce0: 6c79 2c20 6d61 6b65 2073 656e 7365 206f  ly, make sense o
+0000dcf0: 6e6c 7920 7769 7468 2046 4d41 0a20 2020  nly with FMA.   
+0000dd00: 2069 6628 6d72 3e3d 332a 5472 6169 7473   if(mr>=3*Traits
+0000dd10: 3a3a 4c68 7350 726f 6772 6573 7329 0a20  ::LhsProgress). 
+0000dd20: 2020 207b 0a20 2020 2020 202f 2f20 4865     {.      // He
+0000dd30: 7265 2c20 7468 6520 6765 6e65 7261 6c20  re, the general 
+0000dd40: 6964 6561 2069 7320 746f 206c 6f6f 7020  idea is to loop 
+0000dd50: 6f6e 2065 6163 6820 6c61 7267 6573 7420  on each largest 
+0000dd60: 6d69 6372 6f20 686f 7269 7a6f 6e74 616c  micro horizontal
+0000dd70: 2070 616e 656c 206f 6620 7468 6520 6c68   panel of the lh
+0000dd80: 7320 2833 2a54 7261 6974 733a 3a4c 6873  s (3*Traits::Lhs
+0000dd90: 5072 6f67 7265 7373 2078 2064 6570 7468  Progress x depth
+0000dda0: 290a 2020 2020 2020 2f2f 2061 6e64 206f  ).      // and o
+0000ddb0: 6e20 6561 6368 206c 6172 6765 7374 206d  n each largest m
+0000ddc0: 6963 726f 2076 6572 7469 6361 6c20 7061  icro vertical pa
+0000ddd0: 6e65 6c20 6f66 2074 6865 2072 6873 2028  nel of the rhs (
+0000dde0: 6465 7074 6820 2a20 6e72 292e 0a20 2020  depth * nr)..   
+0000ddf0: 2020 202f 2f20 426c 6f63 6b69 6e67 2073     // Blocking s
+0000de00: 697a 6573 2c20 692e 652e 2c20 2764 6570  izes, i.e., 'dep
+0000de10: 7468 2720 6861 7320 6265 656e 2063 6f6d  th' has been com
+0000de20: 7075 7465 6420 736f 2074 6861 7420 7468  puted so that th
+0000de30: 6520 6d69 6372 6f20 686f 7269 7a6f 6e74  e micro horizont
+0000de40: 616c 2070 616e 656c 206f 6620 7468 6520  al panel of the 
+0000de50: 6c68 7320 6669 7420 696e 204c 312e 0a20  lhs fit in L1.. 
+0000de60: 2020 2020 202f 2f20 486f 7765 7665 722c       // However,
+0000de70: 2069 6620 6465 7074 6820 6973 2074 6f6f   if depth is too
+0000de80: 2073 6d61 6c6c 2c20 7765 2063 616e 2065   small, we can e
+0000de90: 7874 656e 6420 7468 6520 6e75 6d62 6572  xtend the number
+0000dea0: 206f 6620 726f 7773 206f 6620 7468 6573   of rows of thes
+0000deb0: 6520 686f 7269 7a6f 6e74 616c 2070 616e  e horizontal pan
+0000dec0: 656c 732e 0a20 2020 2020 202f 2f20 5468  els..      // Th
+0000ded0: 6973 2061 6374 7561 6c20 6e75 6d62 6572  is actual number
+0000dee0: 206f 6620 726f 7773 2069 7320 636f 6d70   of rows is comp
+0000def0: 7574 6564 2061 7320 666f 6c6c 6f77 3a0a  uted as follow:.
+0000df00: 2020 2020 2020 636f 6e73 7420 496e 6465        const Inde
+0000df10: 7820 6c31 203d 2064 6566 6175 6c74 4c31  x l1 = defaultL1
+0000df20: 4361 6368 6553 697a 653b 202f 2f20 696e  CacheSize; // in
+0000df30: 2042 7974 6573 2c20 544f 444f 2c20 6c31   Bytes, TODO, l1
+0000df40: 2073 686f 756c 6420 6265 2070 6173 7365   should be passe
+0000df50: 6420 746f 2074 6869 7320 6675 6e63 7469  d to this functi
+0000df60: 6f6e 2e0a 2020 2020 2020 2f2f 2054 6865  on..      // The
+0000df70: 206d 6178 2831 2c20 2e2e 2e29 2068 6572   max(1, ...) her
+0000df80: 6520 6973 206e 6565 6465 6420 6265 6361  e is needed beca
+0000df90: 7573 6520 7765 206d 6179 2062 6520 7573  use we may be us
+0000dfa0: 696e 6720 626c 6f63 6b69 6e67 2070 6172  ing blocking par
+0000dfb0: 616d 7320 6c61 7267 6572 2074 6861 6e20  ams larger than 
+0000dfc0: 7768 6174 206f 7572 206b 6e6f 776e 206c  what our known l
+0000dfd0: 3120 6361 6368 6520 7369 7a65 0a20 2020  1 cache size.   
+0000dfe0: 2020 202f 2f20 7375 6767 6573 7473 2077     // suggests w
+0000dff0: 6520 7368 6f75 6c64 2062 6520 7573 696e  e should be usin
+0000e000: 673a 2065 6974 6865 7220 6265 6361 7573  g: either becaus
+0000e010: 6520 6f75 7220 6b6e 6f77 6e20 6c31 2063  e our known l1 c
+0000e020: 6163 6865 2073 697a 6520 6973 2069 6e61  ache size is ina
+0000e030: 6363 7572 6174 6520 2865 2e67 2e20 6f6e  ccurate (e.g. on
+0000e040: 2041 6e64 726f 6964 2c20 7765 2063 616e   Android, we can
+0000e050: 206f 6e6c 7920 6775 6573 7329 2c0a 2020   only guess),.  
+0000e060: 2020 2020 2f2f 206f 7220 6265 6361 7573      // or becaus
+0000e070: 6520 7765 2061 7265 2074 6573 7469 6e67  e we are testing
+0000e080: 2073 7065 6369 6669 6320 626c 6f63 6b69   specific blocki
+0000e090: 6e67 2073 697a 6573 2e0a 2020 2020 2020  ng sizes..      
+0000e0a0: 636f 6e73 7420 496e 6465 7820 6163 7475  const Index actu
+0000e0b0: 616c 5f70 616e 656c 5f72 6f77 7320 3d20  al_panel_rows = 
+0000e0c0: 2833 2a4c 6873 5072 6f67 7265 7373 2920  (3*LhsProgress) 
+0000e0d0: 2a20 7374 643a 3a6d 6178 3c49 6e64 6578  * std::max<Index
+0000e0e0: 3e28 312c 2820 286c 3120 2d20 7369 7a65  >(1,( (l1 - size
+0000e0f0: 6f66 2852 6573 5363 616c 6172 292a 6d72  of(ResScalar)*mr
+0000e100: 2a6e 7220 2d20 6465 7074 682a 6e72 2a73  *nr - depth*nr*s
+0000e110: 697a 656f 6628 5268 7353 6361 6c61 7229  izeof(RhsScalar)
+0000e120: 2920 2f20 2864 6570 7468 202a 2073 697a  ) / (depth * siz
+0000e130: 656f 6628 4c68 7353 6361 6c61 7229 202a  eof(LhsScalar) *
+0000e140: 2033 2a4c 6873 5072 6f67 7265 7373 2920   3*LhsProgress) 
+0000e150: 2929 3b0a 2020 2020 2020 666f 7228 496e  ));.      for(In
+0000e160: 6465 7820 6931 3d30 3b20 6931 3c70 6565  dex i1=0; i1<pee
+0000e170: 6c65 645f 6d63 333b 2069 312b 3d61 6374  led_mc3; i1+=act
+0000e180: 7561 6c5f 7061 6e65 6c5f 726f 7773 290a  ual_panel_rows).
+0000e190: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
+0000e1a0: 636f 6e73 7420 496e 6465 7820 6163 7475  const Index actu
+0000e1b0: 616c 5f70 616e 656c 5f65 6e64 203d 2028  al_panel_end = (
+0000e1c0: 7374 643a 3a6d 696e 2928 6931 2b61 6374  std::min)(i1+act
+0000e1d0: 7561 6c5f 7061 6e65 6c5f 726f 7773 2c20  ual_panel_rows, 
+0000e1e0: 7065 656c 6564 5f6d 6333 293b 0a20 2020  peeled_mc3);.   
+0000e1f0: 2020 2020 2066 6f72 2849 6e64 6578 206a       for(Index j
+0000e200: 323d 303b 206a 323c 7061 636b 6574 5f63  2=0; j2<packet_c
+0000e210: 6f6c 7334 3b20 6a32 2b3d 6e72 290a 2020  ols4; j2+=nr).  
+0000e220: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
+0000e230: 2020 666f 7228 496e 6465 7820 693d 6931    for(Index i=i1
+0000e240: 3b20 693c 6163 7475 616c 5f70 616e 656c  ; i<actual_panel
+0000e250: 5f65 6e64 3b20 692b 3d33 2a4c 6873 5072  _end; i+=3*LhsPr
+0000e260: 6f67 7265 7373 290a 2020 2020 2020 2020  ogress).        
+0000e270: 2020 7b0a 2020 2020 2020 2020 2020 0a20    {.          . 
+0000e280: 2020 2020 2020 2020 202f 2f20 5765 2073           // We s
+0000e290: 656c 6563 7465 6420 6120 332a 5472 6169  elected a 3*Trai
+0000e2a0: 7473 3a3a 4c68 7350 726f 6772 6573 7320  ts::LhsProgress 
+0000e2b0: 7820 6e72 206d 6963 726f 2062 6c6f 636b  x nr micro block
+0000e2c0: 206f 6620 7265 7320 7768 6963 6820 6973   of res which is
+0000e2d0: 2065 6e74 6972 656c 790a 2020 2020 2020   entirely.      
+0000e2e0: 2020 2020 2f2f 2073 746f 7265 6420 696e      // stored in
+0000e2f0: 746f 2033 2078 206e 7220 7265 6769 7374  to 3 x nr regist
+0000e300: 6572 732e 0a20 2020 2020 2020 2020 200a  ers..          .
+0000e310: 2020 2020 2020 2020 2020 636f 6e73 7420            const 
+0000e320: 4c68 7353 6361 6c61 722a 2062 6c41 203d  LhsScalar* blA =
+0000e330: 2026 626c 6f63 6b41 5b69 2a73 7472 6964   &blockA[i*strid
+0000e340: 6541 2b6f 6666 7365 7441 2a28 332a 4c68  eA+offsetA*(3*Lh
+0000e350: 7350 726f 6772 6573 7329 5d3b 0a20 2020  sProgress)];.   
+0000e360: 2020 2020 2020 2070 7265 6665 7463 6828         prefetch(
+0000e370: 2662 6c41 5b30 5d29 3b0a 0a20 2020 2020  &blA[0]);..     
+0000e380: 2020 2020 202f 2f20 6765 7473 2072 6573       // gets res
+0000e390: 2062 6c6f 636b 2061 7320 7265 6769 7374   block as regist
+0000e3a0: 6572 0a20 2020 2020 2020 2020 2041 6363  er.          Acc
+0000e3b0: 5061 636b 6574 2043 302c 2043 312c 2043  Packet C0, C1, C
+0000e3c0: 322c 2020 4333 2c0a 2020 2020 2020 2020  2,  C3,.        
+0000e3d0: 2020 2020 2020 2020 2020 2020 4334 2c20              C4, 
+0000e3e0: 4335 2c20 4336 2c20 2043 372c 0a20 2020  C5, C6,  C7,.   
+0000e3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e400: 2043 382c 2043 392c 2043 3130 2c20 4331   C8, C9, C10, C1
+0000e410: 313b 0a20 2020 2020 2020 2020 2074 7261  1;.          tra
+0000e420: 6974 732e 696e 6974 4163 6328 4330 293b  its.initAcc(C0);
+0000e430: 2020 7472 6169 7473 2e69 6e69 7441 6363    traits.initAcc
+0000e440: 2843 3129 3b20 2074 7261 6974 732e 696e  (C1);  traits.in
+0000e450: 6974 4163 6328 4332 293b 2020 7472 6169  itAcc(C2);  trai
+0000e460: 7473 2e69 6e69 7441 6363 2843 3329 3b0a  ts.initAcc(C3);.
+0000e470: 2020 2020 2020 2020 2020 7472 6169 7473            traits
+0000e480: 2e69 6e69 7441 6363 2843 3429 3b20 2074  .initAcc(C4);  t
+0000e490: 7261 6974 732e 696e 6974 4163 6328 4335  raits.initAcc(C5
+0000e4a0: 293b 2020 7472 6169 7473 2e69 6e69 7441  );  traits.initA
+0000e4b0: 6363 2843 3629 3b20 2074 7261 6974 732e  cc(C6);  traits.
+0000e4c0: 696e 6974 4163 6328 4337 293b 0a20 2020  initAcc(C7);.   
+0000e4d0: 2020 2020 2020 2074 7261 6974 732e 696e         traits.in
+0000e4e0: 6974 4163 6328 4338 293b 2020 7472 6169  itAcc(C8);  trai
+0000e4f0: 7473 2e69 6e69 7441 6363 2843 3929 3b20  ts.initAcc(C9); 
+0000e500: 2074 7261 6974 732e 696e 6974 4163 6328   traits.initAcc(
+0000e510: 4331 3029 3b20 7472 6169 7473 2e69 6e69  C10); traits.ini
+0000e520: 7441 6363 2843 3131 293b 0a0a 2020 2020  tAcc(C11);..    
+0000e530: 2020 2020 2020 4c69 6e65 6172 4d61 7070        LinearMapp
+0000e540: 6572 2072 3020 3d20 7265 732e 6765 744c  er r0 = res.getL
+0000e550: 696e 6561 724d 6170 7065 7228 692c 206a  inearMapper(i, j
+0000e560: 3220 2b20 3029 3b0a 2020 2020 2020 2020  2 + 0);.        
+0000e570: 2020 4c69 6e65 6172 4d61 7070 6572 2072    LinearMapper r
+0000e580: 3120 3d20 7265 732e 6765 744c 696e 6561  1 = res.getLinea
+0000e590: 724d 6170 7065 7228 692c 206a 3220 2b20  rMapper(i, j2 + 
+0000e5a0: 3129 3b0a 2020 2020 2020 2020 2020 4c69  1);.          Li
+0000e5b0: 6e65 6172 4d61 7070 6572 2072 3220 3d20  nearMapper r2 = 
+0000e5c0: 7265 732e 6765 744c 696e 6561 724d 6170  res.getLinearMap
+0000e5d0: 7065 7228 692c 206a 3220 2b20 3229 3b0a  per(i, j2 + 2);.
+0000e5e0: 2020 2020 2020 2020 2020 4c69 6e65 6172            Linear
+0000e5f0: 4d61 7070 6572 2072 3320 3d20 7265 732e  Mapper r3 = res.
+0000e600: 6765 744c 696e 6561 724d 6170 7065 7228  getLinearMapper(
+0000e610: 692c 206a 3220 2b20 3329 3b0a 0a20 2020  i, j2 + 3);..   
+0000e620: 2020 2020 2020 2072 302e 7072 6566 6574         r0.prefet
+0000e630: 6368 2830 293b 0a20 2020 2020 2020 2020  ch(0);.         
+0000e640: 2072 312e 7072 6566 6574 6368 2830 293b   r1.prefetch(0);
+0000e650: 0a20 2020 2020 2020 2020 2072 322e 7072  .          r2.pr
+0000e660: 6566 6574 6368 2830 293b 0a20 2020 2020  efetch(0);.     
+0000e670: 2020 2020 2072 332e 7072 6566 6574 6368       r3.prefetch
+0000e680: 2830 293b 0a0a 2020 2020 2020 2020 2020  (0);..          
+0000e690: 2f2f 2070 6572 666f 726d 7320 2269 6e6e  // performs "inn
+0000e6a0: 6572 2220 7072 6f64 7563 7473 0a20 2020  er" products.   
+0000e6b0: 2020 2020 2020 2063 6f6e 7374 2052 6873         const Rhs
+0000e6c0: 5363 616c 6172 2a20 626c 4220 3d20 2662  Scalar* blB = &b
+0000e6d0: 6c6f 636b 425b 6a32 2a73 7472 6964 6542  lockB[j2*strideB
+0000e6e0: 2b6f 6666 7365 7442 2a6e 725d 3b0a 2020  +offsetB*nr];.  
+0000e6f0: 2020 2020 2020 2020 7072 6566 6574 6368          prefetch
+0000e700: 2826 626c 425b 305d 293b 0a20 2020 2020  (&blB[0]);.     
+0000e710: 2020 2020 204c 6873 5061 636b 6574 2041       LhsPacket A
+0000e720: 302c 2041 313b 0a0a 2020 2020 2020 2020  0, A1;..        
+0000e730: 2020 666f 7228 496e 6465 7820 6b3d 303b    for(Index k=0;
+0000e740: 206b 3c70 6565 6c65 645f 6b63 3b20 6b2b   k<peeled_kc; k+
+0000e750: 3d70 6b29 0a20 2020 2020 2020 2020 207b  =pk).          {
+0000e760: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
+0000e770: 454e 5f41 534d 5f43 4f4d 4d45 4e54 2822  EN_ASM_COMMENT("
+0000e780: 6265 6769 6e20 6765 6270 206d 6963 726f  begin gebp micro
+0000e790: 206b 6572 6e65 6c20 3370 5834 2229 3b0a   kernel 3pX4");.
+0000e7a0: 2020 2020 2020 2020 2020 2020 2f2f 2031              // 1
+0000e7b0: 3520 7265 6769 7374 6572 7320 6172 6520  5 registers are 
+0000e7c0: 7461 6b65 6e20 2831 3220 666f 7220 6163  taken (12 for ac
+0000e7d0: 632c 2032 2066 6f72 206c 6873 292e 0a20  c, 2 for lhs).. 
+0000e7e0: 2020 2020 2020 2020 2020 2052 6873 5061             RhsPa
+0000e7f0: 6e65 6c31 3520 7268 735f 7061 6e65 6c3b  nel15 rhs_panel;
+0000e800: 0a20 2020 2020 2020 2020 2020 2052 6873  .            Rhs
+0000e810: 5061 636b 6574 2054 303b 0a20 2020 2020  Packet T0;.     
+0000e820: 2020 2020 2020 204c 6873 5061 636b 6574         LhsPacket
+0000e830: 2041 323b 0a20 2020 2020 2020 2020 2020   A2;.           
+0000e840: 2023 6966 2045 4947 454e 5f43 4f4d 505f   #if EIGEN_COMP_
+0000e850: 474e 5543 5f53 5452 4943 5420 2626 2045  GNUC_STRICT && E
+0000e860: 4947 454e 5f41 5243 485f 4152 4d36 3420  IGEN_ARCH_ARM64 
+0000e870: 2626 2064 6566 696e 6564 2845 4947 454e  && defined(EIGEN
+0000e880: 5f56 4543 544f 5249 5a45 5f4e 454f 4e29  _VECTORIZE_NEON)
+0000e890: 2026 2620 2128 4549 4745 4e5f 474e 5543   && !(EIGEN_GNUC
+0000e8a0: 5f41 545f 4c45 4153 5428 392c 3029 290a  _AT_LEAST(9,0)).
+0000e8b0: 2020 2020 2020 2020 2020 2020 2f2f 2073              // s
+0000e8c0: 6565 2068 7474 703a 2f2f 6569 6765 6e2e  ee http://eigen.
+0000e8d0: 7475 7866 616d 696c 792e 6f72 672f 627a  tuxfamily.org/bz
+0000e8e0: 2f73 686f 775f 6275 672e 6367 693f 6964  /show_bug.cgi?id
+0000e8f0: 3d31 3633 330a 2020 2020 2020 2020 2020  =1633.          
+0000e900: 2020 2f2f 2077 6974 686f 7574 2074 6869    // without thi
+0000e910: 7320 776f 726b 6172 6f75 6e64 2041 302c  s workaround A0,
+0000e920: 2041 312c 2061 6e64 2041 3220 6172 6520   A1, and A2 are 
+0000e930: 6c6f 6164 6564 2069 6e20 7468 6520 7361  loaded in the sa
+0000e940: 6d65 2072 6567 6973 7465 722c 0a20 2020  me register,.   
+0000e950: 2020 2020 2020 2020 202f 2f20 7768 6963           // whic
+0000e960: 6820 6973 206e 6f74 2067 6f6f 6420 666f  h is not good fo
+0000e970: 7220 7069 7065 6c69 6e69 6e67 0a20 2020  r pipelining.   
+0000e980: 2020 2020 2020 2020 2023 6465 6669 6e65           #define
+0000e990: 2045 4947 454e 5f47 4542 505f 3350 5834   EIGEN_GEBP_3PX4
+0000e9a0: 5f52 4547 4953 5445 525f 414c 4c4f 435f  _REGISTER_ALLOC_
+0000e9b0: 574f 524b 4152 4f55 4e44 205f 5f61 736d  WORKAROUND __asm
+0000e9c0: 5f5f 2020 2822 2220 3a20 222b 772c 6d22  __  ("" : "+w,m"
+0000e9d0: 2028 4130 292c 2022 2b77 2c6d 2220 2841   (A0), "+w,m" (A
+0000e9e0: 3129 2c20 222b 772c 6d22 2028 4132 2929  1), "+w,m" (A2))
+0000e9f0: 3b0a 2020 2020 2020 2020 2020 2020 2365  ;.            #e
+0000ea00: 6c73 650a 2020 2020 2020 2020 2020 2020  lse.            
+0000ea10: 2364 6566 696e 6520 4549 4745 4e5f 4745  #define EIGEN_GE
+0000ea20: 4250 5f33 5058 345f 5245 4749 5354 4552  BP_3PX4_REGISTER
+0000ea30: 5f41 4c4c 4f43 5f57 4f52 4b41 524f 554e  _ALLOC_WORKAROUN
+0000ea40: 440a 2020 2020 2020 2020 2020 2020 2365  D.            #e
+0000ea50: 6e64 6966 0a23 6465 6669 6e65 2045 4947  ndif.#define EIG
+0000ea60: 454e 5f47 4542 505f 4f4e 4553 5445 5028  EN_GEBP_ONESTEP(
+0000ea70: 4b29 2020 2020 2020 2020 2020 2020 2020  K)              
+0000ea80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eaa0: 2020 2020 2020 205c 0a20 2020 2020 2020         \.       
+0000eab0: 2020 2020 2064 6f20 7b20 2020 2020 2020       do {       
+0000eac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ead0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eaf0: 2020 2020 2020 2020 2020 205c 0a20 2020             \.   
+0000eb00: 2020 2020 2020 2020 2020 2045 4947 454e             EIGEN
+0000eb10: 5f41 534d 5f43 4f4d 4d45 4e54 2822 6265  _ASM_COMMENT("be
+0000eb20: 6769 6e20 7374 6570 206f 6620 6765 6270  gin step of gebp
+0000eb30: 206d 6963 726f 206b 6572 6e65 6c20 3370   micro kernel 3p
+0000eb40: 5834 2229 3b20 2020 2020 2020 2020 205c  X4");          \
+0000eb50: 0a20 2020 2020 2020 2020 2020 2020 2045  .              E
+0000eb60: 4947 454e 5f41 534d 5f43 4f4d 4d45 4e54  IGEN_ASM_COMMENT
+0000eb70: 2822 4e6f 7465 3a20 7468 6573 6520 6173  ("Note: these as
+0000eb80: 6d20 636f 6d6d 656e 7473 2077 6f72 6b20  m comments work 
+0000eb90: 6172 6f75 6e64 2062 7567 2039 3335 2122  around bug 935!"
+0000eba0: 293b 205c 0a20 2020 2020 2020 2020 2020  ); \.           
+0000ebb0: 2020 2069 6e74 6572 6e61 6c3a 3a70 7265     internal::pre
+0000ebc0: 6665 7463 6828 626c 4120 2b20 2833 202a  fetch(blA + (3 *
+0000ebd0: 204b 202b 2031 3629 202a 204c 6873 5072   K + 16) * LhsPr
+0000ebe0: 6f67 7265 7373 293b 2020 2020 2020 2020  ogress);        
+0000ebf0: 2020 2020 2020 205c 0a20 2020 2020 2020         \.       
+0000ec00: 2020 2020 2020 2069 6620 2845 4947 454e         if (EIGEN
+0000ec10: 5f41 5243 485f 4152 4d20 7c7c 2045 4947  _ARCH_ARM || EIG
+0000ec20: 454e 5f41 5243 485f 4d49 5053 2920 7b20  EN_ARCH_MIPS) { 
+0000ec30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ec40: 2020 2020 2020 2020 2020 205c 0a20 2020             \.   
+0000ec50: 2020 2020 2020 2020 2020 2020 2069 6e74               int
+0000ec60: 6572 6e61 6c3a 3a70 7265 6665 7463 6828  ernal::prefetch(
+0000ec70: 626c 4220 2b20 2834 202a 204b 202b 2031  blB + (4 * K + 1
+0000ec80: 3629 202a 2052 6873 5072 6f67 7265 7373  6) * RhsProgress
+0000ec90: 293b 2020 2020 2020 2020 2020 2020 205c  );             \
+0000eca0: 0a20 2020 2020 2020 2020 2020 2020 207d  .              }
+0000ecb0: 202f 2a20 4275 6720 3935 3320 2a2f 2020   /* Bug 953 */  
+0000ecc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ecd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ece0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ecf0: 2020 205c 0a20 2020 2020 2020 2020 2020     \.           
+0000ed00: 2020 2074 7261 6974 732e 6c6f 6164 4c68     traits.loadLh
+0000ed10: 7328 2662 6c41 5b28 3020 2b20 3320 2a20  s(&blA[(0 + 3 * 
+0000ed20: 4b29 202a 204c 6873 5072 6f67 7265 7373  K) * LhsProgress
+0000ed30: 5d2c 2041 3029 3b20 2020 2020 2020 2020  ], A0);         
+0000ed40: 2020 2020 2020 205c 0a20 2020 2020 2020         \.       
+0000ed50: 2020 2020 2020 2074 7261 6974 732e 6c6f         traits.lo
+0000ed60: 6164 4c68 7328 2662 6c41 5b28 3120 2b20  adLhs(&blA[(1 + 
+0000ed70: 3320 2a20 4b29 202a 204c 6873 5072 6f67  3 * K) * LhsProg
+0000ed80: 7265 7373 5d2c 2041 3129 3b20 2020 2020  ress], A1);     
+0000ed90: 2020 2020 2020 2020 2020 205c 0a20 2020             \.   
+0000eda0: 2020 2020 2020 2020 2020 2074 7261 6974             trait
+0000edb0: 732e 6c6f 6164 4c68 7328 2662 6c41 5b28  s.loadLhs(&blA[(
+0000edc0: 3220 2b20 3320 2a20 4b29 202a 204c 6873  2 + 3 * K) * Lhs
+0000edd0: 5072 6f67 7265 7373 5d2c 2041 3229 3b20  Progress], A2); 
+0000ede0: 2020 2020 2020 2020 2020 2020 2020 205c                 \
+0000edf0: 0a20 2020 2020 2020 2020 2020 2020 2045  .              E
+0000ee00: 4947 454e 5f47 4542 505f 3350 5834 5f52  IGEN_GEBP_3PX4_R
+0000ee10: 4547 4953 5445 525f 414c 4c4f 435f 574f  EGISTER_ALLOC_WO
+0000ee20: 524b 4152 4f55 4e44 205c 0a20 2020 2020  RKAROUND \.     
+0000ee30: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
+0000ee40: 6c6f 6164 5268 7328 626c 4220 2b20 2830  loadRhs(blB + (0
+0000ee50: 2b34 2a4b 2920 2a20 5472 6169 7473 3a3a  +4*K) * Traits::
+0000ee60: 5268 7350 726f 6772 6573 732c 2072 6873  RhsProgress, rhs
+0000ee70: 5f70 616e 656c 293b 2020 2020 205c 0a20  _panel);     \. 
+0000ee80: 2020 2020 2020 2020 2020 2020 2074 7261               tra
+0000ee90: 6974 732e 6d61 6464 2841 302c 2072 6873  its.madd(A0, rhs
+0000eea0: 5f70 616e 656c 2c20 4330 2c20 5430 2c20  _panel, C0, T0, 
+0000eeb0: 6669 783c 303e 293b 2020 2020 2020 2020  fix<0>);        
+0000eec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eed0: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
+0000eee0: 2074 7261 6974 732e 6d61 6464 2841 312c   traits.madd(A1,
+0000eef0: 2072 6873 5f70 616e 656c 2c20 4334 2c20   rhs_panel, C4, 
+0000ef00: 5430 2c20 6669 783c 303e 293b 2020 2020  T0, fix<0>);    
+0000ef10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef20: 2020 2020 205c 0a20 2020 2020 2020 2020       \.         
+0000ef30: 2020 2020 2074 7261 6974 732e 6d61 6464       traits.madd
+0000ef40: 2841 322c 2072 6873 5f70 616e 656c 2c20  (A2, rhs_panel, 
+0000ef50: 4338 2c20 5430 2c20 6669 783c 303e 293b  C8, T0, fix<0>);
+0000ef60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef70: 2020 2020 2020 2020 205c 0a20 2020 2020           \.     
+0000ef80: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
+0000ef90: 7570 6461 7465 5268 7328 626c 4220 2b20  updateRhs(blB + 
+0000efa0: 2831 2b34 2a4b 2920 2a20 5472 6169 7473  (1+4*K) * Traits
+0000efb0: 3a3a 5268 7350 726f 6772 6573 732c 2072  ::RhsProgress, r
+0000efc0: 6873 5f70 616e 656c 293b 2020 205c 0a20  hs_panel);   \. 
+0000efd0: 2020 2020 2020 2020 2020 2020 2074 7261               tra
+0000efe0: 6974 732e 6d61 6464 2841 302c 2072 6873  its.madd(A0, rhs
+0000eff0: 5f70 616e 656c 2c20 4331 2c20 5430 2c20  _panel, C1, T0, 
+0000f000: 6669 783c 313e 293b 2020 2020 2020 2020  fix<1>);        
+0000f010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f020: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
+0000f030: 2074 7261 6974 732e 6d61 6464 2841 312c   traits.madd(A1,
+0000f040: 2072 6873 5f70 616e 656c 2c20 4335 2c20   rhs_panel, C5, 
+0000f050: 5430 2c20 6669 783c 313e 293b 2020 2020  T0, fix<1>);    
+0000f060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f070: 2020 2020 205c 0a20 2020 2020 2020 2020       \.         
+0000f080: 2020 2020 2074 7261 6974 732e 6d61 6464       traits.madd
+0000f090: 2841 322c 2072 6873 5f70 616e 656c 2c20  (A2, rhs_panel, 
+0000f0a0: 4339 2c20 5430 2c20 6669 783c 313e 293b  C9, T0, fix<1>);
+0000f0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f0c0: 2020 2020 2020 2020 205c 0a20 2020 2020           \.     
+0000f0d0: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
+0000f0e0: 7570 6461 7465 5268 7328 626c 4220 2b20  updateRhs(blB + 
+0000f0f0: 2832 2b34 2a4b 2920 2a20 5472 6169 7473  (2+4*K) * Traits
+0000f100: 3a3a 5268 7350 726f 6772 6573 732c 2072  ::RhsProgress, r
+0000f110: 6873 5f70 616e 656c 293b 2020 205c 0a20  hs_panel);   \. 
+0000f120: 2020 2020 2020 2020 2020 2020 2074 7261               tra
+0000f130: 6974 732e 6d61 6464 2841 302c 2072 6873  its.madd(A0, rhs
+0000f140: 5f70 616e 656c 2c20 4332 2c20 5430 2c20  _panel, C2, T0, 
+0000f150: 6669 783c 323e 293b 2020 2020 2020 2020  fix<2>);        
+0000f160: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f170: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
+0000f180: 2074 7261 6974 732e 6d61 6464 2841 312c   traits.madd(A1,
+0000f190: 2072 6873 5f70 616e 656c 2c20 4336 2c20   rhs_panel, C6, 
+0000f1a0: 5430 2c20 6669 783c 323e 293b 2020 2020  T0, fix<2>);    
+0000f1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f1c0: 2020 2020 205c 0a20 2020 2020 2020 2020       \.         
+0000f1d0: 2020 2020 2074 7261 6974 732e 6d61 6464       traits.madd
+0000f1e0: 2841 322c 2072 6873 5f70 616e 656c 2c20  (A2, rhs_panel, 
+0000f1f0: 4331 302c 2054 302c 2066 6978 3c32 3e29  C10, T0, fix<2>)
+0000f200: 3b20 2020 2020 2020 2020 2020 2020 2020  ;               
+0000f210: 2020 2020 2020 2020 205c 0a20 2020 2020           \.     
+0000f220: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
+0000f230: 7570 6461 7465 5268 7328 626c 4220 2b20  updateRhs(blB + 
+0000f240: 2833 2b34 2a4b 2920 2a20 5472 6169 7473  (3+4*K) * Traits
+0000f250: 3a3a 5268 7350 726f 6772 6573 732c 2072  ::RhsProgress, r
+0000f260: 6873 5f70 616e 656c 293b 2020 205c 0a20  hs_panel);   \. 
+0000f270: 2020 2020 2020 2020 2020 2020 2074 7261               tra
+0000f280: 6974 732e 6d61 6464 2841 302c 2072 6873  its.madd(A0, rhs
+0000f290: 5f70 616e 656c 2c20 4333 2c20 5430 2c20  _panel, C3, T0, 
+0000f2a0: 6669 783c 333e 293b 2020 2020 2020 2020  fix<3>);        
+0000f2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f2c0: 205c 0a20 2020 2020 2020 2020 2020 2020   \.             
+0000f2d0: 2074 7261 6974 732e 6d61 6464 2841 312c   traits.madd(A1,
+0000f2e0: 2072 6873 5f70 616e 656c 2c20 4337 2c20   rhs_panel, C7, 
+0000f2f0: 5430 2c20 6669 783c 333e 293b 2020 2020  T0, fix<3>);    
+0000f300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f310: 2020 2020 205c 0a20 2020 2020 2020 2020       \.         
+0000f320: 2020 2020 2074 7261 6974 732e 6d61 6464       traits.madd
+0000f330: 2841 322c 2072 6873 5f70 616e 656c 2c20  (A2, rhs_panel, 
+0000f340: 4331 312c 2054 302c 2066 6978 3c33 3e29  C11, T0, fix<3>)
+0000f350: 3b20 2020 2020 2020 2020 2020 2020 2020  ;               
+0000f360: 2020 2020 2020 2020 205c 0a20 2020 2020           \.     
+0000f370: 2020 2020 2020 2020 2045 4947 454e 5f41           EIGEN_A
+0000f380: 534d 5f43 4f4d 4d45 4e54 2822 656e 6420  SM_COMMENT("end 
+0000f390: 7374 6570 206f 6620 6765 6270 206d 6963  step of gebp mic
+0000f3a0: 726f 206b 6572 6e65 6c20 3370 5834 2229  ro kernel 3pX4")
+0000f3b0: 3b20 2020 2020 2020 2020 2020 205c 0a20  ;            \. 
+0000f3c0: 2020 2020 2020 2020 2020 207d 2077 6869             } whi
+0000f3d0: 6c65 2028 6661 6c73 6529 0a0a 2020 2020  le (false)..    
+0000f3e0: 2020 2020 2020 2020 696e 7465 726e 616c          internal
+0000f3f0: 3a3a 7072 6566 6574 6368 2862 6c42 293b  ::prefetch(blB);
+0000f400: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
+0000f410: 454e 5f47 4542 505f 4f4e 4553 5445 5028  EN_GEBP_ONESTEP(
+0000f420: 3029 3b0a 2020 2020 2020 2020 2020 2020  0);.            
+0000f430: 4549 4745 4e5f 4745 4250 5f4f 4e45 5354  EIGEN_GEBP_ONEST
+0000f440: 4550 2831 293b 0a20 2020 2020 2020 2020  EP(1);.         
+0000f450: 2020 2045 4947 454e 5f47 4542 505f 4f4e     EIGEN_GEBP_ON
+0000f460: 4553 5445 5028 3229 3b0a 2020 2020 2020  ESTEP(2);.      
+0000f470: 2020 2020 2020 4549 4745 4e5f 4745 4250        EIGEN_GEBP
+0000f480: 5f4f 4e45 5354 4550 2833 293b 0a20 2020  _ONESTEP(3);.   
+0000f490: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
+0000f4a0: 4542 505f 4f4e 4553 5445 5028 3429 3b0a  EBP_ONESTEP(4);.
+0000f4b0: 2020 2020 2020 2020 2020 2020 4549 4745              EIGE
+0000f4c0: 4e5f 4745 4250 5f4f 4e45 5354 4550 2835  N_GEBP_ONESTEP(5
+0000f4d0: 293b 0a20 2020 2020 2020 2020 2020 2045  );.            E
+0000f4e0: 4947 454e 5f47 4542 505f 4f4e 4553 5445  IGEN_GEBP_ONESTE
+0000f4f0: 5028 3629 3b0a 2020 2020 2020 2020 2020  P(6);.          
+0000f500: 2020 4549 4745 4e5f 4745 4250 5f4f 4e45    EIGEN_GEBP_ONE
+0000f510: 5354 4550 2837 293b 0a0a 2020 2020 2020  STEP(7);..      
+0000f520: 2020 2020 2020 626c 4220 2b3d 2070 6b2a        blB += pk*
+0000f530: 342a 5268 7350 726f 6772 6573 733b 0a20  4*RhsProgress;. 
+0000f540: 2020 2020 2020 2020 2020 2062 6c41 202b             blA +
+0000f550: 3d20 706b 2a33 2a54 7261 6974 733a 3a4c  = pk*3*Traits::L
+0000f560: 6873 5072 6f67 7265 7373 3b0a 0a20 2020  hsProgress;..   
+0000f570: 2020 2020 2020 2020 2045 4947 454e 5f41           EIGEN_A
+0000f580: 534d 5f43 4f4d 4d45 4e54 2822 656e 6420  SM_COMMENT("end 
+0000f590: 6765 6270 206d 6963 726f 206b 6572 6e65  gebp micro kerne
+0000f5a0: 6c20 3370 5834 2229 3b0a 2020 2020 2020  l 3pX4");.      
+0000f5b0: 2020 2020 7d0a 2020 2020 2020 2020 2020      }.          
+0000f5c0: 2f2f 2070 726f 6365 7373 2072 656d 6169  // process remai
+0000f5d0: 6e69 6e67 2070 6565 6c65 6420 6c6f 6f70  ning peeled loop
+0000f5e0: 0a20 2020 2020 2020 2020 2066 6f72 2849  .          for(I
+0000f5f0: 6e64 6578 206b 3d70 6565 6c65 645f 6b63  ndex k=peeled_kc
+0000f600: 3b20 6b3c 6465 7074 683b 206b 2b2b 290a  ; k<depth; k++).
+0000f610: 2020 2020 2020 2020 2020 7b0a 2020 2020            {.    
+0000f620: 2020 2020 2020 2020 5268 7350 616e 656c          RhsPanel
+0000f630: 3135 2072 6873 5f70 616e 656c 3b0a 2020  15 rhs_panel;.  
+0000f640: 2020 2020 2020 2020 2020 5268 7350 6163            RhsPac
+0000f650: 6b65 7420 5430 3b0a 2020 2020 2020 2020  ket T0;.        
+0000f660: 2020 2020 4c68 7350 6163 6b65 7420 4132      LhsPacket A2
+0000f670: 3b0a 2020 2020 2020 2020 2020 2020 4549  ;.            EI
+0000f680: 4745 4e5f 4745 4250 5f4f 4e45 5354 4550  GEN_GEBP_ONESTEP
+0000f690: 2830 293b 0a20 2020 2020 2020 2020 2020  (0);.           
+0000f6a0: 2062 6c42 202b 3d20 342a 5268 7350 726f   blB += 4*RhsPro
+0000f6b0: 6772 6573 733b 0a20 2020 2020 2020 2020  gress;.         
+0000f6c0: 2020 2062 6c41 202b 3d20 332a 5472 6169     blA += 3*Trai
+0000f6d0: 7473 3a3a 4c68 7350 726f 6772 6573 733b  ts::LhsProgress;
+0000f6e0: 0a20 2020 2020 2020 2020 207d 0a0a 2375  .          }..#u
+0000f6f0: 6e64 6566 2045 4947 454e 5f47 4542 505f  ndef EIGEN_GEBP_
+0000f700: 4f4e 4553 5445 500a 0a20 2020 2020 2020  ONESTEP..       
+0000f710: 2020 2052 6573 5061 636b 6574 2052 302c     ResPacket R0,
+0000f720: 2052 312c 2052 323b 0a20 2020 2020 2020   R1, R2;.       
+0000f730: 2020 2052 6573 5061 636b 6574 2061 6c70     ResPacket alp
+0000f740: 6861 7620 3d20 7073 6574 313c 5265 7350  hav = pset1<ResP
+0000f750: 6163 6b65 743e 2861 6c70 6861 293b 0a0a  acket>(alpha);..
+0000f760: 2020 2020 2020 2020 2020 5230 203d 2072            R0 = r
+0000f770: 302e 7465 6d70 6c61 7465 206c 6f61 6450  0.template loadP
+0000f780: 6163 6b65 743c 5265 7350 6163 6b65 743e  acket<ResPacket>
+0000f790: 2830 202a 2054 7261 6974 733a 3a52 6573  (0 * Traits::Res
+0000f7a0: 5061 636b 6574 5369 7a65 293b 0a20 2020  PacketSize);.   
+0000f7b0: 2020 2020 2020 2052 3120 3d20 7230 2e74         R1 = r0.t
+0000f7c0: 656d 706c 6174 6520 6c6f 6164 5061 636b  emplate loadPack
+0000f7d0: 6574 3c52 6573 5061 636b 6574 3e28 3120  et<ResPacket>(1 
+0000f7e0: 2a20 5472 6169 7473 3a3a 5265 7350 6163  * Traits::ResPac
+0000f7f0: 6b65 7453 697a 6529 3b0a 2020 2020 2020  ketSize);.      
+0000f800: 2020 2020 5232 203d 2072 302e 7465 6d70      R2 = r0.temp
+0000f810: 6c61 7465 206c 6f61 6450 6163 6b65 743c  late loadPacket<
+0000f820: 5265 7350 6163 6b65 743e 2832 202a 2054  ResPacket>(2 * T
+0000f830: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
+0000f840: 5369 7a65 293b 0a20 2020 2020 2020 2020  Size);.         
+0000f850: 2074 7261 6974 732e 6163 6328 4330 2c20   traits.acc(C0, 
+0000f860: 616c 7068 6176 2c20 5230 293b 0a20 2020  alphav, R0);.   
+0000f870: 2020 2020 2020 2074 7261 6974 732e 6163         traits.ac
+0000f880: 6328 4334 2c20 616c 7068 6176 2c20 5231  c(C4, alphav, R1
+0000f890: 293b 0a20 2020 2020 2020 2020 2074 7261  );.          tra
+0000f8a0: 6974 732e 6163 6328 4338 2c20 616c 7068  its.acc(C8, alph
+0000f8b0: 6176 2c20 5232 293b 0a20 2020 2020 2020  av, R2);.       
+0000f8c0: 2020 2072 302e 7374 6f72 6550 6163 6b65     r0.storePacke
+0000f8d0: 7428 3020 2a20 5472 6169 7473 3a3a 5265  t(0 * Traits::Re
+0000f8e0: 7350 6163 6b65 7453 697a 652c 2052 3029  sPacketSize, R0)
+0000f8f0: 3b0a 2020 2020 2020 2020 2020 7230 2e73  ;.          r0.s
+0000f900: 746f 7265 5061 636b 6574 2831 202a 2054  torePacket(1 * T
+0000f910: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
+0000f920: 5369 7a65 2c20 5231 293b 0a20 2020 2020  Size, R1);.     
+0000f930: 2020 2020 2072 302e 7374 6f72 6550 6163       r0.storePac
+0000f940: 6b65 7428 3220 2a20 5472 6169 7473 3a3a  ket(2 * Traits::
+0000f950: 5265 7350 6163 6b65 7453 697a 652c 2052  ResPacketSize, R
+0000f960: 3229 3b0a 0a20 2020 2020 2020 2020 2052  2);..          R
+0000f970: 3020 3d20 7231 2e74 656d 706c 6174 6520  0 = r1.template 
+0000f980: 6c6f 6164 5061 636b 6574 3c52 6573 5061  loadPacket<ResPa
+0000f990: 636b 6574 3e28 3020 2a20 5472 6169 7473  cket>(0 * Traits
+0000f9a0: 3a3a 5265 7350 6163 6b65 7453 697a 6529  ::ResPacketSize)
+0000f9b0: 3b0a 2020 2020 2020 2020 2020 5231 203d  ;.          R1 =
+0000f9c0: 2072 312e 7465 6d70 6c61 7465 206c 6f61   r1.template loa
+0000f9d0: 6450 6163 6b65 743c 5265 7350 6163 6b65  dPacket<ResPacke
+0000f9e0: 743e 2831 202a 2054 7261 6974 733a 3a52  t>(1 * Traits::R
+0000f9f0: 6573 5061 636b 6574 5369 7a65 293b 0a20  esPacketSize);. 
+0000fa00: 2020 2020 2020 2020 2052 3220 3d20 7231           R2 = r1
+0000fa10: 2e74 656d 706c 6174 6520 6c6f 6164 5061  .template loadPa
+0000fa20: 636b 6574 3c52 6573 5061 636b 6574 3e28  cket<ResPacket>(
+0000fa30: 3220 2a20 5472 6169 7473 3a3a 5265 7350  2 * Traits::ResP
+0000fa40: 6163 6b65 7453 697a 6529 3b0a 2020 2020  acketSize);.    
+0000fa50: 2020 2020 2020 7472 6169 7473 2e61 6363        traits.acc
+0000fa60: 2843 312c 2061 6c70 6861 762c 2052 3029  (C1, alphav, R0)
+0000fa70: 3b0a 2020 2020 2020 2020 2020 7472 6169  ;.          trai
+0000fa80: 7473 2e61 6363 2843 352c 2061 6c70 6861  ts.acc(C5, alpha
+0000fa90: 762c 2052 3129 3b0a 2020 2020 2020 2020  v, R1);.        
+0000faa0: 2020 7472 6169 7473 2e61 6363 2843 392c    traits.acc(C9,
+0000fab0: 2061 6c70 6861 762c 2052 3229 3b0a 2020   alphav, R2);.  
+0000fac0: 2020 2020 2020 2020 7231 2e73 746f 7265          r1.store
+0000fad0: 5061 636b 6574 2830 202a 2054 7261 6974  Packet(0 * Trait
+0000fae0: 733a 3a52 6573 5061 636b 6574 5369 7a65  s::ResPacketSize
+0000faf0: 2c20 5230 293b 0a20 2020 2020 2020 2020  , R0);.         
+0000fb00: 2072 312e 7374 6f72 6550 6163 6b65 7428   r1.storePacket(
+0000fb10: 3120 2a20 5472 6169 7473 3a3a 5265 7350  1 * Traits::ResP
+0000fb20: 6163 6b65 7453 697a 652c 2052 3129 3b0a  acketSize, R1);.
+0000fb30: 2020 2020 2020 2020 2020 7231 2e73 746f            r1.sto
+0000fb40: 7265 5061 636b 6574 2832 202a 2054 7261  rePacket(2 * Tra
+0000fb50: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
+0000fb60: 7a65 2c20 5232 293b 0a0a 2020 2020 2020  ze, R2);..      
+0000fb70: 2020 2020 5230 203d 2072 322e 7465 6d70      R0 = r2.temp
+0000fb80: 6c61 7465 206c 6f61 6450 6163 6b65 743c  late loadPacket<
+0000fb90: 5265 7350 6163 6b65 743e 2830 202a 2054  ResPacket>(0 * T
+0000fba0: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
+0000fbb0: 5369 7a65 293b 0a20 2020 2020 2020 2020  Size);.         
+0000fbc0: 2052 3120 3d20 7232 2e74 656d 706c 6174   R1 = r2.templat
+0000fbd0: 6520 6c6f 6164 5061 636b 6574 3c52 6573  e loadPacket<Res
+0000fbe0: 5061 636b 6574 3e28 3120 2a20 5472 6169  Packet>(1 * Trai
+0000fbf0: 7473 3a3a 5265 7350 6163 6b65 7453 697a  ts::ResPacketSiz
+0000fc00: 6529 3b0a 2020 2020 2020 2020 2020 5232  e);.          R2
+0000fc10: 203d 2072 322e 7465 6d70 6c61 7465 206c   = r2.template l
+0000fc20: 6f61 6450 6163 6b65 743c 5265 7350 6163  oadPacket<ResPac
+0000fc30: 6b65 743e 2832 202a 2054 7261 6974 733a  ket>(2 * Traits:
+0000fc40: 3a52 6573 5061 636b 6574 5369 7a65 293b  :ResPacketSize);
+0000fc50: 0a20 2020 2020 2020 2020 2074 7261 6974  .          trait
+0000fc60: 732e 6163 6328 4332 2c20 616c 7068 6176  s.acc(C2, alphav
+0000fc70: 2c20 5230 293b 0a20 2020 2020 2020 2020  , R0);.         
+0000fc80: 2074 7261 6974 732e 6163 6328 4336 2c20   traits.acc(C6, 
+0000fc90: 616c 7068 6176 2c20 5231 293b 0a20 2020  alphav, R1);.   
+0000fca0: 2020 2020 2020 2074 7261 6974 732e 6163         traits.ac
+0000fcb0: 6328 4331 302c 2061 6c70 6861 762c 2052  c(C10, alphav, R
+0000fcc0: 3229 3b0a 2020 2020 2020 2020 2020 7232  2);.          r2
+0000fcd0: 2e73 746f 7265 5061 636b 6574 2830 202a  .storePacket(0 *
+0000fce0: 2054 7261 6974 733a 3a52 6573 5061 636b   Traits::ResPack
+0000fcf0: 6574 5369 7a65 2c20 5230 293b 0a20 2020  etSize, R0);.   
+0000fd00: 2020 2020 2020 2072 322e 7374 6f72 6550         r2.storeP
+0000fd10: 6163 6b65 7428 3120 2a20 5472 6169 7473  acket(1 * Traits
+0000fd20: 3a3a 5265 7350 6163 6b65 7453 697a 652c  ::ResPacketSize,
+0000fd30: 2052 3129 3b0a 2020 2020 2020 2020 2020   R1);.          
+0000fd40: 7232 2e73 746f 7265 5061 636b 6574 2832  r2.storePacket(2
+0000fd50: 202a 2054 7261 6974 733a 3a52 6573 5061   * Traits::ResPa
+0000fd60: 636b 6574 5369 7a65 2c20 5232 293b 0a0a  cketSize, R2);..
+0000fd70: 2020 2020 2020 2020 2020 5230 203d 2072            R0 = r
+0000fd80: 332e 7465 6d70 6c61 7465 206c 6f61 6450  3.template loadP
+0000fd90: 6163 6b65 743c 5265 7350 6163 6b65 743e  acket<ResPacket>
+0000fda0: 2830 202a 2054 7261 6974 733a 3a52 6573  (0 * Traits::Res
+0000fdb0: 5061 636b 6574 5369 7a65 293b 0a20 2020  PacketSize);.   
+0000fdc0: 2020 2020 2020 2052 3120 3d20 7233 2e74         R1 = r3.t
+0000fdd0: 656d 706c 6174 6520 6c6f 6164 5061 636b  emplate loadPack
+0000fde0: 6574 3c52 6573 5061 636b 6574 3e28 3120  et<ResPacket>(1 
+0000fdf0: 2a20 5472 6169 7473 3a3a 5265 7350 6163  * Traits::ResPac
+0000fe00: 6b65 7453 697a 6529 3b0a 2020 2020 2020  ketSize);.      
+0000fe10: 2020 2020 5232 203d 2072 332e 7465 6d70      R2 = r3.temp
+0000fe20: 6c61 7465 206c 6f61 6450 6163 6b65 743c  late loadPacket<
+0000fe30: 5265 7350 6163 6b65 743e 2832 202a 2054  ResPacket>(2 * T
+0000fe40: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
+0000fe50: 5369 7a65 293b 0a20 2020 2020 2020 2020  Size);.         
+0000fe60: 2074 7261 6974 732e 6163 6328 4333 2c20   traits.acc(C3, 
+0000fe70: 616c 7068 6176 2c20 5230 293b 0a20 2020  alphav, R0);.   
+0000fe80: 2020 2020 2020 2074 7261 6974 732e 6163         traits.ac
+0000fe90: 6328 4337 2c20 616c 7068 6176 2c20 5231  c(C7, alphav, R1
+0000fea0: 293b 0a20 2020 2020 2020 2020 2074 7261  );.          tra
+0000feb0: 6974 732e 6163 6328 4331 312c 2061 6c70  its.acc(C11, alp
+0000fec0: 6861 762c 2052 3229 3b0a 2020 2020 2020  hav, R2);.      
+0000fed0: 2020 2020 7233 2e73 746f 7265 5061 636b      r3.storePack
+0000fee0: 6574 2830 202a 2054 7261 6974 733a 3a52  et(0 * Traits::R
+0000fef0: 6573 5061 636b 6574 5369 7a65 2c20 5230  esPacketSize, R0
+0000ff00: 293b 0a20 2020 2020 2020 2020 2072 332e  );.          r3.
+0000ff10: 7374 6f72 6550 6163 6b65 7428 3120 2a20  storePacket(1 * 
+0000ff20: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
+0000ff30: 7453 697a 652c 2052 3129 3b0a 2020 2020  tSize, R1);.    
+0000ff40: 2020 2020 2020 7233 2e73 746f 7265 5061        r3.storePa
+0000ff50: 636b 6574 2832 202a 2054 7261 6974 733a  cket(2 * Traits:
+0000ff60: 3a52 6573 5061 636b 6574 5369 7a65 2c20  :ResPacketSize, 
+0000ff70: 5232 293b 2020 2020 2020 2020 2020 0a20  R2);          . 
+0000ff80: 2020 2020 2020 2020 207d 0a20 2020 2020           }.     
+0000ff90: 2020 207d 0a0a 2020 2020 2020 2020 2f2f     }..        //
+0000ffa0: 2044 6561 6c20 7769 7468 2072 656d 6169   Deal with remai
+0000ffb0: 6e69 6e67 2063 6f6c 756d 6e73 206f 6620  ning columns of 
+0000ffc0: 7468 6520 7268 730a 2020 2020 2020 2020  the rhs.        
+0000ffd0: 666f 7228 496e 6465 7820 6a32 3d70 6163  for(Index j2=pac
+0000ffe0: 6b65 745f 636f 6c73 343b 206a 323c 636f  ket_cols4; j2<co
+0000fff0: 6c73 3b20 6a32 2b2b 290a 2020 2020 2020  ls; j2++).      
+00010000: 2020 7b0a 2020 2020 2020 2020 2020 666f    {.          fo
+00010010: 7228 496e 6465 7820 693d 6931 3b20 693c  r(Index i=i1; i<
+00010020: 6163 7475 616c 5f70 616e 656c 5f65 6e64  actual_panel_end
+00010030: 3b20 692b 3d33 2a4c 6873 5072 6f67 7265  ; i+=3*LhsProgre
+00010040: 7373 290a 2020 2020 2020 2020 2020 7b0a  ss).          {.
+00010050: 2020 2020 2020 2020 2020 2f2f 204f 6e65            // One
+00010060: 2063 6f6c 756d 6e20 6174 2061 2074 696d   column at a tim
+00010070: 650a 2020 2020 2020 2020 2020 636f 6e73  e.          cons
+00010080: 7420 4c68 7353 6361 6c61 722a 2062 6c41  t LhsScalar* blA
+00010090: 203d 2026 626c 6f63 6b41 5b69 2a73 7472   = &blockA[i*str
+000100a0: 6964 6541 2b6f 6666 7365 7441 2a28 332a  ideA+offsetA*(3*
+000100b0: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
+000100c0: 6573 7329 5d3b 0a20 2020 2020 2020 2020  ess)];.         
+000100d0: 2070 7265 6665 7463 6828 2662 6c41 5b30   prefetch(&blA[0
+000100e0: 5d29 3b0a 0a20 2020 2020 2020 2020 202f  ]);..          /
+000100f0: 2f20 6765 7473 2072 6573 2062 6c6f 636b  / gets res block
+00010100: 2061 7320 7265 6769 7374 6572 0a20 2020   as register.   
+00010110: 2020 2020 2020 2041 6363 5061 636b 6574         AccPacket
+00010120: 2043 302c 2043 342c 2043 383b 0a20 2020   C0, C4, C8;.   
+00010130: 2020 2020 2020 2074 7261 6974 732e 696e         traits.in
+00010140: 6974 4163 6328 4330 293b 0a20 2020 2020  itAcc(C0);.     
+00010150: 2020 2020 2074 7261 6974 732e 696e 6974       traits.init
+00010160: 4163 6328 4334 293b 0a20 2020 2020 2020  Acc(C4);.       
+00010170: 2020 2074 7261 6974 732e 696e 6974 4163     traits.initAc
+00010180: 6328 4338 293b 0a0a 2020 2020 2020 2020  c(C8);..        
+00010190: 2020 4c69 6e65 6172 4d61 7070 6572 2072    LinearMapper r
+000101a0: 3020 3d20 7265 732e 6765 744c 696e 6561  0 = res.getLinea
+000101b0: 724d 6170 7065 7228 692c 206a 3229 3b0a  rMapper(i, j2);.
+000101c0: 2020 2020 2020 2020 2020 7230 2e70 7265            r0.pre
+000101d0: 6665 7463 6828 3029 3b0a 0a20 2020 2020  fetch(0);..     
+000101e0: 2020 2020 202f 2f20 7065 7266 6f72 6d73       // performs
+000101f0: 2022 696e 6e65 7222 2070 726f 6475 6374   "inner" product
+00010200: 730a 2020 2020 2020 2020 2020 636f 6e73  s.          cons
+00010210: 7420 5268 7353 6361 6c61 722a 2062 6c42  t RhsScalar* blB
+00010220: 203d 2026 626c 6f63 6b42 5b6a 322a 7374   = &blockB[j2*st
+00010230: 7269 6465 422b 6f66 6673 6574 425d 3b0a  rideB+offsetB];.
+00010240: 2020 2020 2020 2020 2020 4c68 7350 6163            LhsPac
+00010250: 6b65 7420 4130 2c20 4131 2c20 4132 3b0a  ket A0, A1, A2;.
+00010260: 2020 2020 2020 2020 2020 0a20 2020 2020            .     
+00010270: 2020 2020 2066 6f72 2849 6e64 6578 206b       for(Index k
+00010280: 3d30 3b20 6b3c 7065 656c 6564 5f6b 633b  =0; k<peeled_kc;
+00010290: 206b 2b3d 706b 290a 2020 2020 2020 2020   k+=pk).        
+000102a0: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
+000102b0: 4549 4745 4e5f 4153 4d5f 434f 4d4d 454e  EIGEN_ASM_COMMEN
+000102c0: 5428 2262 6567 696e 2067 6562 7020 6d69  T("begin gebp mi
+000102d0: 6372 6f20 6b65 726e 656c 2033 7058 3122  cro kernel 3pX1"
+000102e0: 293b 0a20 2020 2020 2020 2020 2020 2052  );.            R
+000102f0: 6873 5061 636b 6574 2042 5f30 3b0a 2364  hsPacket B_0;.#d
+00010300: 6566 696e 6520 4549 4745 4e5f 4745 4247  efine EIGEN_GEBG
+00010310: 505f 4f4e 4553 5445 5028 4b29 2020 2020  P_ONESTEP(K)    
+00010320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010350: 5c0a 2020 2020 2020 2020 2020 2020 646f  \.            do
+00010360: 207b 2020 2020 2020 2020 2020 2020 2020   {              
+00010370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000103a0: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
+000103b0: 2020 2020 4549 4745 4e5f 4153 4d5f 434f      EIGEN_ASM_CO
+000103c0: 4d4d 454e 5428 2262 6567 696e 2073 7465  MMENT("begin ste
+000103d0: 7020 6f66 2067 6562 7020 6d69 6372 6f20  p of gebp micro 
+000103e0: 6b65 726e 656c 2033 7058 3122 293b 2020  kernel 3pX1");  
+000103f0: 2020 2020 2020 2020 5c0a 2020 2020 2020          \.      
+00010400: 2020 2020 2020 2020 4549 4745 4e5f 4153          EIGEN_AS
+00010410: 4d5f 434f 4d4d 454e 5428 224e 6f74 653a  M_COMMENT("Note:
+00010420: 2074 6865 7365 2061 736d 2063 6f6d 6d65   these asm comme
+00010430: 6e74 7320 776f 726b 2061 726f 756e 6420  nts work around 
+00010440: 6275 6720 3933 3521 2229 3b20 5c0a 2020  bug 935!"); \.  
+00010450: 2020 2020 2020 2020 2020 2020 7472 6169              trai
+00010460: 7473 2e6c 6f61 644c 6873 2826 626c 415b  ts.loadLhs(&blA[
+00010470: 2830 202b 2033 202a 204b 2920 2a20 4c68  (0 + 3 * K) * Lh
+00010480: 7350 726f 6772 6573 735d 2c20 4130 293b  sProgress], A0);
+00010490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000104a0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+000104b0: 7472 6169 7473 2e6c 6f61 644c 6873 2826  traits.loadLhs(&
+000104c0: 626c 415b 2831 202b 2033 202a 204b 2920  blA[(1 + 3 * K) 
+000104d0: 2a20 4c68 7350 726f 6772 6573 735d 2c20  * LhsProgress], 
+000104e0: 4131 293b 2020 2020 2020 2020 2020 2020  A1);            
+000104f0: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
+00010500: 2020 2020 7472 6169 7473 2e6c 6f61 644c      traits.loadL
+00010510: 6873 2826 626c 415b 2832 202b 2033 202a  hs(&blA[(2 + 3 *
+00010520: 204b 2920 2a20 4c68 7350 726f 6772 6573   K) * LhsProgres
+00010530: 735d 2c20 4132 293b 2020 2020 2020 2020  s], A2);        
+00010540: 2020 2020 2020 2020 5c0a 2020 2020 2020          \.      
+00010550: 2020 2020 2020 2020 7472 6169 7473 2e6c          traits.l
+00010560: 6f61 6452 6873 2826 626c 425b 2830 202b  oadRhs(&blB[(0 +
+00010570: 204b 2920 2a20 5268 7350 726f 6772 6573   K) * RhsProgres
+00010580: 735d 2c20 425f 3029 3b20 2020 2020 2020  s], B_0);       
+00010590: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
+000105a0: 2020 2020 2020 2020 2020 2020 7472 6169              trai
+000105b0: 7473 2e6d 6164 6428 4130 2c20 425f 302c  ts.madd(A0, B_0,
+000105c0: 2043 302c 2042 5f30 2c20 6669 783c 303e   C0, B_0, fix<0>
+000105d0: 293b 2020 2020 2020 2020 2020 2020 2020  );              
+000105e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000105f0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00010600: 7472 6169 7473 2e6d 6164 6428 4131 2c20  traits.madd(A1, 
+00010610: 425f 302c 2043 342c 2042 5f30 2c20 6669  B_0, C4, B_0, fi
+00010620: 783c 303e 293b 2020 2020 2020 2020 2020  x<0>);          
+00010630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010640: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
+00010650: 2020 2020 7472 6169 7473 2e6d 6164 6428      traits.madd(
+00010660: 4132 2c20 425f 302c 2043 382c 2042 5f30  A2, B_0, C8, B_0
+00010670: 2c20 6669 783c 303e 293b 2020 2020 2020  , fix<0>);      
+00010680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010690: 2020 2020 2020 2020 5c0a 2020 2020 2020          \.      
+000106a0: 2020 2020 2020 2020 4549 4745 4e5f 4153          EIGEN_AS
+000106b0: 4d5f 434f 4d4d 454e 5428 2265 6e64 2073  M_COMMENT("end s
+000106c0: 7465 7020 6f66 2067 6562 7020 6d69 6372  tep of gebp micr
+000106d0: 6f20 6b65 726e 656c 2033 7058 3122 293b  o kernel 3pX1");
+000106e0: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
+000106f0: 2020 2020 2020 2020 2020 7d20 7768 696c            } whil
+00010700: 6520 2866 616c 7365 290a 0a20 2020 2020  e (false)..     
+00010710: 2020 2020 2020 2045 4947 454e 5f47 4542         EIGEN_GEB
+00010720: 4750 5f4f 4e45 5354 4550 2830 293b 0a20  GP_ONESTEP(0);. 
+00010730: 2020 2020 2020 2020 2020 2045 4947 454e             EIGEN
+00010740: 5f47 4542 4750 5f4f 4e45 5354 4550 2831  _GEBGP_ONESTEP(1
+00010750: 293b 0a20 2020 2020 2020 2020 2020 2045  );.            E
+00010760: 4947 454e 5f47 4542 4750 5f4f 4e45 5354  IGEN_GEBGP_ONEST
+00010770: 4550 2832 293b 0a20 2020 2020 2020 2020  EP(2);.         
+00010780: 2020 2045 4947 454e 5f47 4542 4750 5f4f     EIGEN_GEBGP_O
+00010790: 4e45 5354 4550 2833 293b 0a20 2020 2020  NESTEP(3);.     
+000107a0: 2020 2020 2020 2045 4947 454e 5f47 4542         EIGEN_GEB
+000107b0: 4750 5f4f 4e45 5354 4550 2834 293b 0a20  GP_ONESTEP(4);. 
+000107c0: 2020 2020 2020 2020 2020 2045 4947 454e             EIGEN
+000107d0: 5f47 4542 4750 5f4f 4e45 5354 4550 2835  _GEBGP_ONESTEP(5
+000107e0: 293b 0a20 2020 2020 2020 2020 2020 2045  );.            E
+000107f0: 4947 454e 5f47 4542 4750 5f4f 4e45 5354  IGEN_GEBGP_ONEST
+00010800: 4550 2836 293b 0a20 2020 2020 2020 2020  EP(6);.         
+00010810: 2020 2045 4947 454e 5f47 4542 4750 5f4f     EIGEN_GEBGP_O
+00010820: 4e45 5354 4550 2837 293b 0a0a 2020 2020  NESTEP(7);..    
+00010830: 2020 2020 2020 2020 626c 4220 2b3d 2069          blB += i
+00010840: 6e74 2870 6b29 202a 2069 6e74 2852 6873  nt(pk) * int(Rhs
+00010850: 5072 6f67 7265 7373 293b 0a20 2020 2020  Progress);.     
+00010860: 2020 2020 2020 2062 6c41 202b 3d20 696e         blA += in
+00010870: 7428 706b 2920 2a20 3320 2a20 696e 7428  t(pk) * 3 * int(
+00010880: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
+00010890: 6573 7329 3b0a 0a20 2020 2020 2020 2020  ess);..         
+000108a0: 2020 2045 4947 454e 5f41 534d 5f43 4f4d     EIGEN_ASM_COM
+000108b0: 4d45 4e54 2822 656e 6420 6765 6270 206d  MENT("end gebp m
+000108c0: 6963 726f 206b 6572 6e65 6c20 3370 5831  icro kernel 3pX1
+000108d0: 2229 3b0a 2020 2020 2020 2020 2020 7d0a  ");.          }.
+000108e0: 0a20 2020 2020 2020 2020 202f 2f20 7072  .          // pr
+000108f0: 6f63 6573 7320 7265 6d61 696e 696e 6720  ocess remaining 
+00010900: 7065 656c 6564 206c 6f6f 700a 2020 2020  peeled loop.    
+00010910: 2020 2020 2020 666f 7228 496e 6465 7820        for(Index 
+00010920: 6b3d 7065 656c 6564 5f6b 633b 206b 3c64  k=peeled_kc; k<d
+00010930: 6570 7468 3b20 6b2b 2b29 0a20 2020 2020  epth; k++).     
+00010940: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+00010950: 2020 2052 6873 5061 636b 6574 2042 5f30     RhsPacket B_0
+00010960: 3b0a 2020 2020 2020 2020 2020 2020 4549  ;.            EI
+00010970: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
+00010980: 5028 3029 3b0a 2020 2020 2020 2020 2020  P(0);.          
+00010990: 2020 626c 4220 2b3d 2052 6873 5072 6f67    blB += RhsProg
+000109a0: 7265 7373 3b0a 2020 2020 2020 2020 2020  ress;.          
+000109b0: 2020 626c 4120 2b3d 2033 2a54 7261 6974    blA += 3*Trait
+000109c0: 733a 3a4c 6873 5072 6f67 7265 7373 3b0a  s::LhsProgress;.
+000109d0: 2020 2020 2020 2020 2020 7d0a 2375 6e64            }.#und
+000109e0: 6566 2045 4947 454e 5f47 4542 4750 5f4f  ef EIGEN_GEBGP_O
+000109f0: 4e45 5354 4550 0a20 2020 2020 2020 2020  NESTEP.         
+00010a00: 2052 6573 5061 636b 6574 2052 302c 2052   ResPacket R0, R
+00010a10: 312c 2052 323b 0a20 2020 2020 2020 2020  1, R2;.         
+00010a20: 2052 6573 5061 636b 6574 2061 6c70 6861   ResPacket alpha
+00010a30: 7620 3d20 7073 6574 313c 5265 7350 6163  v = pset1<ResPac
+00010a40: 6b65 743e 2861 6c70 6861 293b 0a0a 2020  ket>(alpha);..  
+00010a50: 2020 2020 2020 2020 5230 203d 2072 302e          R0 = r0.
+00010a60: 7465 6d70 6c61 7465 206c 6f61 6450 6163  template loadPac
+00010a70: 6b65 743c 5265 7350 6163 6b65 743e 2830  ket<ResPacket>(0
+00010a80: 202a 2054 7261 6974 733a 3a52 6573 5061   * Traits::ResPa
+00010a90: 636b 6574 5369 7a65 293b 0a20 2020 2020  cketSize);.     
+00010aa0: 2020 2020 2052 3120 3d20 7230 2e74 656d       R1 = r0.tem
+00010ab0: 706c 6174 6520 6c6f 6164 5061 636b 6574  plate loadPacket
+00010ac0: 3c52 6573 5061 636b 6574 3e28 3120 2a20  <ResPacket>(1 * 
+00010ad0: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
+00010ae0: 7453 697a 6529 3b0a 2020 2020 2020 2020  tSize);.        
+00010af0: 2020 5232 203d 2072 302e 7465 6d70 6c61    R2 = r0.templa
+00010b00: 7465 206c 6f61 6450 6163 6b65 743c 5265  te loadPacket<Re
+00010b10: 7350 6163 6b65 743e 2832 202a 2054 7261  sPacket>(2 * Tra
+00010b20: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
+00010b30: 7a65 293b 0a20 2020 2020 2020 2020 2074  ze);.          t
+00010b40: 7261 6974 732e 6163 6328 4330 2c20 616c  raits.acc(C0, al
+00010b50: 7068 6176 2c20 5230 293b 0a20 2020 2020  phav, R0);.     
+00010b60: 2020 2020 2074 7261 6974 732e 6163 6328       traits.acc(
+00010b70: 4334 2c20 616c 7068 6176 2c20 5231 293b  C4, alphav, R1);
+00010b80: 0a20 2020 2020 2020 2020 2074 7261 6974  .          trait
+00010b90: 732e 6163 6328 4338 2c20 616c 7068 6176  s.acc(C8, alphav
+00010ba0: 2c20 5232 293b 0a20 2020 2020 2020 2020  , R2);.         
+00010bb0: 2072 302e 7374 6f72 6550 6163 6b65 7428   r0.storePacket(
+00010bc0: 3020 2a20 5472 6169 7473 3a3a 5265 7350  0 * Traits::ResP
+00010bd0: 6163 6b65 7453 697a 652c 2052 3029 3b0a  acketSize, R0);.
+00010be0: 2020 2020 2020 2020 2020 7230 2e73 746f            r0.sto
+00010bf0: 7265 5061 636b 6574 2831 202a 2054 7261  rePacket(1 * Tra
+00010c00: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
+00010c10: 7a65 2c20 5231 293b 0a20 2020 2020 2020  ze, R1);.       
+00010c20: 2020 2072 302e 7374 6f72 6550 6163 6b65     r0.storePacke
+00010c30: 7428 3220 2a20 5472 6169 7473 3a3a 5265  t(2 * Traits::Re
+00010c40: 7350 6163 6b65 7453 697a 652c 2052 3229  sPacketSize, R2)
+00010c50: 3b20 2020 2020 2020 2020 200a 2020 2020  ;          .    
+00010c60: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+00010c70: 7d0a 2020 2020 2020 7d0a 2020 2020 7d0a  }.      }.    }.
+00010c80: 0a20 2020 202f 2f2d 2d2d 2d2d 2d2d 2d2d  .    //---------
+00010c90: 2d20 5072 6f63 6573 7320 3220 2a20 4c68  - Process 2 * Lh
+00010ca0: 7350 726f 6772 6573 7320 726f 7773 2061  sProgress rows a
+00010cb0: 7420 6f6e 6365 202d 2d2d 2d2d 2d2d 2d2d  t once ---------
+00010cc0: 2d0a 2020 2020 6966 286d 723e 3d32 2a54  -.    if(mr>=2*T
+00010cd0: 7261 6974 733a 3a4c 6873 5072 6f67 7265  raits::LhsProgre
+00010ce0: 7373 290a 2020 2020 7b0a 2020 2020 2020  ss).    {.      
+00010cf0: 636f 6e73 7420 496e 6465 7820 6c31 203d  const Index l1 =
+00010d00: 2064 6566 6175 6c74 4c31 4361 6368 6553   defaultL1CacheS
+00010d10: 697a 653b 202f 2f20 696e 2042 7974 6573  ize; // in Bytes
+00010d20: 2c20 544f 444f 2c20 6c31 2073 686f 756c  , TODO, l1 shoul
+00010d30: 6420 6265 2070 6173 7365 6420 746f 2074  d be passed to t
+00010d40: 6869 7320 6675 6e63 7469 6f6e 2e0a 2020  his function..  
+00010d50: 2020 2020 2f2f 2054 6865 206d 6178 2831      // The max(1
+00010d60: 2c20 2e2e 2e29 2068 6572 6520 6973 206e  , ...) here is n
+00010d70: 6565 6465 6420 6265 6361 7573 6520 7765  eeded because we
+00010d80: 206d 6179 2062 6520 7573 696e 6720 626c   may be using bl
+00010d90: 6f63 6b69 6e67 2070 6172 616d 7320 6c61  ocking params la
+00010da0: 7267 6572 2074 6861 6e20 7768 6174 206f  rger than what o
+00010db0: 7572 206b 6e6f 776e 206c 3120 6361 6368  ur known l1 cach
+00010dc0: 6520 7369 7a65 0a20 2020 2020 202f 2f20  e size.      // 
+00010dd0: 7375 6767 6573 7473 2077 6520 7368 6f75  suggests we shou
+00010de0: 6c64 2062 6520 7573 696e 673a 2065 6974  ld be using: eit
+00010df0: 6865 7220 6265 6361 7573 6520 6f75 7220  her because our 
+00010e00: 6b6e 6f77 6e20 6c31 2063 6163 6865 2073  known l1 cache s
+00010e10: 697a 6520 6973 2069 6e61 6363 7572 6174  ize is inaccurat
+00010e20: 6520 2865 2e67 2e20 6f6e 2041 6e64 726f  e (e.g. on Andro
+00010e30: 6964 2c20 7765 2063 616e 206f 6e6c 7920  id, we can only 
+00010e40: 6775 6573 7329 2c0a 2020 2020 2020 2f2f  guess),.      //
+00010e50: 206f 7220 6265 6361 7573 6520 7765 2061   or because we a
+00010e60: 7265 2074 6573 7469 6e67 2073 7065 6369  re testing speci
+00010e70: 6669 6320 626c 6f63 6b69 6e67 2073 697a  fic blocking siz
+00010e80: 6573 2e0a 2020 2020 2020 496e 6465 7820  es..      Index 
+00010e90: 6163 7475 616c 5f70 616e 656c 5f72 6f77  actual_panel_row
+00010ea0: 7320 3d20 2832 2a4c 6873 5072 6f67 7265  s = (2*LhsProgre
+00010eb0: 7373 2920 2a20 7374 643a 3a6d 6178 3c49  ss) * std::max<I
+00010ec0: 6e64 6578 3e28 312c 2820 286c 3120 2d20  ndex>(1,( (l1 - 
+00010ed0: 7369 7a65 6f66 2852 6573 5363 616c 6172  sizeof(ResScalar
+00010ee0: 292a 6d72 2a6e 7220 2d20 6465 7074 682a  )*mr*nr - depth*
+00010ef0: 6e72 2a73 697a 656f 6628 5268 7353 6361  nr*sizeof(RhsSca
+00010f00: 6c61 7229 2920 2f20 2864 6570 7468 202a  lar)) / (depth *
+00010f10: 2073 697a 656f 6628 4c68 7353 6361 6c61   sizeof(LhsScala
+00010f20: 7229 202a 2032 2a4c 6873 5072 6f67 7265  r) * 2*LhsProgre
+00010f30: 7373 2920 2929 3b0a 0a20 2020 2020 2066  ss) ));..      f
+00010f40: 6f72 2849 6e64 6578 2069 313d 7065 656c  or(Index i1=peel
+00010f50: 6564 5f6d 6333 3b20 6931 3c70 6565 6c65  ed_mc3; i1<peele
+00010f60: 645f 6d63 323b 2069 312b 3d61 6374 7561  d_mc2; i1+=actua
+00010f70: 6c5f 7061 6e65 6c5f 726f 7773 290a 2020  l_panel_rows).  
+00010f80: 2020 2020 7b0a 2020 2020 2020 2020 496e      {.        In
+00010f90: 6465 7820 6163 7475 616c 5f70 616e 656c  dex actual_panel
+00010fa0: 5f65 6e64 203d 2028 7374 643a 3a6d 696e  _end = (std::min
+00010fb0: 2928 6931 2b61 6374 7561 6c5f 7061 6e65  )(i1+actual_pane
+00010fc0: 6c5f 726f 7773 2c20 7065 656c 6564 5f6d  l_rows, peeled_m
+00010fd0: 6332 293b 0a20 2020 2020 2020 2066 6f72  c2);.        for
+00010fe0: 2849 6e64 6578 206a 323d 303b 206a 323c  (Index j2=0; j2<
+00010ff0: 7061 636b 6574 5f63 6f6c 7334 3b20 6a32  packet_cols4; j2
+00011000: 2b3d 6e72 290a 2020 2020 2020 2020 7b0a  +=nr).        {.
+00011010: 2020 2020 2020 2020 2020 666f 7228 496e            for(In
+00011020: 6465 7820 693d 6931 3b20 693c 6163 7475  dex i=i1; i<actu
+00011030: 616c 5f70 616e 656c 5f65 6e64 3b20 692b  al_panel_end; i+
+00011040: 3d32 2a4c 6873 5072 6f67 7265 7373 290a  =2*LhsProgress).
+00011050: 2020 2020 2020 2020 2020 7b0a 2020 2020            {.    
+00011060: 2020 2020 2020 0a20 2020 2020 2020 2020        .         
+00011070: 202f 2f20 5765 2073 656c 6563 7465 6420   // We selected 
+00011080: 6120 322a 5472 6169 7473 3a3a 4c68 7350  a 2*Traits::LhsP
+00011090: 726f 6772 6573 7320 7820 6e72 206d 6963  rogress x nr mic
+000110a0: 726f 2062 6c6f 636b 206f 6620 7265 7320  ro block of res 
+000110b0: 7768 6963 6820 6973 2065 6e74 6972 656c  which is entirel
+000110c0: 790a 2020 2020 2020 2020 2020 2f2f 2073  y.          // s
+000110d0: 746f 7265 6420 696e 746f 2032 2078 206e  tored into 2 x n
+000110e0: 7220 7265 6769 7374 6572 732e 0a20 2020  r registers..   
+000110f0: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+00011100: 2020 636f 6e73 7420 4c68 7353 6361 6c61    const LhsScala
+00011110: 722a 2062 6c41 203d 2026 626c 6f63 6b41  r* blA = &blockA
+00011120: 5b69 2a73 7472 6964 6541 2b6f 6666 7365  [i*strideA+offse
+00011130: 7441 2a28 322a 5472 6169 7473 3a3a 4c68  tA*(2*Traits::Lh
+00011140: 7350 726f 6772 6573 7329 5d3b 0a20 2020  sProgress)];.   
+00011150: 2020 2020 2020 2070 7265 6665 7463 6828         prefetch(
+00011160: 2662 6c41 5b30 5d29 3b0a 0a20 2020 2020  &blA[0]);..     
+00011170: 2020 2020 202f 2f20 6765 7473 2072 6573       // gets res
+00011180: 2062 6c6f 636b 2061 7320 7265 6769 7374   block as regist
+00011190: 6572 0a20 2020 2020 2020 2020 2041 6363  er.          Acc
+000111a0: 5061 636b 6574 2043 302c 2043 312c 2043  Packet C0, C1, C
+000111b0: 322c 2043 332c 0a20 2020 2020 2020 2020  2, C3,.         
+000111c0: 2020 2020 2020 2020 2020 2043 342c 2043             C4, C
+000111d0: 352c 2043 362c 2043 373b 0a20 2020 2020  5, C6, C7;.     
+000111e0: 2020 2020 2074 7261 6974 732e 696e 6974       traits.init
+000111f0: 4163 6328 4330 293b 2074 7261 6974 732e  Acc(C0); traits.
+00011200: 696e 6974 4163 6328 4331 293b 2074 7261  initAcc(C1); tra
+00011210: 6974 732e 696e 6974 4163 6328 4332 293b  its.initAcc(C2);
+00011220: 2074 7261 6974 732e 696e 6974 4163 6328   traits.initAcc(
+00011230: 4333 293b 0a20 2020 2020 2020 2020 2074  C3);.          t
+00011240: 7261 6974 732e 696e 6974 4163 6328 4334  raits.initAcc(C4
+00011250: 293b 2074 7261 6974 732e 696e 6974 4163  ); traits.initAc
+00011260: 6328 4335 293b 2074 7261 6974 732e 696e  c(C5); traits.in
+00011270: 6974 4163 6328 4336 293b 2074 7261 6974  itAcc(C6); trait
+00011280: 732e 696e 6974 4163 6328 4337 293b 0a0a  s.initAcc(C7);..
+00011290: 2020 2020 2020 2020 2020 4c69 6e65 6172            Linear
+000112a0: 4d61 7070 6572 2072 3020 3d20 7265 732e  Mapper r0 = res.
+000112b0: 6765 744c 696e 6561 724d 6170 7065 7228  getLinearMapper(
+000112c0: 692c 206a 3220 2b20 3029 3b0a 2020 2020  i, j2 + 0);.    
+000112d0: 2020 2020 2020 4c69 6e65 6172 4d61 7070        LinearMapp
+000112e0: 6572 2072 3120 3d20 7265 732e 6765 744c  er r1 = res.getL
+000112f0: 696e 6561 724d 6170 7065 7228 692c 206a  inearMapper(i, j
+00011300: 3220 2b20 3129 3b0a 2020 2020 2020 2020  2 + 1);.        
+00011310: 2020 4c69 6e65 6172 4d61 7070 6572 2072    LinearMapper r
+00011320: 3220 3d20 7265 732e 6765 744c 696e 6561  2 = res.getLinea
+00011330: 724d 6170 7065 7228 692c 206a 3220 2b20  rMapper(i, j2 + 
+00011340: 3229 3b0a 2020 2020 2020 2020 2020 4c69  2);.          Li
+00011350: 6e65 6172 4d61 7070 6572 2072 3320 3d20  nearMapper r3 = 
+00011360: 7265 732e 6765 744c 696e 6561 724d 6170  res.getLinearMap
+00011370: 7065 7228 692c 206a 3220 2b20 3329 3b0a  per(i, j2 + 3);.
+00011380: 0a20 2020 2020 2020 2020 2072 302e 7072  .          r0.pr
+00011390: 6566 6574 6368 2870 7265 6665 7463 685f  efetch(prefetch_
+000113a0: 7265 735f 6f66 6673 6574 293b 0a20 2020  res_offset);.   
+000113b0: 2020 2020 2020 2072 312e 7072 6566 6574         r1.prefet
+000113c0: 6368 2870 7265 6665 7463 685f 7265 735f  ch(prefetch_res_
+000113d0: 6f66 6673 6574 293b 0a20 2020 2020 2020  offset);.       
+000113e0: 2020 2072 322e 7072 6566 6574 6368 2870     r2.prefetch(p
+000113f0: 7265 6665 7463 685f 7265 735f 6f66 6673  refetch_res_offs
+00011400: 6574 293b 0a20 2020 2020 2020 2020 2072  et);.          r
+00011410: 332e 7072 6566 6574 6368 2870 7265 6665  3.prefetch(prefe
+00011420: 7463 685f 7265 735f 6f66 6673 6574 293b  tch_res_offset);
+00011430: 0a0a 2020 2020 2020 2020 2020 2f2f 2070  ..          // p
+00011440: 6572 666f 726d 7320 2269 6e6e 6572 2220  erforms "inner" 
+00011450: 7072 6f64 7563 7473 0a20 2020 2020 2020  products.       
+00011460: 2020 2063 6f6e 7374 2052 6873 5363 616c     const RhsScal
+00011470: 6172 2a20 626c 4220 3d20 2662 6c6f 636b  ar* blB = &block
+00011480: 425b 6a32 2a73 7472 6964 6542 2b6f 6666  B[j2*strideB+off
+00011490: 7365 7442 2a6e 725d 3b0a 2020 2020 2020  setB*nr];.      
+000114a0: 2020 2020 7072 6566 6574 6368 2826 626c      prefetch(&bl
+000114b0: 425b 305d 293b 0a20 2020 2020 2020 2020  B[0]);.         
+000114c0: 204c 6873 5061 636b 6574 2041 302c 2041   LhsPacket A0, A
+000114d0: 313b 0a0a 2020 2020 2020 2020 2020 666f  1;..          fo
+000114e0: 7228 496e 6465 7820 6b3d 303b 206b 3c70  r(Index k=0; k<p
+000114f0: 6565 6c65 645f 6b63 3b20 6b2b 3d70 6b29  eeled_kc; k+=pk)
+00011500: 0a20 2020 2020 2020 2020 207b 0a20 2020  .          {.   
+00011510: 2020 2020 2020 2020 2045 4947 454e 5f41           EIGEN_A
+00011520: 534d 5f43 4f4d 4d45 4e54 2822 6265 6769  SM_COMMENT("begi
+00011530: 6e20 6765 6270 206d 6963 726f 206b 6572  n gebp micro ker
+00011540: 6e65 6c20 3270 5834 2229 3b0a 2020 2020  nel 2pX4");.    
+00011550: 2020 2020 2020 2020 5268 7350 6163 6b65          RhsPacke
+00011560: 7478 3420 7268 735f 7061 6e65 6c3b 0a20  tx4 rhs_panel;. 
+00011570: 2020 2020 2020 2020 2020 2052 6873 5061             RhsPa
+00011580: 636b 6574 2054 303b 0a0a 2020 2020 2020  cket T0;..      
+00011590: 2020 2020 2f2f 204e 4f54 453a 2074 6865      // NOTE: the
+000115a0: 2062 6567 696e 2f65 6e64 2061 736d 2063   begin/end asm c
+000115b0: 6f6d 6d65 6e74 7320 6265 6c6f 7720 776f  omments below wo
+000115c0: 726b 2061 726f 756e 6420 6275 6720 3933  rk around bug 93
+000115d0: 3521 0a20 2020 2020 2020 2020 202f 2f20  5!.          // 
+000115e0: 6275 7420 7468 6579 2061 7265 206e 6f74  but they are not
+000115f0: 2065 6e6f 7567 6820 666f 7220 6763 633e   enough for gcc>
+00011600: 3d36 2077 6974 686f 7574 2046 4d41 2028  =6 without FMA (
+00011610: 6275 6720 3136 3337 290a 2020 2020 2020  bug 1637).      
+00011620: 2020 2020 2369 6620 4549 4745 4e5f 474e      #if EIGEN_GN
+00011630: 5543 5f41 545f 4c45 4153 5428 362c 3029  UC_AT_LEAST(6,0)
+00011640: 2026 2620 6465 6669 6e65 6428 4549 4745   && defined(EIGE
+00011650: 4e5f 5645 4354 4f52 495a 455f 5353 4529  N_VECTORIZE_SSE)
+00011660: 0a20 2020 2020 2020 2020 2020 2023 6465  .            #de
+00011670: 6669 6e65 2045 4947 454e 5f47 4542 505f  fine EIGEN_GEBP_
+00011680: 3250 5834 5f53 5049 4c4c 494e 475f 574f  2PX4_SPILLING_WO
+00011690: 524b 4152 4f55 4e44 205f 5f61 736d 5f5f  RKAROUND __asm__
+000116a0: 2020 2822 2220 3a20 5b61 305d 2022 2b78    ("" : [a0] "+x
+000116b0: 2c6d 2220 2841 3029 2c5b 6131 5d20 222b  ,m" (A0),[a1] "+
+000116c0: 782c 6d22 2028 4131 2929 3b0a 2020 2020  x,m" (A1));.    
+000116d0: 2020 2020 2020 2365 6c73 650a 2020 2020        #else.    
+000116e0: 2020 2020 2020 2020 2364 6566 696e 6520          #define 
+000116f0: 4549 4745 4e5f 4745 4250 5f32 5058 345f  EIGEN_GEBP_2PX4_
+00011700: 5350 494c 4c49 4e47 5f57 4f52 4b41 524f  SPILLING_WORKARO
+00011710: 554e 440a 2020 2020 2020 2020 2020 2365  UND.          #e
+00011720: 6e64 6966 0a23 6465 6669 6e65 2045 4947  ndif.#define EIG
+00011730: 454e 5f47 4542 4750 5f4f 4e45 5354 4550  EN_GEBGP_ONESTEP
+00011740: 284b 2920 2020 2020 2020 2020 2020 2020  (K)             
+00011750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011760: 2020 2020 2020 2020 2020 2020 2020 205c                 \
+00011770: 0a20 2020 2020 2020 2020 2020 2064 6f20  .            do 
+00011780: 7b20 2020 2020 2020 2020 2020 2020 2020  {               
+00011790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000117a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000117b0: 2020 2020 2020 2020 2020 205c 0a20 2020             \.   
+000117c0: 2020 2020 2020 2020 2020 2045 4947 454e             EIGEN
+000117d0: 5f41 534d 5f43 4f4d 4d45 4e54 2822 6265  _ASM_COMMENT("be
+000117e0: 6769 6e20 7374 6570 206f 6620 6765 6270  gin step of gebp
+000117f0: 206d 6963 726f 206b 6572 6e65 6c20 3270   micro kernel 2p
+00011800: 5834 2229 3b20 205c 0a20 2020 2020 2020  X4");  \.       
+00011810: 2020 2020 2020 2074 7261 6974 732e 6c6f         traits.lo
+00011820: 6164 4c68 7328 2662 6c41 5b28 3020 2b20  adLhs(&blA[(0 + 
+00011830: 3220 2a20 4b29 202a 204c 6873 5072 6f67  2 * K) * LhsProg
+00011840: 7265 7373 5d2c 2041 3029 3b20 2020 2020  ress], A0);     
+00011850: 2020 205c 0a20 2020 2020 2020 2020 2020     \.           
+00011860: 2020 2074 7261 6974 732e 6c6f 6164 4c68     traits.loadLh
+00011870: 7328 2662 6c41 5b28 3120 2b20 3220 2a20  s(&blA[(1 + 2 * 
+00011880: 4b29 202a 204c 6873 5072 6f67 7265 7373  K) * LhsProgress
+00011890: 5d2c 2041 3129 3b20 2020 2020 2020 205c  ], A1);        \
+000118a0: 0a20 2020 2020 2020 2020 2020 2020 2074  .              t
+000118b0: 7261 6974 732e 6c6f 6164 5268 7328 2662  raits.loadRhs(&b
+000118c0: 6c42 5b28 3020 2b20 3420 2a20 4b29 202a  lB[(0 + 4 * K) *
+000118d0: 2052 6873 5072 6f67 7265 7373 5d2c 2072   RhsProgress], r
+000118e0: 6873 5f70 616e 656c 293b 205c 0a20 2020  hs_panel); \.   
+000118f0: 2020 2020 2020 2020 2020 2074 7261 6974             trait
+00011900: 732e 6d61 6464 2841 302c 2072 6873 5f70  s.madd(A0, rhs_p
+00011910: 616e 656c 2c20 4330 2c20 5430 2c20 6669  anel, C0, T0, fi
+00011920: 783c 303e 293b 2020 2020 2020 2020 2020  x<0>);          
+00011930: 2020 2020 2020 205c 0a20 2020 2020 2020         \.       
+00011940: 2020 2020 2020 2074 7261 6974 732e 6d61         traits.ma
+00011950: 6464 2841 312c 2072 6873 5f70 616e 656c  dd(A1, rhs_panel
+00011960: 2c20 4334 2c20 5430 2c20 6669 783c 303e  , C4, T0, fix<0>
+00011970: 293b 2020 2020 2020 2020 2020 2020 2020  );              
+00011980: 2020 205c 0a20 2020 2020 2020 2020 2020     \.           
+00011990: 2020 2074 7261 6974 732e 6d61 6464 2841     traits.madd(A
+000119a0: 302c 2072 6873 5f70 616e 656c 2c20 4331  0, rhs_panel, C1
+000119b0: 2c20 5430 2c20 6669 783c 313e 293b 2020  , T0, fix<1>);  
+000119c0: 2020 2020 2020 2020 2020 2020 2020 205c                 \
+000119d0: 0a20 2020 2020 2020 2020 2020 2020 2074  .              t
+000119e0: 7261 6974 732e 6d61 6464 2841 312c 2072  raits.madd(A1, r
+000119f0: 6873 5f70 616e 656c 2c20 4335 2c20 5430  hs_panel, C5, T0
+00011a00: 2c20 6669 783c 313e 293b 2020 2020 2020  , fix<1>);      
+00011a10: 2020 2020 2020 2020 2020 205c 0a20 2020             \.   
+00011a20: 2020 2020 2020 2020 2020 2074 7261 6974             trait
+00011a30: 732e 6d61 6464 2841 302c 2072 6873 5f70  s.madd(A0, rhs_p
+00011a40: 616e 656c 2c20 4332 2c20 5430 2c20 6669  anel, C2, T0, fi
+00011a50: 783c 323e 293b 2020 2020 2020 2020 2020  x<2>);          
+00011a60: 2020 2020 2020 205c 0a20 2020 2020 2020         \.       
+00011a70: 2020 2020 2020 2074 7261 6974 732e 6d61         traits.ma
+00011a80: 6464 2841 312c 2072 6873 5f70 616e 656c  dd(A1, rhs_panel
+00011a90: 2c20 4336 2c20 5430 2c20 6669 783c 323e  , C6, T0, fix<2>
+00011aa0: 293b 2020 2020 2020 2020 2020 2020 2020  );              
+00011ab0: 2020 205c 0a20 2020 2020 2020 2020 2020     \.           
+00011ac0: 2020 2074 7261 6974 732e 6d61 6464 2841     traits.madd(A
+00011ad0: 302c 2072 6873 5f70 616e 656c 2c20 4333  0, rhs_panel, C3
+00011ae0: 2c20 5430 2c20 6669 783c 333e 293b 2020  , T0, fix<3>);  
+00011af0: 2020 2020 2020 2020 2020 2020 2020 205c                 \
+00011b00: 0a20 2020 2020 2020 2020 2020 2020 2074  .              t
+00011b10: 7261 6974 732e 6d61 6464 2841 312c 2072  raits.madd(A1, r
+00011b20: 6873 5f70 616e 656c 2c20 4337 2c20 5430  hs_panel, C7, T0
+00011b30: 2c20 6669 783c 333e 293b 2020 2020 2020  , fix<3>);      
+00011b40: 2020 2020 2020 2020 2020 205c 0a20 2020             \.   
+00011b50: 2020 2020 2020 2020 2020 2045 4947 454e             EIGEN
+00011b60: 5f47 4542 505f 3250 5834 5f53 5049 4c4c  _GEBP_2PX4_SPILL
+00011b70: 494e 475f 574f 524b 4152 4f55 4e44 2020  ING_WORKAROUND  
+00011b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011b90: 2020 2020 2020 205c 0a20 2020 2020 2020         \.       
+00011ba0: 2020 2020 2020 2045 4947 454e 5f41 534d         EIGEN_ASM
+00011bb0: 5f43 4f4d 4d45 4e54 2822 656e 6420 7374  _COMMENT("end st
+00011bc0: 6570 206f 6620 6765 6270 206d 6963 726f  ep of gebp micro
+00011bd0: 206b 6572 6e65 6c20 3270 5834 2229 3b20   kernel 2pX4"); 
+00011be0: 2020 205c 0a20 2020 2020 2020 2020 2020     \.           
+00011bf0: 207d 2077 6869 6c65 2028 6661 6c73 6529   } while (false)
+00011c00: 0a0a 2020 2020 2020 2020 2020 2020 696e  ..            in
+00011c10: 7465 726e 616c 3a3a 7072 6566 6574 6368  ternal::prefetch
+00011c20: 2862 6c42 2b28 3438 2b30 2929 3b0a 2020  (blB+(48+0));.  
+00011c30: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
+00011c40: 4745 4247 505f 4f4e 4553 5445 5028 3029  GEBGP_ONESTEP(0)
+00011c50: 3b0a 2020 2020 2020 2020 2020 2020 4549  ;.            EI
+00011c60: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
+00011c70: 5028 3129 3b0a 2020 2020 2020 2020 2020  P(1);.          
+00011c80: 2020 4549 4745 4e5f 4745 4247 505f 4f4e    EIGEN_GEBGP_ON
+00011c90: 4553 5445 5028 3229 3b0a 2020 2020 2020  ESTEP(2);.      
+00011ca0: 2020 2020 2020 4549 4745 4e5f 4745 4247        EIGEN_GEBG
+00011cb0: 505f 4f4e 4553 5445 5028 3329 3b0a 2020  P_ONESTEP(3);.  
+00011cc0: 2020 2020 2020 2020 2020 696e 7465 726e            intern
+00011cd0: 616c 3a3a 7072 6566 6574 6368 2862 6c42  al::prefetch(blB
+00011ce0: 2b28 3438 2b31 3629 293b 0a20 2020 2020  +(48+16));.     
+00011cf0: 2020 2020 2020 2045 4947 454e 5f47 4542         EIGEN_GEB
+00011d00: 4750 5f4f 4e45 5354 4550 2834 293b 0a20  GP_ONESTEP(4);. 
+00011d10: 2020 2020 2020 2020 2020 2045 4947 454e             EIGEN
+00011d20: 5f47 4542 4750 5f4f 4e45 5354 4550 2835  _GEBGP_ONESTEP(5
+00011d30: 293b 0a20 2020 2020 2020 2020 2020 2045  );.            E
+00011d40: 4947 454e 5f47 4542 4750 5f4f 4e45 5354  IGEN_GEBGP_ONEST
+00011d50: 4550 2836 293b 0a20 2020 2020 2020 2020  EP(6);.         
+00011d60: 2020 2045 4947 454e 5f47 4542 4750 5f4f     EIGEN_GEBGP_O
+00011d70: 4e45 5354 4550 2837 293b 0a0a 2020 2020  NESTEP(7);..    
+00011d80: 2020 2020 2020 2020 626c 4220 2b3d 2070          blB += p
+00011d90: 6b2a 342a 5268 7350 726f 6772 6573 733b  k*4*RhsProgress;
+00011da0: 0a20 2020 2020 2020 2020 2020 2062 6c41  .            blA
+00011db0: 202b 3d20 706b 2a28 322a 5472 6169 7473   += pk*(2*Traits
+00011dc0: 3a3a 4c68 7350 726f 6772 6573 7329 3b0a  ::LhsProgress);.
+00011dd0: 0a20 2020 2020 2020 2020 2020 2045 4947  .            EIG
+00011de0: 454e 5f41 534d 5f43 4f4d 4d45 4e54 2822  EN_ASM_COMMENT("
+00011df0: 656e 6420 6765 6270 206d 6963 726f 206b  end gebp micro k
+00011e00: 6572 6e65 6c20 3270 5834 2229 3b0a 2020  ernel 2pX4");.  
+00011e10: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00011e20: 2020 2020 2f2f 2070 726f 6365 7373 2072      // process r
+00011e30: 656d 6169 6e69 6e67 2070 6565 6c65 6420  emaining peeled 
+00011e40: 6c6f 6f70 0a20 2020 2020 2020 2020 2066  loop.          f
+00011e50: 6f72 2849 6e64 6578 206b 3d70 6565 6c65  or(Index k=peele
+00011e60: 645f 6b63 3b20 6b3c 6465 7074 683b 206b  d_kc; k<depth; k
+00011e70: 2b2b 290a 2020 2020 2020 2020 2020 7b0a  ++).          {.
+00011e80: 2020 2020 2020 2020 2020 2020 5268 7350              RhsP
+00011e90: 6163 6b65 7478 3420 7268 735f 7061 6e65  acketx4 rhs_pane
+00011ea0: 6c3b 0a20 2020 2020 2020 2020 2020 2052  l;.            R
+00011eb0: 6873 5061 636b 6574 2054 303b 0a20 2020  hsPacket T0;.   
+00011ec0: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
+00011ed0: 4542 4750 5f4f 4e45 5354 4550 2830 293b  EBGP_ONESTEP(0);
+00011ee0: 0a20 2020 2020 2020 2020 2020 2062 6c42  .            blB
+00011ef0: 202b 3d20 342a 5268 7350 726f 6772 6573   += 4*RhsProgres
+00011f00: 733b 0a20 2020 2020 2020 2020 2020 2062  s;.            b
+00011f10: 6c41 202b 3d20 322a 5472 6169 7473 3a3a  lA += 2*Traits::
+00011f20: 4c68 7350 726f 6772 6573 733b 0a20 2020  LhsProgress;.   
+00011f30: 2020 2020 2020 207d 0a23 756e 6465 6620         }.#undef 
+00011f40: 4549 4745 4e5f 4745 4247 505f 4f4e 4553  EIGEN_GEBGP_ONES
+00011f50: 5445 500a 0a20 2020 2020 2020 2020 2052  TEP..          R
+00011f60: 6573 5061 636b 6574 2052 302c 2052 312c  esPacket R0, R1,
+00011f70: 2052 322c 2052 333b 0a20 2020 2020 2020   R2, R3;.       
+00011f80: 2020 2052 6573 5061 636b 6574 2061 6c70     ResPacket alp
+00011f90: 6861 7620 3d20 7073 6574 313c 5265 7350  hav = pset1<ResP
+00011fa0: 6163 6b65 743e 2861 6c70 6861 293b 0a0a  acket>(alpha);..
+00011fb0: 2020 2020 2020 2020 2020 5230 203d 2072            R0 = r
+00011fc0: 302e 7465 6d70 6c61 7465 206c 6f61 6450  0.template loadP
+00011fd0: 6163 6b65 743c 5265 7350 6163 6b65 743e  acket<ResPacket>
+00011fe0: 2830 202a 2054 7261 6974 733a 3a52 6573  (0 * Traits::Res
+00011ff0: 5061 636b 6574 5369 7a65 293b 0a20 2020  PacketSize);.   
+00012000: 2020 2020 2020 2052 3120 3d20 7230 2e74         R1 = r0.t
+00012010: 656d 706c 6174 6520 6c6f 6164 5061 636b  emplate loadPack
+00012020: 6574 3c52 6573 5061 636b 6574 3e28 3120  et<ResPacket>(1 
+00012030: 2a20 5472 6169 7473 3a3a 5265 7350 6163  * Traits::ResPac
+00012040: 6b65 7453 697a 6529 3b0a 2020 2020 2020  ketSize);.      
+00012050: 2020 2020 5232 203d 2072 312e 7465 6d70      R2 = r1.temp
+00012060: 6c61 7465 206c 6f61 6450 6163 6b65 743c  late loadPacket<
+00012070: 5265 7350 6163 6b65 743e 2830 202a 2054  ResPacket>(0 * T
+00012080: 7261 6974 733a 3a52 6573 5061 636b 6574  raits::ResPacket
+00012090: 5369 7a65 293b 0a20 2020 2020 2020 2020  Size);.         
+000120a0: 2052 3320 3d20 7231 2e74 656d 706c 6174   R3 = r1.templat
+000120b0: 6520 6c6f 6164 5061 636b 6574 3c52 6573  e loadPacket<Res
+000120c0: 5061 636b 6574 3e28 3120 2a20 5472 6169  Packet>(1 * Trai
+000120d0: 7473 3a3a 5265 7350 6163 6b65 7453 697a  ts::ResPacketSiz
+000120e0: 6529 3b0a 2020 2020 2020 2020 2020 7472  e);.          tr
+000120f0: 6169 7473 2e61 6363 2843 302c 2061 6c70  aits.acc(C0, alp
+00012100: 6861 762c 2052 3029 3b0a 2020 2020 2020  hav, R0);.      
+00012110: 2020 2020 7472 6169 7473 2e61 6363 2843      traits.acc(C
+00012120: 342c 2061 6c70 6861 762c 2052 3129 3b0a  4, alphav, R1);.
+00012130: 2020 2020 2020 2020 2020 7472 6169 7473            traits
+00012140: 2e61 6363 2843 312c 2061 6c70 6861 762c  .acc(C1, alphav,
+00012150: 2052 3229 3b0a 2020 2020 2020 2020 2020   R2);.          
+00012160: 7472 6169 7473 2e61 6363 2843 352c 2061  traits.acc(C5, a
+00012170: 6c70 6861 762c 2052 3329 3b0a 2020 2020  lphav, R3);.    
+00012180: 2020 2020 2020 7230 2e73 746f 7265 5061        r0.storePa
+00012190: 636b 6574 2830 202a 2054 7261 6974 733a  cket(0 * Traits:
+000121a0: 3a52 6573 5061 636b 6574 5369 7a65 2c20  :ResPacketSize, 
+000121b0: 5230 293b 0a20 2020 2020 2020 2020 2072  R0);.          r
+000121c0: 302e 7374 6f72 6550 6163 6b65 7428 3120  0.storePacket(1 
+000121d0: 2a20 5472 6169 7473 3a3a 5265 7350 6163  * Traits::ResPac
+000121e0: 6b65 7453 697a 652c 2052 3129 3b0a 2020  ketSize, R1);.  
+000121f0: 2020 2020 2020 2020 7231 2e73 746f 7265          r1.store
+00012200: 5061 636b 6574 2830 202a 2054 7261 6974  Packet(0 * Trait
+00012210: 733a 3a52 6573 5061 636b 6574 5369 7a65  s::ResPacketSize
+00012220: 2c20 5232 293b 0a20 2020 2020 2020 2020  , R2);.         
+00012230: 2072 312e 7374 6f72 6550 6163 6b65 7428   r1.storePacket(
+00012240: 3120 2a20 5472 6169 7473 3a3a 5265 7350  1 * Traits::ResP
+00012250: 6163 6b65 7453 697a 652c 2052 3329 3b0a  acketSize, R3);.
+00012260: 0a20 2020 2020 2020 2020 2052 3020 3d20  .          R0 = 
+00012270: 7232 2e74 656d 706c 6174 6520 6c6f 6164  r2.template load
+00012280: 5061 636b 6574 3c52 6573 5061 636b 6574  Packet<ResPacket
+00012290: 3e28 3020 2a20 5472 6169 7473 3a3a 5265  >(0 * Traits::Re
+000122a0: 7350 6163 6b65 7453 697a 6529 3b0a 2020  sPacketSize);.  
+000122b0: 2020 2020 2020 2020 5231 203d 2072 322e          R1 = r2.
+000122c0: 7465 6d70 6c61 7465 206c 6f61 6450 6163  template loadPac
+000122d0: 6b65 743c 5265 7350 6163 6b65 743e 2831  ket<ResPacket>(1
+000122e0: 202a 2054 7261 6974 733a 3a52 6573 5061   * Traits::ResPa
+000122f0: 636b 6574 5369 7a65 293b 0a20 2020 2020  cketSize);.     
+00012300: 2020 2020 2052 3220 3d20 7233 2e74 656d       R2 = r3.tem
+00012310: 706c 6174 6520 6c6f 6164 5061 636b 6574  plate loadPacket
+00012320: 3c52 6573 5061 636b 6574 3e28 3020 2a20  <ResPacket>(0 * 
+00012330: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
+00012340: 7453 697a 6529 3b0a 2020 2020 2020 2020  tSize);.        
+00012350: 2020 5233 203d 2072 332e 7465 6d70 6c61    R3 = r3.templa
+00012360: 7465 206c 6f61 6450 6163 6b65 743c 5265  te loadPacket<Re
+00012370: 7350 6163 6b65 743e 2831 202a 2054 7261  sPacket>(1 * Tra
+00012380: 6974 733a 3a52 6573 5061 636b 6574 5369  its::ResPacketSi
+00012390: 7a65 293b 0a20 2020 2020 2020 2020 2074  ze);.          t
+000123a0: 7261 6974 732e 6163 6328 4332 2c20 2061  raits.acc(C2,  a
+000123b0: 6c70 6861 762c 2052 3029 3b0a 2020 2020  lphav, R0);.    
+000123c0: 2020 2020 2020 7472 6169 7473 2e61 6363        traits.acc
+000123d0: 2843 362c 2020 616c 7068 6176 2c20 5231  (C6,  alphav, R1
+000123e0: 293b 0a20 2020 2020 2020 2020 2074 7261  );.          tra
+000123f0: 6974 732e 6163 6328 4333 2c20 2061 6c70  its.acc(C3,  alp
+00012400: 6861 762c 2052 3229 3b0a 2020 2020 2020  hav, R2);.      
+00012410: 2020 2020 7472 6169 7473 2e61 6363 2843      traits.acc(C
+00012420: 372c 2020 616c 7068 6176 2c20 5233 293b  7,  alphav, R3);
+00012430: 0a20 2020 2020 2020 2020 2072 322e 7374  .          r2.st
+00012440: 6f72 6550 6163 6b65 7428 3020 2a20 5472  orePacket(0 * Tr
+00012450: 6169 7473 3a3a 5265 7350 6163 6b65 7453  aits::ResPacketS
+00012460: 697a 652c 2052 3029 3b0a 2020 2020 2020  ize, R0);.      
+00012470: 2020 2020 7232 2e73 746f 7265 5061 636b      r2.storePack
+00012480: 6574 2831 202a 2054 7261 6974 733a 3a52  et(1 * Traits::R
+00012490: 6573 5061 636b 6574 5369 7a65 2c20 5231  esPacketSize, R1
+000124a0: 293b 0a20 2020 2020 2020 2020 2072 332e  );.          r3.
+000124b0: 7374 6f72 6550 6163 6b65 7428 3020 2a20  storePacket(0 * 
+000124c0: 5472 6169 7473 3a3a 5265 7350 6163 6b65  Traits::ResPacke
+000124d0: 7453 697a 652c 2052 3229 3b0a 2020 2020  tSize, R2);.    
+000124e0: 2020 2020 2020 7233 2e73 746f 7265 5061        r3.storePa
+000124f0: 636b 6574 2831 202a 2054 7261 6974 733a  cket(1 * Traits:
+00012500: 3a52 6573 5061 636b 6574 5369 7a65 2c20  :ResPacketSize, 
+00012510: 5233 293b 0a20 2020 2020 2020 2020 207d  R3);.          }
+00012520: 0a20 2020 2020 2020 207d 0a20 2020 2020  .        }.     
+00012530: 200a 2020 2020 2020 2020 2f2f 2044 6561   .        // Dea
+00012540: 6c20 7769 7468 2072 656d 6169 6e69 6e67  l with remaining
+00012550: 2063 6f6c 756d 6e73 206f 6620 7468 6520   columns of the 
+00012560: 7268 730a 2020 2020 2020 2020 666f 7228  rhs.        for(
+00012570: 496e 6465 7820 6a32 3d70 6163 6b65 745f  Index j2=packet_
+00012580: 636f 6c73 343b 206a 323c 636f 6c73 3b20  cols4; j2<cols; 
+00012590: 6a32 2b2b 290a 2020 2020 2020 2020 7b0a  j2++).        {.
+000125a0: 2020 2020 2020 2020 2020 666f 7228 496e            for(In
+000125b0: 6465 7820 693d 6931 3b20 693c 6163 7475  dex i=i1; i<actu
+000125c0: 616c 5f70 616e 656c 5f65 6e64 3b20 692b  al_panel_end; i+
+000125d0: 3d32 2a4c 6873 5072 6f67 7265 7373 290a  =2*LhsProgress).
+000125e0: 2020 2020 2020 2020 2020 7b0a 2020 2020            {.    
+000125f0: 2020 2020 2020 2f2f 204f 6e65 2063 6f6c        // One col
+00012600: 756d 6e20 6174 2061 2074 696d 650a 2020  umn at a time.  
+00012610: 2020 2020 2020 2020 636f 6e73 7420 4c68          const Lh
+00012620: 7353 6361 6c61 722a 2062 6c41 203d 2026  sScalar* blA = &
+00012630: 626c 6f63 6b41 5b69 2a73 7472 6964 6541  blockA[i*strideA
+00012640: 2b6f 6666 7365 7441 2a28 322a 5472 6169  +offsetA*(2*Trai
+00012650: 7473 3a3a 4c68 7350 726f 6772 6573 7329  ts::LhsProgress)
+00012660: 5d3b 0a20 2020 2020 2020 2020 2070 7265  ];.          pre
+00012670: 6665 7463 6828 2662 6c41 5b30 5d29 3b0a  fetch(&blA[0]);.
+00012680: 0a20 2020 2020 2020 2020 202f 2f20 6765  .          // ge
+00012690: 7473 2072 6573 2062 6c6f 636b 2061 7320  ts res block as 
+000126a0: 7265 6769 7374 6572 0a20 2020 2020 2020  register.       
+000126b0: 2020 2041 6363 5061 636b 6574 2043 302c     AccPacket C0,
+000126c0: 2043 343b 0a20 2020 2020 2020 2020 2074   C4;.          t
+000126d0: 7261 6974 732e 696e 6974 4163 6328 4330  raits.initAcc(C0
+000126e0: 293b 0a20 2020 2020 2020 2020 2074 7261  );.          tra
+000126f0: 6974 732e 696e 6974 4163 6328 4334 293b  its.initAcc(C4);
+00012700: 0a0a 2020 2020 2020 2020 2020 4c69 6e65  ..          Line
+00012710: 6172 4d61 7070 6572 2072 3020 3d20 7265  arMapper r0 = re
+00012720: 732e 6765 744c 696e 6561 724d 6170 7065  s.getLinearMappe
+00012730: 7228 692c 206a 3229 3b0a 2020 2020 2020  r(i, j2);.      
+00012740: 2020 2020 7230 2e70 7265 6665 7463 6828      r0.prefetch(
+00012750: 7072 6566 6574 6368 5f72 6573 5f6f 6666  prefetch_res_off
+00012760: 7365 7429 3b0a 0a20 2020 2020 2020 2020  set);..         
+00012770: 202f 2f20 7065 7266 6f72 6d73 2022 696e   // performs "in
+00012780: 6e65 7222 2070 726f 6475 6374 730a 2020  ner" products.  
+00012790: 2020 2020 2020 2020 636f 6e73 7420 5268          const Rh
+000127a0: 7353 6361 6c61 722a 2062 6c42 203d 2026  sScalar* blB = &
+000127b0: 626c 6f63 6b42 5b6a 322a 7374 7269 6465  blockB[j2*stride
+000127c0: 422b 6f66 6673 6574 425d 3b0a 2020 2020  B+offsetB];.    
+000127d0: 2020 2020 2020 4c68 7350 6163 6b65 7420        LhsPacket 
+000127e0: 4130 2c20 4131 3b0a 0a20 2020 2020 2020  A0, A1;..       
+000127f0: 2020 2066 6f72 2849 6e64 6578 206b 3d30     for(Index k=0
+00012800: 3b20 6b3c 7065 656c 6564 5f6b 633b 206b  ; k<peeled_kc; k
+00012810: 2b3d 706b 290a 2020 2020 2020 2020 2020  +=pk).          
+00012820: 7b0a 2020 2020 2020 2020 2020 2020 4549  {.            EI
+00012830: 4745 4e5f 4153 4d5f 434f 4d4d 454e 5428  GEN_ASM_COMMENT(
+00012840: 2262 6567 696e 2067 6562 7020 6d69 6372  "begin gebp micr
+00012850: 6f20 6b65 726e 656c 2032 7058 3122 293b  o kernel 2pX1");
+00012860: 0a20 2020 2020 2020 2020 2020 2052 6873  .            Rhs
+00012870: 5061 636b 6574 2042 5f30 2c20 4231 3b0a  Packet B_0, B1;.
+00012880: 2020 2020 2020 2020 0a23 6465 6669 6e65          .#define
+00012890: 2045 4947 454e 5f47 4542 4750 5f4f 4e45   EIGEN_GEBGP_ONE
+000128a0: 5354 4550 284b 2920 5c0a 2020 2020 2020  STEP(K) \.      
+000128b0: 2020 2020 2020 646f 207b 2020 2020 2020        do {      
+000128c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000128d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000128e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000128f0: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
+00012900: 2020 2020 2020 2020 2020 2020 4549 4745              EIGE
+00012910: 4e5f 4153 4d5f 434f 4d4d 454e 5428 2262  N_ASM_COMMENT("b
+00012920: 6567 696e 2073 7465 7020 6f66 2067 6562  egin step of geb
+00012930: 7020 6d69 6372 6f20 6b65 726e 656c 2032  p micro kernel 2
+00012940: 7058 3122 293b 2020 2020 2020 2020 2020  pX1");          
+00012950: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00012960: 4549 4745 4e5f 4153 4d5f 434f 4d4d 454e  EIGEN_ASM_COMMEN
+00012970: 5428 224e 6f74 653a 2074 6865 7365 2061  T("Note: these a
+00012980: 736d 2063 6f6d 6d65 6e74 7320 776f 726b  sm comments work
+00012990: 2061 726f 756e 6420 6275 6720 3933 3521   around bug 935!
+000129a0: 2229 3b20 5c0a 2020 2020 2020 2020 2020  "); \.          
+000129b0: 2020 2020 7472 6169 7473 2e6c 6f61 644c      traits.loadL
+000129c0: 6873 2826 626c 415b 2830 2b32 2a4b 292a  hs(&blA[(0+2*K)*
+000129d0: 4c68 7350 726f 6772 6573 735d 2c20 4130  LhsProgress], A0
+000129e0: 293b 2020 2020 2020 2020 2020 2020 2020  );              
+000129f0: 2020 2020 2020 2020 5c0a 2020 2020 2020          \.      
+00012a00: 2020 2020 2020 2020 7472 6169 7473 2e6c          traits.l
+00012a10: 6f61 644c 6873 2826 626c 415b 2831 2b32  oadLhs(&blA[(1+2
+00012a20: 2a4b 292a 4c68 7350 726f 6772 6573 735d  *K)*LhsProgress]
+00012a30: 2c20 4131 293b 2020 2020 2020 2020 2020  , A1);          
+00012a40: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
+00012a50: 2020 2020 2020 2020 2020 2020 7472 6169              trai
+00012a60: 7473 2e6c 6f61 6452 6873 2826 626c 425b  ts.loadRhs(&blB[
+00012a70: 2830 2b4b 292a 5268 7350 726f 6772 6573  (0+K)*RhsProgres
+00012a80: 735d 2c20 425f 3029 3b20 2020 2020 2020  s], B_0);       
+00012a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012aa0: 5c0a 2020 2020 2020 2020 2020 2020 2020  \.              
+00012ab0: 7472 6169 7473 2e6d 6164 6428 4130 2c20  traits.madd(A0, 
+00012ac0: 425f 302c 2043 302c 2042 312c 2066 6978  B_0, C0, B1, fix
+00012ad0: 3c30 3e29 3b20 2020 2020 2020 2020 2020  <0>);           
+00012ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012af0: 2020 2020 5c0a 2020 2020 2020 2020 2020      \.          
+00012b00: 2020 2020 7472 6169 7473 2e6d 6164 6428      traits.madd(
+00012b10: 4131 2c20 425f 302c 2043 342c 2042 5f30  A1, B_0, C4, B_0
+00012b20: 2c20 6669 783c 303e 293b 2020 2020 2020  , fix<0>);      
+00012b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012b40: 2020 2020 2020 2020 5c0a 2020 2020 2020          \.      
+00012b50: 2020 2020 2020 2020 4549 4745 4e5f 4153          EIGEN_AS
+00012b60: 4d5f 434f 4d4d 454e 5428 2265 6e64 2073  M_COMMENT("end s
+00012b70: 7465 7020 6f66 2067 6562 7020 6d69 6372  tep of gebp micr
+00012b80: 6f20 6b65 726e 656c 2032 7058 3122 293b  o kernel 2pX1");
+00012b90: 2020 2020 2020 2020 2020 2020 5c0a 2020              \.  
+00012ba0: 2020 2020 2020 2020 2020 7d20 7768 696c            } whil
+00012bb0: 6528 6661 6c73 6529 0a20 2020 2020 2020  e(false).       
+00012bc0: 200a 2020 2020 2020 2020 2020 2020 4549   .            EI
+00012bd0: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
+00012be0: 5028 3029 3b0a 2020 2020 2020 2020 2020  P(0);.          
+00012bf0: 2020 4549 4745 4e5f 4745 4247 505f 4f4e    EIGEN_GEBGP_ON
+00012c00: 4553 5445 5028 3129 3b0a 2020 2020 2020  ESTEP(1);.      
+00012c10: 2020 2020 2020 4549 4745 4e5f 4745 4247        EIGEN_GEBG
+00012c20: 505f 4f4e 4553 5445 5028 3229 3b0a 2020  P_ONESTEP(2);.  
+00012c30: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
+00012c40: 4745 4247 505f 4f4e 4553 5445 5028 3329  GEBGP_ONESTEP(3)
+00012c50: 3b0a 2020 2020 2020 2020 2020 2020 4549  ;.            EI
+00012c60: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
+00012c70: 5028 3429 3b0a 2020 2020 2020 2020 2020  P(4);.          
+00012c80: 2020 4549 4745 4e5f 4745 4247 505f 4f4e    EIGEN_GEBGP_ON
+00012c90: 4553 5445 5028 3529 3b0a 2020 2020 2020  ESTEP(5);.      
+00012ca0: 2020 2020 2020 4549 4745 4e5f 4745 4247        EIGEN_GEBG
+00012cb0: 505f 4f4e 4553 5445 5028 3629 3b0a 2020  P_ONESTEP(6);.  
+00012cc0: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
+00012cd0: 4745 4247 505f 4f4e 4553 5445 5028 3729  GEBGP_ONESTEP(7)
+00012ce0: 3b0a 0a20 2020 2020 2020 2020 2020 2062  ;..            b
+00012cf0: 6c42 202b 3d20 696e 7428 706b 2920 2a20  lB += int(pk) * 
+00012d00: 696e 7428 5268 7350 726f 6772 6573 7329  int(RhsProgress)
+00012d10: 3b0a 2020 2020 2020 2020 2020 2020 626c  ;.            bl
+00012d20: 4120 2b3d 2069 6e74 2870 6b29 202a 2032  A += int(pk) * 2
+00012d30: 202a 2069 6e74 2854 7261 6974 733a 3a4c   * int(Traits::L
+00012d40: 6873 5072 6f67 7265 7373 293b 0a0a 2020  hsProgress);..  
+00012d50: 2020 2020 2020 2020 2020 4549 4745 4e5f            EIGEN_
+00012d60: 4153 4d5f 434f 4d4d 454e 5428 2265 6e64  ASM_COMMENT("end
+00012d70: 2067 6562 7020 6d69 6372 6f20 6b65 726e   gebp micro kern
+00012d80: 656c 2032 7058 3122 293b 0a20 2020 2020  el 2pX1");.     
+00012d90: 2020 2020 207d 0a0a 2020 2020 2020 2020       }..        
+00012da0: 2020 2f2f 2070 726f 6365 7373 2072 656d    // process rem
+00012db0: 6169 6e69 6e67 2070 6565 6c65 6420 6c6f  aining peeled lo
+00012dc0: 6f70 0a20 2020 2020 2020 2020 2066 6f72  op.          for
+00012dd0: 2849 6e64 6578 206b 3d70 6565 6c65 645f  (Index k=peeled_
+00012de0: 6b63 3b20 6b3c 6465 7074 683b 206b 2b2b  kc; k<depth; k++
+00012df0: 290a 2020 2020 2020 2020 2020 7b0a 2020  ).          {.  
+00012e00: 2020 2020 2020 2020 2020 5268 7350 6163            RhsPac
+00012e10: 6b65 7420 425f 302c 2042 313b 0a20 2020  ket B_0, B1;.   
+00012e20: 2020 2020 2020 2020 2045 4947 454e 5f47           EIGEN_G
+00012e30: 4542 4750 5f4f 4e45 5354 4550 2830 293b  EBGP_ONESTEP(0);
+00012e40: 0a20 2020 2020 2020 2020 2020 2062 6c42  .            blB
+00012e50: 202b 3d20 5268 7350 726f 6772 6573 733b   += RhsProgress;
+00012e60: 0a20 2020 2020 2020 2020 2020 2062 6c41  .            blA
+00012e70: 202b 3d20 322a 5472 6169 7473 3a3a 4c68   += 2*Traits::Lh
+00012e80: 7350 726f 6772 6573 733b 0a20 2020 2020  sProgress;.     
+00012e90: 2020 2020 207d 0a23 756e 6465 6620 4549       }.#undef EI
+00012ea0: 4745 4e5f 4745 4247 505f 4f4e 4553 5445  GEN_GEBGP_ONESTE
+00012eb0: 500a 2020 2020 2020 2020 2020 5265 7350  P.          ResP
+00012ec0: 6163 6b65 7420 5230 2c20 5231 3b0a 2020  acket R0, R1;.  
+00012ed0: 2020 2020 2020 2020 5265 7350 6163 6b65          ResPacke
+00012ee0: 7420 616c 7068 6176 203d 2070 7365 7431  t alphav = pset1
+00012ef0: 3c52 6573 5061 636b 6574 3e28 616c 7068  <ResPacket>(alph
+00012f00: 6129 3b0a 0a20 2020 2020 2020 2020 2052  a);..          R
+00012f10: 3020 3d20 7230 2e74 656d 706c 6174 6520  0 = r0.template 
+00012f20: 6c6f 6164 5061 636b 6574 3c52 6573 5061  loadPacket<ResPa
+00012f30: 636b 6574 3e28 3020 2a20 5472 6169 7473  cket>(0 * Traits
+00012f40: 3a3a 5265 7350 6163 6b65 7453 697a 6529  ::ResPacketSize)
+00012f50: 3b0a 2020 2020 2020 2020 2020 5231 203d  ;.          R1 =
+00012f60: 2072 302e 7465 6d70 6c61 7465 206c 6f61   r0.template loa
+00012f70: 6450 6163 6b65 743c 5265 7350 6163 6b65  dPacket<ResPacke
+00012f80: 743e 2831 202a 2054 7261 6974 733a 3a52  t>(1 * Traits::R
+00012f90: 6573 5061 636b 6574 5369 7a65 293b 0a20  esPacketSize);. 
+00012fa0: 2020 2020 2020 2020 2074 7261 6974 732e           traits.
+00012fb0: 6163 6328 4330 2c20 616c 7068 6176 2c20  acc(C0, alphav, 
+00012fc0: 5230 293b 0a20 2020 2020 2020 2020 2074  R0);.          t
+00012fd0: 7261 6974 732e 6163 6328 4334 2c20 616c  raits.acc(C4, al
+00012fe0: 7068 6176 2c20 5231 293b 0a20 2020 2020  phav, R1);.     
+00012ff0: 2020 2020 2072 302e 7374 6f72 6550 6163       r0.storePac
+00013000: 6b65 7428 3020 2a20 5472 6169 7473 3a3a  ket(0 * Traits::
+00013010: 5265 7350 6163 6b65 7453 697a 652c 2052  ResPacketSize, R
+00013020: 3029 3b0a 2020 2020 2020 2020 2020 7230  0);.          r0
+00013030: 2e73 746f 7265 5061 636b 6574 2831 202a  .storePacket(1 *
+00013040: 2054 7261 6974 733a 3a52 6573 5061 636b   Traits::ResPack
+00013050: 6574 5369 7a65 2c20 5231 293b 0a20 2020  etSize, R1);.   
+00013060: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+00013070: 207d 0a20 2020 2020 207d 0a20 2020 207d   }.      }.    }
+00013080: 0a20 2020 202f 2f2d 2d2d 2d2d 2d2d 2d2d  .    //---------
+00013090: 2d20 5072 6f63 6573 7320 3120 2a20 4c68  - Process 1 * Lh
+000130a0: 7350 726f 6772 6573 7320 726f 7773 2061  sProgress rows a
+000130b0: 7420 6f6e 6365 202d 2d2d 2d2d 2d2d 2d2d  t once ---------
+000130c0: 2d0a 2020 2020 6966 286d 723e 3d31 2a54  -.    if(mr>=1*T
+000130d0: 7261 6974 733a 3a4c 6873 5072 6f67 7265  raits::LhsProgre
+000130e0: 7373 290a 2020 2020 7b0a 2020 2020 2020  ss).    {.      
+000130f0: 6c68 735f 7072 6f63 6573 735f 6f6e 655f  lhs_process_one_
+00013100: 7061 636b 6574 3c6e 722c 204c 6873 5072  packet<nr, LhsPr
+00013110: 6f67 7265 7373 2c20 5268 7350 726f 6772  ogress, RhsProgr
+00013120: 6573 732c 204c 6873 5363 616c 6172 2c20  ess, LhsScalar, 
+00013130: 5268 7353 6361 6c61 722c 2052 6573 5363  RhsScalar, ResSc
+00013140: 616c 6172 2c20 4163 6350 6163 6b65 742c  alar, AccPacket,
+00013150: 204c 6873 5061 636b 6574 2c20 5268 7350   LhsPacket, RhsP
+00013160: 6163 6b65 742c 2052 6573 5061 636b 6574  acket, ResPacket
+00013170: 2c20 5472 6169 7473 2c20 4c69 6e65 6172  , Traits, Linear
+00013180: 4d61 7070 6572 2c20 4461 7461 4d61 7070  Mapper, DataMapp
+00013190: 6572 3e20 703b 0a20 2020 2020 2070 2872  er> p;.      p(r
+000131a0: 6573 2c20 626c 6f63 6b41 2c20 626c 6f63  es, blockA, bloc
+000131b0: 6b42 2c20 616c 7068 612c 2070 6565 6c65  kB, alpha, peele
+000131c0: 645f 6d63 322c 2070 6565 6c65 645f 6d63  d_mc2, peeled_mc
+000131d0: 312c 2073 7472 6964 6541 2c20 7374 7269  1, strideA, stri
+000131e0: 6465 422c 206f 6666 7365 7441 2c20 6f66  deB, offsetA, of
+000131f0: 6673 6574 422c 2070 7265 6665 7463 685f  fsetB, prefetch_
+00013200: 7265 735f 6f66 6673 6574 2c20 7065 656c  res_offset, peel
+00013210: 6564 5f6b 632c 2070 6b2c 2063 6f6c 732c  ed_kc, pk, cols,
+00013220: 2064 6570 7468 2c20 7061 636b 6574 5f63   depth, packet_c
+00013230: 6f6c 7334 293b 0a20 2020 207d 0a20 2020  ols4);.    }.   
+00013240: 202f 2f2d 2d2d 2d2d 2d2d 2d2d 2d20 5072   //---------- Pr
+00013250: 6f63 6573 7320 4c68 7350 726f 6772 6573  ocess LhsProgres
+00013260: 7348 616c 6620 726f 7773 2061 7420 6f6e  sHalf rows at on
+00013270: 6365 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020  ce ----------.  
+00013280: 2020 6966 2828 4c68 7350 726f 6772 6573    if((LhsProgres
+00013290: 7348 616c 6620 3c20 4c68 7350 726f 6772  sHalf < LhsProgr
+000132a0: 6573 7329 2026 2620 6d72 3e3d 4c68 7350  ess) && mr>=LhsP
+000132b0: 726f 6772 6573 7348 616c 6629 0a20 2020  rogressHalf).   
+000132c0: 207b 0a20 2020 2020 206c 6873 5f70 726f   {.      lhs_pro
+000132d0: 6365 7373 5f66 7261 6374 696f 6e5f 6f66  cess_fraction_of
+000132e0: 5f70 6163 6b65 743c 6e72 2c20 4c68 7350  _packet<nr, LhsP
+000132f0: 726f 6772 6573 7348 616c 662c 2052 6873  rogressHalf, Rhs
+00013300: 5072 6f67 7265 7373 4861 6c66 2c20 4c68  ProgressHalf, Lh
+00013310: 7353 6361 6c61 722c 2052 6873 5363 616c  sScalar, RhsScal
+00013320: 6172 2c20 5265 7353 6361 6c61 722c 2041  ar, ResScalar, A
+00013330: 6363 5061 636b 6574 4861 6c66 2c20 4c68  ccPacketHalf, Lh
+00013340: 7350 6163 6b65 7448 616c 662c 2052 6873  sPacketHalf, Rhs
+00013350: 5061 636b 6574 4861 6c66 2c20 5265 7350  PacketHalf, ResP
+00013360: 6163 6b65 7448 616c 662c 2048 616c 6654  acketHalf, HalfT
+00013370: 7261 6974 732c 204c 696e 6561 724d 6170  raits, LinearMap
+00013380: 7065 722c 2044 6174 614d 6170 7065 723e  per, DataMapper>
+00013390: 2070 3b0a 2020 2020 2020 7028 7265 732c   p;.      p(res,
+000133a0: 2062 6c6f 636b 412c 2062 6c6f 636b 422c   blockA, blockB,
+000133b0: 2061 6c70 6861 2c20 7065 656c 6564 5f6d   alpha, peeled_m
+000133c0: 6331 2c20 7065 656c 6564 5f6d 635f 6861  c1, peeled_mc_ha
+000133d0: 6c66 2c20 7374 7269 6465 412c 2073 7472  lf, strideA, str
+000133e0: 6964 6542 2c20 6f66 6673 6574 412c 206f  ideB, offsetA, o
+000133f0: 6666 7365 7442 2c20 7072 6566 6574 6368  ffsetB, prefetch
+00013400: 5f72 6573 5f6f 6666 7365 742c 2070 6565  _res_offset, pee
+00013410: 6c65 645f 6b63 2c20 706b 2c20 636f 6c73  led_kc, pk, cols
+00013420: 2c20 6465 7074 682c 2070 6163 6b65 745f  , depth, packet_
+00013430: 636f 6c73 3429 3b0a 2020 2020 7d0a 2020  cols4);.    }.  
+00013440: 2020 2f2f 2d2d 2d2d 2d2d 2d2d 2d2d 2050    //---------- P
+00013450: 726f 6365 7373 204c 6873 5072 6f67 7265  rocess LhsProgre
+00013460: 7373 5175 6172 7465 7220 726f 7773 2061  ssQuarter rows a
+00013470: 7420 6f6e 6365 202d 2d2d 2d2d 2d2d 2d2d  t once ---------
+00013480: 2d0a 2020 2020 6966 2828 4c68 7350 726f  -.    if((LhsPro
+00013490: 6772 6573 7351 7561 7274 6572 203c 204c  gressQuarter < L
+000134a0: 6873 5072 6f67 7265 7373 4861 6c66 2920  hsProgressHalf) 
+000134b0: 2626 206d 723e 3d4c 6873 5072 6f67 7265  && mr>=LhsProgre
+000134c0: 7373 5175 6172 7465 7229 0a20 2020 207b  ssQuarter).    {
+000134d0: 0a20 2020 2020 206c 6873 5f70 726f 6365  .      lhs_proce
+000134e0: 7373 5f66 7261 6374 696f 6e5f 6f66 5f70  ss_fraction_of_p
+000134f0: 6163 6b65 743c 6e72 2c20 4c68 7350 726f  acket<nr, LhsPro
+00013500: 6772 6573 7351 7561 7274 6572 2c20 5268  gressQuarter, Rh
+00013510: 7350 726f 6772 6573 7351 7561 7274 6572  sProgressQuarter
+00013520: 2c20 4c68 7353 6361 6c61 722c 2052 6873  , LhsScalar, Rhs
+00013530: 5363 616c 6172 2c20 5265 7353 6361 6c61  Scalar, ResScala
+00013540: 722c 2041 6363 5061 636b 6574 5175 6172  r, AccPacketQuar
+00013550: 7465 722c 204c 6873 5061 636b 6574 5175  ter, LhsPacketQu
+00013560: 6172 7465 722c 2052 6873 5061 636b 6574  arter, RhsPacket
+00013570: 5175 6172 7465 722c 2052 6573 5061 636b  Quarter, ResPack
+00013580: 6574 5175 6172 7465 722c 2051 7561 7274  etQuarter, Quart
+00013590: 6572 5472 6169 7473 2c20 4c69 6e65 6172  erTraits, Linear
+000135a0: 4d61 7070 6572 2c20 4461 7461 4d61 7070  Mapper, DataMapp
+000135b0: 6572 3e20 703b 0a20 2020 2020 2070 2872  er> p;.      p(r
+000135c0: 6573 2c20 626c 6f63 6b41 2c20 626c 6f63  es, blockA, bloc
+000135d0: 6b42 2c20 616c 7068 612c 2070 6565 6c65  kB, alpha, peele
+000135e0: 645f 6d63 5f68 616c 662c 2070 6565 6c65  d_mc_half, peele
+000135f0: 645f 6d63 5f71 7561 7274 6572 2c20 7374  d_mc_quarter, st
+00013600: 7269 6465 412c 2073 7472 6964 6542 2c20  rideA, strideB, 
+00013610: 6f66 6673 6574 412c 206f 6666 7365 7442  offsetA, offsetB
+00013620: 2c20 7072 6566 6574 6368 5f72 6573 5f6f  , prefetch_res_o
+00013630: 6666 7365 742c 2070 6565 6c65 645f 6b63  ffset, peeled_kc
+00013640: 2c20 706b 2c20 636f 6c73 2c20 6465 7074  , pk, cols, dept
+00013650: 682c 2070 6163 6b65 745f 636f 6c73 3429  h, packet_cols4)
+00013660: 3b0a 2020 2020 7d0a 2020 2020 2f2f 2d2d  ;.    }.    //--
+00013670: 2d2d 2d2d 2d2d 2d2d 2050 726f 6365 7373  -------- Process
+00013680: 2072 656d 6169 6e69 6e67 2072 6f77 732c   remaining rows,
+00013690: 2031 2061 7420 6f6e 6365 202d 2d2d 2d2d   1 at once -----
+000136a0: 2d2d 2d2d 2d0a 2020 2020 6966 2870 6565  -----.    if(pee
+000136b0: 6c65 645f 6d63 5f71 7561 7274 6572 3c72  led_mc_quarter<r
+000136c0: 6f77 7329 0a20 2020 207b 0a20 2020 2020  ows).    {.     
+000136d0: 202f 2f20 6c6f 6f70 206f 6e20 6561 6368   // loop on each
+000136e0: 2070 616e 656c 206f 6620 7468 6520 7268   panel of the rh
+000136f0: 730a 2020 2020 2020 666f 7228 496e 6465  s.      for(Inde
+00013700: 7820 6a32 3d30 3b20 6a32 3c70 6163 6b65  x j2=0; j2<packe
+00013710: 745f 636f 6c73 343b 206a 322b 3d6e 7229  t_cols4; j2+=nr)
+00013720: 0a20 2020 2020 207b 0a20 2020 2020 2020  .      {.       
+00013730: 202f 2f20 6c6f 6f70 206f 6e20 6561 6368   // loop on each
+00013740: 2072 6f77 206f 6620 7468 6520 6c68 7320   row of the lhs 
+00013750: 2831 2a4c 6873 5072 6f67 7265 7373 2078  (1*LhsProgress x
+00013760: 2064 6570 7468 290a 2020 2020 2020 2020   depth).        
+00013770: 666f 7228 496e 6465 7820 693d 7065 656c  for(Index i=peel
+00013780: 6564 5f6d 635f 7175 6172 7465 723b 2069  ed_mc_quarter; i
+00013790: 3c72 6f77 733b 2069 2b3d 3129 0a20 2020  <rows; i+=1).   
+000137a0: 2020 2020 207b 0a20 2020 2020 2020 2020       {.         
+000137b0: 2063 6f6e 7374 204c 6873 5363 616c 6172   const LhsScalar
+000137c0: 2a20 626c 4120 3d20 2662 6c6f 636b 415b  * blA = &blockA[
+000137d0: 692a 7374 7269 6465 412b 6f66 6673 6574  i*strideA+offset
+000137e0: 415d 3b0a 2020 2020 2020 2020 2020 7072  A];.          pr
+000137f0: 6566 6574 6368 2826 626c 415b 305d 293b  efetch(&blA[0]);
+00013800: 0a20 2020 2020 2020 2020 2063 6f6e 7374  .          const
+00013810: 2052 6873 5363 616c 6172 2a20 626c 4220   RhsScalar* blB 
+00013820: 3d20 2662 6c6f 636b 425b 6a32 2a73 7472  = &blockB[j2*str
+00013830: 6964 6542 2b6f 6666 7365 7442 2a6e 725d  ideB+offsetB*nr]
+00013840: 3b0a 0a20 2020 2020 2020 2020 202f 2f20  ;..          // 
+00013850: 4966 204c 6873 5072 6f67 7265 7373 2069  If LhsProgress i
+00013860: 7320 3820 6f72 2031 362c 2069 7420 6173  s 8 or 16, it as
+00013870: 7375 6d65 7320 7468 6174 2074 6865 7265  sumes that there
+00013880: 2069 7320 610a 2020 2020 2020 2020 2020   is a.          
+00013890: 2f2f 2068 616c 6620 6f72 2071 7561 7274  // half or quart
+000138a0: 6572 2070 6163 6b65 742c 2072 6573 7065  er packet, respe
+000138b0: 6374 6976 656c 792c 206f 6620 7468 6520  ctively, of the 
+000138c0: 7361 6d65 2073 697a 6520 6173 0a20 2020  same size as.   
+000138d0: 2020 2020 2020 202f 2f20 6e72 2028 7768         // nr (wh
+000138e0: 6963 6820 6973 2063 7572 7265 6e74 6c79  ich is currently
+000138f0: 2034 2920 666f 7220 7468 6520 7265 7475   4) for the retu
+00013900: 726e 2074 7970 652e 0a20 2020 2020 2020  rn type..       
+00013910: 2020 2063 6f6e 7374 2069 6e74 2053 5265     const int SRe
+00013920: 7350 6163 6b65 7448 616c 6653 697a 6520  sPacketHalfSize 
+00013930: 3d20 756e 7061 636b 6574 5f74 7261 6974  = unpacket_trait
+00013940: 733c 7479 7065 6e61 6d65 2075 6e70 6163  s<typename unpac
+00013950: 6b65 745f 7472 6169 7473 3c53 5265 7350  ket_traits<SResP
+00013960: 6163 6b65 743e 3a3a 6861 6c66 3e3a 3a73  acket>::half>::s
+00013970: 697a 653b 0a20 2020 2020 2020 2020 2063  ize;.          c
+00013980: 6f6e 7374 2069 6e74 2053 5265 7350 6163  onst int SResPac
+00013990: 6b65 7451 7561 7274 6572 5369 7a65 203d  ketQuarterSize =
+000139a0: 2075 6e70 6163 6b65 745f 7472 6169 7473   unpacket_traits
+000139b0: 3c74 7970 656e 616d 6520 756e 7061 636b  <typename unpack
+000139c0: 6574 5f74 7261 6974 733c 7479 7065 6e61  et_traits<typena
+000139d0: 6d65 2075 6e70 6163 6b65 745f 7472 6169  me unpacket_trai
+000139e0: 7473 3c53 5265 7350 6163 6b65 743e 3a3a  ts<SResPacket>::
+000139f0: 6861 6c66 3e3a 3a68 616c 663e 3a3a 7369  half>::half>::si
+00013a00: 7a65 3b0a 2020 2020 2020 2020 2020 6966  ze;.          if
+00013a10: 2028 2853 7761 7070 6564 5472 6169 7473   ((SwappedTraits
+00013a20: 3a3a 4c68 7350 726f 6772 6573 7320 2520  ::LhsProgress % 
+00013a30: 3429 203d 3d20 3020 2626 0a20 2020 2020  4) == 0 &&.     
+00013a40: 2020 2020 2020 2020 2028 5377 6170 7065           (Swappe
+00013a50: 6454 7261 6974 733a 3a4c 6873 5072 6f67  dTraits::LhsProg
+00013a60: 7265 7373 3c3d 3136 2920 2626 0a20 2020  ress<=16) &&.   
+00013a70: 2020 2020 2020 2020 2020 2028 5377 6170             (Swap
+00013a80: 7065 6454 7261 6974 733a 3a4c 6873 5072  pedTraits::LhsPr
+00013a90: 6f67 7265 7373 213d 3820 207c 7c20 5352  ogress!=8  || SR
+00013aa0: 6573 5061 636b 6574 4861 6c66 5369 7a65  esPacketHalfSize
+00013ab0: 3d3d 6e72 2920 2626 0a20 2020 2020 2020  ==nr) &&.       
+00013ac0: 2020 2020 2020 2028 5377 6170 7065 6454         (SwappedT
+00013ad0: 7261 6974 733a 3a4c 6873 5072 6f67 7265  raits::LhsProgre
+00013ae0: 7373 213d 3136 207c 7c20 5352 6573 5061  ss!=16 || SResPa
+00013af0: 636b 6574 5175 6172 7465 7253 697a 653d  cketQuarterSize=
+00013b00: 3d6e 7229 290a 2020 2020 2020 2020 2020  =nr)).          
+00013b10: 7b0a 2020 2020 2020 2020 2020 2020 5341  {.            SA
+00013b20: 6363 5061 636b 6574 2043 302c 2043 312c  ccPacket C0, C1,
+00013b30: 2043 322c 2043 333b 0a20 2020 2020 2020   C2, C3;.       
+00013b40: 2020 2020 2073 7472 6169 7473 2e69 6e69       straits.ini
+00013b50: 7441 6363 2843 3029 3b0a 2020 2020 2020  tAcc(C0);.      
+00013b60: 2020 2020 2020 7374 7261 6974 732e 696e        straits.in
+00013b70: 6974 4163 6328 4331 293b 0a20 2020 2020  itAcc(C1);.     
+00013b80: 2020 2020 2020 2073 7472 6169 7473 2e69         straits.i
+00013b90: 6e69 7441 6363 2843 3229 3b0a 2020 2020  nitAcc(C2);.    
+00013ba0: 2020 2020 2020 2020 7374 7261 6974 732e          straits.
+00013bb0: 696e 6974 4163 6328 4333 293b 0a0a 2020  initAcc(C3);..  
+00013bc0: 2020 2020 2020 2020 2020 636f 6e73 7420            const 
+00013bd0: 496e 6465 7820 7370 6b20 2020 3d20 2873  Index spk   = (s
+00013be0: 7464 3a3a 6d61 7829 2831 2c53 7761 7070  td::max)(1,Swapp
+00013bf0: 6564 5472 6169 7473 3a3a 4c68 7350 726f  edTraits::LhsPro
+00013c00: 6772 6573 732f 3429 3b0a 2020 2020 2020  gress/4);.      
+00013c10: 2020 2020 2020 636f 6e73 7420 496e 6465        const Inde
+00013c20: 7820 656e 646b 2020 3d20 2864 6570 7468  x endk  = (depth
+00013c30: 2f73 706b 292a 7370 6b3b 0a20 2020 2020  /spk)*spk;.     
+00013c40: 2020 2020 2020 2063 6f6e 7374 2049 6e64         const Ind
+00013c50: 6578 2065 6e64 6b34 203d 2028 6465 7074  ex endk4 = (dept
+00013c60: 682f 2873 706b 2a34 2929 2a28 7370 6b2a  h/(spk*4))*(spk*
+00013c70: 3429 3b0a 0a20 2020 2020 2020 2020 2020  4);..           
+00013c80: 2049 6e64 6578 206b 3d30 3b0a 2020 2020   Index k=0;.    
+00013c90: 2020 2020 2020 2020 666f 7228 3b20 6b3c          for(; k<
+00013ca0: 656e 646b 343b 206b 2b3d 342a 7370 6b29  endk4; k+=4*spk)
+00013cb0: 0a20 2020 2020 2020 2020 2020 207b 0a20  .            {. 
+00013cc0: 2020 2020 2020 2020 2020 2020 2053 4c68               SLh
+00013cd0: 7350 6163 6b65 7420 4130 2c41 313b 0a20  sPacket A0,A1;. 
+00013ce0: 2020 2020 2020 2020 2020 2020 2053 5268               SRh
+00013cf0: 7350 6163 6b65 7420 425f 302c 425f 313b  sPacket B_0,B_1;
+00013d00: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00013d10: 7374 7261 6974 732e 6c6f 6164 4c68 7355  straits.loadLhsU
+00013d20: 6e61 6c69 676e 6564 2862 6c42 2b30 2a53  naligned(blB+0*S
+00013d30: 7761 7070 6564 5472 6169 7473 3a3a 4c68  wappedTraits::Lh
+00013d40: 7350 726f 6772 6573 732c 2041 3029 3b0a  sProgress, A0);.
+00013d50: 2020 2020 2020 2020 2020 2020 2020 7374                st
+00013d60: 7261 6974 732e 6c6f 6164 4c68 7355 6e61  raits.loadLhsUna
+00013d70: 6c69 676e 6564 2862 6c42 2b31 2a53 7761  ligned(blB+1*Swa
+00013d80: 7070 6564 5472 6169 7473 3a3a 4c68 7350  ppedTraits::LhsP
+00013d90: 726f 6772 6573 732c 2041 3129 3b0a 0a20  rogress, A1);.. 
+00013da0: 2020 2020 2020 2020 2020 2020 2073 7472               str
+00013db0: 6169 7473 2e6c 6f61 6452 6873 5175 6164  aits.loadRhsQuad
+00013dc0: 2862 6c41 2b30 2a73 706b 2c20 425f 3029  (blA+0*spk, B_0)
+00013dd0: 3b0a 2020 2020 2020 2020 2020 2020 2020  ;.              
+00013de0: 7374 7261 6974 732e 6c6f 6164 5268 7351  straits.loadRhsQ
+00013df0: 7561 6428 626c 412b 312a 7370 6b2c 2042  uad(blA+1*spk, B
+00013e00: 5f31 293b 0a20 2020 2020 2020 2020 2020  _1);.           
+00013e10: 2020 2073 7472 6169 7473 2e6d 6164 6428     straits.madd(
+00013e20: 4130 2c42 5f30 2c43 302c 425f 302c 2066  A0,B_0,C0,B_0, f
+00013e30: 6978 3c30 3e29 3b0a 2020 2020 2020 2020  ix<0>);.        
+00013e40: 2020 2020 2020 7374 7261 6974 732e 6d61        straits.ma
+00013e50: 6464 2841 312c 425f 312c 4331 2c42 5f31  dd(A1,B_1,C1,B_1
+00013e60: 2c20 6669 783c 303e 293b 0a0a 2020 2020  , fix<0>);..    
+00013e70: 2020 2020 2020 2020 2020 7374 7261 6974            strait
+00013e80: 732e 6c6f 6164 4c68 7355 6e61 6c69 676e  s.loadLhsUnalign
+00013e90: 6564 2862 6c42 2b32 2a53 7761 7070 6564  ed(blB+2*Swapped
+00013ea0: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
+00013eb0: 6573 732c 2041 3029 3b0a 2020 2020 2020  ess, A0);.      
+00013ec0: 2020 2020 2020 2020 7374 7261 6974 732e          straits.
+00013ed0: 6c6f 6164 4c68 7355 6e61 6c69 676e 6564  loadLhsUnaligned
+00013ee0: 2862 6c42 2b33 2a53 7761 7070 6564 5472  (blB+3*SwappedTr
+00013ef0: 6169 7473 3a3a 4c68 7350 726f 6772 6573  aits::LhsProgres
+00013f00: 732c 2041 3129 3b0a 2020 2020 2020 2020  s, A1);.        
+00013f10: 2020 2020 2020 7374 7261 6974 732e 6c6f        straits.lo
+00013f20: 6164 5268 7351 7561 6428 626c 412b 322a  adRhsQuad(blA+2*
+00013f30: 7370 6b2c 2042 5f30 293b 0a20 2020 2020  spk, B_0);.     
+00013f40: 2020 2020 2020 2020 2073 7472 6169 7473           straits
+00013f50: 2e6c 6f61 6452 6873 5175 6164 2862 6c41  .loadRhsQuad(blA
+00013f60: 2b33 2a73 706b 2c20 425f 3129 3b0a 2020  +3*spk, B_1);.  
+00013f70: 2020 2020 2020 2020 2020 2020 7374 7261              stra
+00013f80: 6974 732e 6d61 6464 2841 302c 425f 302c  its.madd(A0,B_0,
+00013f90: 4332 2c42 5f30 2c20 6669 783c 303e 293b  C2,B_0, fix<0>);
+00013fa0: 0a20 2020 2020 2020 2020 2020 2020 2073  .              s
+00013fb0: 7472 6169 7473 2e6d 6164 6428 4131 2c42  traits.madd(A1,B
+00013fc0: 5f31 2c43 332c 425f 312c 2066 6978 3c30  _1,C3,B_1, fix<0
+00013fd0: 3e29 3b0a 0a20 2020 2020 2020 2020 2020  >);..           
+00013fe0: 2020 2062 6c42 202b 3d20 342a 5377 6170     blB += 4*Swap
+00013ff0: 7065 6454 7261 6974 733a 3a4c 6873 5072  pedTraits::LhsPr
+00014000: 6f67 7265 7373 3b0a 2020 2020 2020 2020  ogress;.        
+00014010: 2020 2020 2020 626c 4120 2b3d 2034 2a73        blA += 4*s
+00014020: 706b 3b0a 2020 2020 2020 2020 2020 2020  pk;.            
+00014030: 7d0a 2020 2020 2020 2020 2020 2020 4330  }.            C0
+00014040: 203d 2070 6164 6428 7061 6464 2843 302c   = padd(padd(C0,
+00014050: 4331 292c 7061 6464 2843 322c 4333 2929  C1),padd(C2,C3))
+00014060: 3b0a 2020 2020 2020 2020 2020 2020 666f  ;.            fo
+00014070: 7228 3b20 6b3c 656e 646b 3b20 6b2b 3d73  r(; k<endk; k+=s
+00014080: 706b 290a 2020 2020 2020 2020 2020 2020  pk).            
+00014090: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+000140a0: 534c 6873 5061 636b 6574 2041 303b 0a20  SLhsPacket A0;. 
+000140b0: 2020 2020 2020 2020 2020 2020 2053 5268               SRh
+000140c0: 7350 6163 6b65 7420 425f 303b 0a0a 2020  sPacket B_0;..  
+000140d0: 2020 2020 2020 2020 2020 2020 7374 7261              stra
+000140e0: 6974 732e 6c6f 6164 4c68 7355 6e61 6c69  its.loadLhsUnali
+000140f0: 676e 6564 2862 6c42 2c20 4130 293b 0a20  gned(blB, A0);. 
+00014100: 2020 2020 2020 2020 2020 2020 2073 7472               str
+00014110: 6169 7473 2e6c 6f61 6452 6873 5175 6164  aits.loadRhsQuad
+00014120: 2862 6c41 2c20 425f 3029 3b0a 2020 2020  (blA, B_0);.    
+00014130: 2020 2020 2020 2020 2020 7374 7261 6974            strait
+00014140: 732e 6d61 6464 2841 302c 425f 302c 4330  s.madd(A0,B_0,C0
+00014150: 2c42 5f30 2c20 6669 783c 303e 293b 0a0a  ,B_0, fix<0>);..
+00014160: 2020 2020 2020 2020 2020 2020 2020 626c                bl
+00014170: 4220 2b3d 2053 7761 7070 6564 5472 6169  B += SwappedTrai
+00014180: 7473 3a3a 4c68 7350 726f 6772 6573 733b  ts::LhsProgress;
+00014190: 0a20 2020 2020 2020 2020 2020 2020 2062  .              b
+000141a0: 6c41 202b 3d20 7370 6b3b 0a20 2020 2020  lA += spk;.     
+000141b0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+000141c0: 2020 2020 2069 6628 5377 6170 7065 6454       if(SwappedT
+000141d0: 7261 6974 733a 3a4c 6873 5072 6f67 7265  raits::LhsProgre
+000141e0: 7373 3d3d 3829 0a20 2020 2020 2020 2020  ss==8).         
+000141f0: 2020 207b 0a20 2020 2020 2020 2020 2020     {.           
+00014200: 2020 202f 2f20 5370 6563 6961 6c20 6361     // Special ca
+00014210: 7365 2077 6865 7265 2077 6520 6861 7665  se where we have
+00014220: 2074 6f20 6669 7273 7420 7265 6475 6365   to first reduce
+00014230: 2074 6865 2061 6363 756d 756c 6174 696f   the accumulatio
+00014240: 6e20 7265 6769 7374 6572 2043 300a 2020  n register C0.  
+00014250: 2020 2020 2020 2020 2020 2020 7479 7065              type
+00014260: 6465 6620 7479 7065 6e61 6d65 2063 6f6e  def typename con
+00014270: 6469 7469 6f6e 616c 3c53 7761 7070 6564  ditional<Swapped
+00014280: 5472 6169 7473 3a3a 4c68 7350 726f 6772  Traits::LhsProgr
+00014290: 6573 733e 3d38 2c74 7970 656e 616d 6520  ess>=8,typename 
+000142a0: 756e 7061 636b 6574 5f74 7261 6974 733c  unpacket_traits<
+000142b0: 5352 6573 5061 636b 6574 3e3a 3a68 616c  SResPacket>::hal
+000142c0: 662c 5352 6573 5061 636b 6574 3e3a 3a74  f,SResPacket>::t
+000142d0: 7970 6520 5352 6573 5061 636b 6574 4861  ype SResPacketHa
+000142e0: 6c66 3b0a 2020 2020 2020 2020 2020 2020  lf;.            
+000142f0: 2020 7479 7065 6465 6620 7479 7065 6e61    typedef typena
+00014300: 6d65 2063 6f6e 6469 7469 6f6e 616c 3c53  me conditional<S
+00014310: 7761 7070 6564 5472 6169 7473 3a3a 4c68  wappedTraits::Lh
+00014320: 7350 726f 6772 6573 733e 3d38 2c74 7970  sProgress>=8,typ
+00014330: 656e 616d 6520 756e 7061 636b 6574 5f74  ename unpacket_t
+00014340: 7261 6974 733c 534c 6873 5061 636b 6574  raits<SLhsPacket
+00014350: 3e3a 3a68 616c 662c 534c 6873 5061 636b  >::half,SLhsPack
+00014360: 6574 3e3a 3a74 7970 6520 534c 6873 5061  et>::type SLhsPa
+00014370: 636b 6574 4861 6c66 3b0a 2020 2020 2020  cketHalf;.      
+00014380: 2020 2020 2020 2020 7479 7065 6465 6620          typedef 
+00014390: 7479 7065 6e61 6d65 2063 6f6e 6469 7469  typename conditi
+000143a0: 6f6e 616c 3c53 7761 7070 6564 5472 6169  onal<SwappedTrai
+000143b0: 7473 3a3a 4c68 7350 726f 6772 6573 733e  ts::LhsProgress>
+000143c0: 3d38 2c74 7970 656e 616d 6520 756e 7061  =8,typename unpa
+000143d0: 636b 6574 5f74 7261 6974 733c 5352 6873  cket_traits<SRhs
+000143e0: 5061 636b 6574 3e3a 3a68 616c 662c 5352  Packet>::half,SR
+000143f0: 6873 5061 636b 6574 3e3a 3a74 7970 6520  hsPacket>::type 
+00014400: 5352 6873 5061 636b 6574 4861 6c66 3b0a  SRhsPacketHalf;.
+00014410: 2020 2020 2020 2020 2020 2020 2020 7479                ty
+00014420: 7065 6465 6620 7479 7065 6e61 6d65 2063  pedef typename c
+00014430: 6f6e 6469 7469 6f6e 616c 3c53 7761 7070  onditional<Swapp
+00014440: 6564 5472 6169 7473 3a3a 4c68 7350 726f  edTraits::LhsPro
+00014450: 6772 6573 733e 3d38 2c74 7970 656e 616d  gress>=8,typenam
+00014460: 6520 756e 7061 636b 6574 5f74 7261 6974  e unpacket_trait
+00014470: 733c 5341 6363 5061 636b 6574 3e3a 3a68  s<SAccPacket>::h
+00014480: 616c 662c 5341 6363 5061 636b 6574 3e3a  alf,SAccPacket>:
+00014490: 3a74 7970 6520 5341 6363 5061 636b 6574  :type SAccPacket
+000144a0: 4861 6c66 3b0a 0a20 2020 2020 2020 2020  Half;..         
+000144b0: 2020 2020 2053 5265 7350 6163 6b65 7448       SResPacketH
+000144c0: 616c 6620 5220 3d20 7265 732e 7465 6d70  alf R = res.temp
+000144d0: 6c61 7465 2067 6174 6865 7250 6163 6b65  late gatherPacke
+000144e0: 743c 5352 6573 5061 636b 6574 4861 6c66  t<SResPacketHalf
+000144f0: 3e28 692c 206a 3229 3b0a 2020 2020 2020  >(i, j2);.      
+00014500: 2020 2020 2020 2020 5352 6573 5061 636b          SResPack
+00014510: 6574 4861 6c66 2061 6c70 6861 7620 3d20  etHalf alphav = 
+00014520: 7073 6574 313c 5352 6573 5061 636b 6574  pset1<SResPacket
+00014530: 4861 6c66 3e28 616c 7068 6129 3b0a 0a20  Half>(alpha);.. 
+00014540: 2020 2020 2020 2020 2020 2020 2069 6628               if(
+00014550: 6465 7074 682d 656e 646b 3e30 290a 2020  depth-endk>0).  
+00014560: 2020 2020 2020 2020 2020 2020 7b0a 2020              {.  
+00014570: 2020 2020 2020 2020 2020 2020 2020 2f2f                //
+00014580: 2057 6520 6861 7665 2074 6f20 6861 6e64   We have to hand
+00014590: 6c65 2074 6865 206c 6173 7420 726f 7720  le the last row 
+000145a0: 6f66 2074 6865 2072 6873 2077 6869 6368  of the rhs which
+000145b0: 2063 6f72 7265 7370 6f6e 6473 2074 6f20   corresponds to 
+000145c0: 6120 6861 6c66 2d70 6163 6b65 740a 2020  a half-packet.  
+000145d0: 2020 2020 2020 2020 2020 2020 2020 534c                SL
+000145e0: 6873 5061 636b 6574 4861 6c66 2061 303b  hsPacketHalf a0;
+000145f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014600: 2053 5268 7350 6163 6b65 7448 616c 6620   SRhsPacketHalf 
+00014610: 6230 3b0a 2020 2020 2020 2020 2020 2020  b0;.            
+00014620: 2020 2020 7374 7261 6974 732e 6c6f 6164      straits.load
+00014630: 4c68 7355 6e61 6c69 676e 6564 2862 6c42  LhsUnaligned(blB
+00014640: 2c20 6130 293b 0a20 2020 2020 2020 2020  , a0);.         
+00014650: 2020 2020 2020 2073 7472 6169 7473 2e6c         straits.l
+00014660: 6f61 6452 6873 2862 6c41 2c20 6230 293b  oadRhs(blA, b0);
+00014670: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014680: 2053 4163 6350 6163 6b65 7448 616c 6620   SAccPacketHalf 
+00014690: 6330 203d 2070 7265 6475 785f 6861 6c66  c0 = predux_half
+000146a0: 5f64 6f77 746f 3428 4330 293b 0a20 2020  _dowto4(C0);.   
+000146b0: 2020 2020 2020 2020 2020 2020 2073 7472               str
+000146c0: 6169 7473 2e6d 6164 6428 6130 2c62 302c  aits.madd(a0,b0,
+000146d0: 6330 2c62 302c 2066 6978 3c30 3e29 3b0a  c0,b0, fix<0>);.
+000146e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000146f0: 7374 7261 6974 732e 6163 6328 6330 2c20  straits.acc(c0, 
+00014700: 616c 7068 6176 2c20 5229 3b0a 2020 2020  alphav, R);.    
+00014710: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00014720: 2020 2020 2020 2020 2020 656c 7365 0a20            else. 
+00014730: 2020 2020 2020 2020 2020 2020 207b 0a20               {. 
+00014740: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00014750: 7472 6169 7473 2e61 6363 2870 7265 6475  traits.acc(predu
+00014760: 785f 6861 6c66 5f64 6f77 746f 3428 4330  x_half_dowto4(C0
+00014770: 292c 2061 6c70 6861 762c 2052 293b 0a20  ), alphav, R);. 
+00014780: 2020 2020 2020 2020 2020 2020 207d 0a20               }. 
+00014790: 2020 2020 2020 2020 2020 2020 2072 6573               res
+000147a0: 2e73 6361 7474 6572 5061 636b 6574 2869  .scatterPacket(i
+000147b0: 2c20 6a32 2c20 5229 3b0a 2020 2020 2020  , j2, R);.      
+000147c0: 2020 2020 2020 7d0a 2020 2020 2020 2020        }.        
+000147d0: 2020 2020 656c 7365 2069 6620 2853 7761      else if (Swa
+000147e0: 7070 6564 5472 6169 7473 3a3a 4c68 7350  ppedTraits::LhsP
+000147f0: 726f 6772 6573 733d 3d31 3629 0a20 2020  rogress==16).   
+00014800: 2020 2020 2020 2020 207b 0a20 2020 2020           {.     
+00014810: 2020 2020 2020 2020 202f 2f20 5370 6563           // Spec
+00014820: 6961 6c20 6361 7365 2077 6865 7265 2077  ial case where w
+00014830: 6520 6861 7665 2074 6f20 6669 7273 7420  e have to first 
+00014840: 7265 6475 6365 2074 6865 0a20 2020 2020  reduce the.     
+00014850: 2020 2020 2020 2020 202f 2f20 6163 6375           // accu
+00014860: 6d75 6c61 7469 6f6e 2072 6567 6973 7465  mulation registe
+00014870: 7220 4330 2e20 5765 2073 7065 6369 616c  r C0. We special
+00014880: 697a 6520 7468 6520 626c 6f63 6b20 696e  ize the block in
+00014890: 0a20 2020 2020 2020 2020 2020 2020 202f  .              /
+000148a0: 2f20 7465 6d70 6c61 7465 2066 6f72 6d2c  / template form,
+000148b0: 2073 6f20 7468 6174 204c 6873 5072 6f67   so that LhsProg
+000148c0: 7265 7373 203c 2031 3620 7061 7468 7320  ress < 16 paths 
+000148d0: 646f 6e27 740a 2020 2020 2020 2020 2020  don't.          
+000148e0: 2020 2020 2f2f 2066 6169 6c20 746f 2063      // fail to c
+000148f0: 6f6d 7069 6c65 0a20 2020 2020 2020 2020  ompile.         
+00014900: 2020 2020 206c 6173 745f 726f 775f 7072       last_row_pr
+00014910: 6f63 6573 735f 3136 5f70 6163 6b65 7473  ocess_16_packets
+00014920: 3c4c 6873 5363 616c 6172 2c20 5268 7353  <LhsScalar, RhsS
+00014930: 6361 6c61 722c 2049 6e64 6578 2c20 4461  calar, Index, Da
+00014940: 7461 4d61 7070 6572 2c20 6d72 2c20 6e72  taMapper, mr, nr
+00014950: 2c20 436f 6e6a 7567 6174 654c 6873 2c20  , ConjugateLhs, 
+00014960: 436f 6e6a 7567 6174 6552 6873 3e20 703b  ConjugateRhs> p;
+00014970: 0a09 2020 2020 2020 2020 2020 2020 7028  ..            p(
+00014980: 7265 732c 2073 7472 6169 7473 2c20 626c  res, straits, bl
+00014990: 412c 2062 6c42 2c20 6465 7074 682c 2065  A, blB, depth, e
+000149a0: 6e64 6b2c 2069 2c20 6a32 2c61 6c70 6861  ndk, i, j2,alpha
+000149b0: 2c20 4330 293b 0a20 2020 2020 2020 2020  , C0);.         
+000149c0: 2020 207d 0a20 2020 2020 2020 2020 2020     }.           
+000149d0: 2065 6c73 650a 2020 2020 2020 2020 2020   else.          
+000149e0: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
+000149f0: 2020 5352 6573 5061 636b 6574 2052 203d    SResPacket R =
+00014a00: 2072 6573 2e74 656d 706c 6174 6520 6761   res.template ga
+00014a10: 7468 6572 5061 636b 6574 3c53 5265 7350  therPacket<SResP
+00014a20: 6163 6b65 743e 2869 2c20 6a32 293b 0a20  acket>(i, j2);. 
+00014a30: 2020 2020 2020 2020 2020 2020 2053 5265               SRe
+00014a40: 7350 6163 6b65 7420 616c 7068 6176 203d  sPacket alphav =
+00014a50: 2070 7365 7431 3c53 5265 7350 6163 6b65   pset1<SResPacke
+00014a60: 743e 2861 6c70 6861 293b 0a20 2020 2020  t>(alpha);.     
+00014a70: 2020 2020 2020 2020 2073 7472 6169 7473           straits
+00014a80: 2e61 6363 2843 302c 2061 6c70 6861 762c  .acc(C0, alphav,
+00014a90: 2052 293b 0a20 2020 2020 2020 2020 2020   R);.           
+00014aa0: 2020 2072 6573 2e73 6361 7474 6572 5061     res.scatterPa
+00014ab0: 636b 6574 2869 2c20 6a32 2c20 5229 3b0a  cket(i, j2, R);.
+00014ac0: 2020 2020 2020 2020 2020 2020 7d0a 2020              }.  
+00014ad0: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00014ae0: 2020 2020 656c 7365 202f 2f20 7363 616c      else // scal
+00014af0: 6172 2070 6174 680a 2020 2020 2020 2020  ar path.        
+00014b00: 2020 7b0a 2020 2020 2020 2020 2020 2020    {.            
+00014b10: 2f2f 2067 6574 2061 2031 2078 2034 2072  // get a 1 x 4 r
+00014b20: 6573 2062 6c6f 636b 2061 7320 7265 6769  es block as regi
+00014b30: 7374 6572 730a 2020 2020 2020 2020 2020  sters.          
+00014b40: 2020 5265 7353 6361 6c61 7220 4330 2830    ResScalar C0(0
+00014b50: 292c 2043 3128 3029 2c20 4332 2830 292c  ), C1(0), C2(0),
+00014b60: 2043 3328 3029 3b0a 0a20 2020 2020 2020   C3(0);..       
+00014b70: 2020 2020 2066 6f72 2849 6e64 6578 206b       for(Index k
+00014b80: 3d30 3b20 6b3c 6465 7074 683b 206b 2b2b  =0; k<depth; k++
+00014b90: 290a 2020 2020 2020 2020 2020 2020 7b0a  ).            {.
+00014ba0: 2020 2020 2020 2020 2020 2020 2020 4c68                Lh
+00014bb0: 7353 6361 6c61 7220 4130 3b0a 2020 2020  sScalar A0;.    
+00014bc0: 2020 2020 2020 2020 2020 5268 7353 6361            RhsSca
+00014bd0: 6c61 7220 425f 302c 2042 5f31 3b0a 0a20  lar B_0, B_1;.. 
+00014be0: 2020 2020 2020 2020 2020 2020 2041 3020               A0 
+00014bf0: 3d20 626c 415b 6b5d 3b0a 0a20 2020 2020  = blA[k];..     
+00014c00: 2020 2020 2020 2020 2042 5f30 203d 2062           B_0 = b
+00014c10: 6c42 5b30 5d3b 0a20 2020 2020 2020 2020  lB[0];.         
+00014c20: 2020 2020 2042 5f31 203d 2062 6c42 5b31       B_1 = blB[1
+00014c30: 5d3b 0a20 2020 2020 2020 2020 2020 2020  ];.             
+00014c40: 2043 3020 3d20 636a 2e70 6d61 6464 2841   C0 = cj.pmadd(A
+00014c50: 302c 425f 302c 4330 293b 0a20 2020 2020  0,B_0,C0);.     
+00014c60: 2020 2020 2020 2020 2043 3120 3d20 636a           C1 = cj
+00014c70: 2e70 6d61 6464 2841 302c 425f 312c 4331  .pmadd(A0,B_1,C1
+00014c80: 293b 0a0a 2020 2020 2020 2020 2020 2020  );..            
+00014c90: 2020 425f 3020 3d20 626c 425b 325d 3b0a    B_0 = blB[2];.
+00014ca0: 2020 2020 2020 2020 2020 2020 2020 425f                B_
+00014cb0: 3120 3d20 626c 425b 335d 3b0a 2020 2020  1 = blB[3];.    
+00014cc0: 2020 2020 2020 2020 2020 4332 203d 2063            C2 = c
+00014cd0: 6a2e 706d 6164 6428 4130 2c42 5f30 2c43  j.pmadd(A0,B_0,C
+00014ce0: 3229 3b0a 2020 2020 2020 2020 2020 2020  2);.            
+00014cf0: 2020 4333 203d 2063 6a2e 706d 6164 6428    C3 = cj.pmadd(
+00014d00: 4130 2c42 5f31 2c43 3329 3b0a 0a20 2020  A0,B_1,C3);..   
+00014d10: 2020 2020 2020 2020 2020 2062 6c42 202b             blB +
+00014d20: 3d20 343b 0a20 2020 2020 2020 2020 2020  = 4;.           
+00014d30: 207d 0a20 2020 2020 2020 2020 2020 2072   }.            r
+00014d40: 6573 2869 2c20 6a32 202b 2030 2920 2b3d  es(i, j2 + 0) +=
+00014d50: 2061 6c70 6861 202a 2043 303b 0a20 2020   alpha * C0;.   
+00014d60: 2020 2020 2020 2020 2072 6573 2869 2c20           res(i, 
+00014d70: 6a32 202b 2031 2920 2b3d 2061 6c70 6861  j2 + 1) += alpha
+00014d80: 202a 2043 313b 0a20 2020 2020 2020 2020   * C1;.         
+00014d90: 2020 2072 6573 2869 2c20 6a32 202b 2032     res(i, j2 + 2
+00014da0: 2920 2b3d 2061 6c70 6861 202a 2043 323b  ) += alpha * C2;
+00014db0: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
+00014dc0: 2869 2c20 6a32 202b 2033 2920 2b3d 2061  (i, j2 + 3) += a
+00014dd0: 6c70 6861 202a 2043 333b 0a20 2020 2020  lpha * C3;.     
+00014de0: 2020 2020 207d 0a20 2020 2020 2020 207d       }.        }
+00014df0: 0a20 2020 2020 207d 0a20 2020 2020 202f  .      }.      /
+00014e00: 2f20 7265 6d61 696e 696e 6720 636f 6c75  / remaining colu
+00014e10: 6d6e 730a 2020 2020 2020 666f 7228 496e  mns.      for(In
+00014e20: 6465 7820 6a32 3d70 6163 6b65 745f 636f  dex j2=packet_co
+00014e30: 6c73 343b 206a 323c 636f 6c73 3b20 6a32  ls4; j2<cols; j2
+00014e40: 2b2b 290a 2020 2020 2020 7b0a 2020 2020  ++).      {.    
+00014e50: 2020 2020 2f2f 206c 6f6f 7020 6f6e 2065      // loop on e
+00014e60: 6163 6820 726f 7720 6f66 2074 6865 206c  ach row of the l
+00014e70: 6873 2028 312a 4c68 7350 726f 6772 6573  hs (1*LhsProgres
+00014e80: 7320 7820 6465 7074 6829 0a20 2020 2020  s x depth).     
+00014e90: 2020 2066 6f72 2849 6e64 6578 2069 3d70     for(Index i=p
+00014ea0: 6565 6c65 645f 6d63 5f71 7561 7274 6572  eeled_mc_quarter
+00014eb0: 3b20 693c 726f 7773 3b20 692b 3d31 290a  ; i<rows; i+=1).
+00014ec0: 2020 2020 2020 2020 7b0a 2020 2020 2020          {.      
+00014ed0: 2020 2020 636f 6e73 7420 4c68 7353 6361      const LhsSca
+00014ee0: 6c61 722a 2062 6c41 203d 2026 626c 6f63  lar* blA = &bloc
+00014ef0: 6b41 5b69 2a73 7472 6964 6541 2b6f 6666  kA[i*strideA+off
+00014f00: 7365 7441 5d3b 0a20 2020 2020 2020 2020  setA];.         
+00014f10: 2070 7265 6665 7463 6828 2662 6c41 5b30   prefetch(&blA[0
+00014f20: 5d29 3b0a 2020 2020 2020 2020 2020 2f2f  ]);.          //
+00014f30: 2067 6574 7320 6120 3120 7820 3120 7265   gets a 1 x 1 re
+00014f40: 7320 626c 6f63 6b20 6173 2072 6567 6973  s block as regis
+00014f50: 7465 7273 0a20 2020 2020 2020 2020 2052  ters.          R
+00014f60: 6573 5363 616c 6172 2043 3028 3029 3b0a  esScalar C0(0);.
+00014f70: 2020 2020 2020 2020 2020 636f 6e73 7420            const 
+00014f80: 5268 7353 6361 6c61 722a 2062 6c42 203d  RhsScalar* blB =
+00014f90: 2026 626c 6f63 6b42 5b6a 322a 7374 7269   &blockB[j2*stri
+00014fa0: 6465 422b 6f66 6673 6574 425d 3b0a 2020  deB+offsetB];.  
+00014fb0: 2020 2020 2020 2020 666f 7228 496e 6465          for(Inde
+00014fc0: 7820 6b3d 303b 206b 3c64 6570 7468 3b20  x k=0; k<depth; 
+00014fd0: 6b2b 2b29 0a20 2020 2020 2020 2020 207b  k++).          {
+00014fe0: 0a20 2020 2020 2020 2020 2020 204c 6873  .            Lhs
+00014ff0: 5363 616c 6172 2041 3020 3d20 626c 415b  Scalar A0 = blA[
+00015000: 6b5d 3b0a 2020 2020 2020 2020 2020 2020  k];.            
+00015010: 5268 7353 6361 6c61 7220 425f 3020 3d20  RhsScalar B_0 = 
+00015020: 626c 425b 6b5d 3b0a 2020 2020 2020 2020  blB[k];.        
+00015030: 2020 2020 4330 203d 2063 6a2e 706d 6164      C0 = cj.pmad
+00015040: 6428 4130 2c20 425f 302c 2043 3029 3b0a  d(A0, B_0, C0);.
+00015050: 2020 2020 2020 2020 2020 7d0a 2020 2020            }.    
+00015060: 2020 2020 2020 7265 7328 692c 206a 3229        res(i, j2)
+00015070: 202b 3d20 616c 7068 6120 2a20 4330 3b0a   += alpha * C0;.
+00015080: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00015090: 7d0a 2020 2020 7d0a 2020 7d0a 0a0a 2f2f  }.    }.  }...//
+000150a0: 2070 6163 6b20 6120 626c 6f63 6b20 6f66   pack a block of
+000150b0: 2074 6865 206c 6873 0a2f 2f20 5468 6520   the lhs.// The 
+000150c0: 7472 6176 6572 7361 6c20 6973 2061 7320  traversal is as 
+000150d0: 666f 6c6c 6f77 2028 6d72 3d3d 3429 3a0a  follow (mr==4):.
+000150e0: 2f2f 2020 2030 2020 3420 2038 2031 3220  //   0  4  8 12 
+000150f0: 2e2e 2e0a 2f2f 2020 2031 2020 3520 2039  ....//   1  5  9
+00015100: 2031 3320 2e2e 2e0a 2f2f 2020 2032 2020   13 ....//   2  
+00015110: 3620 3130 2031 3420 2e2e 2e0a 2f2f 2020  6 10 14 ....//  
+00015120: 2033 2020 3720 3131 2031 3520 2e2e 2e0a   3  7 11 15 ....
+00015130: 2f2f 0a2f 2f20 2031 3620 3230 2032 3420  //.//  16 20 24 
+00015140: 3238 202e 2e2e 0a2f 2f20 2031 3720 3231  28 ....//  17 21
+00015150: 2032 3520 3239 202e 2e2e 0a2f 2f20 2031   25 29 ....//  1
+00015160: 3820 3232 2032 3620 3330 202e 2e2e 0a2f  8 22 26 30 ..../
+00015170: 2f20 2031 3920 3233 2032 3720 3331 202e  /  19 23 27 31 .
+00015180: 2e2e 0a2f 2f0a 2f2f 2020 3332 2033 3320  ...//.//  32 33 
+00015190: 3334 2033 3520 2e2e 2e0a 2f2f 2020 3336  34 35 ....//  36
+000151a0: 2033 3620 3338 2033 3920 2e2e 2e0a 7465   36 38 39 ....te
+000151b0: 6d70 6c61 7465 3c74 7970 656e 616d 6520  mplate<typename 
+000151c0: 5363 616c 6172 2c20 7479 7065 6e61 6d65  Scalar, typename
+000151d0: 2049 6e64 6578 2c20 7479 7065 6e61 6d65   Index, typename
+000151e0: 2044 6174 614d 6170 7065 722c 2069 6e74   DataMapper, int
+000151f0: 2050 6163 6b31 2c20 696e 7420 5061 636b   Pack1, int Pack
+00015200: 322c 2074 7970 656e 616d 6520 5061 636b  2, typename Pack
+00015210: 6574 2c20 626f 6f6c 2043 6f6e 6a75 6761  et, bool Conjuga
+00015220: 7465 2c20 626f 6f6c 2050 616e 656c 4d6f  te, bool PanelMo
+00015230: 6465 3e0a 7374 7275 6374 2067 656d 6d5f  de>.struct gemm_
+00015240: 7061 636b 5f6c 6873 3c53 6361 6c61 722c  pack_lhs<Scalar,
+00015250: 2049 6e64 6578 2c20 4461 7461 4d61 7070   Index, DataMapp
+00015260: 6572 2c20 5061 636b 312c 2050 6163 6b32  er, Pack1, Pack2
+00015270: 2c20 5061 636b 6574 2c20 436f 6c4d 616a  , Packet, ColMaj
+00015280: 6f72 2c20 436f 6e6a 7567 6174 652c 2050  or, Conjugate, P
+00015290: 616e 656c 4d6f 6465 3e0a 7b0a 2020 7479  anelMode>.{.  ty
+000152a0: 7065 6465 6620 7479 7065 6e61 6d65 2044  pedef typename D
+000152b0: 6174 614d 6170 7065 723a 3a4c 696e 6561  ataMapper::Linea
+000152c0: 724d 6170 7065 7220 4c69 6e65 6172 4d61  rMapper LinearMa
+000152d0: 7070 6572 3b0a 2020 4549 4745 4e5f 444f  pper;.  EIGEN_DO
+000152e0: 4e54 5f49 4e4c 494e 4520 766f 6964 206f  NT_INLINE void o
+000152f0: 7065 7261 746f 7228 2928 5363 616c 6172  perator()(Scalar
+00015300: 2a20 626c 6f63 6b41 2c20 636f 6e73 7420  * blockA, const 
+00015310: 4461 7461 4d61 7070 6572 2620 6c68 732c  DataMapper& lhs,
+00015320: 2049 6e64 6578 2064 6570 7468 2c20 496e   Index depth, In
+00015330: 6465 7820 726f 7773 2c20 496e 6465 7820  dex rows, Index 
+00015340: 7374 7269 6465 3d30 2c20 496e 6465 7820  stride=0, Index 
+00015350: 6f66 6673 6574 3d30 293b 0a7d 3b0a 0a74  offset=0);.};..t
+00015360: 656d 706c 6174 653c 7479 7065 6e61 6d65  emplate<typename
+00015370: 2053 6361 6c61 722c 2074 7970 656e 616d   Scalar, typenam
+00015380: 6520 496e 6465 782c 2074 7970 656e 616d  e Index, typenam
+00015390: 6520 4461 7461 4d61 7070 6572 2c20 696e  e DataMapper, in
+000153a0: 7420 5061 636b 312c 2069 6e74 2050 6163  t Pack1, int Pac
+000153b0: 6b32 2c20 7479 7065 6e61 6d65 2050 6163  k2, typename Pac
+000153c0: 6b65 742c 2062 6f6f 6c20 436f 6e6a 7567  ket, bool Conjug
+000153d0: 6174 652c 2062 6f6f 6c20 5061 6e65 6c4d  ate, bool PanelM
+000153e0: 6f64 653e 0a45 4947 454e 5f44 4f4e 545f  ode>.EIGEN_DONT_
+000153f0: 494e 4c49 4e45 2076 6f69 6420 6765 6d6d  INLINE void gemm
+00015400: 5f70 6163 6b5f 6c68 733c 5363 616c 6172  _pack_lhs<Scalar
+00015410: 2c20 496e 6465 782c 2044 6174 614d 6170  , Index, DataMap
+00015420: 7065 722c 2050 6163 6b31 2c20 5061 636b  per, Pack1, Pack
+00015430: 322c 2050 6163 6b65 742c 2043 6f6c 4d61  2, Packet, ColMa
+00015440: 6a6f 722c 2043 6f6e 6a75 6761 7465 2c20  jor, Conjugate, 
+00015450: 5061 6e65 6c4d 6f64 653e 0a20 203a 3a6f  PanelMode>.  ::o
+00015460: 7065 7261 746f 7228 2928 5363 616c 6172  perator()(Scalar
+00015470: 2a20 626c 6f63 6b41 2c20 636f 6e73 7420  * blockA, const 
+00015480: 4461 7461 4d61 7070 6572 2620 6c68 732c  DataMapper& lhs,
+00015490: 2049 6e64 6578 2064 6570 7468 2c20 496e   Index depth, In
+000154a0: 6465 7820 726f 7773 2c20 496e 6465 7820  dex rows, Index 
+000154b0: 7374 7269 6465 2c20 496e 6465 7820 6f66  stride, Index of
+000154c0: 6673 6574 290a 7b0a 2020 7479 7065 6465  fset).{.  typede
+000154d0: 6620 7479 7065 6e61 6d65 2075 6e70 6163  f typename unpac
+000154e0: 6b65 745f 7472 6169 7473 3c50 6163 6b65  ket_traits<Packe
+000154f0: 743e 3a3a 6861 6c66 2048 616c 6650 6163  t>::half HalfPac
+00015500: 6b65 743b 0a20 2074 7970 6564 6566 2074  ket;.  typedef t
+00015510: 7970 656e 616d 6520 756e 7061 636b 6574  ypename unpacket
+00015520: 5f74 7261 6974 733c 7479 7065 6e61 6d65  _traits<typename
+00015530: 2075 6e70 6163 6b65 745f 7472 6169 7473   unpacket_traits
+00015540: 3c50 6163 6b65 743e 3a3a 6861 6c66 3e3a  <Packet>::half>:
+00015550: 3a68 616c 6620 5175 6172 7465 7250 6163  :half QuarterPac
+00015560: 6b65 743b 0a20 2065 6e75 6d20 7b20 5061  ket;.  enum { Pa
+00015570: 636b 6574 5369 7a65 203d 2075 6e70 6163  cketSize = unpac
+00015580: 6b65 745f 7472 6169 7473 3c50 6163 6b65  ket_traits<Packe
+00015590: 743e 3a3a 7369 7a65 2c0a 2020 2020 2020  t>::size,.      
+000155a0: 2020 2048 616c 6650 6163 6b65 7453 697a     HalfPacketSiz
+000155b0: 6520 3d20 756e 7061 636b 6574 5f74 7261  e = unpacket_tra
+000155c0: 6974 733c 4861 6c66 5061 636b 6574 3e3a  its<HalfPacket>:
+000155d0: 3a73 697a 652c 0a20 2020 2020 2020 2020  :size,.         
+000155e0: 5175 6172 7465 7250 6163 6b65 7453 697a  QuarterPacketSiz
+000155f0: 6520 3d20 756e 7061 636b 6574 5f74 7261  e = unpacket_tra
+00015600: 6974 733c 5175 6172 7465 7250 6163 6b65  its<QuarterPacke
+00015610: 743e 3a3a 7369 7a65 2c0a 2020 2020 2020  t>::size,.      
+00015620: 2020 2048 6173 4861 6c66 203d 2028 696e     HasHalf = (in
+00015630: 7429 4861 6c66 5061 636b 6574 5369 7a65  t)HalfPacketSize
+00015640: 203c 2028 696e 7429 5061 636b 6574 5369   < (int)PacketSi
+00015650: 7a65 2c0a 2020 2020 2020 2020 2048 6173  ze,.         Has
+00015660: 5175 6172 7465 7220 3d20 2869 6e74 2951  Quarter = (int)Q
+00015670: 7561 7274 6572 5061 636b 6574 5369 7a65  uarterPacketSize
+00015680: 203c 2028 696e 7429 4861 6c66 5061 636b   < (int)HalfPack
+00015690: 6574 5369 7a65 7d3b 0a0a 2020 4549 4745  etSize};..  EIGE
+000156a0: 4e5f 4153 4d5f 434f 4d4d 454e 5428 2245  N_ASM_COMMENT("E
+000156b0: 4947 454e 2050 524f 4455 4354 2050 4143  IGEN PRODUCT PAC
+000156c0: 4b20 4c48 5322 293b 0a20 2045 4947 454e  K LHS");.  EIGEN
+000156d0: 5f55 4e55 5345 445f 5641 5249 4142 4c45  _UNUSED_VARIABLE
+000156e0: 2873 7472 6964 6529 3b0a 2020 4549 4745  (stride);.  EIGE
+000156f0: 4e5f 554e 5553 4544 5f56 4152 4941 424c  N_UNUSED_VARIABL
+00015700: 4528 6f66 6673 6574 293b 0a20 2065 6967  E(offset);.  eig
+00015710: 656e 5f61 7373 6572 7428 2828 2150 616e  en_assert(((!Pan
+00015720: 656c 4d6f 6465 2920 2626 2073 7472 6964  elMode) && strid
+00015730: 653d 3d30 2026 2620 6f66 6673 6574 3d3d  e==0 && offset==
+00015740: 3029 207c 7c20 2850 616e 656c 4d6f 6465  0) || (PanelMode
+00015750: 2026 2620 7374 7269 6465 3e3d 6465 7074   && stride>=dept
+00015760: 6820 2626 206f 6666 7365 743c 3d73 7472  h && offset<=str
+00015770: 6964 6529 293b 0a20 2065 6967 656e 5f61  ide));.  eigen_a
+00015780: 7373 6572 7428 2028 2850 6163 6b31 2550  ssert( ((Pack1%P
+00015790: 6163 6b65 7453 697a 6529 3d3d 3020 2626  acketSize)==0 &&
+000157a0: 2050 6163 6b31 3c3d 342a 5061 636b 6574   Pack1<=4*Packet
+000157b0: 5369 7a65 2920 7c7c 2028 5061 636b 313c  Size) || (Pack1<
+000157c0: 3d34 2920 293b 0a20 2063 6f6e 6a5f 6966  =4) );.  conj_if
+000157d0: 3c4e 756d 5472 6169 7473 3c53 6361 6c61  <NumTraits<Scala
+000157e0: 723e 3a3a 4973 436f 6d70 6c65 7820 2626  r>::IsComplex &&
+000157f0: 2043 6f6e 6a75 6761 7465 3e20 636a 3b0a   Conjugate> cj;.
+00015800: 2020 496e 6465 7820 636f 756e 7420 3d20    Index count = 
+00015810: 303b 0a0a 2020 636f 6e73 7420 496e 6465  0;..  const Inde
+00015820: 7820 7065 656c 6564 5f6d 6333 203d 2050  x peeled_mc3 = P
+00015830: 6163 6b31 3e3d 332a 5061 636b 6574 5369  ack1>=3*PacketSi
+00015840: 7a65 203f 2028 726f 7773 2f28 332a 5061  ze ? (rows/(3*Pa
+00015850: 636b 6574 5369 7a65 2929 2a28 332a 5061  cketSize))*(3*Pa
+00015860: 636b 6574 5369 7a65 2920 3a20 303b 0a20  cketSize) : 0;. 
+00015870: 2063 6f6e 7374 2049 6e64 6578 2070 6565   const Index pee
+00015880: 6c65 645f 6d63 3220 3d20 5061 636b 313e  led_mc2 = Pack1>
+00015890: 3d32 2a50 6163 6b65 7453 697a 6520 3f20  =2*PacketSize ? 
+000158a0: 7065 656c 6564 5f6d 6333 2b28 2872 6f77  peeled_mc3+((row
+000158b0: 732d 7065 656c 6564 5f6d 6333 292f 2832  s-peeled_mc3)/(2
+000158c0: 2a50 6163 6b65 7453 697a 6529 292a 2832  *PacketSize))*(2
+000158d0: 2a50 6163 6b65 7453 697a 6529 203a 2030  *PacketSize) : 0
+000158e0: 3b0a 2020 636f 6e73 7420 496e 6465 7820  ;.  const Index 
+000158f0: 7065 656c 6564 5f6d 6331 203d 2050 6163  peeled_mc1 = Pac
+00015900: 6b31 3e3d 312a 5061 636b 6574 5369 7a65  k1>=1*PacketSize
+00015910: 203f 2070 6565 6c65 645f 6d63 322b 2828   ? peeled_mc2+((
+00015920: 726f 7773 2d70 6565 6c65 645f 6d63 3229  rows-peeled_mc2)
+00015930: 2f28 312a 5061 636b 6574 5369 7a65 2929  /(1*PacketSize))
+00015940: 2a28 312a 5061 636b 6574 5369 7a65 2920  *(1*PacketSize) 
+00015950: 3a20 303b 0a20 2063 6f6e 7374 2049 6e64  : 0;.  const Ind
+00015960: 6578 2070 6565 6c65 645f 6d63 5f68 616c  ex peeled_mc_hal
+00015970: 6620 3d20 5061 636b 313e 3d48 616c 6650  f = Pack1>=HalfP
+00015980: 6163 6b65 7453 697a 6520 3f20 7065 656c  acketSize ? peel
+00015990: 6564 5f6d 6331 2b28 2872 6f77 732d 7065  ed_mc1+((rows-pe
+000159a0: 656c 6564 5f6d 6331 292f 2848 616c 6650  eled_mc1)/(HalfP
+000159b0: 6163 6b65 7453 697a 6529 292a 2848 616c  acketSize))*(Hal
+000159c0: 6650 6163 6b65 7453 697a 6529 203a 2030  fPacketSize) : 0
+000159d0: 3b0a 2020 636f 6e73 7420 496e 6465 7820  ;.  const Index 
+000159e0: 7065 656c 6564 5f6d 635f 7175 6172 7465  peeled_mc_quarte
+000159f0: 7220 3d20 5061 636b 313e 3d51 7561 7274  r = Pack1>=Quart
+00015a00: 6572 5061 636b 6574 5369 7a65 203f 2028  erPacketSize ? (
+00015a10: 726f 7773 2f28 5175 6172 7465 7250 6163  rows/(QuarterPac
+00015a20: 6b65 7453 697a 6529 292a 2851 7561 7274  ketSize))*(Quart
+00015a30: 6572 5061 636b 6574 5369 7a65 2920 3a20  erPacketSize) : 
+00015a40: 303b 0a20 2063 6f6e 7374 2049 6e64 6578  0;.  const Index
+00015a50: 206c 6173 745f 6c68 735f 7072 6f67 7265   last_lhs_progre
+00015a60: 7373 203d 2072 6f77 7320 3e20 7065 656c  ss = rows > peel
+00015a70: 6564 5f6d 635f 7175 6172 7465 7220 3f20  ed_mc_quarter ? 
+00015a80: 2872 6f77 7320 2d20 7065 656c 6564 5f6d  (rows - peeled_m
+00015a90: 635f 7175 6172 7465 7229 2026 207e 3120  c_quarter) & ~1 
+00015aa0: 3a20 303b 0a20 2063 6f6e 7374 2049 6e64  : 0;.  const Ind
+00015ab0: 6578 2070 6565 6c65 645f 6d63 3020 3d20  ex peeled_mc0 = 
+00015ac0: 5061 636b 323e 3d50 6163 6b65 7453 697a  Pack2>=PacketSiz
+00015ad0: 6520 3f20 7065 656c 6564 5f6d 635f 7175  e ? peeled_mc_qu
+00015ae0: 6172 7465 720a 2020 2020 2020 2020 2020  arter.          
+00015af0: 2020 2020 2020 2020 2020 2020 2020 203a                 :
+00015b00: 2050 6163 6b32 3e31 2026 2620 6c61 7374   Pack2>1 && last
+00015b10: 5f6c 6873 5f70 726f 6772 6573 7320 3f20  _lhs_progress ? 
+00015b20: 2872 6f77 732f 6c61 7374 5f6c 6873 5f70  (rows/last_lhs_p
+00015b30: 726f 6772 6573 7329 2a6c 6173 745f 6c68  rogress)*last_lh
+00015b40: 735f 7072 6f67 7265 7373 203a 2030 3b0a  s_progress : 0;.
+00015b50: 0a20 2049 6e64 6578 2069 3d30 3b0a 0a20  .  Index i=0;.. 
+00015b60: 202f 2f20 5061 636b 2033 2070 6163 6b65   // Pack 3 packe
+00015b70: 7473 0a20 2069 6628 5061 636b 313e 3d33  ts.  if(Pack1>=3
+00015b80: 2a50 6163 6b65 7453 697a 6529 0a20 207b  *PacketSize).  {
+00015b90: 0a20 2020 2066 6f72 283b 2069 3c70 6565  .    for(; i<pee
+00015ba0: 6c65 645f 6d63 333b 2069 2b3d 332a 5061  led_mc3; i+=3*Pa
+00015bb0: 636b 6574 5369 7a65 290a 2020 2020 7b0a  cketSize).    {.
+00015bc0: 2020 2020 2020 6966 2850 616e 656c 4d6f        if(PanelMo
+00015bd0: 6465 2920 636f 756e 7420 2b3d 2028 332a  de) count += (3*
+00015be0: 5061 636b 6574 5369 7a65 2920 2a20 6f66  PacketSize) * of
+00015bf0: 6673 6574 3b0a 0a20 2020 2020 2066 6f72  fset;..      for
+00015c00: 2849 6e64 6578 206b 3d30 3b20 6b3c 6465  (Index k=0; k<de
+00015c10: 7074 683b 206b 2b2b 290a 2020 2020 2020  pth; k++).      
+00015c20: 7b0a 2020 2020 2020 2020 5061 636b 6574  {.        Packet
+00015c30: 2041 2c20 422c 2043 3b0a 2020 2020 2020   A, B, C;.      
+00015c40: 2020 4120 3d20 6c68 732e 7465 6d70 6c61    A = lhs.templa
+00015c50: 7465 206c 6f61 6450 6163 6b65 743c 5061  te loadPacket<Pa
+00015c60: 636b 6574 3e28 692b 302a 5061 636b 6574  cket>(i+0*Packet
+00015c70: 5369 7a65 2c20 6b29 3b0a 2020 2020 2020  Size, k);.      
+00015c80: 2020 4220 3d20 6c68 732e 7465 6d70 6c61    B = lhs.templa
+00015c90: 7465 206c 6f61 6450 6163 6b65 743c 5061  te loadPacket<Pa
+00015ca0: 636b 6574 3e28 692b 312a 5061 636b 6574  cket>(i+1*Packet
+00015cb0: 5369 7a65 2c20 6b29 3b0a 2020 2020 2020  Size, k);.      
+00015cc0: 2020 4320 3d20 6c68 732e 7465 6d70 6c61    C = lhs.templa
+00015cd0: 7465 206c 6f61 6450 6163 6b65 743c 5061  te loadPacket<Pa
+00015ce0: 636b 6574 3e28 692b 322a 5061 636b 6574  cket>(i+2*Packet
+00015cf0: 5369 7a65 2c20 6b29 3b0a 2020 2020 2020  Size, k);.      
+00015d00: 2020 7073 746f 7265 2862 6c6f 636b 412b    pstore(blockA+
+00015d10: 636f 756e 742c 2063 6a2e 7063 6f6e 6a28  count, cj.pconj(
+00015d20: 4129 293b 2063 6f75 6e74 2b3d 5061 636b  A)); count+=Pack
+00015d30: 6574 5369 7a65 3b0a 2020 2020 2020 2020  etSize;.        
+00015d40: 7073 746f 7265 2862 6c6f 636b 412b 636f  pstore(blockA+co
+00015d50: 756e 742c 2063 6a2e 7063 6f6e 6a28 4229  unt, cj.pconj(B)
+00015d60: 293b 2063 6f75 6e74 2b3d 5061 636b 6574  ); count+=Packet
+00015d70: 5369 7a65 3b0a 2020 2020 2020 2020 7073  Size;.        ps
+00015d80: 746f 7265 2862 6c6f 636b 412b 636f 756e  tore(blockA+coun
+00015d90: 742c 2063 6a2e 7063 6f6e 6a28 4329 293b  t, cj.pconj(C));
+00015da0: 2063 6f75 6e74 2b3d 5061 636b 6574 5369   count+=PacketSi
+00015db0: 7a65 3b0a 2020 2020 2020 7d0a 2020 2020  ze;.      }.    
+00015dc0: 2020 6966 2850 616e 656c 4d6f 6465 2920    if(PanelMode) 
+00015dd0: 636f 756e 7420 2b3d 2028 332a 5061 636b  count += (3*Pack
+00015de0: 6574 5369 7a65 2920 2a20 2873 7472 6964  etSize) * (strid
+00015df0: 652d 6f66 6673 6574 2d64 6570 7468 293b  e-offset-depth);
+00015e00: 0a20 2020 207d 0a20 207d 0a20 202f 2f20  .    }.  }.  // 
+00015e10: 5061 636b 2032 2070 6163 6b65 7473 0a20  Pack 2 packets. 
+00015e20: 2069 6628 5061 636b 313e 3d32 2a50 6163   if(Pack1>=2*Pac
+00015e30: 6b65 7453 697a 6529 0a20 207b 0a20 2020  ketSize).  {.   
+00015e40: 2066 6f72 283b 2069 3c70 6565 6c65 645f   for(; i<peeled_
+00015e50: 6d63 323b 2069 2b3d 322a 5061 636b 6574  mc2; i+=2*Packet
+00015e60: 5369 7a65 290a 2020 2020 7b0a 2020 2020  Size).    {.    
+00015e70: 2020 6966 2850 616e 656c 4d6f 6465 2920    if(PanelMode) 
+00015e80: 636f 756e 7420 2b3d 2028 322a 5061 636b  count += (2*Pack
+00015e90: 6574 5369 7a65 2920 2a20 6f66 6673 6574  etSize) * offset
+00015ea0: 3b0a 0a20 2020 2020 2066 6f72 2849 6e64  ;..      for(Ind
+00015eb0: 6578 206b 3d30 3b20 6b3c 6465 7074 683b  ex k=0; k<depth;
+00015ec0: 206b 2b2b 290a 2020 2020 2020 7b0a 2020   k++).      {.  
+00015ed0: 2020 2020 2020 5061 636b 6574 2041 2c20        Packet A, 
+00015ee0: 423b 0a20 2020 2020 2020 2041 203d 206c  B;.        A = l
+00015ef0: 6873 2e74 656d 706c 6174 6520 6c6f 6164  hs.template load
+00015f00: 5061 636b 6574 3c50 6163 6b65 743e 2869  Packet<Packet>(i
+00015f10: 2b30 2a50 6163 6b65 7453 697a 652c 206b  +0*PacketSize, k
+00015f20: 293b 0a20 2020 2020 2020 2042 203d 206c  );.        B = l
+00015f30: 6873 2e74 656d 706c 6174 6520 6c6f 6164  hs.template load
+00015f40: 5061 636b 6574 3c50 6163 6b65 743e 2869  Packet<Packet>(i
+00015f50: 2b31 2a50 6163 6b65 7453 697a 652c 206b  +1*PacketSize, k
+00015f60: 293b 0a20 2020 2020 2020 2070 7374 6f72  );.        pstor
+00015f70: 6528 626c 6f63 6b41 2b63 6f75 6e74 2c20  e(blockA+count, 
+00015f80: 636a 2e70 636f 6e6a 2841 2929 3b20 636f  cj.pconj(A)); co
+00015f90: 756e 742b 3d50 6163 6b65 7453 697a 653b  unt+=PacketSize;
+00015fa0: 0a20 2020 2020 2020 2070 7374 6f72 6528  .        pstore(
+00015fb0: 626c 6f63 6b41 2b63 6f75 6e74 2c20 636a  blockA+count, cj
+00015fc0: 2e70 636f 6e6a 2842 2929 3b20 636f 756e  .pconj(B)); coun
+00015fd0: 742b 3d50 6163 6b65 7453 697a 653b 0a20  t+=PacketSize;. 
+00015fe0: 2020 2020 207d 0a20 2020 2020 2069 6628       }.      if(
+00015ff0: 5061 6e65 6c4d 6f64 6529 2063 6f75 6e74  PanelMode) count
+00016000: 202b 3d20 2832 2a50 6163 6b65 7453 697a   += (2*PacketSiz
+00016010: 6529 202a 2028 7374 7269 6465 2d6f 6666  e) * (stride-off
+00016020: 7365 742d 6465 7074 6829 3b0a 2020 2020  set-depth);.    
+00016030: 7d0a 2020 7d0a 2020 2f2f 2050 6163 6b20  }.  }.  // Pack 
+00016040: 3120 7061 636b 6574 730a 2020 6966 2850  1 packets.  if(P
+00016050: 6163 6b31 3e3d 312a 5061 636b 6574 5369  ack1>=1*PacketSi
+00016060: 7a65 290a 2020 7b0a 2020 2020 666f 7228  ze).  {.    for(
+00016070: 3b20 693c 7065 656c 6564 5f6d 6331 3b20  ; i<peeled_mc1; 
+00016080: 692b 3d31 2a50 6163 6b65 7453 697a 6529  i+=1*PacketSize)
+00016090: 0a20 2020 207b 0a20 2020 2020 2069 6628  .    {.      if(
+000160a0: 5061 6e65 6c4d 6f64 6529 2063 6f75 6e74  PanelMode) count
+000160b0: 202b 3d20 2831 2a50 6163 6b65 7453 697a   += (1*PacketSiz
+000160c0: 6529 202a 206f 6666 7365 743b 0a0a 2020  e) * offset;..  
+000160d0: 2020 2020 666f 7228 496e 6465 7820 6b3d      for(Index k=
+000160e0: 303b 206b 3c64 6570 7468 3b20 6b2b 2b29  0; k<depth; k++)
+000160f0: 0a20 2020 2020 207b 0a20 2020 2020 2020  .      {.       
+00016100: 2050 6163 6b65 7420 413b 0a20 2020 2020   Packet A;.     
+00016110: 2020 2041 203d 206c 6873 2e74 656d 706c     A = lhs.templ
+00016120: 6174 6520 6c6f 6164 5061 636b 6574 3c50  ate loadPacket<P
+00016130: 6163 6b65 743e 2869 2b30 2a50 6163 6b65  acket>(i+0*Packe
+00016140: 7453 697a 652c 206b 293b 0a20 2020 2020  tSize, k);.     
+00016150: 2020 2070 7374 6f72 6528 626c 6f63 6b41     pstore(blockA
+00016160: 2b63 6f75 6e74 2c20 636a 2e70 636f 6e6a  +count, cj.pconj
+00016170: 2841 2929 3b0a 2020 2020 2020 2020 636f  (A));.        co
+00016180: 756e 742b 3d50 6163 6b65 7453 697a 653b  unt+=PacketSize;
+00016190: 0a20 2020 2020 207d 0a20 2020 2020 2069  .      }.      i
+000161a0: 6628 5061 6e65 6c4d 6f64 6529 2063 6f75  f(PanelMode) cou
+000161b0: 6e74 202b 3d20 2831 2a50 6163 6b65 7453  nt += (1*PacketS
+000161c0: 697a 6529 202a 2028 7374 7269 6465 2d6f  ize) * (stride-o
+000161d0: 6666 7365 742d 6465 7074 6829 3b0a 2020  ffset-depth);.  
+000161e0: 2020 7d0a 2020 7d0a 2020 2f2f 2050 6163    }.  }.  // Pac
+000161f0: 6b20 6861 6c66 2070 6163 6b65 7473 0a20  k half packets. 
+00016200: 2069 6628 4861 7348 616c 6620 2626 2050   if(HasHalf && P
+00016210: 6163 6b31 3e3d 4861 6c66 5061 636b 6574  ack1>=HalfPacket
+00016220: 5369 7a65 290a 2020 7b0a 2020 2020 666f  Size).  {.    fo
+00016230: 7228 3b20 693c 7065 656c 6564 5f6d 635f  r(; i<peeled_mc_
+00016240: 6861 6c66 3b20 692b 3d48 616c 6650 6163  half; i+=HalfPac
+00016250: 6b65 7453 697a 6529 0a20 2020 207b 0a20  ketSize).    {. 
+00016260: 2020 2020 2069 6628 5061 6e65 6c4d 6f64       if(PanelMod
+00016270: 6529 2063 6f75 6e74 202b 3d20 2848 616c  e) count += (Hal
+00016280: 6650 6163 6b65 7453 697a 6529 202a 206f  fPacketSize) * o
+00016290: 6666 7365 743b 0a0a 2020 2020 2020 666f  ffset;..      fo
+000162a0: 7228 496e 6465 7820 6b3d 303b 206b 3c64  r(Index k=0; k<d
+000162b0: 6570 7468 3b20 6b2b 2b29 0a20 2020 2020  epth; k++).     
+000162c0: 207b 0a20 2020 2020 2020 2048 616c 6650   {.        HalfP
+000162d0: 6163 6b65 7420 413b 0a20 2020 2020 2020  acket A;.       
+000162e0: 2041 203d 206c 6873 2e74 656d 706c 6174   A = lhs.templat
+000162f0: 6520 6c6f 6164 5061 636b 6574 3c48 616c  e loadPacket<Hal
+00016300: 6650 6163 6b65 743e 2869 2b30 2a28 4861  fPacket>(i+0*(Ha
+00016310: 6c66 5061 636b 6574 5369 7a65 292c 206b  lfPacketSize), k
+00016320: 293b 0a20 2020 2020 2020 2070 7374 6f72  );.        pstor
+00016330: 6575 2862 6c6f 636b 412b 636f 756e 742c  eu(blockA+count,
+00016340: 2063 6a2e 7063 6f6e 6a28 4129 293b 0a20   cj.pconj(A));. 
+00016350: 2020 2020 2020 2063 6f75 6e74 2b3d 4861         count+=Ha
+00016360: 6c66 5061 636b 6574 5369 7a65 3b0a 2020  lfPacketSize;.  
+00016370: 2020 2020 7d0a 2020 2020 2020 6966 2850      }.      if(P
+00016380: 616e 656c 4d6f 6465 2920 636f 756e 7420  anelMode) count 
+00016390: 2b3d 2028 4861 6c66 5061 636b 6574 5369  += (HalfPacketSi
+000163a0: 7a65 2920 2a20 2873 7472 6964 652d 6f66  ze) * (stride-of
+000163b0: 6673 6574 2d64 6570 7468 293b 0a20 2020  fset-depth);.   
+000163c0: 207d 0a20 207d 0a20 202f 2f20 5061 636b   }.  }.  // Pack
+000163d0: 2071 7561 7274 6572 2070 6163 6b65 7473   quarter packets
+000163e0: 0a20 2069 6628 4861 7351 7561 7274 6572  .  if(HasQuarter
+000163f0: 2026 2620 5061 636b 313e 3d51 7561 7274   && Pack1>=Quart
+00016400: 6572 5061 636b 6574 5369 7a65 290a 2020  erPacketSize).  
+00016410: 7b0a 2020 2020 666f 7228 3b20 693c 7065  {.    for(; i<pe
+00016420: 656c 6564 5f6d 635f 7175 6172 7465 723b  eled_mc_quarter;
+00016430: 2069 2b3d 5175 6172 7465 7250 6163 6b65   i+=QuarterPacke
+00016440: 7453 697a 6529 0a20 2020 207b 0a20 2020  tSize).    {.   
+00016450: 2020 2069 6628 5061 6e65 6c4d 6f64 6529     if(PanelMode)
+00016460: 2063 6f75 6e74 202b 3d20 2851 7561 7274   count += (Quart
+00016470: 6572 5061 636b 6574 5369 7a65 2920 2a20  erPacketSize) * 
+00016480: 6f66 6673 6574 3b0a 0a20 2020 2020 2066  offset;..      f
+00016490: 6f72 2849 6e64 6578 206b 3d30 3b20 6b3c  or(Index k=0; k<
+000164a0: 6465 7074 683b 206b 2b2b 290a 2020 2020  depth; k++).    
+000164b0: 2020 7b0a 2020 2020 2020 2020 5175 6172    {.        Quar
+000164c0: 7465 7250 6163 6b65 7420 413b 0a20 2020  terPacket A;.   
+000164d0: 2020 2020 2041 203d 206c 6873 2e74 656d       A = lhs.tem
+000164e0: 706c 6174 6520 6c6f 6164 5061 636b 6574  plate loadPacket
+000164f0: 3c51 7561 7274 6572 5061 636b 6574 3e28  <QuarterPacket>(
+00016500: 692b 302a 2851 7561 7274 6572 5061 636b  i+0*(QuarterPack
+00016510: 6574 5369 7a65 292c 206b 293b 0a20 2020  etSize), k);.   
+00016520: 2020 2020 2070 7374 6f72 6575 2862 6c6f       pstoreu(blo
+00016530: 636b 412b 636f 756e 742c 2063 6a2e 7063  ckA+count, cj.pc
+00016540: 6f6e 6a28 4129 293b 0a20 2020 2020 2020  onj(A));.       
+00016550: 2063 6f75 6e74 2b3d 5175 6172 7465 7250   count+=QuarterP
+00016560: 6163 6b65 7453 697a 653b 0a20 2020 2020  acketSize;.     
+00016570: 207d 0a20 2020 2020 2069 6628 5061 6e65   }.      if(Pane
+00016580: 6c4d 6f64 6529 2063 6f75 6e74 202b 3d20  lMode) count += 
+00016590: 2851 7561 7274 6572 5061 636b 6574 5369  (QuarterPacketSi
+000165a0: 7a65 2920 2a20 2873 7472 6964 652d 6f66  ze) * (stride-of
+000165b0: 6673 6574 2d64 6570 7468 293b 0a20 2020  fset-depth);.   
+000165c0: 207d 0a20 207d 0a20 202f 2f20 5061 636b   }.  }.  // Pack
+000165d0: 3220 6d61 7920 6265 202a 736d 616c 6c65  2 may be *smalle
+000165e0: 722a 2074 6861 6e20 5061 636b 6574 5369  r* than PacketSi
+000165f0: 7a65 e280 9474 6861 7420 6861 7070 656e  ze...that happen
+00016600: 7320 666f 720a 2020 2f2f 2070 726f 6475  s for.  // produ
+00016610: 6374 7320 6c69 6b65 2072 6561 6c20 2a20  cts like real * 
+00016620: 636f 6d70 6c65 782c 2077 6865 7265 2077  complex, where w
+00016630: 6520 6861 7665 2074 6f20 676f 2068 616c  e have to go hal
+00016640: 6620 7468 650a 2020 2f2f 2070 726f 6772  f the.  // progr
+00016650: 6573 7320 6f6e 2074 6865 206c 6873 2069  ess on the lhs i
+00016660: 6e20 6f72 6465 7220 746f 2064 7570 6c69  n order to dupli
+00016670: 6361 7465 2074 686f 7365 206f 7065 7261  cate those opera
+00016680: 6e64 7320 746f 0a20 202f 2f20 6164 6472  nds to.  // addr
+00016690: 6573 7320 626f 7468 2072 6561 6c20 2620  ess both real & 
+000166a0: 696d 6167 696e 6172 7920 7061 7274 7320  imaginary parts 
+000166b0: 6f6e 2074 6865 2072 6873 2e20 5468 6973  on the rhs. This
+000166c0: 2070 6f72 7469 6f6e 2077 696c 6c0a 2020   portion will.  
+000166d0: 2f2f 2070 6163 6b20 7468 6f73 6520 6861  // pack those ha
+000166e0: 6c66 206f 6e65 7320 756e 7469 6c20 7468  lf ones until th
+000166f0: 6579 206d 6174 6368 2074 6865 206e 756d  ey match the num
+00016700: 6265 7220 6578 7065 6374 6564 206f 6e20  ber expected on 
+00016710: 7468 650a 2020 2f2f 206c 6173 7420 7065  the.  // last pe
+00016720: 656c 696e 6720 6c6f 6f70 2061 7420 7468  eling loop at th
+00016730: 6973 2070 6f69 6e74 2028 666f 7220 7468  is point (for th
+00016740: 6520 7268 7329 2e0a 2020 6966 2850 6163  e rhs)..  if(Pac
+00016750: 6b32 3c50 6163 6b65 7453 697a 6520 2626  k2<PacketSize &&
+00016760: 2050 6163 6b32 3e31 290a 2020 7b0a 2020   Pack2>1).  {.  
+00016770: 2020 666f 7228 3b20 693c 7065 656c 6564    for(; i<peeled
+00016780: 5f6d 6330 3b20 692b 3d6c 6173 745f 6c68  _mc0; i+=last_lh
+00016790: 735f 7072 6f67 7265 7373 290a 2020 2020  s_progress).    
+000167a0: 7b0a 2020 2020 2020 6966 2850 616e 656c  {.      if(Panel
+000167b0: 4d6f 6465 2920 636f 756e 7420 2b3d 206c  Mode) count += l
+000167c0: 6173 745f 6c68 735f 7072 6f67 7265 7373  ast_lhs_progress
+000167d0: 202a 206f 6666 7365 743b 0a0a 2020 2020   * offset;..    
+000167e0: 2020 666f 7228 496e 6465 7820 6b3d 303b    for(Index k=0;
+000167f0: 206b 3c64 6570 7468 3b20 6b2b 2b29 0a20   k<depth; k++). 
+00016800: 2020 2020 2020 2066 6f72 2849 6e64 6578         for(Index
+00016810: 2077 3d30 3b20 773c 6c61 7374 5f6c 6873   w=0; w<last_lhs
+00016820: 5f70 726f 6772 6573 733b 2077 2b2b 290a  _progress; w++).
+00016830: 2020 2020 2020 2020 2020 626c 6f63 6b41            blockA
+00016840: 5b63 6f75 6e74 2b2b 5d20 3d20 636a 286c  [count++] = cj(l
+00016850: 6873 2869 2b77 2c20 6b29 293b 0a0a 2020  hs(i+w, k));..  
+00016860: 2020 2020 6966 2850 616e 656c 4d6f 6465      if(PanelMode
+00016870: 2920 636f 756e 7420 2b3d 206c 6173 745f  ) count += last_
+00016880: 6c68 735f 7072 6f67 7265 7373 202a 2028  lhs_progress * (
+00016890: 7374 7269 6465 2d6f 6666 7365 742d 6465  stride-offset-de
+000168a0: 7074 6829 3b0a 2020 2020 7d0a 2020 7d0a  pth);.    }.  }.
+000168b0: 2020 2f2f 2050 6163 6b20 7363 616c 6172    // Pack scalar
+000168c0: 730a 2020 666f 7228 3b20 693c 726f 7773  s.  for(; i<rows
+000168d0: 3b20 692b 2b29 0a20 207b 0a20 2020 2069  ; i++).  {.    i
+000168e0: 6628 5061 6e65 6c4d 6f64 6529 2063 6f75  f(PanelMode) cou
+000168f0: 6e74 202b 3d20 6f66 6673 6574 3b0a 2020  nt += offset;.  
+00016900: 2020 666f 7228 496e 6465 7820 6b3d 303b    for(Index k=0;
+00016910: 206b 3c64 6570 7468 3b20 6b2b 2b29 0a20   k<depth; k++). 
+00016920: 2020 2020 2062 6c6f 636b 415b 636f 756e       blockA[coun
+00016930: 742b 2b5d 203d 2063 6a28 6c68 7328 692c  t++] = cj(lhs(i,
+00016940: 206b 2929 3b0a 2020 2020 6966 2850 616e   k));.    if(Pan
+00016950: 656c 4d6f 6465 2920 636f 756e 7420 2b3d  elMode) count +=
+00016960: 2028 7374 7269 6465 2d6f 6666 7365 742d   (stride-offset-
+00016970: 6465 7074 6829 3b0a 2020 7d0a 7d0a 0a74  depth);.  }.}..t
+00016980: 656d 706c 6174 653c 7479 7065 6e61 6d65  emplate<typename
+00016990: 2053 6361 6c61 722c 2074 7970 656e 616d   Scalar, typenam
+000169a0: 6520 496e 6465 782c 2074 7970 656e 616d  e Index, typenam
+000169b0: 6520 4461 7461 4d61 7070 6572 2c20 696e  e DataMapper, in
+000169c0: 7420 5061 636b 312c 2069 6e74 2050 6163  t Pack1, int Pac
+000169d0: 6b32 2c20 7479 7065 6e61 6d65 2050 6163  k2, typename Pac
+000169e0: 6b65 742c 2062 6f6f 6c20 436f 6e6a 7567  ket, bool Conjug
+000169f0: 6174 652c 2062 6f6f 6c20 5061 6e65 6c4d  ate, bool PanelM
+00016a00: 6f64 653e 0a73 7472 7563 7420 6765 6d6d  ode>.struct gemm
+00016a10: 5f70 6163 6b5f 6c68 733c 5363 616c 6172  _pack_lhs<Scalar
+00016a20: 2c20 496e 6465 782c 2044 6174 614d 6170  , Index, DataMap
+00016a30: 7065 722c 2050 6163 6b31 2c20 5061 636b  per, Pack1, Pack
+00016a40: 322c 2050 6163 6b65 742c 2052 6f77 4d61  2, Packet, RowMa
+00016a50: 6a6f 722c 2043 6f6e 6a75 6761 7465 2c20  jor, Conjugate, 
+00016a60: 5061 6e65 6c4d 6f64 653e 0a7b 0a20 2074  PanelMode>.{.  t
+00016a70: 7970 6564 6566 2074 7970 656e 616d 6520  ypedef typename 
+00016a80: 4461 7461 4d61 7070 6572 3a3a 4c69 6e65  DataMapper::Line
+00016a90: 6172 4d61 7070 6572 204c 696e 6561 724d  arMapper LinearM
+00016aa0: 6170 7065 723b 0a20 2045 4947 454e 5f44  apper;.  EIGEN_D
+00016ab0: 4f4e 545f 494e 4c49 4e45 2076 6f69 6420  ONT_INLINE void 
+00016ac0: 6f70 6572 6174 6f72 2829 2853 6361 6c61  operator()(Scala
+00016ad0: 722a 2062 6c6f 636b 412c 2063 6f6e 7374  r* blockA, const
+00016ae0: 2044 6174 614d 6170 7065 7226 206c 6873   DataMapper& lhs
+00016af0: 2c20 496e 6465 7820 6465 7074 682c 2049  , Index depth, I
+00016b00: 6e64 6578 2072 6f77 732c 2049 6e64 6578  ndex rows, Index
+00016b10: 2073 7472 6964 653d 302c 2049 6e64 6578   stride=0, Index
+00016b20: 206f 6666 7365 743d 3029 3b0a 7d3b 0a0a   offset=0);.};..
+00016b30: 7465 6d70 6c61 7465 3c74 7970 656e 616d  template<typenam
+00016b40: 6520 5363 616c 6172 2c20 7479 7065 6e61  e Scalar, typena
+00016b50: 6d65 2049 6e64 6578 2c20 7479 7065 6e61  me Index, typena
+00016b60: 6d65 2044 6174 614d 6170 7065 722c 2069  me DataMapper, i
+00016b70: 6e74 2050 6163 6b31 2c20 696e 7420 5061  nt Pack1, int Pa
+00016b80: 636b 322c 2074 7970 656e 616d 6520 5061  ck2, typename Pa
+00016b90: 636b 6574 2c20 626f 6f6c 2043 6f6e 6a75  cket, bool Conju
+00016ba0: 6761 7465 2c20 626f 6f6c 2050 616e 656c  gate, bool Panel
+00016bb0: 4d6f 6465 3e0a 4549 4745 4e5f 444f 4e54  Mode>.EIGEN_DONT
+00016bc0: 5f49 4e4c 494e 4520 766f 6964 2067 656d  _INLINE void gem
+00016bd0: 6d5f 7061 636b 5f6c 6873 3c53 6361 6c61  m_pack_lhs<Scala
+00016be0: 722c 2049 6e64 6578 2c20 4461 7461 4d61  r, Index, DataMa
+00016bf0: 7070 6572 2c20 5061 636b 312c 2050 6163  pper, Pack1, Pac
+00016c00: 6b32 2c20 5061 636b 6574 2c20 526f 774d  k2, Packet, RowM
+00016c10: 616a 6f72 2c20 436f 6e6a 7567 6174 652c  ajor, Conjugate,
+00016c20: 2050 616e 656c 4d6f 6465 3e0a 2020 3a3a   PanelMode>.  ::
+00016c30: 6f70 6572 6174 6f72 2829 2853 6361 6c61  operator()(Scala
+00016c40: 722a 2062 6c6f 636b 412c 2063 6f6e 7374  r* blockA, const
+00016c50: 2044 6174 614d 6170 7065 7226 206c 6873   DataMapper& lhs
+00016c60: 2c20 496e 6465 7820 6465 7074 682c 2049  , Index depth, I
+00016c70: 6e64 6578 2072 6f77 732c 2049 6e64 6578  ndex rows, Index
+00016c80: 2073 7472 6964 652c 2049 6e64 6578 206f   stride, Index o
+00016c90: 6666 7365 7429 0a7b 0a20 2074 7970 6564  ffset).{.  typed
+00016ca0: 6566 2074 7970 656e 616d 6520 756e 7061  ef typename unpa
+00016cb0: 636b 6574 5f74 7261 6974 733c 5061 636b  cket_traits<Pack
+00016cc0: 6574 3e3a 3a68 616c 6620 4861 6c66 5061  et>::half HalfPa
+00016cd0: 636b 6574 3b0a 2020 7479 7065 6465 6620  cket;.  typedef 
+00016ce0: 7479 7065 6e61 6d65 2075 6e70 6163 6b65  typename unpacke
+00016cf0: 745f 7472 6169 7473 3c74 7970 656e 616d  t_traits<typenam
+00016d00: 6520 756e 7061 636b 6574 5f74 7261 6974  e unpacket_trait
+00016d10: 733c 5061 636b 6574 3e3a 3a68 616c 663e  s<Packet>::half>
+00016d20: 3a3a 6861 6c66 2051 7561 7274 6572 5061  ::half QuarterPa
+00016d30: 636b 6574 3b0a 2020 656e 756d 207b 2050  cket;.  enum { P
+00016d40: 6163 6b65 7453 697a 6520 3d20 756e 7061  acketSize = unpa
+00016d50: 636b 6574 5f74 7261 6974 733c 5061 636b  cket_traits<Pack
+00016d60: 6574 3e3a 3a73 697a 652c 0a20 2020 2020  et>::size,.     
+00016d70: 2020 2020 4861 6c66 5061 636b 6574 5369      HalfPacketSi
+00016d80: 7a65 203d 2075 6e70 6163 6b65 745f 7472  ze = unpacket_tr
+00016d90: 6169 7473 3c48 616c 6650 6163 6b65 743e  aits<HalfPacket>
+00016da0: 3a3a 7369 7a65 2c0a 2020 2020 2020 2020  ::size,.        
+00016db0: 2051 7561 7274 6572 5061 636b 6574 5369   QuarterPacketSi
+00016dc0: 7a65 203d 2075 6e70 6163 6b65 745f 7472  ze = unpacket_tr
+00016dd0: 6169 7473 3c51 7561 7274 6572 5061 636b  aits<QuarterPack
+00016de0: 6574 3e3a 3a73 697a 652c 0a20 2020 2020  et>::size,.     
+00016df0: 2020 2020 4861 7348 616c 6620 3d20 2869      HasHalf = (i
+00016e00: 6e74 2948 616c 6650 6163 6b65 7453 697a  nt)HalfPacketSiz
+00016e10: 6520 3c20 2869 6e74 2950 6163 6b65 7453  e < (int)PacketS
+00016e20: 697a 652c 0a20 2020 2020 2020 2020 4861  ize,.         Ha
+00016e30: 7351 7561 7274 6572 203d 2028 696e 7429  sQuarter = (int)
+00016e40: 5175 6172 7465 7250 6163 6b65 7453 697a  QuarterPacketSiz
+00016e50: 6520 3c20 2869 6e74 2948 616c 6650 6163  e < (int)HalfPac
+00016e60: 6b65 7453 697a 657d 3b0a 0a20 2045 4947  ketSize};..  EIG
+00016e70: 454e 5f41 534d 5f43 4f4d 4d45 4e54 2822  EN_ASM_COMMENT("
+00016e80: 4549 4745 4e20 5052 4f44 5543 5420 5041  EIGEN PRODUCT PA
+00016e90: 434b 204c 4853 2229 3b0a 2020 4549 4745  CK LHS");.  EIGE
+00016ea0: 4e5f 554e 5553 4544 5f56 4152 4941 424c  N_UNUSED_VARIABL
+00016eb0: 4528 7374 7269 6465 293b 0a20 2045 4947  E(stride);.  EIG
+00016ec0: 454e 5f55 4e55 5345 445f 5641 5249 4142  EN_UNUSED_VARIAB
+00016ed0: 4c45 286f 6666 7365 7429 3b0a 2020 6569  LE(offset);.  ei
+00016ee0: 6765 6e5f 6173 7365 7274 2828 2821 5061  gen_assert(((!Pa
+00016ef0: 6e65 6c4d 6f64 6529 2026 2620 7374 7269  nelMode) && stri
+00016f00: 6465 3d3d 3020 2626 206f 6666 7365 743d  de==0 && offset=
+00016f10: 3d30 2920 7c7c 2028 5061 6e65 6c4d 6f64  =0) || (PanelMod
+00016f20: 6520 2626 2073 7472 6964 653e 3d64 6570  e && stride>=dep
+00016f30: 7468 2026 2620 6f66 6673 6574 3c3d 7374  th && offset<=st
+00016f40: 7269 6465 2929 3b0a 2020 636f 6e6a 5f69  ride));.  conj_i
+00016f50: 663c 4e75 6d54 7261 6974 733c 5363 616c  f<NumTraits<Scal
+00016f60: 6172 3e3a 3a49 7343 6f6d 706c 6578 2026  ar>::IsComplex &
+00016f70: 2620 436f 6e6a 7567 6174 653e 2063 6a3b  & Conjugate> cj;
+00016f80: 0a20 2049 6e64 6578 2063 6f75 6e74 203d  .  Index count =
+00016f90: 2030 3b0a 2020 626f 6f6c 2067 6f6e 655f   0;.  bool gone_
+00016fa0: 6861 6c66 203d 2066 616c 7365 2c20 676f  half = false, go
+00016fb0: 6e65 5f71 7561 7274 6572 203d 2066 616c  ne_quarter = fal
+00016fc0: 7365 2c20 676f 6e65 5f6c 6173 7420 3d20  se, gone_last = 
+00016fd0: 6661 6c73 653b 0a0a 2020 496e 6465 7820  false;..  Index 
+00016fe0: 6920 3d20 303b 0a20 2069 6e74 2070 6163  i = 0;.  int pac
+00016ff0: 6b20 3d20 5061 636b 313b 0a20 2069 6e74  k = Pack1;.  int
+00017000: 2070 7369 7a65 203d 2050 6163 6b65 7453   psize = PacketS
+00017010: 697a 653b 0a20 2077 6869 6c65 2870 6163  ize;.  while(pac
+00017020: 6b3e 3029 0a20 207b 0a20 2020 2049 6e64  k>0).  {.    Ind
+00017030: 6578 2072 656d 6169 6e69 6e67 5f72 6f77  ex remaining_row
+00017040: 7320 3d20 726f 7773 2d69 3b0a 2020 2020  s = rows-i;.    
+00017050: 496e 6465 7820 7065 656c 6564 5f6d 6320  Index peeled_mc 
+00017060: 3d20 676f 6e65 5f6c 6173 7420 3f20 5061  = gone_last ? Pa
+00017070: 636b 323e 3120 3f20 2872 6f77 732f 7061  ck2>1 ? (rows/pa
+00017080: 636b 292a 7061 636b 203a 2030 203a 2069  ck)*pack : 0 : i
+00017090: 2b28 7265 6d61 696e 696e 675f 726f 7773  +(remaining_rows
+000170a0: 2f70 6163 6b29 2a70 6163 6b3b 0a20 2020  /pack)*pack;.   
+000170b0: 2049 6e64 6578 2073 7461 7274 696e 675f   Index starting_
+000170c0: 706f 7320 3d20 693b 0a20 2020 2066 6f72  pos = i;.    for
+000170d0: 283b 2069 3c70 6565 6c65 645f 6d63 3b20  (; i<peeled_mc; 
+000170e0: 692b 3d70 6163 6b29 0a20 2020 207b 0a20  i+=pack).    {. 
+000170f0: 2020 2020 2069 6628 5061 6e65 6c4d 6f64       if(PanelMod
+00017100: 6529 2063 6f75 6e74 202b 3d20 7061 636b  e) count += pack
+00017110: 202a 206f 6666 7365 743b 0a0a 2020 2020   * offset;..    
+00017120: 2020 496e 6465 7820 6b3d 303b 0a20 2020    Index k=0;.   
+00017130: 2020 2069 6628 7061 636b 3e3d 7073 697a     if(pack>=psiz
+00017140: 6520 2626 2070 7369 7a65 203e 3d20 5175  e && psize >= Qu
+00017150: 6172 7465 7250 6163 6b65 7453 697a 6529  arterPacketSize)
+00017160: 0a20 2020 2020 207b 0a20 2020 2020 2020  .      {.       
+00017170: 2063 6f6e 7374 2049 6e64 6578 2070 6565   const Index pee
+00017180: 6c65 645f 6b20 3d20 2864 6570 7468 2f70  led_k = (depth/p
+00017190: 7369 7a65 292a 7073 697a 653b 0a20 2020  size)*psize;.   
+000171a0: 2020 2020 2066 6f72 283b 206b 3c70 6565       for(; k<pee
+000171b0: 6c65 645f 6b3b 206b 2b3d 7073 697a 6529  led_k; k+=psize)
+000171c0: 0a20 2020 2020 2020 207b 0a20 2020 2020  .        {.     
+000171d0: 2020 2020 2066 6f72 2028 496e 6465 7820       for (Index 
+000171e0: 6d20 3d20 303b 206d 203c 2070 6163 6b3b  m = 0; m < pack;
+000171f0: 206d 202b 3d20 7073 697a 6529 0a20 2020   m += psize).   
+00017200: 2020 2020 2020 207b 0a20 2020 2020 2020         {.       
+00017210: 2020 2020 2069 6620 2870 7369 7a65 203d       if (psize =
+00017220: 3d20 5061 636b 6574 5369 7a65 2920 7b0a  = PacketSize) {.
+00017230: 2020 2020 2020 2020 2020 2020 2020 5061                Pa
+00017240: 636b 6574 426c 6f63 6b3c 5061 636b 6574  cketBlock<Packet
+00017250: 3e20 6b65 726e 656c 3b0a 2020 2020 2020  > kernel;.      
+00017260: 2020 2020 2020 2020 666f 7220 2869 6e74          for (int
+00017270: 2070 203d 2030 3b20 7020 3c20 7073 697a   p = 0; p < psiz
+00017280: 653b 202b 2b70 2920 6b65 726e 656c 2e70  e; ++p) kernel.p
+00017290: 6163 6b65 745b 705d 203d 206c 6873 2e74  acket[p] = lhs.t
+000172a0: 656d 706c 6174 6520 6c6f 6164 5061 636b  emplate loadPack
+000172b0: 6574 3c50 6163 6b65 743e 2869 2b70 2b6d  et<Packet>(i+p+m
+000172c0: 2c20 6b29 3b0a 2020 2020 2020 2020 2020  , k);.          
+000172d0: 2020 2020 7074 7261 6e73 706f 7365 286b      ptranspose(k
+000172e0: 6572 6e65 6c29 3b0a 2020 2020 2020 2020  ernel);.        
+000172f0: 2020 2020 2020 666f 7220 2869 6e74 2070        for (int p
+00017300: 203d 2030 3b20 7020 3c20 7073 697a 653b   = 0; p < psize;
+00017310: 202b 2b70 2920 7073 746f 7265 2862 6c6f   ++p) pstore(blo
+00017320: 636b 412b 636f 756e 742b 6d2b 2870 6163  ckA+count+m+(pac
+00017330: 6b29 2a70 2c20 636a 2e70 636f 6e6a 286b  k)*p, cj.pconj(k
+00017340: 6572 6e65 6c2e 7061 636b 6574 5b70 5d29  ernel.packet[p])
+00017350: 293b 0a20 2020 2020 2020 2020 2020 207d  );.            }
+00017360: 2065 6c73 6520 6966 2028 4861 7348 616c   else if (HasHal
+00017370: 6620 2626 2070 7369 7a65 203d 3d20 4861  f && psize == Ha
+00017380: 6c66 5061 636b 6574 5369 7a65 2920 7b0a  lfPacketSize) {.
+00017390: 2020 2020 2020 2020 2020 2020 2020 676f                go
+000173a0: 6e65 5f68 616c 6620 3d20 7472 7565 3b0a  ne_half = true;.
+000173b0: 2020 2020 2020 2020 2020 2020 2020 5061                Pa
+000173c0: 636b 6574 426c 6f63 6b3c 4861 6c66 5061  cketBlock<HalfPa
+000173d0: 636b 6574 3e20 6b65 726e 656c 5f68 616c  cket> kernel_hal
+000173e0: 663b 0a20 2020 2020 2020 2020 2020 2020  f;.             
+000173f0: 2066 6f72 2028 696e 7420 7020 3d20 303b   for (int p = 0;
+00017400: 2070 203c 2070 7369 7a65 3b20 2b2b 7029   p < psize; ++p)
+00017410: 206b 6572 6e65 6c5f 6861 6c66 2e70 6163   kernel_half.pac
+00017420: 6b65 745b 705d 203d 206c 6873 2e74 656d  ket[p] = lhs.tem
+00017430: 706c 6174 6520 6c6f 6164 5061 636b 6574  plate loadPacket
+00017440: 3c48 616c 6650 6163 6b65 743e 2869 2b70  <HalfPacket>(i+p
+00017450: 2b6d 2c20 6b29 3b0a 2020 2020 2020 2020  +m, k);.        
+00017460: 2020 2020 2020 7074 7261 6e73 706f 7365        ptranspose
+00017470: 286b 6572 6e65 6c5f 6861 6c66 293b 0a20  (kernel_half);. 
+00017480: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+00017490: 2028 696e 7420 7020 3d20 303b 2070 203c   (int p = 0; p <
+000174a0: 2070 7369 7a65 3b20 2b2b 7029 2070 7374   psize; ++p) pst
+000174b0: 6f72 6528 626c 6f63 6b41 2b63 6f75 6e74  ore(blockA+count
+000174c0: 2b6d 2b28 7061 636b 292a 702c 2063 6a2e  +m+(pack)*p, cj.
+000174d0: 7063 6f6e 6a28 6b65 726e 656c 5f68 616c  pconj(kernel_hal
+000174e0: 662e 7061 636b 6574 5b70 5d29 293b 0a20  f.packet[p]));. 
+000174f0: 2020 2020 2020 2020 2020 207d 2065 6c73             } els
+00017500: 6520 6966 2028 4861 7351 7561 7274 6572  e if (HasQuarter
+00017510: 2026 2620 7073 697a 6520 3d3d 2051 7561   && psize == Qua
+00017520: 7274 6572 5061 636b 6574 5369 7a65 2920  rterPacketSize) 
+00017530: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
+00017540: 676f 6e65 5f71 7561 7274 6572 203d 2074  gone_quarter = t
+00017550: 7275 653b 0a20 2020 2020 2020 2020 2020  rue;.           
+00017560: 2020 2050 6163 6b65 7442 6c6f 636b 3c51     PacketBlock<Q
+00017570: 7561 7274 6572 5061 636b 6574 3e20 6b65  uarterPacket> ke
+00017580: 726e 656c 5f71 7561 7274 6572 3b0a 2020  rnel_quarter;.  
+00017590: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+000175a0: 2869 6e74 2070 203d 2030 3b20 7020 3c20  (int p = 0; p < 
+000175b0: 7073 697a 653b 202b 2b70 2920 6b65 726e  psize; ++p) kern
+000175c0: 656c 5f71 7561 7274 6572 2e70 6163 6b65  el_quarter.packe
+000175d0: 745b 705d 203d 206c 6873 2e74 656d 706c  t[p] = lhs.templ
+000175e0: 6174 6520 6c6f 6164 5061 636b 6574 3c51  ate loadPacket<Q
+000175f0: 7561 7274 6572 5061 636b 6574 3e28 692b  uarterPacket>(i+
+00017600: 702b 6d2c 206b 293b 0a20 2020 2020 2020  p+m, k);.       
+00017610: 2020 2020 2020 2070 7472 616e 7370 6f73         ptranspos
+00017620: 6528 6b65 726e 656c 5f71 7561 7274 6572  e(kernel_quarter
+00017630: 293b 0a20 2020 2020 2020 2020 2020 2020  );.             
+00017640: 2066 6f72 2028 696e 7420 7020 3d20 303b   for (int p = 0;
+00017650: 2070 203c 2070 7369 7a65 3b20 2b2b 7029   p < psize; ++p)
+00017660: 2070 7374 6f72 6528 626c 6f63 6b41 2b63   pstore(blockA+c
+00017670: 6f75 6e74 2b6d 2b28 7061 636b 292a 702c  ount+m+(pack)*p,
+00017680: 2063 6a2e 7063 6f6e 6a28 6b65 726e 656c   cj.pconj(kernel
+00017690: 5f71 7561 7274 6572 2e70 6163 6b65 745b  _quarter.packet[
+000176a0: 705d 2929 3b0a 0920 2020 207d 0a20 2020  p]));..    }.   
+000176b0: 2020 2020 2020 207d 0a20 2020 2020 2020         }.       
+000176c0: 2020 2063 6f75 6e74 202b 3d20 7073 697a     count += psiz
+000176d0: 652a 7061 636b 3b0a 2020 2020 2020 2020  e*pack;.        
+000176e0: 7d0a 2020 2020 2020 7d0a 0a20 2020 2020  }.      }..     
+000176f0: 2066 6f72 283b 206b 3c64 6570 7468 3b20   for(; k<depth; 
+00017700: 6b2b 2b29 0a20 2020 2020 207b 0a20 2020  k++).      {.   
+00017710: 2020 2020 2049 6e64 6578 2077 3d30 3b0a       Index w=0;.
+00017720: 2020 2020 2020 2020 666f 7228 3b20 773c          for(; w<
+00017730: 7061 636b 2d33 3b20 772b 3d34 290a 2020  pack-3; w+=4).  
+00017740: 2020 2020 2020 7b0a 2020 2020 2020 2020        {.        
+00017750: 2020 5363 616c 6172 2061 2863 6a28 6c68    Scalar a(cj(lh
+00017760: 7328 692b 772b 302c 206b 2929 292c 0a20  s(i+w+0, k))),. 
+00017770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017780: 6228 636a 286c 6873 2869 2b77 2b31 2c20  b(cj(lhs(i+w+1, 
+00017790: 6b29 2929 2c0a 2020 2020 2020 2020 2020  k))),.          
+000177a0: 2020 2020 2020 2063 2863 6a28 6c68 7328         c(cj(lhs(
+000177b0: 692b 772b 322c 206b 2929 292c 0a20 2020  i+w+2, k))),.   
+000177c0: 2020 2020 2020 2020 2020 2020 2020 6428                d(
+000177d0: 636a 286c 6873 2869 2b77 2b33 2c20 6b29  cj(lhs(i+w+3, k)
+000177e0: 2929 3b0a 2020 2020 2020 2020 2020 626c  ));.          bl
+000177f0: 6f63 6b41 5b63 6f75 6e74 2b2b 5d20 3d20  ockA[count++] = 
+00017800: 613b 0a20 2020 2020 2020 2020 2062 6c6f  a;.          blo
+00017810: 636b 415b 636f 756e 742b 2b5d 203d 2062  ckA[count++] = b
+00017820: 3b0a 2020 2020 2020 2020 2020 626c 6f63  ;.          bloc
+00017830: 6b41 5b63 6f75 6e74 2b2b 5d20 3d20 633b  kA[count++] = c;
+00017840: 0a20 2020 2020 2020 2020 2062 6c6f 636b  .          block
+00017850: 415b 636f 756e 742b 2b5d 203d 2064 3b0a  A[count++] = d;.
+00017860: 2020 2020 2020 2020 7d0a 2020 2020 2020          }.      
+00017870: 2020 6966 2870 6163 6b25 3429 0a20 2020    if(pack%4).   
+00017880: 2020 2020 2020 2066 6f72 283b 773c 7061         for(;w<pa
+00017890: 636b 3b2b 2b77 290a 2020 2020 2020 2020  ck;++w).        
+000178a0: 2020 2020 626c 6f63 6b41 5b63 6f75 6e74      blockA[count
+000178b0: 2b2b 5d20 3d20 636a 286c 6873 2869 2b77  ++] = cj(lhs(i+w
+000178c0: 2c20 6b29 293b 0a20 2020 2020 207d 0a0a  , k));.      }..
+000178d0: 2020 2020 2020 6966 2850 616e 656c 4d6f        if(PanelMo
+000178e0: 6465 2920 636f 756e 7420 2b3d 2070 6163  de) count += pac
+000178f0: 6b20 2a20 2873 7472 6964 652d 6f66 6673  k * (stride-offs
+00017900: 6574 2d64 6570 7468 293b 0a20 2020 207d  et-depth);.    }
+00017910: 0a0a 2020 2020 7061 636b 202d 3d20 7073  ..    pack -= ps
+00017920: 697a 653b 0a20 2020 2049 6e64 6578 206c  ize;.    Index l
+00017930: 6566 7420 3d20 726f 7773 202d 2069 3b0a  eft = rows - i;.
+00017940: 2020 2020 6966 2028 7061 636b 203c 3d20      if (pack <= 
+00017950: 3029 207b 0a20 2020 2020 2069 6620 2821  0) {.      if (!
+00017960: 676f 6e65 5f6c 6173 7420 2626 0a20 2020  gone_last &&.   
+00017970: 2020 2020 2020 2028 7374 6172 7469 6e67         (starting
+00017980: 5f70 6f73 203d 3d20 6920 7c7c 206c 6566  _pos == i || lef
+00017990: 7420 3e3d 2070 7369 7a65 2f32 207c 7c20  t >= psize/2 || 
+000179a0: 6c65 6674 203e 3d20 7073 697a 652f 3429  left >= psize/4)
+000179b0: 2026 260a 2020 2020 2020 2020 2020 2828   &&.          ((
+000179c0: 7073 697a 652f 3220 3d3d 2048 616c 6650  psize/2 == HalfP
+000179d0: 6163 6b65 7453 697a 6520 2626 2048 6173  acketSize && Has
+000179e0: 4861 6c66 2026 2620 2167 6f6e 655f 6861  Half && !gone_ha
+000179f0: 6c66 2920 7c7c 0a20 2020 2020 2020 2020  lf) ||.         
+00017a00: 2020 2870 7369 7a65 2f32 203d 3d20 5175    (psize/2 == Qu
+00017a10: 6172 7465 7250 6163 6b65 7453 697a 6520  arterPacketSize 
+00017a20: 2626 2048 6173 5175 6172 7465 7220 2626  && HasQuarter &&
+00017a30: 2021 676f 6e65 5f71 7561 7274 6572 2929   !gone_quarter))
+00017a40: 2920 7b0a 2020 2020 2020 2020 7073 697a  ) {.        psiz
+00017a50: 6520 2f3d 2032 3b0a 2020 2020 2020 2020  e /= 2;.        
+00017a60: 7061 636b 203d 2070 7369 7a65 3b0a 2020  pack = psize;.  
+00017a70: 2020 2020 2020 636f 6e74 696e 7565 3b0a        continue;.
+00017a80: 2020 2020 2020 7d0a 2020 2020 2020 2f2f        }.      //
+00017a90: 2050 6163 6b32 206d 6179 2062 6520 2a73   Pack2 may be *s
+00017aa0: 6d61 6c6c 6572 2a20 7468 616e 2050 6163  maller* than Pac
+00017ab0: 6b65 7453 697a 65e2 8094 7468 6174 2068  ketSize...that h
+00017ac0: 6170 7065 6e73 2066 6f72 0a20 2020 2020  appens for.     
+00017ad0: 202f 2f20 7072 6f64 7563 7473 206c 696b   // products lik
+00017ae0: 6520 7265 616c 202a 2063 6f6d 706c 6578  e real * complex
+00017af0: 2c20 7768 6572 6520 7765 2068 6176 6520  , where we have 
+00017b00: 746f 2067 6f20 6861 6c66 2074 6865 0a20  to go half the. 
+00017b10: 2020 2020 202f 2f20 7072 6f67 7265 7373       // progress
+00017b20: 206f 6e20 7468 6520 6c68 7320 696e 206f   on the lhs in o
+00017b30: 7264 6572 2074 6f20 6475 706c 6963 6174  rder to duplicat
+00017b40: 6520 7468 6f73 6520 6f70 6572 616e 6473  e those operands
+00017b50: 2074 6f0a 2020 2020 2020 2f2f 2061 6464   to.      // add
+00017b60: 7265 7373 2062 6f74 6820 7265 616c 2026  ress both real &
+00017b70: 2069 6d61 6769 6e61 7279 2070 6172 7473   imaginary parts
+00017b80: 206f 6e20 7468 6520 7268 732e 2054 6869   on the rhs. Thi
+00017b90: 7320 706f 7274 696f 6e20 7769 6c6c 0a20  s portion will. 
+00017ba0: 2020 2020 202f 2f20 7061 636b 2074 686f       // pack tho
+00017bb0: 7365 2068 616c 6620 6f6e 6573 2075 6e74  se half ones unt
+00017bc0: 696c 2074 6865 7920 6d61 7463 6820 7468  il they match th
+00017bd0: 6520 6e75 6d62 6572 2065 7870 6563 7465  e number expecte
+00017be0: 6420 6f6e 2074 6865 0a20 2020 2020 202f  d on the.      /
+00017bf0: 2f20 6c61 7374 2070 6565 6c69 6e67 206c  / last peeling l
+00017c00: 6f6f 7020 6174 2074 6869 7320 706f 696e  oop at this poin
+00017c10: 7420 2866 6f72 2074 6865 2072 6873 292e  t (for the rhs).
+00017c20: 0a20 2020 2020 2069 6620 2850 6163 6b32  .      if (Pack2
+00017c30: 203c 2050 6163 6b65 7453 697a 6520 2626   < PacketSize &&
+00017c40: 2021 676f 6e65 5f6c 6173 7429 207b 0a20   !gone_last) {. 
+00017c50: 2020 2020 2020 2067 6f6e 655f 6c61 7374         gone_last
+00017c60: 203d 2074 7275 653b 0a20 2020 2020 2020   = true;.       
+00017c70: 2070 7369 7a65 203d 2070 6163 6b20 3d20   psize = pack = 
+00017c80: 6c65 6674 2026 207e 313b 0a20 2020 2020  left & ~1;.     
+00017c90: 207d 0a20 2020 207d 0a20 207d 0a0a 2020   }.    }.  }..  
+00017ca0: 666f 7228 3b20 693c 726f 7773 3b20 692b  for(; i<rows; i+
+00017cb0: 2b29 0a20 207b 0a20 2020 2069 6628 5061  +).  {.    if(Pa
+00017cc0: 6e65 6c4d 6f64 6529 2063 6f75 6e74 202b  nelMode) count +
+00017cd0: 3d20 6f66 6673 6574 3b0a 2020 2020 666f  = offset;.    fo
+00017ce0: 7228 496e 6465 7820 6b3d 303b 206b 3c64  r(Index k=0; k<d
+00017cf0: 6570 7468 3b20 6b2b 2b29 0a20 2020 2020  epth; k++).     
+00017d00: 2062 6c6f 636b 415b 636f 756e 742b 2b5d   blockA[count++]
+00017d10: 203d 2063 6a28 6c68 7328 692c 206b 2929   = cj(lhs(i, k))
+00017d20: 3b0a 2020 2020 6966 2850 616e 656c 4d6f  ;.    if(PanelMo
+00017d30: 6465 2920 636f 756e 7420 2b3d 2028 7374  de) count += (st
+00017d40: 7269 6465 2d6f 6666 7365 742d 6465 7074  ride-offset-dept
+00017d50: 6829 3b0a 2020 7d0a 7d0a 0a2f 2f20 636f  h);.  }.}..// co
+00017d60: 7079 2061 2063 6f6d 706c 6574 6520 7061  py a complete pa
+00017d70: 6e65 6c20 6f66 2074 6865 2072 6873 0a2f  nel of the rhs./
+00017d80: 2f20 7468 6973 2076 6572 7369 6f6e 2069  / this version i
+00017d90: 7320 6f70 7469 6d69 7a65 6420 666f 7220  s optimized for 
+00017da0: 636f 6c75 6d6e 206d 616a 6f72 206d 6174  column major mat
+00017db0: 7269 6365 730a 2f2f 2054 6865 2074 7261  rices.// The tra
+00017dc0: 7665 7273 616c 206f 7264 6572 2069 7320  versal order is 
+00017dd0: 6173 2066 6f6c 6c6f 773a 2028 6e72 3d3d  as follow: (nr==
+00017de0: 3429 3a0a 2f2f 2020 3020 2031 2020 3220  4):.//  0  1  2 
+00017df0: 2033 2020 2031 3220 3133 2031 3420 3135   3   12 13 14 15
+00017e00: 2020 2032 3420 3237 0a2f 2f20 2034 2020     24 27.//  4  
+00017e10: 3520 2036 2020 3720 2020 3136 2031 3720  5  6  7   16 17 
+00017e20: 3138 2031 3920 2020 3235 2032 380a 2f2f  18 19   25 28.//
+00017e30: 2020 3820 2039 2031 3020 3131 2020 2032    8  9 10 11   2
+00017e40: 3020 3231 2032 3220 3233 2020 2032 3620  0 21 22 23   26 
+00017e50: 3239 0a2f 2f20 202e 2020 2e20 202e 2020  29.//  .  .  .  
+00017e60: 2e20 2020 202e 2020 2e20 202e 2020 2e20  .    .  .  .  . 
+00017e70: 2020 202e 2020 2e0a 7465 6d70 6c61 7465     .  ..template
+00017e80: 3c74 7970 656e 616d 6520 5363 616c 6172  <typename Scalar
+00017e90: 2c20 7479 7065 6e61 6d65 2049 6e64 6578  , typename Index
+00017ea0: 2c20 7479 7065 6e61 6d65 2044 6174 614d  , typename DataM
+00017eb0: 6170 7065 722c 2069 6e74 206e 722c 2062  apper, int nr, b
+00017ec0: 6f6f 6c20 436f 6e6a 7567 6174 652c 2062  ool Conjugate, b
+00017ed0: 6f6f 6c20 5061 6e65 6c4d 6f64 653e 0a73  ool PanelMode>.s
+00017ee0: 7472 7563 7420 6765 6d6d 5f70 6163 6b5f  truct gemm_pack_
+00017ef0: 7268 733c 5363 616c 6172 2c20 496e 6465  rhs<Scalar, Inde
+00017f00: 782c 2044 6174 614d 6170 7065 722c 206e  x, DataMapper, n
+00017f10: 722c 2043 6f6c 4d61 6a6f 722c 2043 6f6e  r, ColMajor, Con
+00017f20: 6a75 6761 7465 2c20 5061 6e65 6c4d 6f64  jugate, PanelMod
+00017f30: 653e 0a7b 0a20 2074 7970 6564 6566 2074  e>.{.  typedef t
+00017f40: 7970 656e 616d 6520 7061 636b 6574 5f74  ypename packet_t
+00017f50: 7261 6974 733c 5363 616c 6172 3e3a 3a74  raits<Scalar>::t
+00017f60: 7970 6520 5061 636b 6574 3b0a 2020 7479  ype Packet;.  ty
+00017f70: 7065 6465 6620 7479 7065 6e61 6d65 2044  pedef typename D
+00017f80: 6174 614d 6170 7065 723a 3a4c 696e 6561  ataMapper::Linea
+00017f90: 724d 6170 7065 7220 4c69 6e65 6172 4d61  rMapper LinearMa
+00017fa0: 7070 6572 3b0a 2020 656e 756d 207b 2050  pper;.  enum { P
+00017fb0: 6163 6b65 7453 697a 6520 3d20 7061 636b  acketSize = pack
+00017fc0: 6574 5f74 7261 6974 733c 5363 616c 6172  et_traits<Scalar
+00017fd0: 3e3a 3a73 697a 6520 7d3b 0a20 2045 4947  >::size };.  EIG
+00017fe0: 454e 5f44 4f4e 545f 494e 4c49 4e45 2076  EN_DONT_INLINE v
+00017ff0: 6f69 6420 6f70 6572 6174 6f72 2829 2853  oid operator()(S
+00018000: 6361 6c61 722a 2062 6c6f 636b 422c 2063  calar* blockB, c
+00018010: 6f6e 7374 2044 6174 614d 6170 7065 7226  onst DataMapper&
+00018020: 2072 6873 2c20 496e 6465 7820 6465 7074   rhs, Index dept
+00018030: 682c 2049 6e64 6578 2063 6f6c 732c 2049  h, Index cols, I
+00018040: 6e64 6578 2073 7472 6964 653d 302c 2049  ndex stride=0, I
+00018050: 6e64 6578 206f 6666 7365 743d 3029 3b0a  ndex offset=0);.
+00018060: 7d3b 0a0a 7465 6d70 6c61 7465 3c74 7970  };..template<typ
+00018070: 656e 616d 6520 5363 616c 6172 2c20 7479  ename Scalar, ty
+00018080: 7065 6e61 6d65 2049 6e64 6578 2c20 7479  pename Index, ty
+00018090: 7065 6e61 6d65 2044 6174 614d 6170 7065  pename DataMappe
+000180a0: 722c 2069 6e74 206e 722c 2062 6f6f 6c20  r, int nr, bool 
+000180b0: 436f 6e6a 7567 6174 652c 2062 6f6f 6c20  Conjugate, bool 
+000180c0: 5061 6e65 6c4d 6f64 653e 0a45 4947 454e  PanelMode>.EIGEN
+000180d0: 5f44 4f4e 545f 494e 4c49 4e45 2076 6f69  _DONT_INLINE voi
+000180e0: 6420 6765 6d6d 5f70 6163 6b5f 7268 733c  d gemm_pack_rhs<
+000180f0: 5363 616c 6172 2c20 496e 6465 782c 2044  Scalar, Index, D
+00018100: 6174 614d 6170 7065 722c 206e 722c 2043  ataMapper, nr, C
+00018110: 6f6c 4d61 6a6f 722c 2043 6f6e 6a75 6761  olMajor, Conjuga
+00018120: 7465 2c20 5061 6e65 6c4d 6f64 653e 0a20  te, PanelMode>. 
+00018130: 203a 3a6f 7065 7261 746f 7228 2928 5363   ::operator()(Sc
+00018140: 616c 6172 2a20 626c 6f63 6b42 2c20 636f  alar* blockB, co
+00018150: 6e73 7420 4461 7461 4d61 7070 6572 2620  nst DataMapper& 
+00018160: 7268 732c 2049 6e64 6578 2064 6570 7468  rhs, Index depth
+00018170: 2c20 496e 6465 7820 636f 6c73 2c20 496e  , Index cols, In
+00018180: 6465 7820 7374 7269 6465 2c20 496e 6465  dex stride, Inde
+00018190: 7820 6f66 6673 6574 290a 7b0a 2020 4549  x offset).{.  EI
+000181a0: 4745 4e5f 4153 4d5f 434f 4d4d 454e 5428  GEN_ASM_COMMENT(
+000181b0: 2245 4947 454e 2050 524f 4455 4354 2050  "EIGEN PRODUCT P
+000181c0: 4143 4b20 5248 5320 434f 4c4d 414a 4f52  ACK RHS COLMAJOR
+000181d0: 2229 3b0a 2020 4549 4745 4e5f 554e 5553  ");.  EIGEN_UNUS
+000181e0: 4544 5f56 4152 4941 424c 4528 7374 7269  ED_VARIABLE(stri
+000181f0: 6465 293b 0a20 2045 4947 454e 5f55 4e55  de);.  EIGEN_UNU
+00018200: 5345 445f 5641 5249 4142 4c45 286f 6666  SED_VARIABLE(off
+00018210: 7365 7429 3b0a 2020 6569 6765 6e5f 6173  set);.  eigen_as
+00018220: 7365 7274 2828 2821 5061 6e65 6c4d 6f64  sert(((!PanelMod
+00018230: 6529 2026 2620 7374 7269 6465 3d3d 3020  e) && stride==0 
+00018240: 2626 206f 6666 7365 743d 3d30 2920 7c7c  && offset==0) ||
+00018250: 2028 5061 6e65 6c4d 6f64 6520 2626 2073   (PanelMode && s
+00018260: 7472 6964 653e 3d64 6570 7468 2026 2620  tride>=depth && 
+00018270: 6f66 6673 6574 3c3d 7374 7269 6465 2929  offset<=stride))
+00018280: 3b0a 2020 636f 6e6a 5f69 663c 4e75 6d54  ;.  conj_if<NumT
+00018290: 7261 6974 733c 5363 616c 6172 3e3a 3a49  raits<Scalar>::I
+000182a0: 7343 6f6d 706c 6578 2026 2620 436f 6e6a  sComplex && Conj
+000182b0: 7567 6174 653e 2063 6a3b 0a20 2049 6e64  ugate> cj;.  Ind
+000182c0: 6578 2070 6163 6b65 745f 636f 6c73 3820  ex packet_cols8 
+000182d0: 3d20 6e72 3e3d 3820 3f20 2863 6f6c 732f  = nr>=8 ? (cols/
+000182e0: 3829 202a 2038 203a 2030 3b0a 2020 496e  8) * 8 : 0;.  In
+000182f0: 6465 7820 7061 636b 6574 5f63 6f6c 7334  dex packet_cols4
+00018300: 203d 206e 723e 3d34 203f 2028 636f 6c73   = nr>=4 ? (cols
+00018310: 2f34 2920 2a20 3420 3a20 303b 0a20 2049  /4) * 4 : 0;.  I
+00018320: 6e64 6578 2063 6f75 6e74 203d 2030 3b0a  ndex count = 0;.
+00018330: 2020 636f 6e73 7420 496e 6465 7820 7065    const Index pe
+00018340: 656c 6564 5f6b 203d 2028 6465 7074 682f  eled_k = (depth/
+00018350: 5061 636b 6574 5369 7a65 292a 5061 636b  PacketSize)*Pack
+00018360: 6574 5369 7a65 3b0a 2f2f 2020 2069 6628  etSize;.//   if(
+00018370: 6e72 3e3d 3829 0a2f 2f20 2020 7b0a 2f2f  nr>=8).//   {.//
+00018380: 2020 2020 2066 6f72 2849 6e64 6578 206a       for(Index j
+00018390: 323d 303b 206a 323c 7061 636b 6574 5f63  2=0; j2<packet_c
+000183a0: 6f6c 7338 3b20 6a32 2b3d 3829 0a2f 2f20  ols8; j2+=8).// 
+000183b0: 2020 2020 7b0a 2f2f 2020 2020 2020 202f      {.//       /
+000183c0: 2f20 736b 6970 2077 6861 7420 7765 2068  / skip what we h
+000183d0: 6176 6520 6265 666f 7265 0a2f 2f20 2020  ave before.//   
+000183e0: 2020 2020 6966 2850 616e 656c 4d6f 6465      if(PanelMode
+000183f0: 2920 636f 756e 7420 2b3d 2038 202a 206f  ) count += 8 * o
+00018400: 6666 7365 743b 0a2f 2f20 2020 2020 2020  ffset;.//       
+00018410: 636f 6e73 7420 5363 616c 6172 2a20 6230  const Scalar* b0
+00018420: 203d 2026 7268 735b 286a 322b 3029 2a72   = &rhs[(j2+0)*r
+00018430: 6873 5374 7269 6465 5d3b 0a2f 2f20 2020  hsStride];.//   
+00018440: 2020 2020 636f 6e73 7420 5363 616c 6172      const Scalar
+00018450: 2a20 6231 203d 2026 7268 735b 286a 322b  * b1 = &rhs[(j2+
+00018460: 3129 2a72 6873 5374 7269 6465 5d3b 0a2f  1)*rhsStride];./
+00018470: 2f20 2020 2020 2020 636f 6e73 7420 5363  /       const Sc
+00018480: 616c 6172 2a20 6232 203d 2026 7268 735b  alar* b2 = &rhs[
+00018490: 286a 322b 3229 2a72 6873 5374 7269 6465  (j2+2)*rhsStride
+000184a0: 5d3b 0a2f 2f20 2020 2020 2020 636f 6e73  ];.//       cons
+000184b0: 7420 5363 616c 6172 2a20 6233 203d 2026  t Scalar* b3 = &
+000184c0: 7268 735b 286a 322b 3329 2a72 6873 5374  rhs[(j2+3)*rhsSt
+000184d0: 7269 6465 5d3b 0a2f 2f20 2020 2020 2020  ride];.//       
+000184e0: 636f 6e73 7420 5363 616c 6172 2a20 6234  const Scalar* b4
+000184f0: 203d 2026 7268 735b 286a 322b 3429 2a72   = &rhs[(j2+4)*r
+00018500: 6873 5374 7269 6465 5d3b 0a2f 2f20 2020  hsStride];.//   
+00018510: 2020 2020 636f 6e73 7420 5363 616c 6172      const Scalar
+00018520: 2a20 6235 203d 2026 7268 735b 286a 322b  * b5 = &rhs[(j2+
+00018530: 3529 2a72 6873 5374 7269 6465 5d3b 0a2f  5)*rhsStride];./
+00018540: 2f20 2020 2020 2020 636f 6e73 7420 5363  /       const Sc
+00018550: 616c 6172 2a20 6236 203d 2026 7268 735b  alar* b6 = &rhs[
+00018560: 286a 322b 3629 2a72 6873 5374 7269 6465  (j2+6)*rhsStride
+00018570: 5d3b 0a2f 2f20 2020 2020 2020 636f 6e73  ];.//       cons
+00018580: 7420 5363 616c 6172 2a20 6237 203d 2026  t Scalar* b7 = &
+00018590: 7268 735b 286a 322b 3729 2a72 6873 5374  rhs[(j2+7)*rhsSt
+000185a0: 7269 6465 5d3b 0a2f 2f20 2020 2020 2020  ride];.//       
+000185b0: 496e 6465 7820 6b3d 303b 0a2f 2f20 2020  Index k=0;.//   
+000185c0: 2020 2020 6966 2850 6163 6b65 7453 697a      if(PacketSiz
+000185d0: 653d 3d38 2920 2f2f 2054 4f44 4f20 656e  e==8) // TODO en
+000185e0: 6162 6c65 2076 6563 746f 7269 7a65 6420  able vectorized 
+000185f0: 7472 616e 7370 6f73 6974 696f 6e20 666f  transposition fo
+00018600: 7220 5061 636b 6574 5369 7a65 3d3d 340a  r PacketSize==4.
+00018610: 2f2f 2020 2020 2020 207b 0a2f 2f20 2020  //       {.//   
+00018620: 2020 2020 2020 666f 7228 3b20 6b3c 7065        for(; k<pe
+00018630: 656c 6564 5f6b 3b20 6b2b 3d50 6163 6b65  eled_k; k+=Packe
+00018640: 7453 697a 6529 207b 0a2f 2f20 2020 2020  tSize) {.//     
+00018650: 2020 2020 2020 5061 636b 6574 426c 6f63        PacketBloc
+00018660: 6b3c 5061 636b 6574 3e20 6b65 726e 656c  k<Packet> kernel
+00018670: 3b0a 2f2f 2020 2020 2020 2020 2020 2066  ;.//           f
+00018680: 6f72 2028 696e 7420 7020 3d20 303b 2070  or (int p = 0; p
+00018690: 203c 2050 6163 6b65 7453 697a 653b 202b   < PacketSize; +
+000186a0: 2b70 2920 7b0a 2f2f 2020 2020 2020 2020  +p) {.//        
+000186b0: 2020 2020 206b 6572 6e65 6c2e 7061 636b       kernel.pack
+000186c0: 6574 5b70 5d20 3d20 706c 6f61 6475 3c50  et[p] = ploadu<P
+000186d0: 6163 6b65 743e 2826 7268 735b 286a 322b  acket>(&rhs[(j2+
+000186e0: 7029 2a72 6873 5374 7269 6465 2b6b 5d29  p)*rhsStride+k])
+000186f0: 3b0a 2f2f 2020 2020 2020 2020 2020 207d  ;.//           }
+00018700: 0a2f 2f20 2020 2020 2020 2020 2020 7074  .//           pt
+00018710: 7261 6e73 706f 7365 286b 6572 6e65 6c29  ranspose(kernel)
+00018720: 3b0a 2f2f 2020 2020 2020 2020 2020 2066  ;.//           f
+00018730: 6f72 2028 696e 7420 7020 3d20 303b 2070  or (int p = 0; p
+00018740: 203c 2050 6163 6b65 7453 697a 653b 202b   < PacketSize; +
+00018750: 2b70 2920 7b0a 2f2f 2020 2020 2020 2020  +p) {.//        
+00018760: 2020 2020 2070 7374 6f72 6575 2862 6c6f       pstoreu(blo
+00018770: 636b 422b 636f 756e 742c 2063 6a2e 7063  ckB+count, cj.pc
+00018780: 6f6e 6a28 6b65 726e 656c 2e70 6163 6b65  onj(kernel.packe
+00018790: 745b 705d 2929 3b0a 2f2f 2020 2020 2020  t[p]));.//      
+000187a0: 2020 2020 2020 2063 6f75 6e74 2b3d 5061         count+=Pa
+000187b0: 636b 6574 5369 7a65 3b0a 2f2f 2020 2020  cketSize;.//    
+000187c0: 2020 2020 2020 207d 0a2f 2f20 2020 2020         }.//     
+000187d0: 2020 2020 7d0a 2f2f 2020 2020 2020 207d      }.//       }
+000187e0: 0a2f 2f20 2020 2020 2020 666f 7228 3b20  .//       for(; 
+000187f0: 6b3c 6465 7074 683b 206b 2b2b 290a 2f2f  k<depth; k++).//
+00018800: 2020 2020 2020 207b 0a2f 2f20 2020 2020         {.//     
+00018810: 2020 2020 626c 6f63 6b42 5b63 6f75 6e74      blockB[count
+00018820: 2b30 5d20 3d20 636a 2862 305b 6b5d 293b  +0] = cj(b0[k]);
+00018830: 0a2f 2f20 2020 2020 2020 2020 626c 6f63  .//         bloc
+00018840: 6b42 5b63 6f75 6e74 2b31 5d20 3d20 636a  kB[count+1] = cj
+00018850: 2862 315b 6b5d 293b 0a2f 2f20 2020 2020  (b1[k]);.//     
+00018860: 2020 2020 626c 6f63 6b42 5b63 6f75 6e74      blockB[count
+00018870: 2b32 5d20 3d20 636a 2862 325b 6b5d 293b  +2] = cj(b2[k]);
+00018880: 0a2f 2f20 2020 2020 2020 2020 626c 6f63  .//         bloc
+00018890: 6b42 5b63 6f75 6e74 2b33 5d20 3d20 636a  kB[count+3] = cj
+000188a0: 2862 335b 6b5d 293b 0a2f 2f20 2020 2020  (b3[k]);.//     
+000188b0: 2020 2020 626c 6f63 6b42 5b63 6f75 6e74      blockB[count
+000188c0: 2b34 5d20 3d20 636a 2862 345b 6b5d 293b  +4] = cj(b4[k]);
+000188d0: 0a2f 2f20 2020 2020 2020 2020 626c 6f63  .//         bloc
+000188e0: 6b42 5b63 6f75 6e74 2b35 5d20 3d20 636a  kB[count+5] = cj
+000188f0: 2862 355b 6b5d 293b 0a2f 2f20 2020 2020  (b5[k]);.//     
+00018900: 2020 2020 626c 6f63 6b42 5b63 6f75 6e74      blockB[count
+00018910: 2b36 5d20 3d20 636a 2862 365b 6b5d 293b  +6] = cj(b6[k]);
+00018920: 0a2f 2f20 2020 2020 2020 2020 626c 6f63  .//         bloc
+00018930: 6b42 5b63 6f75 6e74 2b37 5d20 3d20 636a  kB[count+7] = cj
+00018940: 2862 375b 6b5d 293b 0a2f 2f20 2020 2020  (b7[k]);.//     
+00018950: 2020 2020 636f 756e 7420 2b3d 2038 3b0a      count += 8;.
+00018960: 2f2f 2020 2020 2020 207d 0a2f 2f20 2020  //       }.//   
+00018970: 2020 2020 2f2f 2073 6b69 7020 7768 6174      // skip what
+00018980: 2077 6520 6861 7665 2061 6674 6572 0a2f   we have after./
+00018990: 2f20 2020 2020 2020 6966 2850 616e 656c  /       if(Panel
+000189a0: 4d6f 6465 2920 636f 756e 7420 2b3d 2038  Mode) count += 8
+000189b0: 202a 2028 7374 7269 6465 2d6f 6666 7365   * (stride-offse
+000189c0: 742d 6465 7074 6829 3b0a 2f2f 2020 2020  t-depth);.//    
+000189d0: 207d 0a2f 2f20 2020 7d0a 0a20 2069 6628   }.//   }..  if(
+000189e0: 6e72 3e3d 3429 0a20 207b 0a20 2020 2066  nr>=4).  {.    f
+000189f0: 6f72 2849 6e64 6578 206a 323d 7061 636b  or(Index j2=pack
+00018a00: 6574 5f63 6f6c 7338 3b20 6a32 3c70 6163  et_cols8; j2<pac
+00018a10: 6b65 745f 636f 6c73 343b 206a 322b 3d34  ket_cols4; j2+=4
+00018a20: 290a 2020 2020 7b0a 2020 2020 2020 2f2f  ).    {.      //
+00018a30: 2073 6b69 7020 7768 6174 2077 6520 6861   skip what we ha
+00018a40: 7665 2062 6566 6f72 650a 2020 2020 2020  ve before.      
+00018a50: 6966 2850 616e 656c 4d6f 6465 2920 636f  if(PanelMode) co
+00018a60: 756e 7420 2b3d 2034 202a 206f 6666 7365  unt += 4 * offse
+00018a70: 743b 0a20 2020 2020 2063 6f6e 7374 204c  t;.      const L
+00018a80: 696e 6561 724d 6170 7065 7220 646d 3020  inearMapper dm0 
+00018a90: 3d20 7268 732e 6765 744c 696e 6561 724d  = rhs.getLinearM
+00018aa0: 6170 7065 7228 302c 206a 3220 2b20 3029  apper(0, j2 + 0)
+00018ab0: 3b0a 2020 2020 2020 636f 6e73 7420 4c69  ;.      const Li
+00018ac0: 6e65 6172 4d61 7070 6572 2064 6d31 203d  nearMapper dm1 =
+00018ad0: 2072 6873 2e67 6574 4c69 6e65 6172 4d61   rhs.getLinearMa
+00018ae0: 7070 6572 2830 2c20 6a32 202b 2031 293b  pper(0, j2 + 1);
+00018af0: 0a20 2020 2020 2063 6f6e 7374 204c 696e  .      const Lin
+00018b00: 6561 724d 6170 7065 7220 646d 3220 3d20  earMapper dm2 = 
+00018b10: 7268 732e 6765 744c 696e 6561 724d 6170  rhs.getLinearMap
+00018b20: 7065 7228 302c 206a 3220 2b20 3229 3b0a  per(0, j2 + 2);.
+00018b30: 2020 2020 2020 636f 6e73 7420 4c69 6e65        const Line
+00018b40: 6172 4d61 7070 6572 2064 6d33 203d 2072  arMapper dm3 = r
+00018b50: 6873 2e67 6574 4c69 6e65 6172 4d61 7070  hs.getLinearMapp
+00018b60: 6572 2830 2c20 6a32 202b 2033 293b 0a0a  er(0, j2 + 3);..
+00018b70: 2020 2020 2020 496e 6465 7820 6b3d 303b        Index k=0;
+00018b80: 0a20 2020 2020 2069 6628 2850 6163 6b65  .      if((Packe
+00018b90: 7453 697a 6525 3429 3d3d 3029 202f 2f20  tSize%4)==0) // 
+00018ba0: 544f 444f 2065 6e61 626c 6520 7665 6374  TODO enable vect
+00018bb0: 6f72 697a 6564 2074 7261 6e73 706f 7369  orized transposi
+00018bc0: 7469 6f6e 2066 6f72 2050 6163 6b65 7453  tion for PacketS
+00018bd0: 697a 653d 3d32 203f 3f0a 2020 2020 2020  ize==2 ??.      
+00018be0: 7b0a 2020 2020 2020 2020 666f 7228 3b20  {.        for(; 
+00018bf0: 6b3c 7065 656c 6564 5f6b 3b20 6b2b 3d50  k<peeled_k; k+=P
+00018c00: 6163 6b65 7453 697a 6529 207b 0a20 2020  acketSize) {.   
+00018c10: 2020 2020 2020 2050 6163 6b65 7442 6c6f         PacketBlo
+00018c20: 636b 3c50 6163 6b65 742c 2850 6163 6b65  ck<Packet,(Packe
+00018c30: 7453 697a 6525 3429 3d3d 303f 343a 5061  tSize%4)==0?4:Pa
+00018c40: 636b 6574 5369 7a65 3e20 6b65 726e 656c  cketSize> kernel
+00018c50: 3b0a 2020 2020 2020 2020 2020 6b65 726e  ;.          kern
+00018c60: 656c 2e70 6163 6b65 745b 3020 2020 2020  el.packet[0     
+00018c70: 2020 2020 2020 5d20 3d20 646d 302e 7465        ] = dm0.te
+00018c80: 6d70 6c61 7465 206c 6f61 6450 6163 6b65  mplate loadPacke
+00018c90: 743c 5061 636b 6574 3e28 6b29 3b0a 2020  t<Packet>(k);.  
+00018ca0: 2020 2020 2020 2020 6b65 726e 656c 2e70          kernel.p
+00018cb0: 6163 6b65 745b 3125 5061 636b 6574 5369  acket[1%PacketSi
+00018cc0: 7a65 5d20 3d20 646d 312e 7465 6d70 6c61  ze] = dm1.templa
+00018cd0: 7465 206c 6f61 6450 6163 6b65 743c 5061  te loadPacket<Pa
+00018ce0: 636b 6574 3e28 6b29 3b0a 2020 2020 2020  cket>(k);.      
+00018cf0: 2020 2020 6b65 726e 656c 2e70 6163 6b65      kernel.packe
+00018d00: 745b 3225 5061 636b 6574 5369 7a65 5d20  t[2%PacketSize] 
+00018d10: 3d20 646d 322e 7465 6d70 6c61 7465 206c  = dm2.template l
+00018d20: 6f61 6450 6163 6b65 743c 5061 636b 6574  oadPacket<Packet
+00018d30: 3e28 6b29 3b0a 2020 2020 2020 2020 2020  >(k);.          
+00018d40: 6b65 726e 656c 2e70 6163 6b65 745b 3325  kernel.packet[3%
+00018d50: 5061 636b 6574 5369 7a65 5d20 3d20 646d  PacketSize] = dm
+00018d60: 332e 7465 6d70 6c61 7465 206c 6f61 6450  3.template loadP
+00018d70: 6163 6b65 743c 5061 636b 6574 3e28 6b29  acket<Packet>(k)
+00018d80: 3b0a 2020 2020 2020 2020 2020 7074 7261  ;.          ptra
+00018d90: 6e73 706f 7365 286b 6572 6e65 6c29 3b0a  nspose(kernel);.
+00018da0: 2020 2020 2020 2020 2020 7073 746f 7265            pstore
+00018db0: 7528 626c 6f63 6b42 2b63 6f75 6e74 2b30  u(blockB+count+0
+00018dc0: 2a50 6163 6b65 7453 697a 652c 2063 6a2e  *PacketSize, cj.
+00018dd0: 7063 6f6e 6a28 6b65 726e 656c 2e70 6163  pconj(kernel.pac
+00018de0: 6b65 745b 305d 2929 3b0a 2020 2020 2020  ket[0]));.      
+00018df0: 2020 2020 7073 746f 7265 7528 626c 6f63      pstoreu(bloc
+00018e00: 6b42 2b63 6f75 6e74 2b31 2a50 6163 6b65  kB+count+1*Packe
+00018e10: 7453 697a 652c 2063 6a2e 7063 6f6e 6a28  tSize, cj.pconj(
+00018e20: 6b65 726e 656c 2e70 6163 6b65 745b 3125  kernel.packet[1%
+00018e30: 5061 636b 6574 5369 7a65 5d29 293b 0a20  PacketSize]));. 
+00018e40: 2020 2020 2020 2020 2070 7374 6f72 6575           pstoreu
+00018e50: 2862 6c6f 636b 422b 636f 756e 742b 322a  (blockB+count+2*
+00018e60: 5061 636b 6574 5369 7a65 2c20 636a 2e70  PacketSize, cj.p
+00018e70: 636f 6e6a 286b 6572 6e65 6c2e 7061 636b  conj(kernel.pack
+00018e80: 6574 5b32 2550 6163 6b65 7453 697a 655d  et[2%PacketSize]
+00018e90: 2929 3b0a 2020 2020 2020 2020 2020 7073  ));.          ps
+00018ea0: 746f 7265 7528 626c 6f63 6b42 2b63 6f75  toreu(blockB+cou
+00018eb0: 6e74 2b33 2a50 6163 6b65 7453 697a 652c  nt+3*PacketSize,
+00018ec0: 2063 6a2e 7063 6f6e 6a28 6b65 726e 656c   cj.pconj(kernel
+00018ed0: 2e70 6163 6b65 745b 3325 5061 636b 6574  .packet[3%Packet
+00018ee0: 5369 7a65 5d29 293b 0a20 2020 2020 2020  Size]));.       
+00018ef0: 2020 2063 6f75 6e74 2b3d 342a 5061 636b     count+=4*Pack
+00018f00: 6574 5369 7a65 3b0a 2020 2020 2020 2020  etSize;.        
+00018f10: 7d0a 2020 2020 2020 7d0a 2020 2020 2020  }.      }.      
+00018f20: 666f 7228 3b20 6b3c 6465 7074 683b 206b  for(; k<depth; k
+00018f30: 2b2b 290a 2020 2020 2020 7b0a 2020 2020  ++).      {.    
+00018f40: 2020 2020 626c 6f63 6b42 5b63 6f75 6e74      blockB[count
+00018f50: 2b30 5d20 3d20 636a 2864 6d30 286b 2929  +0] = cj(dm0(k))
+00018f60: 3b0a 2020 2020 2020 2020 626c 6f63 6b42  ;.        blockB
+00018f70: 5b63 6f75 6e74 2b31 5d20 3d20 636a 2864  [count+1] = cj(d
+00018f80: 6d31 286b 2929 3b0a 2020 2020 2020 2020  m1(k));.        
+00018f90: 626c 6f63 6b42 5b63 6f75 6e74 2b32 5d20  blockB[count+2] 
+00018fa0: 3d20 636a 2864 6d32 286b 2929 3b0a 2020  = cj(dm2(k));.  
+00018fb0: 2020 2020 2020 626c 6f63 6b42 5b63 6f75        blockB[cou
+00018fc0: 6e74 2b33 5d20 3d20 636a 2864 6d33 286b  nt+3] = cj(dm3(k
+00018fd0: 2929 3b0a 2020 2020 2020 2020 636f 756e  ));.        coun
+00018fe0: 7420 2b3d 2034 3b0a 2020 2020 2020 7d0a  t += 4;.      }.
+00018ff0: 2020 2020 2020 2f2f 2073 6b69 7020 7768        // skip wh
+00019000: 6174 2077 6520 6861 7665 2061 6674 6572  at we have after
+00019010: 0a20 2020 2020 2069 6628 5061 6e65 6c4d  .      if(PanelM
+00019020: 6f64 6529 2063 6f75 6e74 202b 3d20 3420  ode) count += 4 
+00019030: 2a20 2873 7472 6964 652d 6f66 6673 6574  * (stride-offset
+00019040: 2d64 6570 7468 293b 0a20 2020 207d 0a20  -depth);.    }. 
+00019050: 207d 0a0a 2020 2f2f 2063 6f70 7920 7468   }..  // copy th
+00019060: 6520 7265 6d61 696e 696e 6720 636f 6c75  e remaining colu
+00019070: 6d6e 7320 6f6e 6520 6174 2061 2074 696d  mns one at a tim
+00019080: 6520 286e 723d 3d31 290a 2020 666f 7228  e (nr==1).  for(
+00019090: 496e 6465 7820 6a32 3d70 6163 6b65 745f  Index j2=packet_
+000190a0: 636f 6c73 343b 206a 323c 636f 6c73 3b20  cols4; j2<cols; 
+000190b0: 2b2b 6a32 290a 2020 7b0a 2020 2020 6966  ++j2).  {.    if
+000190c0: 2850 616e 656c 4d6f 6465 2920 636f 756e  (PanelMode) coun
+000190d0: 7420 2b3d 206f 6666 7365 743b 0a20 2020  t += offset;.   
+000190e0: 2063 6f6e 7374 204c 696e 6561 724d 6170   const LinearMap
+000190f0: 7065 7220 646d 3020 3d20 7268 732e 6765  per dm0 = rhs.ge
+00019100: 744c 696e 6561 724d 6170 7065 7228 302c  tLinearMapper(0,
+00019110: 206a 3229 3b0a 2020 2020 666f 7228 496e   j2);.    for(In
+00019120: 6465 7820 6b3d 303b 206b 3c64 6570 7468  dex k=0; k<depth
+00019130: 3b20 6b2b 2b29 0a20 2020 207b 0a20 2020  ; k++).    {.   
+00019140: 2020 2062 6c6f 636b 425b 636f 756e 745d     blockB[count]
+00019150: 203d 2063 6a28 646d 3028 6b29 293b 0a20   = cj(dm0(k));. 
+00019160: 2020 2020 2063 6f75 6e74 202b 3d20 313b       count += 1;
+00019170: 0a20 2020 207d 0a20 2020 2069 6628 5061  .    }.    if(Pa
+00019180: 6e65 6c4d 6f64 6529 2063 6f75 6e74 202b  nelMode) count +
+00019190: 3d20 2873 7472 6964 652d 6f66 6673 6574  = (stride-offset
+000191a0: 2d64 6570 7468 293b 0a20 207d 0a7d 0a0a  -depth);.  }.}..
+000191b0: 2f2f 2074 6869 7320 7665 7273 696f 6e20  // this version 
+000191c0: 6973 206f 7074 696d 697a 6564 2066 6f72  is optimized for
+000191d0: 2072 6f77 206d 616a 6f72 206d 6174 7269   row major matri
+000191e0: 6365 730a 7465 6d70 6c61 7465 3c74 7970  ces.template<typ
+000191f0: 656e 616d 6520 5363 616c 6172 2c20 7479  ename Scalar, ty
+00019200: 7065 6e61 6d65 2049 6e64 6578 2c20 7479  pename Index, ty
+00019210: 7065 6e61 6d65 2044 6174 614d 6170 7065  pename DataMappe
+00019220: 722c 2069 6e74 206e 722c 2062 6f6f 6c20  r, int nr, bool 
+00019230: 436f 6e6a 7567 6174 652c 2062 6f6f 6c20  Conjugate, bool 
+00019240: 5061 6e65 6c4d 6f64 653e 0a73 7472 7563  PanelMode>.struc
+00019250: 7420 6765 6d6d 5f70 6163 6b5f 7268 733c  t gemm_pack_rhs<
+00019260: 5363 616c 6172 2c20 496e 6465 782c 2044  Scalar, Index, D
+00019270: 6174 614d 6170 7065 722c 206e 722c 2052  ataMapper, nr, R
+00019280: 6f77 4d61 6a6f 722c 2043 6f6e 6a75 6761  owMajor, Conjuga
+00019290: 7465 2c20 5061 6e65 6c4d 6f64 653e 0a7b  te, PanelMode>.{
+000192a0: 0a20 2074 7970 6564 6566 2074 7970 656e  .  typedef typen
+000192b0: 616d 6520 7061 636b 6574 5f74 7261 6974  ame packet_trait
+000192c0: 733c 5363 616c 6172 3e3a 3a74 7970 6520  s<Scalar>::type 
+000192d0: 5061 636b 6574 3b0a 2020 7479 7065 6465  Packet;.  typede
+000192e0: 6620 7479 7065 6e61 6d65 2075 6e70 6163  f typename unpac
+000192f0: 6b65 745f 7472 6169 7473 3c50 6163 6b65  ket_traits<Packe
+00019300: 743e 3a3a 6861 6c66 2048 616c 6650 6163  t>::half HalfPac
+00019310: 6b65 743b 0a20 2074 7970 6564 6566 2074  ket;.  typedef t
+00019320: 7970 656e 616d 6520 756e 7061 636b 6574  ypename unpacket
+00019330: 5f74 7261 6974 733c 7479 7065 6e61 6d65  _traits<typename
+00019340: 2075 6e70 6163 6b65 745f 7472 6169 7473   unpacket_traits
+00019350: 3c50 6163 6b65 743e 3a3a 6861 6c66 3e3a  <Packet>::half>:
+00019360: 3a68 616c 6620 5175 6172 7465 7250 6163  :half QuarterPac
+00019370: 6b65 743b 0a20 2074 7970 6564 6566 2074  ket;.  typedef t
+00019380: 7970 656e 616d 6520 4461 7461 4d61 7070  ypename DataMapp
+00019390: 6572 3a3a 4c69 6e65 6172 4d61 7070 6572  er::LinearMapper
+000193a0: 204c 696e 6561 724d 6170 7065 723b 0a20   LinearMapper;. 
+000193b0: 2065 6e75 6d20 7b20 5061 636b 6574 5369   enum { PacketSi
+000193c0: 7a65 203d 2070 6163 6b65 745f 7472 6169  ze = packet_trai
+000193d0: 7473 3c53 6361 6c61 723e 3a3a 7369 7a65  ts<Scalar>::size
+000193e0: 2c0a 2020 2020 2020 2020 2048 616c 6650  ,.         HalfP
+000193f0: 6163 6b65 7453 697a 6520 3d20 756e 7061  acketSize = unpa
+00019400: 636b 6574 5f74 7261 6974 733c 4861 6c66  cket_traits<Half
+00019410: 5061 636b 6574 3e3a 3a73 697a 652c 0a09  Packet>::size,..
+00019420: 0920 5175 6172 7465 7250 6163 6b65 7453  . QuarterPacketS
+00019430: 697a 6520 3d20 756e 7061 636b 6574 5f74  ize = unpacket_t
+00019440: 7261 6974 733c 5175 6172 7465 7250 6163  raits<QuarterPac
+00019450: 6b65 743e 3a3a 7369 7a65 7d3b 0a20 2045  ket>::size};.  E
+00019460: 4947 454e 5f44 4f4e 545f 494e 4c49 4e45  IGEN_DONT_INLINE
+00019470: 2076 6f69 6420 6f70 6572 6174 6f72 2829   void operator()
+00019480: 2853 6361 6c61 722a 2062 6c6f 636b 422c  (Scalar* blockB,
+00019490: 2063 6f6e 7374 2044 6174 614d 6170 7065   const DataMappe
+000194a0: 7226 2072 6873 2c20 496e 6465 7820 6465  r& rhs, Index de
+000194b0: 7074 682c 2049 6e64 6578 2063 6f6c 732c  pth, Index cols,
+000194c0: 2049 6e64 6578 2073 7472 6964 653d 302c   Index stride=0,
+000194d0: 2049 6e64 6578 206f 6666 7365 743d 3029   Index offset=0)
+000194e0: 0a20 207b 0a20 2020 2045 4947 454e 5f41  .  {.    EIGEN_A
+000194f0: 534d 5f43 4f4d 4d45 4e54 2822 4549 4745  SM_COMMENT("EIGE
+00019500: 4e20 5052 4f44 5543 5420 5041 434b 2052  N PRODUCT PACK R
+00019510: 4853 2052 4f57 4d41 4a4f 5222 293b 0a20  HS ROWMAJOR");. 
+00019520: 2020 2045 4947 454e 5f55 4e55 5345 445f     EIGEN_UNUSED_
+00019530: 5641 5249 4142 4c45 2873 7472 6964 6529  VARIABLE(stride)
+00019540: 3b0a 2020 2020 4549 4745 4e5f 554e 5553  ;.    EIGEN_UNUS
+00019550: 4544 5f56 4152 4941 424c 4528 6f66 6673  ED_VARIABLE(offs
+00019560: 6574 293b 0a20 2020 2065 6967 656e 5f61  et);.    eigen_a
+00019570: 7373 6572 7428 2828 2150 616e 656c 4d6f  ssert(((!PanelMo
+00019580: 6465 2920 2626 2073 7472 6964 653d 3d30  de) && stride==0
+00019590: 2026 2620 6f66 6673 6574 3d3d 3029 207c   && offset==0) |
+000195a0: 7c20 2850 616e 656c 4d6f 6465 2026 2620  | (PanelMode && 
+000195b0: 7374 7269 6465 3e3d 6465 7074 6820 2626  stride>=depth &&
+000195c0: 206f 6666 7365 743c 3d73 7472 6964 6529   offset<=stride)
+000195d0: 293b 0a20 2020 2063 6f6e 7374 2062 6f6f  );.    const boo
+000195e0: 6c20 4861 7348 616c 6620 3d20 2869 6e74  l HasHalf = (int
+000195f0: 2948 616c 6650 6163 6b65 7453 697a 6520  )HalfPacketSize 
+00019600: 3c20 2869 6e74 2950 6163 6b65 7453 697a  < (int)PacketSiz
+00019610: 653b 0a20 2020 2063 6f6e 7374 2062 6f6f  e;.    const boo
+00019620: 6c20 4861 7351 7561 7274 6572 203d 2028  l HasQuarter = (
+00019630: 696e 7429 5175 6172 7465 7250 6163 6b65  int)QuarterPacke
+00019640: 7453 697a 6520 3c20 2869 6e74 2948 616c  tSize < (int)Hal
+00019650: 6650 6163 6b65 7453 697a 653b 0a20 2020  fPacketSize;.   
+00019660: 2063 6f6e 6a5f 6966 3c4e 756d 5472 6169   conj_if<NumTrai
+00019670: 7473 3c53 6361 6c61 723e 3a3a 4973 436f  ts<Scalar>::IsCo
+00019680: 6d70 6c65 7820 2626 2043 6f6e 6a75 6761  mplex && Conjuga
+00019690: 7465 3e20 636a 3b0a 2020 2020 496e 6465  te> cj;.    Inde
+000196a0: 7820 7061 636b 6574 5f63 6f6c 7338 203d  x packet_cols8 =
+000196b0: 206e 723e 3d38 203f 2028 636f 6c73 2f38   nr>=8 ? (cols/8
+000196c0: 2920 2a20 3820 3a20 303b 0a20 2020 2049  ) * 8 : 0;.    I
+000196d0: 6e64 6578 2070 6163 6b65 745f 636f 6c73  ndex packet_cols
+000196e0: 3420 3d20 6e72 3e3d 3420 3f20 2863 6f6c  4 = nr>=4 ? (col
+000196f0: 732f 3429 202a 2034 203a 2030 3b0a 2020  s/4) * 4 : 0;.  
+00019700: 2020 496e 6465 7820 636f 756e 7420 3d20    Index count = 
+00019710: 303b 0a0a 2020 2f2f 2020 2069 6628 6e72  0;..  //   if(nr
+00019720: 3e3d 3829 0a20 202f 2f20 2020 7b0a 2020  >=8).  //   {.  
+00019730: 2f2f 2020 2020 2066 6f72 2849 6e64 6578  //     for(Index
+00019740: 206a 323d 303b 206a 323c 7061 636b 6574   j2=0; j2<packet
+00019750: 5f63 6f6c 7338 3b20 6a32 2b3d 3829 0a20  _cols8; j2+=8). 
+00019760: 202f 2f20 2020 2020 7b0a 2020 2f2f 2020   //     {.  //  
+00019770: 2020 2020 202f 2f20 736b 6970 2077 6861       // skip wha
+00019780: 7420 7765 2068 6176 6520 6265 666f 7265  t we have before
+00019790: 0a20 202f 2f20 2020 2020 2020 6966 2850  .  //       if(P
+000197a0: 616e 656c 4d6f 6465 2920 636f 756e 7420  anelMode) count 
+000197b0: 2b3d 2038 202a 206f 6666 7365 743b 0a20  += 8 * offset;. 
+000197c0: 202f 2f20 2020 2020 2020 666f 7228 496e   //       for(In
+000197d0: 6465 7820 6b3d 303b 206b 3c64 6570 7468  dex k=0; k<depth
+000197e0: 3b20 6b2b 2b29 0a20 202f 2f20 2020 2020  ; k++).  //     
+000197f0: 2020 7b0a 2020 2f2f 2020 2020 2020 2020    {.  //        
+00019800: 2069 6620 2850 6163 6b65 7453 697a 653d   if (PacketSize=
+00019810: 3d38 2920 7b0a 2020 2f2f 2020 2020 2020  =8) {.  //      
+00019820: 2020 2020 2050 6163 6b65 7420 4120 3d20       Packet A = 
+00019830: 706c 6f61 6475 3c50 6163 6b65 743e 2826  ploadu<Packet>(&
+00019840: 7268 735b 6b2a 7268 7353 7472 6964 6520  rhs[k*rhsStride 
+00019850: 2b20 6a32 5d29 3b0a 2020 2f2f 2020 2020  + j2]);.  //    
+00019860: 2020 2020 2020 2070 7374 6f72 6575 2862         pstoreu(b
+00019870: 6c6f 636b 422b 636f 756e 742c 2063 6a2e  lockB+count, cj.
+00019880: 7063 6f6e 6a28 4129 293b 0a20 202f 2f20  pconj(A));.  // 
+00019890: 2020 2020 2020 2020 7d20 656c 7365 2069          } else i
+000198a0: 6620 2850 6163 6b65 7453 697a 653d 3d34  f (PacketSize==4
+000198b0: 2920 7b0a 2020 2f2f 2020 2020 2020 2020  ) {.  //        
+000198c0: 2020 2050 6163 6b65 7420 4120 3d20 706c     Packet A = pl
+000198d0: 6f61 6475 3c50 6163 6b65 743e 2826 7268  oadu<Packet>(&rh
+000198e0: 735b 6b2a 7268 7353 7472 6964 6520 2b20  s[k*rhsStride + 
+000198f0: 6a32 5d29 3b0a 2020 2f2f 2020 2020 2020  j2]);.  //      
+00019900: 2020 2020 2050 6163 6b65 7420 4220 3d20       Packet B = 
+00019910: 706c 6f61 6475 3c50 6163 6b65 743e 2826  ploadu<Packet>(&
+00019920: 7268 735b 6b2a 7268 7353 7472 6964 6520  rhs[k*rhsStride 
+00019930: 2b20 6a32 202b 2050 6163 6b65 7453 697a  + j2 + PacketSiz
+00019940: 655d 293b 0a20 202f 2f20 2020 2020 2020  e]);.  //       
+00019950: 2020 2020 7073 746f 7265 7528 626c 6f63      pstoreu(bloc
+00019960: 6b42 2b63 6f75 6e74 2c20 636a 2e70 636f  kB+count, cj.pco
+00019970: 6e6a 2841 2929 3b0a 2020 2f2f 2020 2020  nj(A));.  //    
+00019980: 2020 2020 2020 2070 7374 6f72 6575 2862         pstoreu(b
+00019990: 6c6f 636b 422b 636f 756e 742b 5061 636b  lockB+count+Pack
+000199a0: 6574 5369 7a65 2c20 636a 2e70 636f 6e6a  etSize, cj.pconj
+000199b0: 2842 2929 3b0a 2020 2f2f 2020 2020 2020  (B));.  //      
+000199c0: 2020 207d 2065 6c73 6520 7b0a 2020 2f2f     } else {.  //
+000199d0: 2020 2020 2020 2020 2020 2063 6f6e 7374             const
+000199e0: 2053 6361 6c61 722a 2062 3020 3d20 2672   Scalar* b0 = &r
+000199f0: 6873 5b6b 2a72 6873 5374 7269 6465 202b  hs[k*rhsStride +
+00019a00: 206a 325d 3b0a 2020 2f2f 2020 2020 2020   j2];.  //      
+00019a10: 2020 2020 2062 6c6f 636b 425b 636f 756e       blockB[coun
+00019a20: 742b 305d 203d 2063 6a28 6230 5b30 5d29  t+0] = cj(b0[0])
+00019a30: 3b0a 2020 2f2f 2020 2020 2020 2020 2020  ;.  //          
+00019a40: 2062 6c6f 636b 425b 636f 756e 742b 315d   blockB[count+1]
+00019a50: 203d 2063 6a28 6230 5b31 5d29 3b0a 2020   = cj(b0[1]);.  
+00019a60: 2f2f 2020 2020 2020 2020 2020 2062 6c6f  //           blo
+00019a70: 636b 425b 636f 756e 742b 325d 203d 2063  ckB[count+2] = c
+00019a80: 6a28 6230 5b32 5d29 3b0a 2020 2f2f 2020  j(b0[2]);.  //  
+00019a90: 2020 2020 2020 2020 2062 6c6f 636b 425b           blockB[
+00019aa0: 636f 756e 742b 335d 203d 2063 6a28 6230  count+3] = cj(b0
+00019ab0: 5b33 5d29 3b0a 2020 2f2f 2020 2020 2020  [3]);.  //      
+00019ac0: 2020 2020 2062 6c6f 636b 425b 636f 756e       blockB[coun
+00019ad0: 742b 345d 203d 2063 6a28 6230 5b34 5d29  t+4] = cj(b0[4])
+00019ae0: 3b0a 2020 2f2f 2020 2020 2020 2020 2020  ;.  //          
+00019af0: 2062 6c6f 636b 425b 636f 756e 742b 355d   blockB[count+5]
+00019b00: 203d 2063 6a28 6230 5b35 5d29 3b0a 2020   = cj(b0[5]);.  
+00019b10: 2f2f 2020 2020 2020 2020 2020 2062 6c6f  //           blo
+00019b20: 636b 425b 636f 756e 742b 365d 203d 2063  ckB[count+6] = c
+00019b30: 6a28 6230 5b36 5d29 3b0a 2020 2f2f 2020  j(b0[6]);.  //  
+00019b40: 2020 2020 2020 2020 2062 6c6f 636b 425b           blockB[
+00019b50: 636f 756e 742b 375d 203d 2063 6a28 6230  count+7] = cj(b0
+00019b60: 5b37 5d29 3b0a 2020 2f2f 2020 2020 2020  [7]);.  //      
+00019b70: 2020 207d 0a20 202f 2f20 2020 2020 2020     }.  //       
+00019b80: 2020 636f 756e 7420 2b3d 2038 3b0a 2020    count += 8;.  
+00019b90: 2f2f 2020 2020 2020 207d 0a20 202f 2f20  //       }.  // 
+00019ba0: 2020 2020 2020 2f2f 2073 6b69 7020 7768        // skip wh
+00019bb0: 6174 2077 6520 6861 7665 2061 6674 6572  at we have after
+00019bc0: 0a20 202f 2f20 2020 2020 2020 6966 2850  .  //       if(P
+00019bd0: 616e 656c 4d6f 6465 2920 636f 756e 7420  anelMode) count 
+00019be0: 2b3d 2038 202a 2028 7374 7269 6465 2d6f  += 8 * (stride-o
+00019bf0: 6666 7365 742d 6465 7074 6829 3b0a 2020  ffset-depth);.  
+00019c00: 2f2f 2020 2020 207d 0a20 202f 2f20 2020  //     }.  //   
+00019c10: 7d0a 2020 2020 6966 286e 723e 3d34 290a  }.    if(nr>=4).
+00019c20: 2020 2020 7b0a 2020 2020 2020 666f 7228      {.      for(
+00019c30: 496e 6465 7820 6a32 3d70 6163 6b65 745f  Index j2=packet_
+00019c40: 636f 6c73 383b 206a 323c 7061 636b 6574  cols8; j2<packet
+00019c50: 5f63 6f6c 7334 3b20 6a32 2b3d 3429 0a20  _cols4; j2+=4). 
+00019c60: 2020 2020 207b 0a20 2020 2020 2020 202f       {.        /
+00019c70: 2f20 736b 6970 2077 6861 7420 7765 2068  / skip what we h
+00019c80: 6176 6520 6265 666f 7265 0a20 2020 2020  ave before.     
+00019c90: 2020 2069 6628 5061 6e65 6c4d 6f64 6529     if(PanelMode)
+00019ca0: 2063 6f75 6e74 202b 3d20 3420 2a20 6f66   count += 4 * of
+00019cb0: 6673 6574 3b0a 2020 2020 2020 2020 666f  fset;.        fo
+00019cc0: 7228 496e 6465 7820 6b3d 303b 206b 3c64  r(Index k=0; k<d
+00019cd0: 6570 7468 3b20 6b2b 2b29 0a20 2020 2020  epth; k++).     
+00019ce0: 2020 207b 0a20 2020 2020 2020 2020 2069     {.          i
+00019cf0: 6620 2850 6163 6b65 7453 697a 653d 3d34  f (PacketSize==4
+00019d00: 2920 7b0a 2020 2020 2020 2020 2020 2020  ) {.            
+00019d10: 5061 636b 6574 2041 203d 2072 6873 2e74  Packet A = rhs.t
+00019d20: 656d 706c 6174 6520 6c6f 6164 5061 636b  emplate loadPack
+00019d30: 6574 3c50 6163 6b65 743e 286b 2c20 6a32  et<Packet>(k, j2
+00019d40: 293b 0a20 2020 2020 2020 2020 2020 2070  );.            p
+00019d50: 7374 6f72 6575 2862 6c6f 636b 422b 636f  storeu(blockB+co
+00019d60: 756e 742c 2063 6a2e 7063 6f6e 6a28 4129  unt, cj.pconj(A)
+00019d70: 293b 0a20 2020 2020 2020 2020 2020 2063  );.            c
+00019d80: 6f75 6e74 202b 3d20 5061 636b 6574 5369  ount += PacketSi
+00019d90: 7a65 3b0a 2020 2020 2020 2020 2020 7d20  ze;.          } 
+00019da0: 656c 7365 2069 6620 2848 6173 4861 6c66  else if (HasHalf
+00019db0: 2026 2620 4861 6c66 5061 636b 6574 5369   && HalfPacketSi
+00019dc0: 7a65 3d3d 3429 207b 0a20 2020 2020 2020  ze==4) {.       
+00019dd0: 2020 2020 2048 616c 6650 6163 6b65 7420       HalfPacket 
+00019de0: 4120 3d20 7268 732e 7465 6d70 6c61 7465  A = rhs.template
+00019df0: 206c 6f61 6450 6163 6b65 743c 4861 6c66   loadPacket<Half
+00019e00: 5061 636b 6574 3e28 6b2c 206a 3229 3b0a  Packet>(k, j2);.
+00019e10: 2020 2020 2020 2020 2020 2020 7073 746f              psto
+00019e20: 7265 7528 626c 6f63 6b42 2b63 6f75 6e74  reu(blockB+count
+00019e30: 2c20 636a 2e70 636f 6e6a 2841 2929 3b0a  , cj.pconj(A));.
+00019e40: 2020 2020 2020 2020 2020 2020 636f 756e              coun
+00019e50: 7420 2b3d 2048 616c 6650 6163 6b65 7453  t += HalfPacketS
+00019e60: 697a 653b 0a20 2020 2020 2020 2020 207d  ize;.          }
+00019e70: 2065 6c73 6520 6966 2028 4861 7351 7561   else if (HasQua
+00019e80: 7274 6572 2026 2620 5175 6172 7465 7250  rter && QuarterP
+00019e90: 6163 6b65 7453 697a 653d 3d34 2920 7b0a  acketSize==4) {.
+00019ea0: 2020 2020 2020 2020 2020 2020 5175 6172              Quar
+00019eb0: 7465 7250 6163 6b65 7420 4120 3d20 7268  terPacket A = rh
+00019ec0: 732e 7465 6d70 6c61 7465 206c 6f61 6450  s.template loadP
+00019ed0: 6163 6b65 743c 5175 6172 7465 7250 6163  acket<QuarterPac
+00019ee0: 6b65 743e 286b 2c20 6a32 293b 0a20 2020  ket>(k, j2);.   
+00019ef0: 2020 2020 2020 2020 2070 7374 6f72 6575           pstoreu
+00019f00: 2862 6c6f 636b 422b 636f 756e 742c 2063  (blockB+count, c
+00019f10: 6a2e 7063 6f6e 6a28 4129 293b 0a20 2020  j.pconj(A));.   
+00019f20: 2020 2020 2020 2020 2063 6f75 6e74 202b           count +
+00019f30: 3d20 5175 6172 7465 7250 6163 6b65 7453  = QuarterPacketS
+00019f40: 697a 653b 0a20 2020 2020 2020 2020 207d  ize;.          }
+00019f50: 2065 6c73 6520 7b0a 2020 2020 2020 2020   else {.        
+00019f60: 2020 2020 636f 6e73 7420 4c69 6e65 6172      const Linear
+00019f70: 4d61 7070 6572 2064 6d30 203d 2072 6873  Mapper dm0 = rhs
+00019f80: 2e67 6574 4c69 6e65 6172 4d61 7070 6572  .getLinearMapper
+00019f90: 286b 2c20 6a32 293b 0a20 2020 2020 2020  (k, j2);.       
+00019fa0: 2020 2020 2062 6c6f 636b 425b 636f 756e       blockB[coun
+00019fb0: 742b 305d 203d 2063 6a28 646d 3028 3029  t+0] = cj(dm0(0)
+00019fc0: 293b 0a20 2020 2020 2020 2020 2020 2062  );.            b
+00019fd0: 6c6f 636b 425b 636f 756e 742b 315d 203d  lockB[count+1] =
+00019fe0: 2063 6a28 646d 3028 3129 293b 0a20 2020   cj(dm0(1));.   
+00019ff0: 2020 2020 2020 2020 2062 6c6f 636b 425b           blockB[
+0001a000: 636f 756e 742b 325d 203d 2063 6a28 646d  count+2] = cj(dm
+0001a010: 3028 3229 293b 0a20 2020 2020 2020 2020  0(2));.         
+0001a020: 2020 2062 6c6f 636b 425b 636f 756e 742b     blockB[count+
+0001a030: 335d 203d 2063 6a28 646d 3028 3329 293b  3] = cj(dm0(3));
+0001a040: 0a20 2020 2020 2020 2020 2020 2063 6f75  .            cou
+0001a050: 6e74 202b 3d20 343b 0a20 2020 2020 2020  nt += 4;.       
+0001a060: 2020 207d 0a20 2020 2020 2020 207d 0a20     }.        }. 
+0001a070: 2020 2020 2020 202f 2f20 736b 6970 2077         // skip w
+0001a080: 6861 7420 7765 2068 6176 6520 6166 7465  hat we have afte
+0001a090: 720a 2020 2020 2020 2020 6966 2850 616e  r.        if(Pan
+0001a0a0: 656c 4d6f 6465 2920 636f 756e 7420 2b3d  elMode) count +=
+0001a0b0: 2034 202a 2028 7374 7269 6465 2d6f 6666   4 * (stride-off
+0001a0c0: 7365 742d 6465 7074 6829 3b0a 2020 2020  set-depth);.    
+0001a0d0: 2020 7d0a 2020 2020 7d0a 2020 2020 2f2f    }.    }.    //
+0001a0e0: 2063 6f70 7920 7468 6520 7265 6d61 696e   copy the remain
+0001a0f0: 696e 6720 636f 6c75 6d6e 7320 6f6e 6520  ing columns one 
+0001a100: 6174 2061 2074 696d 6520 286e 723d 3d31  at a time (nr==1
+0001a110: 290a 2020 2020 666f 7228 496e 6465 7820  ).    for(Index 
+0001a120: 6a32 3d70 6163 6b65 745f 636f 6c73 343b  j2=packet_cols4;
+0001a130: 206a 323c 636f 6c73 3b20 2b2b 6a32 290a   j2<cols; ++j2).
+0001a140: 2020 2020 7b0a 2020 2020 2020 6966 2850      {.      if(P
+0001a150: 616e 656c 4d6f 6465 2920 636f 756e 7420  anelMode) count 
+0001a160: 2b3d 206f 6666 7365 743b 0a20 2020 2020  += offset;.     
+0001a170: 2066 6f72 2849 6e64 6578 206b 3d30 3b20   for(Index k=0; 
+0001a180: 6b3c 6465 7074 683b 206b 2b2b 290a 2020  k<depth; k++).  
+0001a190: 2020 2020 7b0a 2020 2020 2020 2020 626c      {.        bl
+0001a1a0: 6f63 6b42 5b63 6f75 6e74 5d20 3d20 636a  ockB[count] = cj
+0001a1b0: 2872 6873 286b 2c20 6a32 2929 3b0a 2020  (rhs(k, j2));.  
+0001a1c0: 2020 2020 2020 636f 756e 7420 2b3d 2031        count += 1
+0001a1d0: 3b0a 2020 2020 2020 7d0a 2020 2020 2020  ;.      }.      
+0001a1e0: 6966 2850 616e 656c 4d6f 6465 2920 636f  if(PanelMode) co
+0001a1f0: 756e 7420 2b3d 2073 7472 6964 652d 6f66  unt += stride-of
+0001a200: 6673 6574 2d64 6570 7468 3b0a 2020 2020  fset-depth;.    
+0001a210: 7d0a 2020 7d0a 7d3b 0a0a 7d20 2f2f 2065  }.  }.};..} // e
+0001a220: 6e64 206e 616d 6573 7061 6365 2069 6e74  nd namespace int
+0001a230: 6572 6e61 6c0a 0a2f 2a2a 205c 7265 7475  ernal../** \retu
+0001a240: 726e 7320 7468 6520 6375 7272 656e 746c  rns the currentl
+0001a250: 7920 7365 7420 6c65 7665 6c20 3120 6370  y set level 1 cp
+0001a260: 7520 6361 6368 6520 7369 7a65 2028 696e  u cache size (in
+0001a270: 2062 7974 6573 2920 7573 6564 2074 6f20   bytes) used to 
+0001a280: 6573 7469 6d61 7465 2074 6865 2069 6465  estimate the ide
+0001a290: 616c 2062 6c6f 636b 696e 6720 7369 7a65  al blocking size
+0001a2a0: 2070 6172 616d 6574 6572 732e 0a20 202a   parameters..  *
+0001a2b0: 205c 7361 2073 6574 4370 7543 6163 6865   \sa setCpuCache
+0001a2c0: 5369 7a65 202a 2f0a 696e 6c69 6e65 2073  Size */.inline s
+0001a2d0: 7464 3a3a 7074 7264 6966 665f 7420 6c31  td::ptrdiff_t l1
+0001a2e0: 4361 6368 6553 697a 6528 290a 7b0a 2020  CacheSize().{.  
+0001a2f0: 7374 643a 3a70 7472 6469 6666 5f74 206c  std::ptrdiff_t l
+0001a300: 312c 206c 322c 206c 333b 0a20 2069 6e74  1, l2, l3;.  int
+0001a310: 6572 6e61 6c3a 3a6d 616e 6167 655f 6361  ernal::manage_ca
+0001a320: 6368 696e 675f 7369 7a65 7328 4765 7441  ching_sizes(GetA
+0001a330: 6374 696f 6e2c 2026 6c31 2c20 266c 322c  ction, &l1, &l2,
+0001a340: 2026 6c33 293b 0a20 2072 6574 7572 6e20   &l3);.  return 
+0001a350: 6c31 3b0a 7d0a 0a2f 2a2a 205c 7265 7475  l1;.}../** \retu
+0001a360: 726e 7320 7468 6520 6375 7272 656e 746c  rns the currentl
+0001a370: 7920 7365 7420 6c65 7665 6c20 3220 6370  y set level 2 cp
+0001a380: 7520 6361 6368 6520 7369 7a65 2028 696e  u cache size (in
+0001a390: 2062 7974 6573 2920 7573 6564 2074 6f20   bytes) used to 
+0001a3a0: 6573 7469 6d61 7465 2074 6865 2069 6465  estimate the ide
+0001a3b0: 616c 2062 6c6f 636b 696e 6720 7369 7a65  al blocking size
+0001a3c0: 2070 6172 616d 6574 6572 732e 0a20 202a   parameters..  *
+0001a3d0: 205c 7361 2073 6574 4370 7543 6163 6865   \sa setCpuCache
+0001a3e0: 5369 7a65 202a 2f0a 696e 6c69 6e65 2073  Size */.inline s
+0001a3f0: 7464 3a3a 7074 7264 6966 665f 7420 6c32  td::ptrdiff_t l2
+0001a400: 4361 6368 6553 697a 6528 290a 7b0a 2020  CacheSize().{.  
+0001a410: 7374 643a 3a70 7472 6469 6666 5f74 206c  std::ptrdiff_t l
+0001a420: 312c 206c 322c 206c 333b 0a20 2069 6e74  1, l2, l3;.  int
+0001a430: 6572 6e61 6c3a 3a6d 616e 6167 655f 6361  ernal::manage_ca
+0001a440: 6368 696e 675f 7369 7a65 7328 4765 7441  ching_sizes(GetA
+0001a450: 6374 696f 6e2c 2026 6c31 2c20 266c 322c  ction, &l1, &l2,
+0001a460: 2026 6c33 293b 0a20 2072 6574 7572 6e20   &l3);.  return 
+0001a470: 6c32 3b0a 7d0a 0a2f 2a2a 205c 7265 7475  l2;.}../** \retu
+0001a480: 726e 7320 7468 6520 6375 7272 656e 746c  rns the currentl
+0001a490: 7920 7365 7420 6c65 7665 6c20 3320 6370  y set level 3 cp
+0001a4a0: 7520 6361 6368 6520 7369 7a65 2028 696e  u cache size (in
+0001a4b0: 2062 7974 6573 2920 7573 6564 2074 6f20   bytes) used to 
+0001a4c0: 6573 7469 6d61 7465 2074 6865 2069 6465  estimate the ide
+0001a4d0: 616c 2062 6c6f 636b 696e 6720 7369 7a65  al blocking size
+0001a4e0: 2070 6172 616d 6574 655c 0a72 732e 2020   paramete\.rs.  
+0001a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a550: 2020 2020 2020 2020 2020 2020 2020 0a2a                .*
+0001a560: 205c 7361 2073 6574 4370 7543 6163 6865   \sa setCpuCache
+0001a570: 5369 7a65 202a 2f0a 696e 6c69 6e65 2073  Size */.inline s
+0001a580: 7464 3a3a 7074 7264 6966 665f 7420 6c33  td::ptrdiff_t l3
+0001a590: 4361 6368 6553 697a 6528 290a 7b0a 2020  CacheSize().{.  
+0001a5a0: 7374 643a 3a70 7472 6469 6666 5f74 206c  std::ptrdiff_t l
+0001a5b0: 312c 206c 322c 206c 333b 0a20 2069 6e74  1, l2, l3;.  int
+0001a5c0: 6572 6e61 6c3a 3a6d 616e 6167 655f 6361  ernal::manage_ca
+0001a5d0: 6368 696e 675f 7369 7a65 7328 4765 7441  ching_sizes(GetA
+0001a5e0: 6374 696f 6e2c 2026 6c31 2c20 266c 322c  ction, &l1, &l2,
+0001a5f0: 2026 6c33 293b 0a20 2072 6574 7572 6e20   &l3);.  return 
+0001a600: 6c33 3b0a 7d0a 0a2f 2a2a 2053 6574 2074  l3;.}../** Set t
+0001a610: 6865 2063 7075 204c 3120 616e 6420 4c32  he cpu L1 and L2
+0001a620: 2063 6163 6865 2073 697a 6573 2028 696e   cache sizes (in
+0001a630: 2062 7974 6573 292e 0a20 202a 2054 6865   bytes)..  * The
+0001a640: 7365 2076 616c 7565 7320 6172 6520 7573  se values are us
+0001a650: 6520 746f 2061 646a 7573 7420 7468 6520  e to adjust the 
+0001a660: 7369 7a65 206f 6620 7468 6520 626c 6f63  size of the bloc
+0001a670: 6b73 0a20 202a 2066 6f72 2074 6865 2061  ks.  * for the a
+0001a680: 6c67 6f72 6974 686d 7320 776f 726b 696e  lgorithms workin
+0001a690: 6720 7065 7220 626c 6f63 6b73 2e0a 2020  g per blocks..  
+0001a6a0: 2a0a 2020 2a20 5c73 6120 636f 6d70 7574  *.  * \sa comput
+0001a6b0: 6550 726f 6475 6374 426c 6f63 6b69 6e67  eProductBlocking
+0001a6c0: 5369 7a65 7320 2a2f 0a69 6e6c 696e 6520  Sizes */.inline 
+0001a6d0: 766f 6964 2073 6574 4370 7543 6163 6865  void setCpuCache
+0001a6e0: 5369 7a65 7328 7374 643a 3a70 7472 6469  Sizes(std::ptrdi
+0001a6f0: 6666 5f74 206c 312c 2073 7464 3a3a 7074  ff_t l1, std::pt
+0001a700: 7264 6966 665f 7420 6c32 2c20 7374 643a  rdiff_t l2, std:
+0001a710: 3a70 7472 6469 6666 5f74 206c 3329 0a7b  :ptrdiff_t l3).{
+0001a720: 0a20 2069 6e74 6572 6e61 6c3a 3a6d 616e  .  internal::man
+0001a730: 6167 655f 6361 6368 696e 675f 7369 7a65  age_caching_size
+0001a740: 7328 5365 7441 6374 696f 6e2c 2026 6c31  s(SetAction, &l1
+0001a750: 2c20 266c 322c 2026 6c33 293b 0a7d 0a0a  , &l2, &l3);.}..
+0001a760: 7d20 2f2f 2065 6e64 206e 616d 6573 7061  } // end namespa
+0001a770: 6365 2045 6967 656e 0a0a 2365 6e64 6966  ce Eigen..#endif
+0001a780: 202f 2f20 4549 4745 4e5f 4745 4e45 5241   // EIGEN_GENERA
+0001a790: 4c5f 424c 4f43 4b5f 5041 4e45 4c5f 480a  L_BLOCK_PANEL_H.
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixMatrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixMatrix.h`

 * *Files 6% similar despite different names*

```diff
@@ -16,70 +16,72 @@
 
 template<typename _LhsScalar, typename _RhsScalar> class level3_blocking;
 
 /* Specialization for a row-major destination matrix => simple transposition of the product */
 template<
   typename Index,
   typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
-  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs>
-struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>
+  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,
+  int ResInnerStride>
+struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,ResInnerStride>
 {
   typedef gebp_traits<RhsScalar,LhsScalar> Traits;
 
   typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
   static EIGEN_STRONG_INLINE void run(
     Index rows, Index cols, Index depth,
     const LhsScalar* lhs, Index lhsStride,
     const RhsScalar* rhs, Index rhsStride,
-    ResScalar* res, Index resStride,
+    ResScalar* res, Index resIncr, Index resStride,
     ResScalar alpha,
     level3_blocking<RhsScalar,LhsScalar>& blocking,
     GemmParallelInfo<Index>* info = 0)
   {
     // transpose the product such that the result is column major
     general_matrix_matrix_product<Index,
       RhsScalar, RhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateRhs,
       LhsScalar, LhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateLhs,
-      ColMajor>
-    ::run(cols,rows,depth,rhs,rhsStride,lhs,lhsStride,res,resStride,alpha,blocking,info);
+      ColMajor,ResInnerStride>
+    ::run(cols,rows,depth,rhs,rhsStride,lhs,lhsStride,res,resIncr,resStride,alpha,blocking,info);
   }
 };
 
 /*  Specialization for a col-major destination matrix
  *    => Blocking algorithm following Goto's paper */
 template<
   typename Index,
   typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
-  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs>
-struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>
+  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,
+  int ResInnerStride>
+struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,ResInnerStride>
 {
 
 typedef gebp_traits<LhsScalar,RhsScalar> Traits;
 
 typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
 static void run(Index rows, Index cols, Index depth,
   const LhsScalar* _lhs, Index lhsStride,
   const RhsScalar* _rhs, Index rhsStride,
-  ResScalar* _res, Index resStride,
+  ResScalar* _res, Index resIncr, Index resStride,
   ResScalar alpha,
   level3_blocking<LhsScalar,RhsScalar>& blocking,
   GemmParallelInfo<Index>* info = 0)
 {
   typedef const_blas_data_mapper<LhsScalar, Index, LhsStorageOrder> LhsMapper;
   typedef const_blas_data_mapper<RhsScalar, Index, RhsStorageOrder> RhsMapper;
-  typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
-  LhsMapper lhs(_lhs,lhsStride);
-  RhsMapper rhs(_rhs,rhsStride);
-  ResMapper res(_res, resStride);
+  typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor,Unaligned,ResInnerStride> ResMapper;
+  LhsMapper lhs(_lhs, lhsStride);
+  RhsMapper rhs(_rhs, rhsStride);
+  ResMapper res(_res, resStride, resIncr);
 
   Index kc = blocking.kc();                   // cache block size along the K direction
   Index mc = (std::min)(rows,blocking.mc());  // cache block size along the M direction
   Index nc = (std::min)(cols,blocking.nc());  // cache block size along the N direction
 
-  gemm_pack_lhs<LhsScalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
+  gemm_pack_lhs<LhsScalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder> pack_lhs;
   gemm_pack_rhs<RhsScalar, Index, RhsMapper, Traits::nr, RhsStorageOrder> pack_rhs;
   gebp_kernel<LhsScalar, RhsScalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp;
 
 #ifdef EIGEN_HAS_OPENMP
   if(info)
   {
     // this is the parallel version!
@@ -104,15 +106,15 @@
       // Pack A_k to A' in a parallel fashion:
       // each thread packs the sub block A_k,i to A'_i where i is the thread id.
 
       // However, before copying to A'_i, we have to make sure that no other thread is still using it,
       // i.e., we test that info[tid].users equals 0.
       // Then, we set info[tid].users to the number of threads to mark that all other threads are going to use it.
       while(info[tid].users!=0) {}
-      info[tid].users += threads;
+      info[tid].users = threads;
 
       pack_lhs(blockA+info[tid].lhs_start*actual_kc, lhs.getSubMapper(info[tid].lhs_start,k), actual_kc, info[tid].lhs_length);
 
       // Notify the other threads that the part A'_i is ready to go.
       info[tid].sync = k;
 
       // Computes C_i += A' * B' per A'_i
@@ -142,15 +144,17 @@
         // C_j += A' * B'
         gebp(res.getSubMapper(0, j), blockA, blockB, rows, actual_kc, actual_nc, alpha);
       }
 
       // Release all the sub blocks A'_i of A' for the current thread,
       // i.e., we simply decrement the number of users by 1
       for(Index i=0; i<threads; ++i)
+#if !EIGEN_HAS_CXX11_ATOMIC
         #pragma omp atomic
+#endif
         info[i].users -= 1;
     }
   }
   else
 #endif // EIGEN_HAS_OPENMP
   {
     EIGEN_UNUSED_VARIABLE(info);
@@ -222,15 +226,15 @@
   {
     if(cols==-1)
       cols = m_rhs.cols();
 
     Gemm::run(rows, cols, m_lhs.cols(),
               &m_lhs.coeffRef(row,0), m_lhs.outerStride(),
               &m_rhs.coeffRef(0,col), m_rhs.outerStride(),
-              (Scalar*)&(m_dest.coeffRef(row,col)), m_dest.outerStride(),
+              (Scalar*)&(m_dest.coeffRef(row,col)), m_dest.innerStride(), m_dest.outerStride(),
               m_actualAlpha, m_blocking, info);
   }
 
   typedef typename Gemm::Traits Traits;
 
   protected:
     const Lhs& m_lhs;
@@ -423,64 +427,85 @@
   };
 
   typedef generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> lazyproduct;
 
   template<typename Dst>
   static void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
-    if((rhs.rows()+dst.rows()+dst.cols())<20 && rhs.rows()>0)
-      lazyproduct::evalTo(dst, lhs, rhs);
+    // See http://eigen.tuxfamily.org/bz/show_bug.cgi?id=404 for a discussion and helper program
+    // to determine the following heuristic.
+    // EIGEN_GEMM_TO_COEFFBASED_THRESHOLD is typically defined to 20 in GeneralProduct.h,
+    // unless it has been specialized by the user or for a given architecture.
+    // Note that the condition rhs.rows()>0 was required because lazy product is (was?) not happy with empty inputs.
+    // I'm not sure it is still required.
+    if((rhs.rows()+dst.rows()+dst.cols())<EIGEN_GEMM_TO_COEFFBASED_THRESHOLD && rhs.rows()>0)
+      lazyproduct::eval_dynamic(dst, lhs, rhs, internal::assign_op<typename Dst::Scalar,Scalar>());
     else
     {
       dst.setZero();
       scaleAndAddTo(dst, lhs, rhs, Scalar(1));
     }
   }
 
   template<typename Dst>
   static void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
-    if((rhs.rows()+dst.rows()+dst.cols())<20 && rhs.rows()>0)
-      lazyproduct::addTo(dst, lhs, rhs);
+    if((rhs.rows()+dst.rows()+dst.cols())<EIGEN_GEMM_TO_COEFFBASED_THRESHOLD && rhs.rows()>0)
+      lazyproduct::eval_dynamic(dst, lhs, rhs, internal::add_assign_op<typename Dst::Scalar,Scalar>());
     else
       scaleAndAddTo(dst,lhs, rhs, Scalar(1));
   }
 
   template<typename Dst>
   static void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)
   {
-    if((rhs.rows()+dst.rows()+dst.cols())<20 && rhs.rows()>0)
-      lazyproduct::subTo(dst, lhs, rhs);
+    if((rhs.rows()+dst.rows()+dst.cols())<EIGEN_GEMM_TO_COEFFBASED_THRESHOLD && rhs.rows()>0)
+      lazyproduct::eval_dynamic(dst, lhs, rhs, internal::sub_assign_op<typename Dst::Scalar,Scalar>());
     else
       scaleAndAddTo(dst, lhs, rhs, Scalar(-1));
   }
 
   template<typename Dest>
   static void scaleAndAddTo(Dest& dst, const Lhs& a_lhs, const Rhs& a_rhs, const Scalar& alpha)
   {
     eigen_assert(dst.rows()==a_lhs.rows() && dst.cols()==a_rhs.cols());
     if(a_lhs.cols()==0 || a_lhs.rows()==0 || a_rhs.cols()==0)
       return;
 
+    if (dst.cols() == 1)
+    {
+      // Fallback to GEMV if either the lhs or rhs is a runtime vector
+      typename Dest::ColXpr dst_vec(dst.col(0));
+      return internal::generic_product_impl<Lhs,typename Rhs::ConstColXpr,DenseShape,DenseShape,GemvProduct>
+        ::scaleAndAddTo(dst_vec, a_lhs, a_rhs.col(0), alpha);
+    }
+    else if (dst.rows() == 1)
+    {
+      // Fallback to GEMV if either the lhs or rhs is a runtime vector
+      typename Dest::RowXpr dst_vec(dst.row(0));
+      return internal::generic_product_impl<typename Lhs::ConstRowXpr,Rhs,DenseShape,DenseShape,GemvProduct>
+        ::scaleAndAddTo(dst_vec, a_lhs.row(0), a_rhs, alpha);
+    }
+
     typename internal::add_const_on_value_type<ActualLhsType>::type lhs = LhsBlasTraits::extract(a_lhs);
     typename internal::add_const_on_value_type<ActualRhsType>::type rhs = RhsBlasTraits::extract(a_rhs);
 
-    Scalar actualAlpha = alpha * LhsBlasTraits::extractScalarFactor(a_lhs)
-                               * RhsBlasTraits::extractScalarFactor(a_rhs);
+    Scalar actualAlpha = combine_scalar_factors(alpha, a_lhs, a_rhs);
 
     typedef internal::gemm_blocking_space<(Dest::Flags&RowMajorBit) ? RowMajor : ColMajor,LhsScalar,RhsScalar,
             Dest::MaxRowsAtCompileTime,Dest::MaxColsAtCompileTime,MaxDepthAtCompileTime> BlockingType;
 
     typedef internal::gemm_functor<
       Scalar, Index,
       internal::general_matrix_matrix_product<
         Index,
         LhsScalar, (ActualLhsTypeCleaned::Flags&RowMajorBit) ? RowMajor : ColMajor, bool(LhsBlasTraits::NeedToConjugate),
         RhsScalar, (ActualRhsTypeCleaned::Flags&RowMajorBit) ? RowMajor : ColMajor, bool(RhsBlasTraits::NeedToConjugate),
-        (Dest::Flags&RowMajorBit) ? RowMajor : ColMajor>,
+        (Dest::Flags&RowMajorBit) ? RowMajor : ColMajor,
+        Dest::InnerStrideAtCompileTime>,
       ActualLhsTypeCleaned, ActualRhsTypeCleaned, Dest, BlockingType> GemmFunctor;
 
     BlockingType blocking(dst.rows(), dst.cols(), lhs.cols(), 1, true);
     internal::parallelize_gemm<(Dest::MaxRowsAtCompileTime>32 || Dest::MaxRowsAtCompileTime==Dynamic)>
         (GemmFunctor(lhs, rhs, dst, actualAlpha, blocking), a_lhs.rows(), a_rhs.cols(), a_lhs.cols(), Dest::Flags&RowMajorBit);
   }
 };
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h`

 * *Files 6% similar despite different names*

```diff
@@ -21,77 +21,80 @@
 * This file implements a general A * B product while
 * evaluating only one triangular part of the product.
 * This is a more general version of self adjoint product (C += A A^T)
 * as the level 3 SYRK Blas routine.
 **********************************************************************/
 
 // forward declarations (defined at the end of this file)
-template<typename LhsScalar, typename RhsScalar, typename Index, int mr, int nr, bool ConjLhs, bool ConjRhs, int UpLo>
+template<typename LhsScalar, typename RhsScalar, typename Index, int mr, int nr, bool ConjLhs, bool ConjRhs, int ResInnerStride, int UpLo>
 struct tribb_kernel;
   
 /* Optimized matrix-matrix product evaluating only one triangular half */
 template <typename Index,
           typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
           typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,
-                              int ResStorageOrder, int  UpLo, int Version = Specialized>
+                              int ResStorageOrder, int ResInnerStride, int  UpLo, int Version = Specialized>
 struct general_matrix_matrix_triangular_product;
 
 // as usual if the result is row major => we transpose the product
 template <typename Index, typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
-                          typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs, int  UpLo, int Version>
-struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>
+                          typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,
+                          int ResInnerStride, int  UpLo, int Version>
+struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,ResInnerStride,UpLo,Version>
 {
   typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
   static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,
-                                      const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resStride,
+                                      const RhsScalar* rhs, Index rhsStride, ResScalar* res, Index resIncr, Index resStride,
                                       const ResScalar& alpha, level3_blocking<RhsScalar,LhsScalar>& blocking)
   {
     general_matrix_matrix_triangular_product<Index,
         RhsScalar, RhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateRhs,
         LhsScalar, LhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateLhs,
-        ColMajor, UpLo==Lower?Upper:Lower>
-      ::run(size,depth,rhs,rhsStride,lhs,lhsStride,res,resStride,alpha,blocking);
+        ColMajor, ResInnerStride, UpLo==Lower?Upper:Lower>
+      ::run(size,depth,rhs,rhsStride,lhs,lhsStride,res,resIncr,resStride,alpha,blocking);
   }
 };
 
 template <typename Index, typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
-                          typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs, int  UpLo, int Version>
-struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>
+                          typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,
+                          int ResInnerStride, int  UpLo, int Version>
+struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,ResInnerStride,UpLo,Version>
 {
   typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;
   static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,
-                                      const RhsScalar* _rhs, Index rhsStride, ResScalar* _res, Index resStride,
+                                      const RhsScalar* _rhs, Index rhsStride,
+                                      ResScalar* _res, Index resIncr, Index resStride,
                                       const ResScalar& alpha, level3_blocking<LhsScalar,RhsScalar>& blocking)
   {
     typedef gebp_traits<LhsScalar,RhsScalar> Traits;
 
     typedef const_blas_data_mapper<LhsScalar, Index, LhsStorageOrder> LhsMapper;
     typedef const_blas_data_mapper<RhsScalar, Index, RhsStorageOrder> RhsMapper;
-    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
+    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor, Unaligned, ResInnerStride> ResMapper;
     LhsMapper lhs(_lhs,lhsStride);
     RhsMapper rhs(_rhs,rhsStride);
-    ResMapper res(_res, resStride);
+    ResMapper res(_res, resStride, resIncr);
 
     Index kc = blocking.kc();
     Index mc = (std::min)(size,blocking.mc());
 
     // !!! mc must be a multiple of nr:
     if(mc > Traits::nr)
       mc = (mc/Traits::nr)*Traits::nr;
 
     std::size_t sizeA = kc*mc;
     std::size_t sizeB = kc*size;
 
     ei_declare_aligned_stack_constructed_variable(LhsScalar, blockA, sizeA, blocking.blockA());
     ei_declare_aligned_stack_constructed_variable(RhsScalar, blockB, sizeB, blocking.blockB());
 
-    gemm_pack_lhs<LhsScalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
+    gemm_pack_lhs<LhsScalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder> pack_lhs;
     gemm_pack_rhs<RhsScalar, Index, RhsMapper, Traits::nr, RhsStorageOrder> pack_rhs;
     gebp_kernel<LhsScalar, RhsScalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp;
-    tribb_kernel<LhsScalar, RhsScalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs, UpLo> sybb;
+    tribb_kernel<LhsScalar, RhsScalar, Index, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs, ResInnerStride, UpLo> sybb;
 
     for(Index k2=0; k2<depth; k2+=kc)
     {
       const Index actual_kc = (std::min)(k2+kc,depth)-k2;
 
       // note that the actual rhs is the transpose/adjoint of mat
       pack_rhs(blockB, rhs.getSubMapper(k2,0), actual_kc, size);
@@ -106,16 +109,15 @@
         //  1 - before the diagonal => processed with gebp or skipped
         //  2 - the actual_mc x actual_mc symmetric block => processed with a special kernel
         //  3 - after the diagonal => processed with gebp or skipped
         if (UpLo==Lower)
           gebp(res.getSubMapper(i2, 0), blockA, blockB, actual_mc, actual_kc,
                (std::min)(size,i2), alpha, -1, -1, 0, 0);
 
-
-        sybb(_res+resStride*i2 + i2, resStride, blockA, blockB + actual_kc*i2, actual_mc, actual_kc, alpha);
+        sybb(_res+resStride*i2 + resIncr*i2, resIncr, resStride, blockA, blockB + actual_kc*i2, actual_mc, actual_kc, alpha);
 
         if (UpLo==Upper)
         {
           Index j2 = i2+actual_mc;
           gebp(res.getSubMapper(i2, j2), blockA, blockB+actual_kc*j2, actual_mc,
                actual_kc, (std::max)(Index(0), size-j2), alpha, -1, -1, 0, 0);
         }
@@ -129,64 +131,67 @@
 // - the current destination block is processed per panel of actual_mc x BlockSize
 //   where BlockSize is set to the minimal value allowing gebp to be as fast as possible
 // - then, as usual, each panel is split into three parts along the diagonal,
 //   the sub blocks above and below the diagonal are processed as usual,
 //   while the triangular block overlapping the diagonal is evaluated into a
 //   small temporary buffer which is then accumulated into the result using a
 //   triangular traversal.
-template<typename LhsScalar, typename RhsScalar, typename Index, int mr, int nr, bool ConjLhs, bool ConjRhs, int UpLo>
+template<typename LhsScalar, typename RhsScalar, typename Index, int mr, int nr, bool ConjLhs, bool ConjRhs, int ResInnerStride, int UpLo>
 struct tribb_kernel
 {
   typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;
   typedef typename Traits::ResScalar ResScalar;
 
   enum {
     BlockSize  = meta_least_common_multiple<EIGEN_PLAIN_ENUM_MAX(mr,nr),EIGEN_PLAIN_ENUM_MIN(mr,nr)>::ret
   };
-  void operator()(ResScalar* _res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha)
+  void operator()(ResScalar* _res, Index resIncr, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha)
   {
-    typedef blas_data_mapper<ResScalar, Index, ColMajor> ResMapper;
-    ResMapper res(_res, resStride);
-    gebp_kernel<LhsScalar, RhsScalar, Index, ResMapper, mr, nr, ConjLhs, ConjRhs> gebp_kernel;
+    typedef blas_data_mapper<ResScalar, Index, ColMajor, Unaligned, ResInnerStride> ResMapper;
+    typedef blas_data_mapper<ResScalar, Index, ColMajor, Unaligned> BufferMapper;
+    ResMapper res(_res, resStride, resIncr);
+    gebp_kernel<LhsScalar, RhsScalar, Index, ResMapper, mr, nr, ConjLhs, ConjRhs> gebp_kernel1;
+    gebp_kernel<LhsScalar, RhsScalar, Index, BufferMapper, mr, nr, ConjLhs, ConjRhs> gebp_kernel2;
 
     Matrix<ResScalar,BlockSize,BlockSize,ColMajor> buffer((internal::constructor_without_unaligned_array_assert()));
 
     // let's process the block per panel of actual_mc x BlockSize,
     // again, each is split into three parts, etc.
     for (Index j=0; j<size; j+=BlockSize)
     {
       Index actualBlockSize = std::min<Index>(BlockSize,size - j);
       const RhsScalar* actual_b = blockB+j*depth;
 
       if(UpLo==Upper)
-        gebp_kernel(res.getSubMapper(0, j), blockA, actual_b, j, depth, actualBlockSize, alpha,
-                    -1, -1, 0, 0);
-
+        gebp_kernel1(res.getSubMapper(0, j), blockA, actual_b, j, depth, actualBlockSize, alpha,
+                     -1, -1, 0, 0);
+      
       // selfadjoint micro block
       {
         Index i = j;
         buffer.setZero();
         // 1 - apply the kernel on the temporary buffer
-        gebp_kernel(ResMapper(buffer.data(), BlockSize), blockA+depth*i, actual_b, actualBlockSize, depth, actualBlockSize, alpha,
-                    -1, -1, 0, 0);
+        gebp_kernel2(BufferMapper(buffer.data(), BlockSize), blockA+depth*i, actual_b, actualBlockSize, depth, actualBlockSize, alpha,
+                     -1, -1, 0, 0);
+
         // 2 - triangular accumulation
         for(Index j1=0; j1<actualBlockSize; ++j1)
         {
-          ResScalar* r = &res(i, j + j1);
+          typename ResMapper::LinearMapper r = res.getLinearMapper(i,j+j1);
           for(Index i1=UpLo==Lower ? j1 : 0;
               UpLo==Lower ? i1<actualBlockSize : i1<=j1; ++i1)
-            r[i1] += buffer(i1,j1);
+            r(i1) += buffer(i1,j1);
         }
       }
 
       if(UpLo==Lower)
       {
         Index i = j+actualBlockSize;
-        gebp_kernel(res.getSubMapper(i, j), blockA+depth*i, actual_b, size-i, 
-                    depth, actualBlockSize, alpha, -1, -1, 0, 0);
+        gebp_kernel1(res.getSubMapper(i, j), blockA+depth*i, actual_b, size-i, 
+                     depth, actualBlockSize, alpha, -1, -1, 0, 0);
       }
     }
   }
 };
 
 } // end namespace internal
 
@@ -282,30 +287,31 @@
           MatrixType::MaxColsAtCompileTime, MatrixType::MaxColsAtCompileTime, _ActualRhs::MaxColsAtCompileTime> BlockingType;
 
     BlockingType blocking(size, size, depth, 1, false);
 
     internal::general_matrix_matrix_triangular_product<Index,
       typename Lhs::Scalar, LhsIsRowMajor ? RowMajor : ColMajor, LhsBlasTraits::NeedToConjugate,
       typename Rhs::Scalar, RhsIsRowMajor ? RowMajor : ColMajor, RhsBlasTraits::NeedToConjugate,
-      IsRowMajor ? RowMajor : ColMajor, UpLo&(Lower|Upper)>
+      IsRowMajor ? RowMajor : ColMajor, MatrixType::InnerStrideAtCompileTime, UpLo&(Lower|Upper)>
       ::run(size, depth,
             &actualLhs.coeffRef(SkipDiag&&(UpLo&Lower)==Lower ? 1 : 0,0), actualLhs.outerStride(),
             &actualRhs.coeffRef(0,SkipDiag&&(UpLo&Upper)==Upper ? 1 : 0), actualRhs.outerStride(),
-            mat.data() + (SkipDiag ? (bool(IsRowMajor) != ((UpLo&Lower)==Lower) ? 1 : mat.outerStride() ) : 0), mat.outerStride(), actualAlpha, blocking);
+            mat.data() + (SkipDiag ? (bool(IsRowMajor) != ((UpLo&Lower)==Lower) ? mat.innerStride() : mat.outerStride() ) : 0),
+            mat.innerStride(), mat.outerStride(), actualAlpha, blocking);
   }
 };
 
 template<typename MatrixType, unsigned int UpLo>
 template<typename ProductType>
-TriangularView<MatrixType,UpLo>& TriangularViewImpl<MatrixType,UpLo,Dense>::_assignProduct(const ProductType& prod, const Scalar& alpha, bool beta)
+EIGEN_DEVICE_FUNC TriangularView<MatrixType,UpLo>& TriangularViewImpl<MatrixType,UpLo,Dense>::_assignProduct(const ProductType& prod, const Scalar& alpha, bool beta)
 {
   EIGEN_STATIC_ASSERT((UpLo&UnitDiag)==0, WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED);
   eigen_assert(derived().nestedExpression().rows() == prod.rows() && derived().cols() == prod.cols());
-  
+
   general_product_to_triangular_selector<MatrixType, ProductType, UpLo, internal::traits<ProductType>::InnerSize==1>::run(derived().nestedExpression().const_cast_derived(), prod, alpha, beta);
-  
+
   return derived();
 }
 
 } // end namespace Eigen
 
 #endif // EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixMatrixTriangular_BLAS.h`

 * *Files 2% similar despite different names*

```diff
@@ -33,38 +33,38 @@
 #ifndef EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_BLAS_H
 #define EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_BLAS_H
 
 namespace Eigen {
 
 namespace internal {
 
-template <typename Index, typename Scalar, int AStorageOrder, bool ConjugateA, int ResStorageOrder, int  UpLo>
+template <typename Index, typename Scalar, int AStorageOrder, bool ConjugateA, int ResStorageOrder, int UpLo>
 struct general_matrix_matrix_rankupdate :
        general_matrix_matrix_triangular_product<
-         Index,Scalar,AStorageOrder,ConjugateA,Scalar,AStorageOrder,ConjugateA,ResStorageOrder,UpLo,BuiltIn> {};
+         Index,Scalar,AStorageOrder,ConjugateA,Scalar,AStorageOrder,ConjugateA,ResStorageOrder,1,UpLo,BuiltIn> {};
 
 
 // try to go to BLAS specialization
 #define EIGEN_BLAS_RANKUPDATE_SPECIALIZE(Scalar) \
 template <typename Index, int LhsStorageOrder, bool ConjugateLhs, \
                           int RhsStorageOrder, bool ConjugateRhs, int  UpLo> \
 struct general_matrix_matrix_triangular_product<Index,Scalar,LhsStorageOrder,ConjugateLhs, \
-               Scalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Specialized> { \
+               Scalar,RhsStorageOrder,ConjugateRhs,ColMajor,1,UpLo,Specialized> { \
   static EIGEN_STRONG_INLINE void run(Index size, Index depth,const Scalar* lhs, Index lhsStride, \
-                          const Scalar* rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha, level3_blocking<Scalar, Scalar>& blocking) \
+                          const Scalar* rhs, Index rhsStride, Scalar* res, Index resIncr, Index resStride, Scalar alpha, level3_blocking<Scalar, Scalar>& blocking) \
   { \
     if ( lhs==rhs && ((UpLo&(Lower|Upper))==UpLo) ) { \
       general_matrix_matrix_rankupdate<Index,Scalar,LhsStorageOrder,ConjugateLhs,ColMajor,UpLo> \
       ::run(size,depth,lhs,lhsStride,rhs,rhsStride,res,resStride,alpha,blocking); \
     } else { \
       general_matrix_matrix_triangular_product<Index, \
         Scalar, LhsStorageOrder, ConjugateLhs, \
         Scalar, RhsStorageOrder, ConjugateRhs, \
-        ColMajor, UpLo, BuiltIn> \
-      ::run(size,depth,lhs,lhsStride,rhs,rhsStride,res,resStride,alpha,blocking); \
+        ColMajor, 1, UpLo, BuiltIn> \
+      ::run(size,depth,lhs,lhsStride,rhs,rhsStride,res,resIncr,resStride,alpha,blocking); \
     } \
   } \
 };
 
 EIGEN_BLAS_RANKUPDATE_SPECIALIZE(double)
 EIGEN_BLAS_RANKUPDATE_SPECIALIZE(float)
 // TODO handle complex cases
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixMatrix_BLAS.h`

 * *Files 2% similar despite different names*

```diff
@@ -47,28 +47,30 @@
 // gemm specialization
 
 #define GEMM_SPECIALIZATION(EIGTYPE, EIGPREFIX, BLASTYPE, BLASFUNC) \
 template< \
   typename Index, \
   int LhsStorageOrder, bool ConjugateLhs, \
   int RhsStorageOrder, bool ConjugateRhs> \
-struct general_matrix_matrix_product<Index,EIGTYPE,LhsStorageOrder,ConjugateLhs,EIGTYPE,RhsStorageOrder,ConjugateRhs,ColMajor> \
+struct general_matrix_matrix_product<Index,EIGTYPE,LhsStorageOrder,ConjugateLhs,EIGTYPE,RhsStorageOrder,ConjugateRhs,ColMajor,1> \
 { \
 typedef gebp_traits<EIGTYPE,EIGTYPE> Traits; \
 \
 static void run(Index rows, Index cols, Index depth, \
   const EIGTYPE* _lhs, Index lhsStride, \
   const EIGTYPE* _rhs, Index rhsStride, \
-  EIGTYPE* res, Index resStride, \
+  EIGTYPE* res, Index resIncr, Index resStride, \
   EIGTYPE alpha, \
   level3_blocking<EIGTYPE, EIGTYPE>& /*blocking*/, \
   GemmParallelInfo<Index>* /*info = 0*/) \
 { \
   using std::conj; \
 \
+  EIGEN_ONLY_USED_FOR_DEBUG(resIncr); \
+  eigen_assert(resIncr == 1); \
   char transa, transb; \
   BlasIndex m, n, k, lda, ldb, ldc; \
   const EIGTYPE *a, *b; \
   EIGTYPE beta(1); \
   MatrixX##EIGPREFIX a_tmp, b_tmp; \
 \
 /* Set transpose options */ \
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/GeneralMatrixVector_BLAS.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/Parallelizer.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/Parallelizer.h`

 * *Files 16% similar despite different names*

```diff
@@ -6,22 +6,27 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_PARALLELIZER_H
 #define EIGEN_PARALLELIZER_H
 
+#if EIGEN_HAS_CXX11_ATOMIC
+#include <atomic>
+#endif
+
 namespace Eigen {
 
 namespace internal {
 
 /** \internal */
 inline void manage_multi_threading(Action action, int* v)
 {
-  static EIGEN_UNUSED int m_maxThreads = -1;
+  static int m_maxThreads = -1;
+  EIGEN_UNUSED_VARIABLE(m_maxThreads)
 
   if(action==SetAction)
   {
     eigen_internal_assert(v!=0);
     m_maxThreads = *v;
   }
   else if(action==GetAction)
@@ -71,31 +76,43 @@
 
 namespace internal {
 
 template<typename Index> struct GemmParallelInfo
 {
   GemmParallelInfo() : sync(-1), users(0), lhs_start(0), lhs_length(0) {}
 
+  // volatile is not enough on all architectures (see bug 1572)
+  // to guarantee that when thread A says to thread B that it is
+  // done with packing a block, then all writes have been really
+  // carried out... C++11 memory model+atomic guarantees this.
+#if EIGEN_HAS_CXX11_ATOMIC
+  std::atomic<Index> sync;
+  std::atomic<int> users;
+#else
   Index volatile sync;
   int volatile users;
+#endif
 
   Index lhs_start;
   Index lhs_length;
 };
 
 template<bool Condition, typename Functor, typename Index>
 void parallelize_gemm(const Functor& func, Index rows, Index cols, Index depth, bool transpose)
 {
   // TODO when EIGEN_USE_BLAS is defined,
   // we should still enable OMP for other scalar types
-#if !(defined (EIGEN_HAS_OPENMP)) || defined (EIGEN_USE_BLAS)
+  // Without C++11, we have to disable GEMM's parallelization on
+  // non x86 architectures because there volatile is not enough for our purpose.
+  // See bug 1572.
+#if (! defined(EIGEN_HAS_OPENMP)) || defined(EIGEN_USE_BLAS) || ((!EIGEN_HAS_CXX11_ATOMIC) && !(EIGEN_ARCH_i386_OR_x86_64))
   // FIXME the transpose variable is only needed to properly split
   // the matrix product when multithreading is enabled. This is a temporary
   // fix to support row-major destination matrices. This whole
-  // parallelizer mechanism has to be redisigned anyway.
+  // parallelizer mechanism has to be redesigned anyway.
   EIGEN_UNUSED_VARIABLE(depth);
   EIGEN_UNUSED_VARIABLE(transpose);
   func(0,rows, 0,cols);
 #else
 
   // Dynamically check whether we should enable or disable OpenMP.
   // The conditions are:
@@ -108,20 +125,20 @@
   Index size = transpose ? rows : cols;
   Index pb_max_threads = std::max<Index>(1,size / Functor::Traits::nr);
 
   // compute the maximal number of threads from the total amount of work:
   double work = static_cast<double>(rows) * static_cast<double>(cols) *
       static_cast<double>(depth);
   double kMinTaskSize = 50000;  // FIXME improve this heuristic.
-  pb_max_threads = std::max<Index>(1, std::min<Index>(pb_max_threads, work / kMinTaskSize));
+  pb_max_threads = std::max<Index>(1, std::min<Index>(pb_max_threads, static_cast<Index>( work / kMinTaskSize ) ));
 
   // compute the number of threads we are going to use
   Index threads = std::min<Index>(nbThreads(), pb_max_threads);
 
-  // if multi-threading is explicitely disabled, not useful, or if we already are in a parallel session,
+  // if multi-threading is explicitly disabled, not useful, or if we already are in a parallel session,
   // then abort multi-threading
   // FIXME omp_get_num_threads()>1 only works for openmp, what if the user does not use openmp?
   if((!Condition) || (threads==1) || (omp_get_num_threads()>1))
     return func(0,rows, 0,cols);
 
   Eigen::initParallel();
   func.initParallelSession(threads);
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointMatrixMatrix.h`

 * *Files 7% similar despite different names*

```diff
@@ -41,37 +41,54 @@
     // transposed copy
     for(Index k=i+BlockRows; k<cols; k++)
       for(Index w=0; w<BlockRows; w++)
         blockA[count++] = numext::conj(lhs(k, i+w)); // transposed
   }
   void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)
   {
-    enum { PacketSize = packet_traits<Scalar>::size };
+    typedef typename unpacket_traits<typename packet_traits<Scalar>::type>::half HalfPacket;
+    typedef typename unpacket_traits<typename unpacket_traits<typename packet_traits<Scalar>::type>::half>::half QuarterPacket;
+    enum { PacketSize = packet_traits<Scalar>::size,
+           HalfPacketSize = unpacket_traits<HalfPacket>::size,
+           QuarterPacketSize = unpacket_traits<QuarterPacket>::size,
+           HasHalf = (int)HalfPacketSize < (int)PacketSize,
+           HasQuarter = (int)QuarterPacketSize < (int)HalfPacketSize};
+
     const_blas_data_mapper<Scalar,Index,StorageOrder> lhs(_lhs,lhsStride);
     Index count = 0;
     //Index peeled_mc3 = (rows/Pack1)*Pack1;
     
     const Index peeled_mc3 = Pack1>=3*PacketSize ? (rows/(3*PacketSize))*(3*PacketSize) : 0;
     const Index peeled_mc2 = Pack1>=2*PacketSize ? peeled_mc3+((rows-peeled_mc3)/(2*PacketSize))*(2*PacketSize) : 0;
-    const Index peeled_mc1 = Pack1>=1*PacketSize ? (rows/(1*PacketSize))*(1*PacketSize) : 0;
+    const Index peeled_mc1 = Pack1>=1*PacketSize ? peeled_mc2+((rows-peeled_mc2)/(1*PacketSize))*(1*PacketSize) : 0;
+    const Index peeled_mc_half = Pack1>=HalfPacketSize ? peeled_mc1+((rows-peeled_mc1)/(HalfPacketSize))*(HalfPacketSize) : 0;
+    const Index peeled_mc_quarter = Pack1>=QuarterPacketSize ? peeled_mc_half+((rows-peeled_mc_half)/(QuarterPacketSize))*(QuarterPacketSize) : 0;
     
     if(Pack1>=3*PacketSize)
       for(Index i=0; i<peeled_mc3; i+=3*PacketSize)
         pack<3*PacketSize>(blockA, lhs, cols, i, count);
     
     if(Pack1>=2*PacketSize)
       for(Index i=peeled_mc3; i<peeled_mc2; i+=2*PacketSize)
         pack<2*PacketSize>(blockA, lhs, cols, i, count);
     
     if(Pack1>=1*PacketSize)
       for(Index i=peeled_mc2; i<peeled_mc1; i+=1*PacketSize)
         pack<1*PacketSize>(blockA, lhs, cols, i, count);
 
+    if(HasHalf && Pack1>=HalfPacketSize)
+      for(Index i=peeled_mc1; i<peeled_mc_half; i+=HalfPacketSize)
+        pack<HalfPacketSize>(blockA, lhs, cols, i, count);
+
+    if(HasQuarter && Pack1>=QuarterPacketSize)
+      for(Index i=peeled_mc_half; i<peeled_mc_quarter; i+=QuarterPacketSize)
+        pack<QuarterPacketSize>(blockA, lhs, cols, i, count);
+
     // do the same with mr==1
-    for(Index i=peeled_mc1; i<rows; i++)
+    for(Index i=peeled_mc_quarter; i<rows; i++)
     {
       for(Index k=0; k<i; k++)
         blockA[count++] = lhs(i, k);                   // normal
 
       blockA[count++] = numext::real(lhs(i, i));       // real (diagonal)
 
       for(Index k=i+1; k<cols; k++)
@@ -273,90 +290,93 @@
 
 /* Optimized selfadjoint matrix * matrix (_SYMM) product built on top of
  * the general matrix matrix product.
  */
 template <typename Scalar, typename Index,
           int LhsStorageOrder, bool LhsSelfAdjoint, bool ConjugateLhs,
           int RhsStorageOrder, bool RhsSelfAdjoint, bool ConjugateRhs,
-          int ResStorageOrder>
+          int ResStorageOrder, int ResInnerStride>
 struct product_selfadjoint_matrix;
 
 template <typename Scalar, typename Index,
           int LhsStorageOrder, bool LhsSelfAdjoint, bool ConjugateLhs,
-          int RhsStorageOrder, bool RhsSelfAdjoint, bool ConjugateRhs>
-struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>
+          int RhsStorageOrder, bool RhsSelfAdjoint, bool ConjugateRhs,
+          int ResInnerStride>
+struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor,ResInnerStride>
 {
 
   static EIGEN_STRONG_INLINE void run(
     Index rows, Index cols,
     const Scalar* lhs, Index lhsStride,
     const Scalar* rhs, Index rhsStride,
-    Scalar* res,       Index resStride,
+    Scalar* res,       Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
   {
     product_selfadjoint_matrix<Scalar, Index,
       EIGEN_LOGICAL_XOR(RhsSelfAdjoint,RhsStorageOrder==RowMajor) ? ColMajor : RowMajor,
       RhsSelfAdjoint, NumTraits<Scalar>::IsComplex && EIGEN_LOGICAL_XOR(RhsSelfAdjoint,ConjugateRhs),
       EIGEN_LOGICAL_XOR(LhsSelfAdjoint,LhsStorageOrder==RowMajor) ? ColMajor : RowMajor,
       LhsSelfAdjoint, NumTraits<Scalar>::IsComplex && EIGEN_LOGICAL_XOR(LhsSelfAdjoint,ConjugateLhs),
-      ColMajor>
-      ::run(cols, rows,  rhs, rhsStride,  lhs, lhsStride,  res, resStride,  alpha, blocking);
+      ColMajor,ResInnerStride>
+      ::run(cols, rows,  rhs, rhsStride,  lhs, lhsStride,  res, resIncr, resStride,  alpha, blocking);
   }
 };
 
 template <typename Scalar, typename Index,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs>
-struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride>
+struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor,ResInnerStride>
 {
 
   static EIGEN_DONT_INLINE void run(
     Index rows, Index cols,
     const Scalar* _lhs, Index lhsStride,
     const Scalar* _rhs, Index rhsStride,
-    Scalar* res,        Index resStride,
+    Scalar* res,        Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking);
 };
 
 template <typename Scalar, typename Index,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs>
-EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>::run(
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride>
+EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor,ResInnerStride>::run(
     Index rows, Index cols,
     const Scalar* _lhs, Index lhsStride,
     const Scalar* _rhs, Index rhsStride,
-    Scalar* _res,        Index resStride,
+    Scalar* _res,       Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
   {
     Index size = rows;
 
     typedef gebp_traits<Scalar,Scalar> Traits;
 
     typedef const_blas_data_mapper<Scalar, Index, LhsStorageOrder> LhsMapper;
     typedef const_blas_data_mapper<Scalar, Index, (LhsStorageOrder == RowMajor) ? ColMajor : RowMajor> LhsTransposeMapper;
     typedef const_blas_data_mapper<Scalar, Index, RhsStorageOrder> RhsMapper;
-    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
+    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor, Unaligned, ResInnerStride> ResMapper;
     LhsMapper lhs(_lhs,lhsStride);
     LhsTransposeMapper lhs_transpose(_lhs,lhsStride);
     RhsMapper rhs(_rhs,rhsStride);
-    ResMapper res(_res, resStride);
+    ResMapper res(_res, resStride, resIncr);
 
     Index kc = blocking.kc();                   // cache block size along the K direction
     Index mc = (std::min)(rows,blocking.mc());  // cache block size along the M direction
     // kc must be smaller than mc
     kc = (std::min)(kc,mc);
     std::size_t sizeA = kc*mc;
     std::size_t sizeB = kc*cols;
     ei_declare_aligned_stack_constructed_variable(Scalar, blockA, sizeA, blocking.blockA());
     ei_declare_aligned_stack_constructed_variable(Scalar, blockB, sizeB, blocking.blockB());
 
     gebp_kernel<Scalar, Scalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp_kernel;
     symm_pack_lhs<Scalar, Index, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
     gemm_pack_rhs<Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder> pack_rhs;
-    gemm_pack_lhs<Scalar, Index, LhsTransposeMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder==RowMajor?ColMajor:RowMajor, true> pack_lhs_transposed;
+    gemm_pack_lhs<Scalar, Index, LhsTransposeMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder==RowMajor?ColMajor:RowMajor, true> pack_lhs_transposed;
 
     for(Index k2=0; k2<size; k2+=kc)
     {
       const Index actual_kc = (std::min)(k2+kc,size)-k2;
 
       // we have selected one row panel of rhs and one column panel of lhs
       // pack rhs's panel into a sequential chunk of memory
@@ -383,65 +403,67 @@
 
         gebp_kernel(res.getSubMapper(k2, 0), blockA, blockB, actual_mc, actual_kc, cols, alpha);
       }
 
       for(Index i2=k2+kc; i2<size; i2+=mc)
       {
         const Index actual_mc = (std::min)(i2+mc,size)-i2;
-        gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder,false>()
+        gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder,false>()
           (blockA, lhs.getSubMapper(i2, k2), actual_kc, actual_mc);
 
         gebp_kernel(res.getSubMapper(i2, 0), blockA, blockB, actual_mc, actual_kc, cols, alpha);
       }
     }
   }
 
 // matrix * selfadjoint product
 template <typename Scalar, typename Index,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs>
-struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride>
+struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor,ResInnerStride>
 {
 
   static EIGEN_DONT_INLINE void run(
     Index rows, Index cols,
     const Scalar* _lhs, Index lhsStride,
     const Scalar* _rhs, Index rhsStride,
-    Scalar* res,        Index resStride,
+    Scalar* res,        Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking);
 };
 
 template <typename Scalar, typename Index,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs>
-EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>::run(
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride>
+EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor,ResInnerStride>::run(
     Index rows, Index cols,
     const Scalar* _lhs, Index lhsStride,
     const Scalar* _rhs, Index rhsStride,
-    Scalar* _res,        Index resStride,
+    Scalar* _res,       Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
   {
     Index size = cols;
 
     typedef gebp_traits<Scalar,Scalar> Traits;
 
     typedef const_blas_data_mapper<Scalar, Index, LhsStorageOrder> LhsMapper;
-    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
+    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor, Unaligned, ResInnerStride> ResMapper;
     LhsMapper lhs(_lhs,lhsStride);
-    ResMapper res(_res,resStride);
+    ResMapper res(_res,resStride, resIncr);
 
     Index kc = blocking.kc();                   // cache block size along the K direction
     Index mc = (std::min)(rows,blocking.mc());  // cache block size along the M direction
     std::size_t sizeA = kc*mc;
     std::size_t sizeB = kc*cols;
     ei_declare_aligned_stack_constructed_variable(Scalar, blockA, sizeA, blocking.blockA());
     ei_declare_aligned_stack_constructed_variable(Scalar, blockB, sizeB, blocking.blockB());
 
     gebp_kernel<Scalar, Scalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp_kernel;
-    gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
+    gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder> pack_lhs;
     symm_pack_rhs<Scalar, Index, Traits::nr,RhsStorageOrder> pack_rhs;
 
     for(Index k2=0; k2<size; k2+=kc)
     {
       const Index actual_kc = (std::min)(k2+kc,size)-k2;
 
       pack_rhs(blockB, _rhs, rhsStride, actual_kc, cols, k2);
@@ -499,20 +521,21 @@
     BlockingType blocking(lhs.rows(), rhs.cols(), lhs.cols(), 1, false);
 
     internal::product_selfadjoint_matrix<Scalar, Index,
       EIGEN_LOGICAL_XOR(LhsIsUpper,internal::traits<Lhs>::Flags &RowMajorBit) ? RowMajor : ColMajor, LhsIsSelfAdjoint,
       NumTraits<Scalar>::IsComplex && EIGEN_LOGICAL_XOR(LhsIsUpper,bool(LhsBlasTraits::NeedToConjugate)),
       EIGEN_LOGICAL_XOR(RhsIsUpper,internal::traits<Rhs>::Flags &RowMajorBit) ? RowMajor : ColMajor, RhsIsSelfAdjoint,
       NumTraits<Scalar>::IsComplex && EIGEN_LOGICAL_XOR(RhsIsUpper,bool(RhsBlasTraits::NeedToConjugate)),
-      internal::traits<Dest>::Flags&RowMajorBit  ? RowMajor : ColMajor>
+      internal::traits<Dest>::Flags&RowMajorBit  ? RowMajor : ColMajor,
+      Dest::InnerStrideAtCompileTime>
       ::run(
         lhs.rows(), rhs.cols(),                 // sizes
         &lhs.coeffRef(0,0), lhs.outerStride(),  // lhs info
         &rhs.coeffRef(0,0), rhs.outerStride(),  // rhs info
-        &dst.coeffRef(0,0), dst.outerStride(),  // result info
+        &dst.coeffRef(0,0), dst.innerStride(), dst.outerStride(),  // result info
         actualAlpha, blocking                   // alpha
       );
   }
 };
 
 } // end namespace internal
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointMatrixMatrix_BLAS.h`

 * *Files 6% similar despite different names*

```diff
@@ -40,24 +40,26 @@
 
 /* Optimized selfadjoint matrix * matrix (?SYMM/?HEMM) product */
 
 #define EIGEN_BLAS_SYMM_L(EIGTYPE, BLASTYPE, EIGPREFIX, BLASFUNC) \
 template <typename Index, \
           int LhsStorageOrder, bool ConjugateLhs, \
           int RhsStorageOrder, bool ConjugateRhs> \
-struct product_selfadjoint_matrix<EIGTYPE,Index,LhsStorageOrder,true,ConjugateLhs,RhsStorageOrder,false,ConjugateRhs,ColMajor> \
+struct product_selfadjoint_matrix<EIGTYPE,Index,LhsStorageOrder,true,ConjugateLhs,RhsStorageOrder,false,ConjugateRhs,ColMajor,1> \
 {\
 \
   static void run( \
     Index rows, Index cols, \
     const EIGTYPE* _lhs, Index lhsStride, \
     const EIGTYPE* _rhs, Index rhsStride, \
-    EIGTYPE* res,        Index resStride, \
+    EIGTYPE* res,        Index resIncr, Index resStride, \
     EIGTYPE alpha, level3_blocking<EIGTYPE, EIGTYPE>& /*blocking*/) \
   { \
+    EIGEN_ONLY_USED_FOR_DEBUG(resIncr); \
+    eigen_assert(resIncr == 1); \
     char side='L', uplo='L'; \
     BlasIndex m, n, lda, ldb, ldc; \
     const EIGTYPE *a, *b; \
     EIGTYPE beta(1); \
     MatrixX##EIGPREFIX b_tmp; \
 \
 /* Set transpose options */ \
@@ -87,23 +89,25 @@
 };
 
 
 #define EIGEN_BLAS_HEMM_L(EIGTYPE, BLASTYPE, EIGPREFIX, BLASFUNC) \
 template <typename Index, \
           int LhsStorageOrder, bool ConjugateLhs, \
           int RhsStorageOrder, bool ConjugateRhs> \
-struct product_selfadjoint_matrix<EIGTYPE,Index,LhsStorageOrder,true,ConjugateLhs,RhsStorageOrder,false,ConjugateRhs,ColMajor> \
+struct product_selfadjoint_matrix<EIGTYPE,Index,LhsStorageOrder,true,ConjugateLhs,RhsStorageOrder,false,ConjugateRhs,ColMajor,1> \
 {\
   static void run( \
     Index rows, Index cols, \
     const EIGTYPE* _lhs, Index lhsStride, \
     const EIGTYPE* _rhs, Index rhsStride, \
-    EIGTYPE* res,        Index resStride, \
+    EIGTYPE* res,        Index resIncr, Index resStride, \
     EIGTYPE alpha, level3_blocking<EIGTYPE, EIGTYPE>& /*blocking*/) \
   { \
+    EIGEN_ONLY_USED_FOR_DEBUG(resIncr); \
+    eigen_assert(resIncr == 1); \
     char side='L', uplo='L'; \
     BlasIndex m, n, lda, ldb, ldc; \
     const EIGTYPE *a, *b; \
     EIGTYPE beta(1); \
     MatrixX##EIGPREFIX b_tmp; \
     Matrix<EIGTYPE, Dynamic, Dynamic, LhsStorageOrder> a_tmp; \
 \
@@ -163,24 +167,26 @@
 
 /* Optimized matrix * selfadjoint matrix (?SYMM/?HEMM) product */
 
 #define EIGEN_BLAS_SYMM_R(EIGTYPE, BLASTYPE, EIGPREFIX, BLASFUNC) \
 template <typename Index, \
           int LhsStorageOrder, bool ConjugateLhs, \
           int RhsStorageOrder, bool ConjugateRhs> \
-struct product_selfadjoint_matrix<EIGTYPE,Index,LhsStorageOrder,false,ConjugateLhs,RhsStorageOrder,true,ConjugateRhs,ColMajor> \
+struct product_selfadjoint_matrix<EIGTYPE,Index,LhsStorageOrder,false,ConjugateLhs,RhsStorageOrder,true,ConjugateRhs,ColMajor,1> \
 {\
 \
   static void run( \
     Index rows, Index cols, \
     const EIGTYPE* _lhs, Index lhsStride, \
     const EIGTYPE* _rhs, Index rhsStride, \
-    EIGTYPE* res,        Index resStride, \
+    EIGTYPE* res,        Index resIncr, Index resStride, \
     EIGTYPE alpha, level3_blocking<EIGTYPE, EIGTYPE>& /*blocking*/) \
   { \
+    EIGEN_ONLY_USED_FOR_DEBUG(resIncr); \
+    eigen_assert(resIncr == 1); \
     char side='R', uplo='L'; \
     BlasIndex m, n, lda, ldb, ldc; \
     const EIGTYPE *a, *b; \
     EIGTYPE beta(1); \
     MatrixX##EIGPREFIX b_tmp; \
 \
 /* Set m, n, k */ \
@@ -209,23 +215,25 @@
 };
 
 
 #define EIGEN_BLAS_HEMM_R(EIGTYPE, BLASTYPE, EIGPREFIX, BLASFUNC) \
 template <typename Index, \
           int LhsStorageOrder, bool ConjugateLhs, \
           int RhsStorageOrder, bool ConjugateRhs> \
-struct product_selfadjoint_matrix<EIGTYPE,Index,LhsStorageOrder,false,ConjugateLhs,RhsStorageOrder,true,ConjugateRhs,ColMajor> \
+struct product_selfadjoint_matrix<EIGTYPE,Index,LhsStorageOrder,false,ConjugateLhs,RhsStorageOrder,true,ConjugateRhs,ColMajor,1> \
 {\
   static void run( \
     Index rows, Index cols, \
     const EIGTYPE* _lhs, Index lhsStride, \
     const EIGTYPE* _rhs, Index rhsStride, \
-    EIGTYPE* res,        Index resStride, \
+    EIGTYPE* res,        Index resIncr, Index resStride, \
     EIGTYPE alpha, level3_blocking<EIGTYPE, EIGTYPE>& /*blocking*/) \
   { \
+    EIGEN_ONLY_USED_FOR_DEBUG(resIncr); \
+    eigen_assert(resIncr == 1); \
     char side='R', uplo='L'; \
     BlasIndex m, n, lda, ldb, ldc; \
     const EIGTYPE *a, *b; \
     EIGTYPE beta(1); \
     MatrixX##EIGPREFIX b_tmp; \
     Matrix<EIGTYPE, Dynamic, Dynamic, RhsStorageOrder> a_tmp; \
 \
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointMatrixVector.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointMatrixVector.h`

 * *Files 2% similar despite different names*

```diff
@@ -11,36 +11,38 @@
 #define EIGEN_SELFADJOINT_MATRIX_VECTOR_H
 
 namespace Eigen { 
 
 namespace internal {
 
 /* Optimized selfadjoint matrix * vector product:
- * This algorithm processes 2 columns at onces that allows to both reduce
+ * This algorithm processes 2 columns at once that allows to both reduce
  * the number of load/stores of the result by a factor 2 and to reduce
  * the instruction dependency.
  */
 
 template<typename Scalar, typename Index, int StorageOrder, int UpLo, bool ConjugateLhs, bool ConjugateRhs, int Version=Specialized>
 struct selfadjoint_matrix_vector_product;
 
 template<typename Scalar, typename Index, int StorageOrder, int UpLo, bool ConjugateLhs, bool ConjugateRhs, int Version>
 struct selfadjoint_matrix_vector_product
 
 {
-static EIGEN_DONT_INLINE void run(
+static EIGEN_DONT_INLINE EIGEN_DEVICE_FUNC
+void run(
   Index size,
   const Scalar*  lhs, Index lhsStride,
   const Scalar*  rhs,
   Scalar* res,
   Scalar alpha);
 };
 
 template<typename Scalar, typename Index, int StorageOrder, int UpLo, bool ConjugateLhs, bool ConjugateRhs, int Version>
-EIGEN_DONT_INLINE void selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,Version>::run(
+EIGEN_DONT_INLINE EIGEN_DEVICE_FUNC
+void selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,Version>::run(
   Index size,
   const Scalar*  lhs, Index lhsStride,
   const Scalar*  rhs,
   Scalar* res,
   Scalar alpha)
 {
   typedef typename packet_traits<Scalar>::type Packet;
@@ -58,16 +60,15 @@
   conj_helper<RealScalar,Scalar,false, ConjugateRhs> cjd;
 
   conj_helper<Packet,Packet,NumTraits<Scalar>::IsComplex && EIGEN_LOGICAL_XOR(ConjugateLhs,  IsRowMajor), ConjugateRhs> pcj0;
   conj_helper<Packet,Packet,NumTraits<Scalar>::IsComplex && EIGEN_LOGICAL_XOR(ConjugateLhs, !IsRowMajor), ConjugateRhs> pcj1;
 
   Scalar cjAlpha = ConjugateRhs ? numext::conj(alpha) : alpha;
 
-
-  Index bound = (std::max)(Index(0),size-8) & 0xfffffffe;
+  Index bound = numext::maxi(Index(0), size-8) & 0xfffffffe;
   if (FirstTriangular)
     bound = size - bound;
 
   for (Index j=FirstTriangular ? bound : 0;
        j<(FirstTriangular ? size : bound);j+=2)
   {
     const Scalar* EIGEN_RESTRICT A0 = lhs + j*lhsStride;
@@ -171,15 +172,16 @@
   typedef internal::blas_traits<Rhs> RhsBlasTraits;
   typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;
   typedef typename internal::remove_all<ActualRhsType>::type ActualRhsTypeCleaned;
 
   enum { LhsUpLo = LhsMode&(Upper|Lower) };
 
   template<typename Dest>
-  static void run(Dest& dest, const Lhs &a_lhs, const Rhs &a_rhs, const Scalar& alpha)
+  static EIGEN_DEVICE_FUNC
+  void run(Dest& dest, const Lhs &a_lhs, const Rhs &a_rhs, const Scalar& alpha)
   {
     typedef typename Dest::Scalar ResScalar;
     typedef typename Rhs::Scalar RhsScalar;
     typedef Map<Matrix<ResScalar,Dynamic,1>, EIGEN_PLAIN_ENUM_MIN(AlignedMax,internal::packet_traits<ResScalar>::size)> MappedDest;
     
     eigen_assert(dest.rows()==a_lhs.rows() && dest.cols()==a_rhs.cols());
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointMatrixVector_BLAS.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointProduct.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointProduct.h`

 * *Files 2% similar despite different names*

```diff
@@ -105,26 +105,26 @@
 
     BlockingType blocking(size, size, depth, 1, false);
 
 
     internal::general_matrix_matrix_triangular_product<Index,
       Scalar, OtherIsRowMajor ? RowMajor : ColMajor,   OtherBlasTraits::NeedToConjugate  && NumTraits<Scalar>::IsComplex,
       Scalar, OtherIsRowMajor ? ColMajor : RowMajor, (!OtherBlasTraits::NeedToConjugate) && NumTraits<Scalar>::IsComplex,
-      IsRowMajor ? RowMajor : ColMajor, UpLo>
+      IsRowMajor ? RowMajor : ColMajor, MatrixType::InnerStrideAtCompileTime, UpLo>
       ::run(size, depth,
-            &actualOther.coeffRef(0,0), actualOther.outerStride(), &actualOther.coeffRef(0,0), actualOther.outerStride(),
-            mat.data(), mat.outerStride(), actualAlpha, blocking);
+            actualOther.data(), actualOther.outerStride(), actualOther.data(), actualOther.outerStride(),
+            mat.data(), mat.innerStride(), mat.outerStride(), actualAlpha, blocking);
   }
 };
 
 // high level API
 
 template<typename MatrixType, unsigned int UpLo>
 template<typename DerivedU>
-SelfAdjointView<MatrixType,UpLo>& SelfAdjointView<MatrixType,UpLo>
+EIGEN_DEVICE_FUNC SelfAdjointView<MatrixType,UpLo>& SelfAdjointView<MatrixType,UpLo>
 ::rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha)
 {
   selfadjoint_product_selector<MatrixType,DerivedU,UpLo>::run(_expression().const_cast_derived(), u.derived(), alpha);
 
   return *this;
 }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/SelfadjointRank2Update.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/SelfadjointRank2Update.h`

 * *Files 3% similar despite different names*

```diff
@@ -20,15 +20,16 @@
 
 template<typename Scalar, typename Index, typename UType, typename VType, int UpLo>
 struct selfadjoint_rank2_update_selector;
 
 template<typename Scalar, typename Index, typename UType, typename VType>
 struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>
 {
-  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)
+  static EIGEN_DEVICE_FUNC
+  void run(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)
   {
     const Index size = u.size();
     for (Index i=0; i<size; ++i)
     {
       Map<Matrix<Scalar,Dynamic,1> >(mat+stride*i+i, size-i) +=
                         (numext::conj(alpha) * numext::conj(u.coeff(i))) * v.tail(size-i)
                       + (alpha * numext::conj(v.coeff(i))) * u.tail(size-i);
@@ -53,15 +54,15 @@
   : conditional<!Cond, const T&,
       CwiseUnaryOp<scalar_conjugate_op<typename traits<T>::Scalar>,T> > {};
 
 } // end namespace internal
 
 template<typename MatrixType, unsigned int UpLo>
 template<typename DerivedU, typename DerivedV>
-SelfAdjointView<MatrixType,UpLo>& SelfAdjointView<MatrixType,UpLo>
+EIGEN_DEVICE_FUNC SelfAdjointView<MatrixType,UpLo>& SelfAdjointView<MatrixType,UpLo>
 ::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha)
 {
   typedef internal::blas_traits<DerivedU> UBlasTraits;
   typedef typename UBlasTraits::DirectLinearAccessType ActualUType;
   typedef typename internal::remove_all<ActualUType>::type _ActualUType;
   typename internal::add_const_on_value_type<ActualUType>::type actualU = UBlasTraits::extract(u.derived());
 
@@ -75,16 +76,16 @@
 
   enum { IsRowMajor = (internal::traits<MatrixType>::Flags&RowMajorBit) ? 1 : 0 };
   Scalar actualAlpha = alpha * UBlasTraits::extractScalarFactor(u.derived())
                              * numext::conj(VBlasTraits::extractScalarFactor(v.derived()));
   if (IsRowMajor)
     actualAlpha = numext::conj(actualAlpha);
 
-  typedef typename internal::remove_all<typename internal::conj_expr_if<IsRowMajor ^ UBlasTraits::NeedToConjugate,_ActualUType>::type>::type UType;
-  typedef typename internal::remove_all<typename internal::conj_expr_if<IsRowMajor ^ VBlasTraits::NeedToConjugate,_ActualVType>::type>::type VType;
+  typedef typename internal::remove_all<typename internal::conj_expr_if<int(IsRowMajor) ^ int(UBlasTraits::NeedToConjugate), _ActualUType>::type>::type UType;
+  typedef typename internal::remove_all<typename internal::conj_expr_if<int(IsRowMajor) ^ int(VBlasTraits::NeedToConjugate), _ActualVType>::type>::type VType;
   internal::selfadjoint_rank2_update_selector<Scalar, Index, UType, VType,
     (IsRowMajor ? int(UpLo==Upper ? Lower : Upper) : UpLo)>
     ::run(_expression().const_cast_derived().data(),_expression().outerStride(),UType(actualU),VType(actualV),actualAlpha);
 
   return *this;
 }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/TriangularMatrixMatrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/TriangularMatrixMatrix.h`

 * *Files 6% similar despite different names*

```diff
@@ -41,92 +41,96 @@
 /* Optimized triangular matrix * matrix (_TRMM++) product built on top of
  * the general matrix matrix product.
  */
 template <typename Scalar, typename Index,
           int Mode, bool LhsIsTriangular,
           int LhsStorageOrder, bool ConjugateLhs,
           int RhsStorageOrder, bool ConjugateRhs,
-          int ResStorageOrder, int Version = Specialized>
+          int ResStorageOrder, int ResInnerStride,
+          int Version = Specialized>
 struct product_triangular_matrix_matrix;
 
 template <typename Scalar, typename Index,
           int Mode, bool LhsIsTriangular,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs, int Version>
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride, int Version>
 struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,
                                            LhsStorageOrder,ConjugateLhs,
-                                           RhsStorageOrder,ConjugateRhs,RowMajor,Version>
+                                           RhsStorageOrder,ConjugateRhs,RowMajor,ResInnerStride,Version>
 {
   static EIGEN_STRONG_INLINE void run(
     Index rows, Index cols, Index depth,
     const Scalar* lhs, Index lhsStride,
     const Scalar* rhs, Index rhsStride,
-    Scalar* res,       Index resStride,
+    Scalar* res,       Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
   {
     product_triangular_matrix_matrix<Scalar, Index,
       (Mode&(UnitDiag|ZeroDiag)) | ((Mode&Upper) ? Lower : Upper),
       (!LhsIsTriangular),
       RhsStorageOrder==RowMajor ? ColMajor : RowMajor,
       ConjugateRhs,
       LhsStorageOrder==RowMajor ? ColMajor : RowMajor,
       ConjugateLhs,
-      ColMajor>
-      ::run(cols, rows, depth, rhs, rhsStride, lhs, lhsStride, res, resStride, alpha, blocking);
+      ColMajor, ResInnerStride>
+      ::run(cols, rows, depth, rhs, rhsStride, lhs, lhsStride, res, resIncr, resStride, alpha, blocking);
   }
 };
 
 // implements col-major += alpha * op(triangular) * op(general)
 template <typename Scalar, typename Index, int Mode,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs, int Version>
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride, int Version>
 struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,
                                            LhsStorageOrder,ConjugateLhs,
-                                           RhsStorageOrder,ConjugateRhs,ColMajor,Version>
+                                           RhsStorageOrder,ConjugateRhs,ColMajor,ResInnerStride,Version>
 {
   
   typedef gebp_traits<Scalar,Scalar> Traits;
   enum {
     SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),
     IsLower = (Mode&Lower) == Lower,
     SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1
   };
 
   static EIGEN_DONT_INLINE void run(
     Index _rows, Index _cols, Index _depth,
     const Scalar* _lhs, Index lhsStride,
     const Scalar* _rhs, Index rhsStride,
-    Scalar* res,        Index resStride,
+    Scalar* res,        Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking);
 };
 
 template <typename Scalar, typename Index, int Mode,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs, int Version>
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride, int Version>
 EIGEN_DONT_INLINE void product_triangular_matrix_matrix<Scalar,Index,Mode,true,
                                                         LhsStorageOrder,ConjugateLhs,
-                                                        RhsStorageOrder,ConjugateRhs,ColMajor,Version>::run(
+                                                        RhsStorageOrder,ConjugateRhs,ColMajor,ResInnerStride,Version>::run(
     Index _rows, Index _cols, Index _depth,
     const Scalar* _lhs, Index lhsStride,
     const Scalar* _rhs, Index rhsStride,
-    Scalar* _res,        Index resStride,
+    Scalar* _res,       Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
   {
     // strip zeros
     Index diagSize  = (std::min)(_rows,_depth);
     Index rows      = IsLower ? _rows : diagSize;
     Index depth     = IsLower ? diagSize : _depth;
     Index cols      = _cols;
     
     typedef const_blas_data_mapper<Scalar, Index, LhsStorageOrder> LhsMapper;
     typedef const_blas_data_mapper<Scalar, Index, RhsStorageOrder> RhsMapper;
-    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
+    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor, Unaligned, ResInnerStride> ResMapper;
     LhsMapper lhs(_lhs,lhsStride);
     RhsMapper rhs(_rhs,rhsStride);
-    ResMapper res(_res, resStride);
+    ResMapper res(_res, resStride, resIncr);
 
     Index kc = blocking.kc();                   // cache block size along the K direction
     Index mc = (std::min)(rows,blocking.mc());  // cache block size along the M direction
     // The small panel size must not be larger than blocking size.
     // Usually this should never be the case because SmallPanelWidth^2 is very small
     // compared to L2 cache size, but let's be safe:
     Index panelWidth = (std::min)(Index(SmallPanelWidth),(std::min)(kc,mc));
@@ -147,15 +151,15 @@
     triangularBuffer.setZero();
     if((Mode&ZeroDiag)==ZeroDiag)
       triangularBuffer.diagonal().setZero();
     else
       triangularBuffer.diagonal().setOnes();
 
     gebp_kernel<Scalar, Scalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp_kernel;
-    gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
+    gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder> pack_lhs;
     gemm_pack_rhs<Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder> pack_rhs;
 
     for(Index k2=IsLower ? depth : 0;
         IsLower ? k2>0 : k2<depth;
         IsLower ? k2-=kc : k2+=kc)
     {
       Index actual_kc = (std::min)(IsLower ? k2 : depth-k2, kc);
@@ -218,72 +222,74 @@
       // the part below (lower case) or above (upper case) the diagonal => GEPP
       {
         Index start = IsLower ? k2 : 0;
         Index end   = IsLower ? rows : (std::min)(actual_k2,rows);
         for(Index i2=start; i2<end; i2+=mc)
         {
           const Index actual_mc = (std::min)(i2+mc,end)-i2;
-          gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr,Traits::LhsProgress, LhsStorageOrder,false>()
+          gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr,Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder,false>()
             (blockA, lhs.getSubMapper(i2, actual_k2), actual_kc, actual_mc);
 
           gebp_kernel(res.getSubMapper(i2, 0), blockA, blockB, actual_mc,
                       actual_kc, cols, alpha, -1, -1, 0, 0);
         }
       }
     }
   }
 
 // implements col-major += alpha * op(general) * op(triangular)
 template <typename Scalar, typename Index, int Mode,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs, int Version>
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride, int Version>
 struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,
                                         LhsStorageOrder,ConjugateLhs,
-                                        RhsStorageOrder,ConjugateRhs,ColMajor,Version>
+                                        RhsStorageOrder,ConjugateRhs,ColMajor,ResInnerStride,Version>
 {
   typedef gebp_traits<Scalar,Scalar> Traits;
   enum {
     SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),
     IsLower = (Mode&Lower) == Lower,
     SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1
   };
 
   static EIGEN_DONT_INLINE void run(
     Index _rows, Index _cols, Index _depth,
     const Scalar* _lhs, Index lhsStride,
     const Scalar* _rhs, Index rhsStride,
-    Scalar* res,        Index resStride,
+    Scalar* res,        Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking);
 };
 
 template <typename Scalar, typename Index, int Mode,
           int LhsStorageOrder, bool ConjugateLhs,
-          int RhsStorageOrder, bool ConjugateRhs, int Version>
+          int RhsStorageOrder, bool ConjugateRhs,
+          int ResInnerStride, int Version>
 EIGEN_DONT_INLINE void product_triangular_matrix_matrix<Scalar,Index,Mode,false,
                                                         LhsStorageOrder,ConjugateLhs,
-                                                        RhsStorageOrder,ConjugateRhs,ColMajor,Version>::run(
+                                                        RhsStorageOrder,ConjugateRhs,ColMajor,ResInnerStride,Version>::run(
     Index _rows, Index _cols, Index _depth,
     const Scalar* _lhs, Index lhsStride,
     const Scalar* _rhs, Index rhsStride,
-    Scalar* _res,        Index resStride,
+    Scalar* _res,       Index resIncr, Index resStride,
     const Scalar& alpha, level3_blocking<Scalar,Scalar>& blocking)
   {
     const Index PacketBytes = packet_traits<Scalar>::size*sizeof(Scalar);
     // strip zeros
     Index diagSize  = (std::min)(_cols,_depth);
     Index rows      = _rows;
     Index depth     = IsLower ? _depth : diagSize;
     Index cols      = IsLower ? diagSize : _cols;
     
     typedef const_blas_data_mapper<Scalar, Index, LhsStorageOrder> LhsMapper;
     typedef const_blas_data_mapper<Scalar, Index, RhsStorageOrder> RhsMapper;
-    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor> ResMapper;
+    typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor, Unaligned, ResInnerStride> ResMapper;
     LhsMapper lhs(_lhs,lhsStride);
     RhsMapper rhs(_rhs,rhsStride);
-    ResMapper res(_res, resStride);
+    ResMapper res(_res, resStride, resIncr);
 
     Index kc = blocking.kc();                   // cache block size along the K direction
     Index mc = (std::min)(rows,blocking.mc());  // cache block size along the M direction
 
     std::size_t sizeA = kc*mc;
     std::size_t sizeB = kc*cols+EIGEN_MAX_ALIGN_BYTES/sizeof(Scalar);
 
@@ -295,15 +301,15 @@
     triangularBuffer.setZero();
     if((Mode&ZeroDiag)==ZeroDiag)
       triangularBuffer.diagonal().setZero();
     else
       triangularBuffer.diagonal().setOnes();
 
     gebp_kernel<Scalar, Scalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp_kernel;
-    gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, LhsStorageOrder> pack_lhs;
+    gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder> pack_lhs;
     gemm_pack_rhs<Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder> pack_rhs;
     gemm_pack_rhs<Scalar, Index, RhsMapper, Traits::nr,RhsStorageOrder,false,true> pack_rhs_panel;
 
     for(Index k2=IsLower ? 0 : depth;
         IsLower ? k2<depth  : k2>0;
         IsLower ? k2+=kc   : k2-=kc)
     {
@@ -429,20 +435,20 @@
 
     BlockingType blocking(stripedRows, stripedCols, stripedDepth, 1, false);
 
     internal::product_triangular_matrix_matrix<Scalar, Index,
       Mode, LhsIsTriangular,
       (internal::traits<ActualLhsTypeCleaned>::Flags&RowMajorBit) ? RowMajor : ColMajor, LhsBlasTraits::NeedToConjugate,
       (internal::traits<ActualRhsTypeCleaned>::Flags&RowMajorBit) ? RowMajor : ColMajor, RhsBlasTraits::NeedToConjugate,
-      (internal::traits<Dest          >::Flags&RowMajorBit) ? RowMajor : ColMajor>
+      (internal::traits<Dest          >::Flags&RowMajorBit) ? RowMajor : ColMajor, Dest::InnerStrideAtCompileTime>
       ::run(
         stripedRows, stripedCols, stripedDepth,   // sizes
         &lhs.coeffRef(0,0), lhs.outerStride(),    // lhs info
         &rhs.coeffRef(0,0), rhs.outerStride(),    // rhs info
-        &dst.coeffRef(0,0), dst.outerStride(),    // result info
+        &dst.coeffRef(0,0), dst.innerStride(), dst.outerStride(),    // result info
         actualAlpha, blocking
       );
 
     // Apply correction if the diagonal is unit and a scalar factor was nested:
     if ((Mode&UnitDiag)==UnitDiag)
     {
       if (LhsIsTriangular && lhs_alpha!=LhsScalar(1))
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/TriangularMatrixMatrix_BLAS.h`

 * *Files 1% similar despite different names*

```diff
@@ -42,30 +42,32 @@
           int Mode, bool LhsIsTriangular,
           int LhsStorageOrder, bool ConjugateLhs,
           int RhsStorageOrder, bool ConjugateRhs,
           int ResStorageOrder>
 struct product_triangular_matrix_matrix_trmm :
        product_triangular_matrix_matrix<Scalar,Index,Mode,
           LhsIsTriangular,LhsStorageOrder,ConjugateLhs,
-          RhsStorageOrder, ConjugateRhs, ResStorageOrder, BuiltIn> {};
+          RhsStorageOrder, ConjugateRhs, ResStorageOrder, 1, BuiltIn> {};
 
 
 // try to go to BLAS specialization
 #define EIGEN_BLAS_TRMM_SPECIALIZE(Scalar, LhsIsTriangular) \
 template <typename Index, int Mode, \
           int LhsStorageOrder, bool ConjugateLhs, \
           int RhsStorageOrder, bool ConjugateRhs> \
 struct product_triangular_matrix_matrix<Scalar,Index, Mode, LhsIsTriangular, \
-           LhsStorageOrder,ConjugateLhs, RhsStorageOrder,ConjugateRhs,ColMajor,Specialized> { \
+           LhsStorageOrder,ConjugateLhs, RhsStorageOrder,ConjugateRhs,ColMajor,1,Specialized> { \
   static inline void run(Index _rows, Index _cols, Index _depth, const Scalar* _lhs, Index lhsStride,\
-    const Scalar* _rhs, Index rhsStride, Scalar* res, Index resStride, Scalar alpha, level3_blocking<Scalar,Scalar>& blocking) { \
+    const Scalar* _rhs, Index rhsStride, Scalar* res, Index resIncr, Index resStride, Scalar alpha, level3_blocking<Scalar,Scalar>& blocking) { \
+      EIGEN_ONLY_USED_FOR_DEBUG(resIncr); \
+      eigen_assert(resIncr == 1); \
       product_triangular_matrix_matrix_trmm<Scalar,Index,Mode, \
         LhsIsTriangular,LhsStorageOrder,ConjugateLhs, \
         RhsStorageOrder, ConjugateRhs, ColMajor>::run( \
-        _rows, _cols, _depth, _lhs, lhsStride, _rhs, rhsStride, res, resStride, alpha, blocking); \
+          _rows, _cols, _depth, _lhs, lhsStride, _rhs, rhsStride, res, resStride, alpha, blocking); \
   } \
 };
 
 EIGEN_BLAS_TRMM_SPECIALIZE(double, true)
 EIGEN_BLAS_TRMM_SPECIALIZE(double, false)
 EIGEN_BLAS_TRMM_SPECIALIZE(dcomplex, true)
 EIGEN_BLAS_TRMM_SPECIALIZE(dcomplex, false)
@@ -111,25 +113,25 @@
 \
      /* FIXME handle mkl_domain_get_max_threads */ \
      /*int nthr = mkl_domain_get_max_threads(EIGEN_BLAS_DOMAIN_BLAS);*/ int nthr = 1;\
 \
      if (((nthr==1) && (((std::max)(rows,depth)-diagSize)/(double)diagSize < 0.5))) { \
      /* Most likely no benefit to call TRMM or GEMM from BLAS */ \
        product_triangular_matrix_matrix<EIGTYPE,Index,Mode,true, \
-       LhsStorageOrder,ConjugateLhs, RhsStorageOrder, ConjugateRhs, ColMajor, BuiltIn>::run( \
-           _rows, _cols, _depth, _lhs, lhsStride, _rhs, rhsStride, res, resStride, alpha, blocking); \
+       LhsStorageOrder,ConjugateLhs, RhsStorageOrder, ConjugateRhs, ColMajor, 1, BuiltIn>::run( \
+           _rows, _cols, _depth, _lhs, lhsStride, _rhs, rhsStride, res, 1, resStride, alpha, blocking); \
      /*std::cout << "TRMM_L: A is not square! Go to Eigen TRMM implementation!\n";*/ \
      } else { \
      /* Make sense to call GEMM */ \
        Map<const MatrixLhs, 0, OuterStride<> > lhsMap(_lhs,rows,depth,OuterStride<>(lhsStride)); \
        MatrixLhs aa_tmp=lhsMap.template triangularView<Mode>(); \
        BlasIndex aStride = convert_index<BlasIndex>(aa_tmp.outerStride()); \
        gemm_blocking_space<ColMajor,EIGTYPE,EIGTYPE,Dynamic,Dynamic,Dynamic> gemm_blocking(_rows,_cols,_depth, 1, true); \
-       general_matrix_matrix_product<Index,EIGTYPE,LhsStorageOrder,ConjugateLhs,EIGTYPE,RhsStorageOrder,ConjugateRhs,ColMajor>::run( \
-       rows, cols, depth, aa_tmp.data(), aStride, _rhs, rhsStride, res, resStride, alpha, gemm_blocking, 0); \
+       general_matrix_matrix_product<Index,EIGTYPE,LhsStorageOrder,ConjugateLhs,EIGTYPE,RhsStorageOrder,ConjugateRhs,ColMajor,1>::run( \
+       rows, cols, depth, aa_tmp.data(), aStride, _rhs, rhsStride, res, 1, resStride, alpha, gemm_blocking, 0); \
 \
      /*std::cout << "TRMM_L: A is not square! Go to BLAS GEMM implementation! " << nthr<<" \n";*/ \
      } \
      return; \
    } \
    char side = 'L', transa, uplo, diag = 'N'; \
    EIGTYPE *b; \
@@ -228,25 +230,25 @@
    if (cols != depth) { \
 \
      int nthr = 1 /*mkl_domain_get_max_threads(EIGEN_BLAS_DOMAIN_BLAS)*/; \
 \
      if ((nthr==1) && (((std::max)(cols,depth)-diagSize)/(double)diagSize < 0.5)) { \
      /* Most likely no benefit to call TRMM or GEMM from BLAS*/ \
        product_triangular_matrix_matrix<EIGTYPE,Index,Mode,false, \
-       LhsStorageOrder,ConjugateLhs, RhsStorageOrder, ConjugateRhs, ColMajor, BuiltIn>::run( \
-           _rows, _cols, _depth, _lhs, lhsStride, _rhs, rhsStride, res, resStride, alpha, blocking); \
+       LhsStorageOrder,ConjugateLhs, RhsStorageOrder, ConjugateRhs, ColMajor, 1, BuiltIn>::run( \
+           _rows, _cols, _depth, _lhs, lhsStride, _rhs, rhsStride, res, 1, resStride, alpha, blocking); \
        /*std::cout << "TRMM_R: A is not square! Go to Eigen TRMM implementation!\n";*/ \
      } else { \
      /* Make sense to call GEMM */ \
        Map<const MatrixRhs, 0, OuterStride<> > rhsMap(_rhs,depth,cols, OuterStride<>(rhsStride)); \
        MatrixRhs aa_tmp=rhsMap.template triangularView<Mode>(); \
        BlasIndex aStride = convert_index<BlasIndex>(aa_tmp.outerStride()); \
        gemm_blocking_space<ColMajor,EIGTYPE,EIGTYPE,Dynamic,Dynamic,Dynamic> gemm_blocking(_rows,_cols,_depth, 1, true); \
-       general_matrix_matrix_product<Index,EIGTYPE,LhsStorageOrder,ConjugateLhs,EIGTYPE,RhsStorageOrder,ConjugateRhs,ColMajor>::run( \
-       rows, cols, depth, _lhs, lhsStride, aa_tmp.data(), aStride, res, resStride, alpha, gemm_blocking, 0); \
+       general_matrix_matrix_product<Index,EIGTYPE,LhsStorageOrder,ConjugateLhs,EIGTYPE,RhsStorageOrder,ConjugateRhs,ColMajor,1>::run( \
+       rows, cols, depth, _lhs, lhsStride, aa_tmp.data(), aStride, res, 1, resStride, alpha, gemm_blocking, 0); \
 \
      /*std::cout << "TRMM_R: A is not square! Go to BLAS GEMM implementation! " << nthr<<" \n";*/ \
      } \
      return; \
    } \
    char side = 'R', transa, uplo, diag = 'N'; \
    EIGTYPE *b; \
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/TriangularMatrixVector.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/TriangularMatrixVector.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/TriangularMatrixVector_BLAS.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/TriangularSolverMatrix.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/TriangularSolverMatrix.h`

 * *Files 7% similar despite different names*

```diff
@@ -11,56 +11,56 @@
 #define EIGEN_TRIANGULAR_SOLVER_MATRIX_H
 
 namespace Eigen { 
 
 namespace internal {
 
 // if the rhs is row major, let's transpose the product
-template <typename Scalar, typename Index, int Side, int Mode, bool Conjugate, int TriStorageOrder>
-struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>
+template <typename Scalar, typename Index, int Side, int Mode, bool Conjugate, int TriStorageOrder, int OtherInnerStride>
+struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor,OtherInnerStride>
 {
   static void run(
     Index size, Index cols,
     const Scalar*  tri, Index triStride,
-    Scalar* _other, Index otherStride,
+    Scalar* _other, Index otherIncr, Index otherStride,
     level3_blocking<Scalar,Scalar>& blocking)
   {
     triangular_solve_matrix<
       Scalar, Index, Side==OnTheLeft?OnTheRight:OnTheLeft,
       (Mode&UnitDiag) | ((Mode&Upper) ? Lower : Upper),
       NumTraits<Scalar>::IsComplex && Conjugate,
-      TriStorageOrder==RowMajor ? ColMajor : RowMajor, ColMajor>
-      ::run(size, cols, tri, triStride, _other, otherStride, blocking);
+      TriStorageOrder==RowMajor ? ColMajor : RowMajor, ColMajor, OtherInnerStride>
+      ::run(size, cols, tri, triStride, _other, otherIncr, otherStride, blocking);
   }
 };
 
 /* Optimized triangular solver with multiple right hand side and the triangular matrix on the left
  */
-template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder>
-struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>
+template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder,int OtherInnerStride>
+struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor,OtherInnerStride>
 {
   static EIGEN_DONT_INLINE void run(
     Index size, Index otherSize,
     const Scalar* _tri, Index triStride,
-    Scalar* _other, Index otherStride,
+    Scalar* _other, Index otherIncr, Index otherStride,
     level3_blocking<Scalar,Scalar>& blocking);
 };
-template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder>
-EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>::run(
+template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder, int OtherInnerStride>
+EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor,OtherInnerStride>::run(
     Index size, Index otherSize,
     const Scalar* _tri, Index triStride,
-    Scalar* _other, Index otherStride,
+    Scalar* _other, Index otherIncr, Index otherStride,
     level3_blocking<Scalar,Scalar>& blocking)
   {
     Index cols = otherSize;
 
     typedef const_blas_data_mapper<Scalar, Index, TriStorageOrder> TriMapper;
-    typedef blas_data_mapper<Scalar, Index, ColMajor> OtherMapper;
+    typedef blas_data_mapper<Scalar, Index, ColMajor, Unaligned, OtherInnerStride> OtherMapper;
     TriMapper tri(_tri, triStride);
-    OtherMapper other(_other, otherStride);
+    OtherMapper other(_other, otherStride, otherIncr);
 
     typedef gebp_traits<Scalar,Scalar> Traits;
 
     enum {
       SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),
       IsLower = (Mode&Lower) == Lower
     };
@@ -72,15 +72,15 @@
     std::size_t sizeB = kc*cols;
 
     ei_declare_aligned_stack_constructed_variable(Scalar, blockA, sizeA, blocking.blockA());
     ei_declare_aligned_stack_constructed_variable(Scalar, blockB, sizeB, blocking.blockB());
 
     conj_if<Conjugate> conj;
     gebp_kernel<Scalar, Scalar, Index, OtherMapper, Traits::mr, Traits::nr, Conjugate, false> gebp_kernel;
-    gemm_pack_lhs<Scalar, Index, TriMapper, Traits::mr, Traits::LhsProgress, TriStorageOrder> pack_lhs;
+    gemm_pack_lhs<Scalar, Index, TriMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, TriStorageOrder> pack_lhs;
     gemm_pack_rhs<Scalar, Index, OtherMapper, Traits::nr, ColMajor, false, true> pack_rhs;
 
     // the goal here is to subdivise the Rhs panels such that we keep some cache
     // coherence when accessing the rhs elements
     std::ptrdiff_t l1, l2, l3;
     manage_caching_sizes(GetAction, &l1, &l2, &l3);
     Index subcols = cols>0 ? l2/(4 * sizeof(Scalar) * std::max<Index>(otherStride,size)) : 0;
@@ -124,27 +124,29 @@
             Scalar a = (Mode & UnitDiag) ? Scalar(1) : Scalar(1)/conj(tri(i,i));
             for (Index j=j2; j<j2+actual_cols; ++j)
             {
               if (TriStorageOrder==RowMajor)
               {
                 Scalar b(0);
                 const Scalar* l = &tri(i,s);
-                Scalar* r = &other(s,j);
+                typename OtherMapper::LinearMapper r = other.getLinearMapper(s,j);
                 for (Index i3=0; i3<k; ++i3)
-                  b += conj(l[i3]) * r[i3];
+                  b += conj(l[i3]) * r(i3);
 
                 other(i,j) = (other(i,j) - b)*a;
               }
               else
               {
-                Scalar b = (other(i,j) *= a);
-                Scalar* r = &other(s,j);
-                const Scalar* l = &tri(s,i);
+                Scalar& otherij = other(i,j);
+                otherij *= a;
+                Scalar b = otherij;
+                typename OtherMapper::LinearMapper r = other.getLinearMapper(s,j);
+                typename TriMapper::LinearMapper l = tri.getLinearMapper(s,i);
                 for (Index i3=0;i3<rs;++i3)
-                  r[i3] -= b * conj(l[i3]);
+                  r(i3) -= b * conj(l(i3));
               }
             }
           }
 
           Index lengthTarget = actual_kc-k1-actualPanelWidth;
           Index startBlock   = IsLower ? k2+k1 : k2-k1-actualPanelWidth;
           Index blockBOffset = IsLower ? k1 : lengthTarget;
@@ -181,36 +183,36 @@
         }
       }
     }
   }
 
 /* Optimized triangular solver with multiple left hand sides and the triangular matrix on the right
  */
-template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder>
-struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>
+template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder, int OtherInnerStride>
+struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor,OtherInnerStride>
 {
   static EIGEN_DONT_INLINE void run(
     Index size, Index otherSize,
     const Scalar* _tri, Index triStride,
-    Scalar* _other, Index otherStride,
+    Scalar* _other, Index otherIncr, Index otherStride,
     level3_blocking<Scalar,Scalar>& blocking);
 };
-template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder>
-EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>::run(
+template <typename Scalar, typename Index, int Mode, bool Conjugate, int TriStorageOrder, int OtherInnerStride>
+EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor,OtherInnerStride>::run(
     Index size, Index otherSize,
     const Scalar* _tri, Index triStride,
-    Scalar* _other, Index otherStride,
+    Scalar* _other, Index otherIncr, Index otherStride,
     level3_blocking<Scalar,Scalar>& blocking)
   {
     Index rows = otherSize;
     typedef typename NumTraits<Scalar>::Real RealScalar;
 
-    typedef blas_data_mapper<Scalar, Index, ColMajor> LhsMapper;
+    typedef blas_data_mapper<Scalar, Index, ColMajor, Unaligned, OtherInnerStride> LhsMapper;
     typedef const_blas_data_mapper<Scalar, Index, TriStorageOrder> RhsMapper;
-    LhsMapper lhs(_other, otherStride);
+    LhsMapper lhs(_other, otherStride, otherIncr);
     RhsMapper rhs(_tri, triStride);
 
     typedef gebp_traits<Scalar,Scalar> Traits;
     enum {
       RhsStorageOrder   = TriStorageOrder,
       SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),
       IsLower = (Mode&Lower) == Lower
@@ -225,15 +227,15 @@
     ei_declare_aligned_stack_constructed_variable(Scalar, blockA, sizeA, blocking.blockA());
     ei_declare_aligned_stack_constructed_variable(Scalar, blockB, sizeB, blocking.blockB());
 
     conj_if<Conjugate> conj;
     gebp_kernel<Scalar, Scalar, Index, LhsMapper, Traits::mr, Traits::nr, false, Conjugate> gebp_kernel;
     gemm_pack_rhs<Scalar, Index, RhsMapper, Traits::nr, RhsStorageOrder> pack_rhs;
     gemm_pack_rhs<Scalar, Index, RhsMapper, Traits::nr, RhsStorageOrder,false,true> pack_rhs_panel;
-    gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, ColMajor, false, true> pack_lhs_panel;
+    gemm_pack_lhs<Scalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, ColMajor, false, true> pack_lhs_panel;
 
     for(Index k2=IsLower ? size : 0;
         IsLower ? k2>0 : k2<size;
         IsLower ? k2-=kc : k2+=kc)
     {
       const Index actual_kc = (std::min)(IsLower ? k2 : size-k2, kc);
       Index actual_k2 = IsLower ? k2-actual_kc : k2 ;
@@ -293,32 +295,32 @@
             }
 
             // unblocked triangular solve
             for (Index k=0; k<actualPanelWidth; ++k)
             {
               Index j = IsLower ? absolute_j2+actualPanelWidth-k-1 : absolute_j2+k;
 
-              Scalar* r = &lhs(i2,j);
+              typename LhsMapper::LinearMapper r = lhs.getLinearMapper(i2,j);
               for (Index k3=0; k3<k; ++k3)
               {
                 Scalar b = conj(rhs(IsLower ? j+1+k3 : absolute_j2+k3,j));
-                Scalar* a = &lhs(i2,IsLower ? j+1+k3 : absolute_j2+k3);
+                typename LhsMapper::LinearMapper a = lhs.getLinearMapper(i2,IsLower ? j+1+k3 : absolute_j2+k3);
                 for (Index i=0; i<actual_mc; ++i)
-                  r[i] -= a[i] * b;
+                  r(i) -= a(i) * b;
               }
               if((Mode & UnitDiag)==0)
               {
                 Scalar inv_rjj = RealScalar(1)/conj(rhs(j,j));
                 for (Index i=0; i<actual_mc; ++i)
-                  r[i] *= inv_rjj;
+                  r(i) *= inv_rjj;
               }
             }
 
             // pack the just computed part of lhs to A
-            pack_lhs_panel(blockA, LhsMapper(_other+absolute_j2*otherStride+i2, otherStride),
+            pack_lhs_panel(blockA, lhs.getSubMapper(i2,absolute_j2),
                            actualPanelWidth, actual_mc,
                            actual_kc, j2);
           }
         }
 
         if (rs>0)
           gebp_kernel(lhs.getSubMapper(i2, startPanel), blockA, geb,
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/TriangularSolverMatrix_BLAS.h`

 * *Files 3% similar despite different names*

```diff
@@ -36,27 +36,29 @@
 namespace Eigen {
 
 namespace internal {
 
 // implements LeftSide op(triangular)^-1 * general
 #define EIGEN_BLAS_TRSM_L(EIGTYPE, BLASTYPE, BLASFUNC) \
 template <typename Index, int Mode, bool Conjugate, int TriStorageOrder> \
-struct triangular_solve_matrix<EIGTYPE,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor> \
+struct triangular_solve_matrix<EIGTYPE,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor,1> \
 { \
   enum { \
     IsLower = (Mode&Lower) == Lower, \
     IsUnitDiag  = (Mode&UnitDiag) ? 1 : 0, \
     IsZeroDiag  = (Mode&ZeroDiag) ? 1 : 0, \
     conjA = ((TriStorageOrder==ColMajor) && Conjugate) ? 1 : 0 \
   }; \
   static void run( \
       Index size, Index otherSize, \
       const EIGTYPE* _tri, Index triStride, \
-      EIGTYPE* _other, Index otherStride, level3_blocking<EIGTYPE,EIGTYPE>& /*blocking*/) \
+      EIGTYPE* _other, Index otherIncr, Index otherStride, level3_blocking<EIGTYPE,EIGTYPE>& /*blocking*/) \
   { \
+   EIGEN_ONLY_USED_FOR_DEBUG(otherIncr); \
+   eigen_assert(otherIncr == 1); \
    BlasIndex m = convert_index<BlasIndex>(size), n = convert_index<BlasIndex>(otherSize), lda, ldb; \
    char side = 'L', uplo, diag='N', transa; \
    /* Set alpha_ */ \
    EIGTYPE alpha(1); \
    ldb = convert_index<BlasIndex>(otherStride);\
 \
    const EIGTYPE *a; \
@@ -95,27 +97,29 @@
 EIGEN_BLAS_TRSM_L(float,    float,  strsm_)
 EIGEN_BLAS_TRSM_L(scomplex, float,  ctrsm_)
 #endif
 
 // implements RightSide general * op(triangular)^-1
 #define EIGEN_BLAS_TRSM_R(EIGTYPE, BLASTYPE, BLASFUNC) \
 template <typename Index, int Mode, bool Conjugate, int TriStorageOrder> \
-struct triangular_solve_matrix<EIGTYPE,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor> \
+struct triangular_solve_matrix<EIGTYPE,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor,1> \
 { \
   enum { \
     IsLower = (Mode&Lower) == Lower, \
     IsUnitDiag  = (Mode&UnitDiag) ? 1 : 0, \
     IsZeroDiag  = (Mode&ZeroDiag) ? 1 : 0, \
     conjA = ((TriStorageOrder==ColMajor) && Conjugate) ? 1 : 0 \
   }; \
   static void run( \
       Index size, Index otherSize, \
       const EIGTYPE* _tri, Index triStride, \
-      EIGTYPE* _other, Index otherStride, level3_blocking<EIGTYPE,EIGTYPE>& /*blocking*/) \
+      EIGTYPE* _other, Index otherIncr, Index otherStride, level3_blocking<EIGTYPE,EIGTYPE>& /*blocking*/) \
   { \
+   EIGEN_ONLY_USED_FOR_DEBUG(otherIncr); \
+   eigen_assert(otherIncr == 1); \
    BlasIndex m = convert_index<BlasIndex>(otherSize), n = convert_index<BlasIndex>(size), lda, ldb; \
    char side = 'R', uplo, diag='N', transa; \
    /* Set alpha_ */ \
    EIGTYPE alpha(1); \
    ldb = convert_index<BlasIndex>(otherStride);\
 \
    const EIGTYPE *a; \
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/products/TriangularSolverVector.h` & `chronogram-0.2.0/include/Eigen/src/Core/products/TriangularSolverVector.h`

 * *Files 4% similar despite different names*

```diff
@@ -54,15 +54,15 @@
       Index actualPanelWidth = (std::min)(IsLower ? size - pi : pi, PanelWidth);
 
       Index r = IsLower ? pi : size - pi; // remaining size
       if (r > 0)
       {
         // let's directly call the low level product function because:
         // 1 - it is faster to compile
-        // 2 - it is slighlty faster at runtime
+        // 2 - it is slightly faster at runtime
         Index startRow = IsLower ? pi : pi-actualPanelWidth;
         Index startCol = IsLower ? 0 : pi;
 
         general_matrix_vector_product<Index,LhsScalar,LhsMapper,RowMajor,Conjugate,RhsScalar,RhsMapper,false>::run(
           actualPanelWidth, r,
           LhsMapper(&lhs.coeffRef(startRow,startCol), lhsStride),
           RhsMapper(rhs + startCol, 1),
@@ -73,15 +73,15 @@
       for(Index k=0; k<actualPanelWidth; ++k)
       {
         Index i = IsLower ? pi+k : pi-k-1;
         Index s = IsLower ? pi   : i+1;
         if (k>0)
           rhs[i] -= (cjLhs.row(i).segment(s,k).transpose().cwiseProduct(Map<const Matrix<RhsScalar,Dynamic,1> >(rhs+s,k))).sum();
 
-        if(!(Mode & UnitDiag))
+        if((!(Mode & UnitDiag)) && numext::not_equal_strict(rhs[i],RhsScalar(0)))
           rhs[i] /= cjLhs(i,i);
       }
     }
   }
 };
 
 // forward and backward substitution, column-major, rhs is a vector
@@ -110,28 +110,31 @@
       Index actualPanelWidth = (std::min)(IsLower ? size - pi : pi, PanelWidth);
       Index startBlock = IsLower ? pi : pi-actualPanelWidth;
       Index endBlock = IsLower ? pi + actualPanelWidth : 0;
 
       for(Index k=0; k<actualPanelWidth; ++k)
       {
         Index i = IsLower ? pi+k : pi-k-1;
-        if(!(Mode & UnitDiag))
-          rhs[i] /= cjLhs.coeff(i,i);
-
-        Index r = actualPanelWidth - k - 1; // remaining size
-        Index s = IsLower ? i+1 : i-r;
-        if (r>0)
-          Map<Matrix<RhsScalar,Dynamic,1> >(rhs+s,r) -= rhs[i] * cjLhs.col(i).segment(s,r);
+        if(numext::not_equal_strict(rhs[i],RhsScalar(0)))
+        {
+          if(!(Mode & UnitDiag))
+            rhs[i] /= cjLhs.coeff(i,i);
+
+          Index r = actualPanelWidth - k - 1; // remaining size
+          Index s = IsLower ? i+1 : i-r;
+          if (r>0)
+            Map<Matrix<RhsScalar,Dynamic,1> >(rhs+s,r) -= rhs[i] * cjLhs.col(i).segment(s,r);
+        }
       }
       Index r = IsLower ? size - endBlock : startBlock; // remaining size
       if (r > 0)
       {
         // let's directly call the low level product function because:
         // 1 - it is faster to compile
-        // 2 - it is slighlty faster at runtime
+        // 2 - it is slightly faster at runtime
         general_matrix_vector_product<Index,LhsScalar,LhsMapper,ColMajor,Conjugate,RhsScalar,RhsMapper,false>::run(
             r, actualPanelWidth,
             LhsMapper(&lhs.coeffRef(endBlock,startBlock), lhsStride),
             RhsMapper(rhs+startBlock, 1),
             rhs+endBlock, 1, RhsScalar(-1));
       }
     }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/BlasUtil.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/BlasUtil.h`

 * *Files 26% similar despite different names*

```diff
@@ -20,113 +20,29 @@
 // forward declarations
 template<typename LhsScalar, typename RhsScalar, typename Index, typename DataMapper, int mr, int nr, bool ConjugateLhs=false, bool ConjugateRhs=false>
 struct gebp_kernel;
 
 template<typename Scalar, typename Index, typename DataMapper, int nr, int StorageOrder, bool Conjugate = false, bool PanelMode=false>
 struct gemm_pack_rhs;
 
-template<typename Scalar, typename Index, typename DataMapper, int Pack1, int Pack2, int StorageOrder, bool Conjugate = false, bool PanelMode = false>
+template<typename Scalar, typename Index, typename DataMapper, int Pack1, int Pack2, typename Packet, int StorageOrder, bool Conjugate = false, bool PanelMode = false>
 struct gemm_pack_lhs;
 
 template<
   typename Index,
   typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,
   typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,
-  int ResStorageOrder>
+  int ResStorageOrder, int ResInnerStride>
 struct general_matrix_matrix_product;
 
 template<typename Index,
          typename LhsScalar, typename LhsMapper, int LhsStorageOrder, bool ConjugateLhs,
          typename RhsScalar, typename RhsMapper, bool ConjugateRhs, int Version=Specialized>
 struct general_matrix_vector_product;
 
-
-template<bool Conjugate> struct conj_if;
-
-template<> struct conj_if<true> {
-  template<typename T>
-  inline T operator()(const T& x) const { return numext::conj(x); }
-  template<typename T>
-  inline T pconj(const T& x) const { return internal::pconj(x); }
-};
-
-template<> struct conj_if<false> {
-  template<typename T>
-  inline const T& operator()(const T& x) const { return x; }
-  template<typename T>
-  inline const T& pconj(const T& x) const { return x; }
-};
-
-// Generic implementation for custom complex types.
-template<typename LhsScalar, typename RhsScalar, bool ConjLhs, bool ConjRhs>
-struct conj_helper
-{
-  typedef typename ScalarBinaryOpTraits<LhsScalar,RhsScalar>::ReturnType Scalar;
-
-  EIGEN_STRONG_INLINE Scalar pmadd(const LhsScalar& x, const RhsScalar& y, const Scalar& c) const
-  { return padd(c, pmul(x,y)); }
-
-  EIGEN_STRONG_INLINE Scalar pmul(const LhsScalar& x, const RhsScalar& y) const
-  { return conj_if<ConjLhs>()(x) *  conj_if<ConjRhs>()(y); }
-};
-
-template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>
-{
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }
-  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }
-};
-
-template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>
-{
-  typedef std::complex<RealScalar> Scalar;
-  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const
-  { return c + pmul(x,y); }
-
-  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const
-  { return Scalar(numext::real(x)*numext::real(y) + numext::imag(x)*numext::imag(y), numext::imag(x)*numext::real(y) - numext::real(x)*numext::imag(y)); }
-};
-
-template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>
-{
-  typedef std::complex<RealScalar> Scalar;
-  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const
-  { return c + pmul(x,y); }
-
-  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const
-  { return Scalar(numext::real(x)*numext::real(y) + numext::imag(x)*numext::imag(y), numext::real(x)*numext::imag(y) - numext::imag(x)*numext::real(y)); }
-};
-
-template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>
-{
-  typedef std::complex<RealScalar> Scalar;
-  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const
-  { return c + pmul(x,y); }
-
-  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const
-  { return Scalar(numext::real(x)*numext::real(y) - numext::imag(x)*numext::imag(y), - numext::real(x)*numext::imag(y) - numext::imag(x)*numext::real(y)); }
-};
-
-template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>
-{
-  typedef std::complex<RealScalar> Scalar;
-  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const
-  { return padd(c, pmul(x,y)); }
-  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const
-  { return conj_if<Conj>()(x)*y; }
-};
-
-template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>
-{
-  typedef std::complex<RealScalar> Scalar;
-  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const
-  { return padd(c, pmul(x,y)); }
-  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const
-  { return x*conj_if<Conj>()(y); }
-};
-
 template<typename From,typename To> struct get_factor {
   EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE To run(const From& x) { return To(x); }
 };
 
 template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {
   EIGEN_DEVICE_FUNC
   static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return numext::real(x); }
@@ -151,57 +67,116 @@
     return (UIntPtr(m_data+i)%sizeof(Packet))==0;
   }
 
   protected:
   Scalar* m_data;
 };
 
-template<typename Scalar, typename Index, int AlignmentType>
-class BlasLinearMapper {
-  public:
-  typedef typename packet_traits<Scalar>::type Packet;
-  typedef typename packet_traits<Scalar>::half HalfPacket;
+template<typename Scalar, typename Index, int AlignmentType, int Incr=1>
+class BlasLinearMapper;
 
-  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasLinearMapper(Scalar *data) : m_data(data) {}
+template<typename Scalar, typename Index, int AlignmentType>
+class BlasLinearMapper<Scalar,Index,AlignmentType>
+{
+public:
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasLinearMapper(Scalar *data, Index incr=1)
+    : m_data(data)
+  {
+    EIGEN_ONLY_USED_FOR_DEBUG(incr);
+    eigen_assert(incr==1);
+  }
 
   EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void prefetch(int i) const {
     internal::prefetch(&operator()(i));
   }
 
   EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar& operator()(Index i) const {
     return m_data[i];
   }
 
-  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet loadPacket(Index i) const {
-    return ploadt<Packet, AlignmentType>(m_data + i);
-  }
-
-  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE HalfPacket loadHalfPacket(Index i) const {
-    return ploadt<HalfPacket, AlignmentType>(m_data + i);
+  template<typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketType loadPacket(Index i) const {
+    return ploadt<PacketType, AlignmentType>(m_data + i);
   }
 
-  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacket(Index i, const Packet &p) const {
-    pstoret<Scalar, Packet, AlignmentType>(m_data + i, p);
+  template<typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacket(Index i, const PacketType &p) const {
+    pstoret<Scalar, PacketType, AlignmentType>(m_data + i, p);
   }
 
-  protected:
+protected:
   Scalar *m_data;
 };
 
 // Lightweight helper class to access matrix coefficients.
-template<typename Scalar, typename Index, int StorageOrder, int AlignmentType = Unaligned>
-class blas_data_mapper {
-  public:
-  typedef typename packet_traits<Scalar>::type Packet;
-  typedef typename packet_traits<Scalar>::half HalfPacket;
+template<typename Scalar, typename Index, int StorageOrder, int AlignmentType = Unaligned, int Incr = 1>
+class blas_data_mapper;
+
+// TMP to help PacketBlock store implementation.
+// There's currently no known use case for PacketBlock load.
+// The default implementation assumes ColMajor order.
+// It always store each packet sequentially one `stride` apart.
+template<typename Index, typename Scalar, typename Packet, int n, int idx, int StorageOrder>
+struct PacketBlockManagement
+{
+  PacketBlockManagement<Index, Scalar, Packet, n, idx - 1, StorageOrder> pbm;
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(Scalar *to, const Index stride, Index i, Index j, const PacketBlock<Packet, n> &block) const {
+    pbm.store(to, stride, i, j, block);
+    pstoreu<Scalar>(to + i + (j + idx)*stride, block.packet[idx]);
+  }
+};
+
+// PacketBlockManagement specialization to take care of RowMajor order without ifs.
+template<typename Index, typename Scalar, typename Packet, int n, int idx>
+struct PacketBlockManagement<Index, Scalar, Packet, n, idx, RowMajor>
+{
+  PacketBlockManagement<Index, Scalar, Packet, n, idx - 1, RowMajor> pbm;
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(Scalar *to, const Index stride, Index i, Index j, const PacketBlock<Packet, n> &block) const {
+    pbm.store(to, stride, i, j, block);
+    pstoreu<Scalar>(to + j + (i + idx)*stride, block.packet[idx]);
+  }
+};
 
+template<typename Index, typename Scalar, typename Packet, int n, int StorageOrder>
+struct PacketBlockManagement<Index, Scalar, Packet, n, -1, StorageOrder>
+{
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(Scalar *to, const Index stride, Index i, Index j, const PacketBlock<Packet, n> &block) const {
+    EIGEN_UNUSED_VARIABLE(to);
+    EIGEN_UNUSED_VARIABLE(stride);
+    EIGEN_UNUSED_VARIABLE(i);
+    EIGEN_UNUSED_VARIABLE(j);
+    EIGEN_UNUSED_VARIABLE(block);
+  }
+};
+
+template<typename Index, typename Scalar, typename Packet, int n>
+struct PacketBlockManagement<Index, Scalar, Packet, n, -1, RowMajor>
+{
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(Scalar *to, const Index stride, Index i, Index j, const PacketBlock<Packet, n> &block) const {
+    EIGEN_UNUSED_VARIABLE(to);
+    EIGEN_UNUSED_VARIABLE(stride);
+    EIGEN_UNUSED_VARIABLE(i);
+    EIGEN_UNUSED_VARIABLE(j);
+    EIGEN_UNUSED_VARIABLE(block);
+  }
+};
+
+template<typename Scalar, typename Index, int StorageOrder, int AlignmentType>
+class blas_data_mapper<Scalar,Index,StorageOrder,AlignmentType,1>
+{
+public:
   typedef BlasLinearMapper<Scalar, Index, AlignmentType> LinearMapper;
   typedef BlasVectorMapper<Scalar, Index> VectorMapper;
 
-  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE blas_data_mapper(Scalar* data, Index stride, Index incr=1)
+   : m_data(data), m_stride(stride)
+  {
+    EIGEN_ONLY_USED_FOR_DEBUG(incr);
+    eigen_assert(incr==1);
+  }
 
   EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType>
   getSubMapper(Index i, Index j) const {
     return blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType>(&operator()(i, j), m_stride);
   }
 
   EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE LinearMapper getLinearMapper(Index i, Index j) const {
@@ -214,20 +189,22 @@
 
 
   EIGEN_DEVICE_FUNC
   EIGEN_ALWAYS_INLINE Scalar& operator()(Index i, Index j) const {
     return m_data[StorageOrder==RowMajor ? j + i*m_stride : i + j*m_stride];
   }
 
-  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet loadPacket(Index i, Index j) const {
-    return ploadt<Packet, AlignmentType>(&operator()(i, j));
+  template<typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketType loadPacket(Index i, Index j) const {
+    return ploadt<PacketType, AlignmentType>(&operator()(i, j));
   }
 
-  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE HalfPacket loadHalfPacket(Index i, Index j) const {
-    return ploadt<HalfPacket, AlignmentType>(&operator()(i, j));
+  template <typename PacketT, int AlignmentT>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketT load(Index i, Index j) const {
+    return ploadt<PacketT, AlignmentT>(&operator()(i, j));
   }
 
   template<typename SubPacket>
   EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void scatterPacket(Index i, Index j, const SubPacket &p) const {
     pscatter<Scalar, SubPacket>(&operator()(i, j), p, m_stride);
   }
 
@@ -242,17 +219,173 @@
   EIGEN_DEVICE_FUNC Index firstAligned(Index size) const {
     if (UIntPtr(m_data)%sizeof(Scalar)) {
       return -1;
     }
     return internal::first_default_aligned(m_data, size);
   }
 
-  protected:
+  template<typename SubPacket, int n>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacketBlock(Index i, Index j, const PacketBlock<SubPacket, n> &block) const {
+    PacketBlockManagement<Index, Scalar, SubPacket, n, n-1, StorageOrder> pbm;
+    pbm.store(m_data, m_stride, i, j, block);
+  }
+protected:
+  Scalar* EIGEN_RESTRICT m_data;
+  const Index m_stride;
+};
+
+// Implementation of non-natural increment (i.e. inner-stride != 1)
+// The exposed API is not complete yet compared to the Incr==1 case
+// because some features makes less sense in this case.
+template<typename Scalar, typename Index, int AlignmentType, int Incr>
+class BlasLinearMapper
+{
+public:
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasLinearMapper(Scalar *data,Index incr) : m_data(data), m_incr(incr) {}
+
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void prefetch(int i) const {
+    internal::prefetch(&operator()(i));
+  }
+
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar& operator()(Index i) const {
+    return m_data[i*m_incr.value()];
+  }
+
+  template<typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketType loadPacket(Index i) const {
+    return pgather<Scalar,PacketType>(m_data + i*m_incr.value(), m_incr.value());
+  }
+
+  template<typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacket(Index i, const PacketType &p) const {
+    pscatter<Scalar, PacketType>(m_data + i*m_incr.value(), p, m_incr.value());
+  }
+
+protected:
+  Scalar *m_data;
+  const internal::variable_if_dynamic<Index,Incr> m_incr;
+};
+
+template<typename Scalar, typename Index, int StorageOrder, int AlignmentType,int Incr>
+class blas_data_mapper
+{
+public:
+  typedef BlasLinearMapper<Scalar, Index, AlignmentType,Incr> LinearMapper;
+
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE blas_data_mapper(Scalar* data, Index stride, Index incr) : m_data(data), m_stride(stride), m_incr(incr) {}
+
+  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE blas_data_mapper
+  getSubMapper(Index i, Index j) const {
+    return blas_data_mapper(&operator()(i, j), m_stride, m_incr.value());
+  }
+
+  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE LinearMapper getLinearMapper(Index i, Index j) const {
+    return LinearMapper(&operator()(i, j), m_incr.value());
+  }
+
+  EIGEN_DEVICE_FUNC
+  EIGEN_ALWAYS_INLINE Scalar& operator()(Index i, Index j) const {
+    return m_data[StorageOrder==RowMajor ? j*m_incr.value() + i*m_stride : i*m_incr.value() + j*m_stride];
+  }
+
+  template<typename PacketType>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketType loadPacket(Index i, Index j) const {
+    return pgather<Scalar,PacketType>(&operator()(i, j),m_incr.value());
+  }
+
+  template <typename PacketT, int AlignmentT>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketT load(Index i, Index j) const {
+    return pgather<Scalar,PacketT>(&operator()(i, j),m_incr.value());
+  }
+
+  template<typename SubPacket>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void scatterPacket(Index i, Index j, const SubPacket &p) const {
+    pscatter<Scalar, SubPacket>(&operator()(i, j), p, m_stride);
+  }
+
+  template<typename SubPacket>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE SubPacket gatherPacket(Index i, Index j) const {
+    return pgather<Scalar, SubPacket>(&operator()(i, j), m_stride);
+  }
+
+  // storePacketBlock_helper defines a way to access values inside the PacketBlock, this is essentially required by the Complex types.
+  template<typename SubPacket, typename ScalarT, int n, int idx>
+  struct storePacketBlock_helper
+  {
+    storePacketBlock_helper<SubPacket, ScalarT, n, idx-1> spbh;
+    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>* sup, Index i, Index j, const PacketBlock<SubPacket, n>& block) const {
+      spbh.store(sup, i,j,block);
+      for(int l = 0; l < unpacket_traits<SubPacket>::size; l++)
+      {
+        ScalarT *v = &sup->operator()(i+l, j+idx);
+        *v = block.packet[idx][l];
+      }
+    }
+  };
+
+  template<typename SubPacket, int n, int idx>
+  struct storePacketBlock_helper<SubPacket, std::complex<float>, n, idx>
+  {
+    storePacketBlock_helper<SubPacket, std::complex<float>, n, idx-1> spbh;
+    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>* sup, Index i, Index j, const PacketBlock<SubPacket, n>& block) const {
+      spbh.store(sup,i,j,block);
+      for(int l = 0; l < unpacket_traits<SubPacket>::size; l++)
+      {
+        std::complex<float> *v = &sup->operator()(i+l, j+idx);
+        v->real(block.packet[idx].v[2*l+0]);
+        v->imag(block.packet[idx].v[2*l+1]);
+      }
+    }
+  };
+
+  template<typename SubPacket, int n, int idx>
+  struct storePacketBlock_helper<SubPacket, std::complex<double>, n, idx>
+  {
+    storePacketBlock_helper<SubPacket, std::complex<double>, n, idx-1> spbh;
+    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>* sup, Index i, Index j, const PacketBlock<SubPacket, n>& block) const {
+      spbh.store(sup,i,j,block);
+      for(int l = 0; l < unpacket_traits<SubPacket>::size; l++)
+      {
+        std::complex<double> *v = &sup->operator()(i+l, j+idx);
+        v->real(block.packet[idx].v[2*l+0]);
+        v->imag(block.packet[idx].v[2*l+1]);
+      }
+    }
+  };
+
+  template<typename SubPacket, typename ScalarT, int n>
+  struct storePacketBlock_helper<SubPacket, ScalarT, n, -1>
+  {
+    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>*, Index, Index, const PacketBlock<SubPacket, n>& ) const {
+    }
+  };
+
+  template<typename SubPacket, int n>
+  struct storePacketBlock_helper<SubPacket, std::complex<float>, n, -1>
+  {
+    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>*, Index, Index, const PacketBlock<SubPacket, n>& ) const {
+    }
+  };
+
+  template<typename SubPacket, int n>
+  struct storePacketBlock_helper<SubPacket, std::complex<double>, n, -1>
+  {
+    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>*, Index, Index, const PacketBlock<SubPacket, n>& ) const {
+    }
+  };
+  // This function stores a PacketBlock on m_data, this approach is really quite slow compare to Incr=1 and should be avoided when possible.
+  template<typename SubPacket, int n>
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacketBlock(Index i, Index j, const PacketBlock<SubPacket, n>&block) const {
+    storePacketBlock_helper<SubPacket, Scalar, n, n-1> spb;
+    spb.store(this, i,j,block);
+  }
+protected:
   Scalar* EIGEN_RESTRICT m_data;
   const Index m_stride;
+  const internal::variable_if_dynamic<Index,Incr> m_incr;
 };
 
 // lightweight helper class to access matrix coefficients (const version)
 template<typename Scalar, typename Index, int StorageOrder>
 class const_blas_data_mapper : public blas_data_mapper<const Scalar, Index, StorageOrder> {
   public:
   EIGEN_ALWAYS_INLINE const_blas_data_mapper(const Scalar *data, Index stride) : blas_data_mapper<const Scalar, Index, StorageOrder>(data, stride) {}
@@ -274,22 +407,23 @@
   enum {
     IsComplex = NumTraits<Scalar>::IsComplex,
     IsTransposed = false,
     NeedToConjugate = false,
     HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)
                               && (   bool(XprType::IsVectorAtCompileTime)
                                   || int(inner_stride_at_compile_time<XprType>::ret) == 1)
-                             ) ?  1 : 0
+                             ) ?  1 : 0,
+    HasScalarFactor = false
   };
   typedef typename conditional<bool(HasUsableDirectAccess),
     ExtractType,
     typename _ExtractType::PlainObject
     >::type DirectLinearAccessType;
-  static inline ExtractType extract(const XprType& x) { return x; }
-  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }
+  static inline EIGEN_DEVICE_FUNC ExtractType extract(const XprType& x) { return x; }
+  static inline EIGEN_DEVICE_FUNC const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }
 };
 
 // pop conjugate
 template<typename Scalar, typename NestedXpr>
 struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >
  : blas_traits<NestedXpr>
 {
@@ -306,25 +440,31 @@
 };
 
 // pop scalar multiple
 template<typename Scalar, typename NestedXpr, typename Plain>
 struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain>, NestedXpr> >
  : blas_traits<NestedXpr>
 {
+  enum {
+    HasScalarFactor = true
+  };
   typedef blas_traits<NestedXpr> Base;
   typedef CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain>, NestedXpr> XprType;
   typedef typename Base::ExtractType ExtractType;
-  static inline ExtractType extract(const XprType& x) { return Base::extract(x.rhs()); }
-  static inline Scalar extractScalarFactor(const XprType& x)
+  static inline EIGEN_DEVICE_FUNC ExtractType extract(const XprType& x) { return Base::extract(x.rhs()); }
+  static inline EIGEN_DEVICE_FUNC Scalar extractScalarFactor(const XprType& x)
   { return x.lhs().functor().m_other * Base::extractScalarFactor(x.rhs()); }
 };
 template<typename Scalar, typename NestedXpr, typename Plain>
 struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, NestedXpr, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain> > >
  : blas_traits<NestedXpr>
 {
+  enum {
+    HasScalarFactor = true
+  };
   typedef blas_traits<NestedXpr> Base;
   typedef CwiseBinaryOp<scalar_product_op<Scalar>, NestedXpr, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain> > XprType;
   typedef typename Base::ExtractType ExtractType;
   static inline ExtractType extract(const XprType& x) { return Base::extract(x.lhs()); }
   static inline Scalar extractScalarFactor(const XprType& x)
   { return Base::extractScalarFactor(x.lhs()) * x.rhs().functor().m_other; }
 };
@@ -335,14 +475,17 @@
 {};
 
 // pop opposite
 template<typename Scalar, typename NestedXpr>
 struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >
  : blas_traits<NestedXpr>
 {
+  enum {
+    HasScalarFactor = true
+  };
   typedef blas_traits<NestedXpr> Base;
   typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;
   typedef typename Base::ExtractType ExtractType;
   static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }
   static inline Scalar extractScalarFactor(const XprType& x)
   { return - Base::extractScalarFactor(x.nestedExpression()); }
 };
@@ -371,28 +514,70 @@
 template<typename T>
 struct blas_traits<const T>
      : blas_traits<T>
 {};
 
 template<typename T, bool HasUsableDirectAccess=blas_traits<T>::HasUsableDirectAccess>
 struct extract_data_selector {
-  static const typename T::Scalar* run(const T& m)
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static const typename T::Scalar* run(const T& m)
   {
     return blas_traits<T>::extract(m).data();
   }
 };
 
 template<typename T>
 struct extract_data_selector<T,false> {
   static typename T::Scalar* run(const T&) { return 0; }
 };
 
-template<typename T> const typename T::Scalar* extract_data(const T& m)
+template<typename T>
+EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE const typename T::Scalar* extract_data(const T& m)
 {
   return extract_data_selector<T>::run(m);
 }
 
+/**
+ * \c combine_scalar_factors extracts and multiplies factors from GEMM and GEMV products.
+ * There is a specialization for booleans
+ */
+template<typename ResScalar, typename Lhs, typename Rhs>
+struct combine_scalar_factors_impl
+{
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static ResScalar run(const Lhs& lhs, const Rhs& rhs)
+  {
+    return blas_traits<Lhs>::extractScalarFactor(lhs) * blas_traits<Rhs>::extractScalarFactor(rhs);
+  }
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static ResScalar run(const ResScalar& alpha, const Lhs& lhs, const Rhs& rhs)
+  {
+    return alpha * blas_traits<Lhs>::extractScalarFactor(lhs) * blas_traits<Rhs>::extractScalarFactor(rhs);
+  }
+};
+template<typename Lhs, typename Rhs>
+struct combine_scalar_factors_impl<bool, Lhs, Rhs>
+{
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static bool run(const Lhs& lhs, const Rhs& rhs)
+  {
+    return blas_traits<Lhs>::extractScalarFactor(lhs) && blas_traits<Rhs>::extractScalarFactor(rhs);
+  }
+  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static bool run(const bool& alpha, const Lhs& lhs, const Rhs& rhs)
+  {
+    return alpha && blas_traits<Lhs>::extractScalarFactor(lhs) && blas_traits<Rhs>::extractScalarFactor(rhs);
+  }
+};
+
+template<typename ResScalar, typename Lhs, typename Rhs>
+EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE ResScalar combine_scalar_factors(const ResScalar& alpha, const Lhs& lhs, const Rhs& rhs)
+{
+  return combine_scalar_factors_impl<ResScalar,Lhs,Rhs>::run(alpha, lhs, rhs);
+}
+template<typename ResScalar, typename Lhs, typename Rhs>
+EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE ResScalar combine_scalar_factors(const Lhs& lhs, const Rhs& rhs)
+{
+  return combine_scalar_factors_impl<ResScalar,Lhs,Rhs>::run(lhs, rhs);
+}
+
+
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_BLASUTIL_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/Constants.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/Constants.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
 // Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>
 // Copyright (C) 2007-2009 Benoit Jacob <jacob.benoit.1@gmail.com>
+// Copyright (C) 2020, Arm Limited and Contributors
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_CONSTANTS_H
 #define EIGEN_CONSTANTS_H
@@ -21,14 +22,18 @@
 const int Dynamic = -1;
 
 /** This value means that a signed quantity (e.g., a signed index) is not known at compile-time, and that instead its value
   * has to be specified at runtime.
   */
 const int DynamicIndex = 0xffffff;
 
+/** This value means that the increment to go from one value to another in a sequence is not constant for each step.
+  */
+const int UndefinedIncr = 0xfffffe;
+
 /** This value means +Infinity; it is currently used only as the p parameter to MatrixBase::lpNorm<int>().
   * The value Infinity there means the L-infinity norm.
   */
 const int Infinity = -1;
 
 /** This value means that the cost to evaluate an expression coefficient is either very expensive or
   * cannot be known at compile time.
@@ -148,15 +153,15 @@
   * See the comment on LvalueBit for an explanation of how LvalueBit and DirectAccessBit are mutually orthogonal.
   */
 const unsigned int DirectAccessBit = 0x40;
 
 /** \deprecated \ingroup flags
   *
   * means the first coefficient packet is guaranteed to be aligned.
-  * An expression cannot has the AlignedBit without the PacketAccessBit flag.
+  * An expression cannot have the AlignedBit without the PacketAccessBit flag.
   * In other words, this means we are allow to perform an aligned packet access to the first element regardless
   * of the expression kind:
   * \code
   * expression.packet<Aligned>(0);
   * \endcode
   */
 EIGEN_DEPRECATED const unsigned int AlignedBit = 0x80;
@@ -247,20 +252,14 @@
   AlignedMax = Unaligned
 #else
 #error Invalid value for EIGEN_MAX_ALIGN_BYTES
 #endif
 };
 
 /** \ingroup enums
- * Enum used by DenseBase::corner() in Eigen2 compatibility mode. */
-// FIXME after the corner() API change, this was not needed anymore, except by AlignedBox
-// TODO: find out what to do with that. Adapt the AlignedBox API ?
-enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };
-
-/** \ingroup enums
   * Enum containing possible values for the \p Direction parameter of
   * Reverse, PartialReduxExpr and VectorwiseOp. */
 enum DirectionType { 
   /** For Reverse, all columns are reversed; 
     * for PartialReduxExpr and VectorwiseOp, act on columns. */
   Vertical, 
   /** For Reverse, all rows are reversed; 
@@ -326,17 +325,28 @@
   DontAlign = 0x2
 };
 
 /** \ingroup enums
   * Enum for specifying whether to apply or solve on the left or right. */
 enum SideType {
   /** Apply transformation on the left. */
-  OnTheLeft = 1,  
+  OnTheLeft = 1,
   /** Apply transformation on the right. */
-  OnTheRight = 2  
+  OnTheRight = 2
+};
+
+/** \ingroup enums
+ * Enum for specifying NaN-propagation behavior, e.g. for coeff-wise min/max. */
+enum NaNPropagationOptions {
+  /**  Implementation defined behavior if NaNs are present. */
+  PropagateFast = 0,
+  /**  Always propagate NaNs. */
+  PropagateNaN,
+  /**  Always propagate not-NaNs. */
+  PropagateNumbers
 };
 
 /* the following used to be written as:
  *
  *   struct NoChange_t {};
  *   namespace {
  *     EIGEN_UNUSED NoChange_t NoChange;
@@ -460,22 +470,28 @@
 {
   enum Type {
     Generic = 0x0,
     SSE = 0x1,
     AltiVec = 0x2,
     VSX = 0x3,
     NEON = 0x4,
+    MSA = 0x5,
+    SVE = 0x6,
 #if defined EIGEN_VECTORIZE_SSE
     Target = SSE
 #elif defined EIGEN_VECTORIZE_ALTIVEC
     Target = AltiVec
 #elif defined EIGEN_VECTORIZE_VSX
     Target = VSX
 #elif defined EIGEN_VECTORIZE_NEON
     Target = NEON
+#elif defined EIGEN_VECTORIZE_SVE
+    Target = SVE
+#elif defined EIGEN_VECTORIZE_MSA
+    Target = MSA
 #else
     Target = Generic
 #endif
   };
 }
 
 /** \internal \ingroup enums
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/DisableStupidWarnings.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/DisableStupidWarnings.h`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 #ifndef EIGEN_WARNINGS_DISABLED
 #define EIGEN_WARNINGS_DISABLED
 
 #ifdef _MSC_VER
   // 4100 - unreferenced formal parameter (occurred e.g. in aligned_allocator::destroy(pointer p))
   // 4101 - unreferenced local variable
-  // 4127 - conditional expression is constant
   // 4181 - qualifier applied to reference type ignored
   // 4211 - nonstandard extension used : redefined extern to static
   // 4244 - 'argument' : conversion from 'type1' to 'type2', possible loss of data
   // 4273 - QtAlignedMalloc, inconsistent DLL linkage
   // 4324 - structure was padded due to declspec(align())
   // 4503 - decorated name length exceeded, name was truncated
   // 4512 - assignment operator could not be generated
@@ -16,15 +15,15 @@
   // 4700 - uninitialized local variable 'xyz' used
   // 4714 - function marked as __forceinline not inlined
   // 4717 - 'function' : recursive on all control paths, function will cause runtime stack overflow
   // 4800 - 'type' : forcing value to bool 'true' or 'false' (performance warning)
   #ifndef EIGEN_PERMANENTLY_DISABLE_STUPID_WARNINGS
     #pragma warning( push )
   #endif
-  #pragma warning( disable : 4100 4101 4127 4181 4211 4244 4273 4324 4503 4512 4522 4700 4714 4717 4800)
+  #pragma warning( disable : 4100 4101 4181 4211 4244 4273 4324 4503 4512 4522 4700 4714 4717 4800)
 
 #elif defined __INTEL_COMPILER
   // 2196 - routine is both "inline" and "noinline" ("noinline" assumed)
   //        ICC 12 generates this warning even without any inline keyword, when defining class methods 'inline' i.e. inside of class body
   //        typedef that may be a reference type.
   // 279  - controlling expression is constant
   //        ICC 12 generates this warning on assert(constant_expression_depending_on_template_params) and frankly this is a legitimate use case.
@@ -38,14 +37,25 @@
 #elif defined __clang__
   // -Wconstant-logical-operand - warning: use of logical && with constant operand; switch to bitwise & or remove constant
   //     this is really a stupid warning as it warns on compile-time expressions involving enums
   #ifndef EIGEN_PERMANENTLY_DISABLE_STUPID_WARNINGS
     #pragma clang diagnostic push
   #endif
   #pragma clang diagnostic ignored "-Wconstant-logical-operand"
+  #if __clang_major__ >= 3 && __clang_minor__ >= 5
+    #pragma clang diagnostic ignored "-Wabsolute-value"
+  #endif
+  #if __clang_major__ >= 10
+    #pragma clang diagnostic ignored "-Wimplicit-int-float-conversion"
+  #endif
+  #if ( defined(__ALTIVEC__) || defined(__VSX__) ) && __cplusplus < 201103L
+    // warning: generic selections are a C11-specific feature
+    // ignoring warnings thrown at vec_ctf in Altivec/PacketMath.h
+    #pragma clang diagnostic ignored "-Wc11-extensions"
+  #endif
 
 #elif defined __GNUC__
 
   #if (!defined(EIGEN_PERMANENTLY_DISABLE_STUPID_WARNINGS)) &&  (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
     #pragma GCC diagnostic push
   #endif
   // g++ warns about local variables shadowing member functions, which is too strict
@@ -53,18 +63,22 @@
   #if __GNUC__ == 4 && __GNUC_MINOR__ < 8
     // Until g++-4.7 there are warnings when comparing unsigned int vs 0, even in templated functions:
     #pragma GCC diagnostic ignored "-Wtype-limits"
   #endif
   #if __GNUC__>=6
     #pragma GCC diagnostic ignored "-Wignored-attributes"
   #endif
-
+  #if __GNUC__==7
+    // See: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=89325
+    #pragma GCC diagnostic ignored "-Wattributes"
+  #endif
 #endif
 
 #if defined __NVCC__
+  #pragma diag_suppress boolean_controlling_expr_is_constant
   // Disable the "statement is unreachable" message
   #pragma diag_suppress code_is_unreachable
   // Disable the "dynamic initialization in unreachable code" message
   #pragma diag_suppress initialization_not_reachable
   // Disable the "invalid error number" message that we get with older versions of nvcc
   #pragma diag_suppress 1222
   // Disable the "calling a __host__ function from a __host__ __device__ function is not allowed" messages (yes, there are many of them and they seem to change with every version of the compiler)
@@ -74,10 +88,19 @@
   #pragma diag_suppress 2653
   #pragma diag_suppress 2668
   #pragma diag_suppress 2669
   #pragma diag_suppress 2670
   #pragma diag_suppress 2671
   #pragma diag_suppress 2735
   #pragma diag_suppress 2737
+  #pragma diag_suppress 2739
 #endif
 
+#else
+// warnings already disabled:
+# ifndef EIGEN_WARNINGS_DISABLED_2
+#  define EIGEN_WARNINGS_DISABLED_2
+# elif defined(EIGEN_INTERNAL_DEBUGGING)
+#  error "Do not include \"DisableStupidWarnings.h\" recursively more than twice!"
+# endif
+
 #endif // not EIGEN_WARNINGS_DISABLED
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/ForwardDeclarations.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/ForwardDeclarations.h`

 * *Files 13% similar despite different names*

```diff
@@ -43,19 +43,15 @@
 } // end namespace internal
 
 template<typename T> struct NumTraits;
 
 template<typename Derived> struct EigenBase;
 template<typename Derived> class DenseBase;
 template<typename Derived> class PlainObjectBase;
-
-
-template<typename Derived,
-         int Level = internal::accessors_level<Derived>::value >
-class DenseCoeffsBase;
+template<typename Derived, int Level> class DenseCoeffsBase;
 
 template<typename _Scalar, int _Rows, int _Cols,
          int _Options = AutoAlign |
 #if EIGEN_GNUC_AT(3,4)
     // workaround a bug in at least gcc 3.4.6
     // the innermost ?: ternary operator is misparsed. We write it slightly
     // differently and this makes gcc 3.4.6 happy, but it's ugly.
@@ -79,14 +75,16 @@
 template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged;
 template<typename ExpressionType, template <typename> class StorageBase > class NoAlias;
 template<typename ExpressionType> class NestByValue;
 template<typename ExpressionType> class ForceAlignedAccess;
 template<typename ExpressionType> class SwapWrapper;
 
 template<typename XprType, int BlockRows=Dynamic, int BlockCols=Dynamic, bool InnerPanel = false> class Block;
+template<typename XprType, typename RowIndices, typename ColIndices> class IndexedView;
+template<typename XprType, int Rows=Dynamic, int Cols=Dynamic, int Order=0> class Reshaped;
 
 template<typename MatrixType, int Size=Dynamic> class VectorBlock;
 template<typename MatrixType> class Transpose;
 template<typename MatrixType> class Conjugate;
 template<typename NullaryOp, typename MatrixType>         class CwiseNullaryOp;
 template<typename UnaryOp,   typename MatrixType>         class CwiseUnaryOp;
 template<typename ViewOp,    typename MatrixType>         class CwiseUnaryView;
@@ -108,15 +106,15 @@
 template<typename Derived> class TranspositionsBase;
 template<typename _IndicesType> class PermutationWrapper;
 template<typename _IndicesType> class TranspositionsWrapper;
 
 template<typename Derived,
          int Level = internal::accessors_level<Derived>::has_write_access ? WriteAccessors : ReadOnlyAccessors
 > class MapBase;
-template<int InnerStrideAtCompileTime, int OuterStrideAtCompileTime> class Stride;
+template<int OuterStrideAtCompileTime, int InnerStrideAtCompileTime> class Stride;
 template<int Value = Dynamic> class InnerStride;
 template<int Value = Dynamic> class OuterStride;
 template<typename MatrixType, int MapOptions=Unaligned, typename StrideType = Stride<0,0> > class Map;
 template<typename Derived> class RefBase;
 template<typename PlainObjectType, int Options = 0,
          typename StrideType = typename internal::conditional<PlainObjectType::IsVectorAtCompileTime,InnerStride<1>,OuterStride<> >::type > class Ref;
 
@@ -129,14 +127,18 @@
 template<typename Derived> class ReturnByValue;
 template<typename ExpressionType> class ArrayWrapper;
 template<typename ExpressionType> class MatrixWrapper;
 template<typename Derived> class SolverBase;
 template<typename XprType> class InnerIterator;
 
 namespace internal {
+template<typename XprType> class generic_randaccess_stl_iterator;
+template<typename XprType> class pointer_based_stl_iterator;
+template<typename XprType, DirectionType Direction> class subvector_stl_iterator;
+template<typename XprType, DirectionType Direction> class subvector_stl_reverse_iterator;
 template<typename DecompositionType> struct kernel_retval_base;
 template<typename DecompositionType> struct kernel_retval;
 template<typename DecompositionType> struct image_retval_base;
 template<typename DecompositionType> struct image_retval;
 } // end namespace internal
 
 namespace internal {
@@ -174,22 +176,23 @@
 // Provides scalar/packet-wise product and product with accumulation
 // with optional conjugation of the arguments.
 template<typename LhsScalar, typename RhsScalar, bool ConjLhs=false, bool ConjRhs=false> struct conj_helper;
 
 template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_sum_op;
 template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_difference_op;
 template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_conj_product_op;
-template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_min_op;
-template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_max_op;
+template<typename LhsScalar,typename RhsScalar=LhsScalar, int NaNPropagation=PropagateFast> struct scalar_min_op;
+template<typename LhsScalar,typename RhsScalar=LhsScalar, int NaNPropagation=PropagateFast> struct scalar_max_op;
 template<typename Scalar> struct scalar_opposite_op;
 template<typename Scalar> struct scalar_conjugate_op;
 template<typename Scalar> struct scalar_real_op;
 template<typename Scalar> struct scalar_imag_op;
 template<typename Scalar> struct scalar_abs_op;
 template<typename Scalar> struct scalar_abs2_op;
+template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_absolute_difference_op;
 template<typename Scalar> struct scalar_sqrt_op;
 template<typename Scalar> struct scalar_rsqrt_op;
 template<typename Scalar> struct scalar_exp_op;
 template<typename Scalar> struct scalar_log_op;
 template<typename Scalar> struct scalar_cos_op;
 template<typename Scalar> struct scalar_sin_op;
 template<typename Scalar> struct scalar_acos_op;
@@ -198,30 +201,46 @@
 template<typename Scalar> struct scalar_inverse_op;
 template<typename Scalar> struct scalar_square_op;
 template<typename Scalar> struct scalar_cube_op;
 template<typename Scalar, typename NewType> struct scalar_cast_op;
 template<typename Scalar> struct scalar_random_op;
 template<typename Scalar> struct scalar_constant_op;
 template<typename Scalar> struct scalar_identity_op;
-template<typename Scalar,bool iscpx> struct scalar_sign_op;
+template<typename Scalar,bool is_complex, bool is_integer> struct scalar_sign_op;
 template<typename Scalar,typename ScalarExponent> struct scalar_pow_op;
 template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_hypot_op;
 template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_product_op;
 template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_quotient_op;
 
 // SpecialFunctions module
 template<typename Scalar> struct scalar_lgamma_op;
 template<typename Scalar> struct scalar_digamma_op;
 template<typename Scalar> struct scalar_erf_op;
 template<typename Scalar> struct scalar_erfc_op;
+template<typename Scalar> struct scalar_ndtri_op;
 template<typename Scalar> struct scalar_igamma_op;
 template<typename Scalar> struct scalar_igammac_op;
 template<typename Scalar> struct scalar_zeta_op;
 template<typename Scalar> struct scalar_betainc_op;
 
+// Bessel functions in SpecialFunctions module
+template<typename Scalar> struct scalar_bessel_i0_op;
+template<typename Scalar> struct scalar_bessel_i0e_op;
+template<typename Scalar> struct scalar_bessel_i1_op;
+template<typename Scalar> struct scalar_bessel_i1e_op;
+template<typename Scalar> struct scalar_bessel_j0_op;
+template<typename Scalar> struct scalar_bessel_y0_op;
+template<typename Scalar> struct scalar_bessel_j1_op;
+template<typename Scalar> struct scalar_bessel_y1_op;
+template<typename Scalar> struct scalar_bessel_k0_op;
+template<typename Scalar> struct scalar_bessel_k0e_op;
+template<typename Scalar> struct scalar_bessel_k1_op;
+template<typename Scalar> struct scalar_bessel_k1e_op;
+
+
 } // end namespace internal
 
 struct IOFormat;
 
 // Array module
 template<typename _Scalar, int _Rows, int _Cols,
          int _Options = AutoAlign |
@@ -251,14 +270,15 @@
 namespace internal {
 template<typename MatrixType> struct inverse_impl;
 }
 template<typename MatrixType> class HouseholderQR;
 template<typename MatrixType> class ColPivHouseholderQR;
 template<typename MatrixType> class FullPivHouseholderQR;
 template<typename MatrixType> class CompleteOrthogonalDecomposition;
+template<typename MatrixType> class SVDBase;
 template<typename MatrixType, int QRPreconditioner = ColPivHouseholderQRPreconditioner> class JacobiSVD;
 template<typename MatrixType> class BDCSVD;
 template<typename MatrixType, int UpLo = Lower> class LLT;
 template<typename MatrixType, int UpLo = Lower> class LDLT;
 template<typename VectorsType, typename CoeffsType, int Side=OnTheLeft> class HouseholderSequence;
 template<typename Scalar>     class JacobiRotation;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/MKL_support.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/MKL_support.h`

 * *Files 5% similar despite different names*

```diff
@@ -51,28 +51,35 @@
 
 #if defined(EIGEN_USE_MKL_VML) && !defined(EIGEN_USE_MKL)
   #define EIGEN_USE_MKL
 #endif
 
 
 #if defined EIGEN_USE_MKL
-#   include <mkl.h> 
+#   if (!defined MKL_DIRECT_CALL) && (!defined EIGEN_MKL_NO_DIRECT_CALL)
+#       define MKL_DIRECT_CALL
+#       define MKL_DIRECT_CALL_JUST_SET
+#   endif
+#   include <mkl.h>
 /*Check IMKL version for compatibility: < 10.3 is not usable with Eigen*/
 #   ifndef INTEL_MKL_VERSION
 #       undef EIGEN_USE_MKL /* INTEL_MKL_VERSION is not even defined on older versions */
 #   elif INTEL_MKL_VERSION < 100305    /* the intel-mkl-103-release-notes say this was when the lapacke.h interface was added*/
 #       undef EIGEN_USE_MKL
 #   endif
 #   ifndef EIGEN_USE_MKL
     /*If the MKL version is too old, undef everything*/
 #       undef   EIGEN_USE_MKL_ALL
 #       undef   EIGEN_USE_LAPACKE
 #       undef   EIGEN_USE_MKL_VML
 #       undef   EIGEN_USE_LAPACKE_STRICT
 #       undef   EIGEN_USE_LAPACKE
+#       ifdef   MKL_DIRECT_CALL_JUST_SET
+#           undef MKL_DIRECT_CALL
+#       endif
 #   endif
 #endif
 
 #if defined EIGEN_USE_MKL
 
 #define EIGEN_MKL_VML_THRESHOLD 128
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/Memory.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/Memory.h`

 * *Files 14% similar despite different names*

```diff
@@ -59,47 +59,68 @@
 
 #endif
 
 namespace Eigen {
 
 namespace internal {
 
-EIGEN_DEVICE_FUNC 
+EIGEN_DEVICE_FUNC
 inline void throw_std_bad_alloc()
 {
   #ifdef EIGEN_EXCEPTIONS
     throw std::bad_alloc();
   #else
     std::size_t huge = static_cast<std::size_t>(-1);
-    ::operator new(huge);
+    #if defined(EIGEN_HIPCC)
+    //
+    // calls to "::operator new" are to be treated as opaque function calls (i.e no inlining),
+    // and as a consequence the code in the #else block triggers the hipcc warning :
+    // "no overloaded function has restriction specifiers that are compatible with the ambient context"
+    //
+    // "throw_std_bad_alloc" has the EIGEN_DEVICE_FUNC attribute, so it seems that hipcc expects
+    // the same on "operator new"
+    // Reverting code back to the old version in this #if block for the hipcc compiler
+    //
+    new int[huge];
+    #else
+    void* unused = ::operator new(huge);
+    EIGEN_UNUSED_VARIABLE(unused);
+    #endif
   #endif
 }
 
 /*****************************************************************************
 *** Implementation of handmade aligned functions                           ***
 *****************************************************************************/
 
 /* ----- Hand made implementations of aligned malloc/free and realloc ----- */
 
 /** \internal Like malloc, but the returned pointer is guaranteed to be 16-byte aligned.
   * Fast, but wastes 16 additional bytes of memory. Does not throw any exception.
   */
-inline void* handmade_aligned_malloc(std::size_t size)
+EIGEN_DEVICE_FUNC inline void* handmade_aligned_malloc(std::size_t size, std::size_t alignment = EIGEN_DEFAULT_ALIGN_BYTES)
 {
-  void *original = std::malloc(size+EIGEN_DEFAULT_ALIGN_BYTES);
+  eigen_assert(alignment >= sizeof(void*) && (alignment & (alignment-1)) == 0 && "Alignment must be at least sizeof(void*) and a power of 2");
+
+  EIGEN_USING_STD(malloc)
+  void *original = malloc(size+alignment);
+  
   if (original == 0) return 0;
-  void *aligned = reinterpret_cast<void*>((reinterpret_cast<std::size_t>(original) & ~(std::size_t(EIGEN_DEFAULT_ALIGN_BYTES-1))) + EIGEN_DEFAULT_ALIGN_BYTES);
+  void *aligned = reinterpret_cast<void*>((reinterpret_cast<std::size_t>(original) & ~(std::size_t(alignment-1))) + alignment);
   *(reinterpret_cast<void**>(aligned) - 1) = original;
   return aligned;
 }
 
 /** \internal Frees memory allocated with handmade_aligned_malloc */
-inline void handmade_aligned_free(void *ptr)
+EIGEN_DEVICE_FUNC inline void handmade_aligned_free(void *ptr)
 {
-  if (ptr) std::free(*(reinterpret_cast<void**>(ptr) - 1));
+  if (ptr) {
+    EIGEN_USING_STD(free)
+    free(*(reinterpret_cast<void**>(ptr) - 1));
+  }
 }
 
 /** \internal
   * \brief Reallocates aligned memory.
   * Since we know that our handmade version is based on std::malloc
   * we can use std::realloc to implement efficient reallocation.
   */
@@ -110,15 +131,15 @@
   std::ptrdiff_t previous_offset = static_cast<char *>(ptr)-static_cast<char *>(original);
   original = std::realloc(original,size+EIGEN_DEFAULT_ALIGN_BYTES);
   if (original == 0) return 0;
   void *aligned = reinterpret_cast<void*>((reinterpret_cast<std::size_t>(original) & ~(std::size_t(EIGEN_DEFAULT_ALIGN_BYTES-1))) + EIGEN_DEFAULT_ALIGN_BYTES);
   void *previous_aligned = static_cast<char *>(original)+previous_offset;
   if(aligned!=previous_aligned)
     std::memmove(aligned, previous_aligned, size);
-  
+
   *(reinterpret_cast<void**>(aligned) - 1) = original;
   return aligned;
 }
 
 /*****************************************************************************
 *** Implementation of portable aligned versions of malloc/free/realloc     ***
 *****************************************************************************/
@@ -138,31 +159,34 @@
 }
 EIGEN_DEVICE_FUNC inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }
 EIGEN_DEVICE_FUNC inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }
 EIGEN_DEVICE_FUNC inline void check_that_malloc_is_allowed()
 {
   eigen_assert(is_malloc_allowed() && "heap allocation is forbidden (EIGEN_RUNTIME_NO_MALLOC is defined and g_is_malloc_allowed is false)");
 }
-#else 
+#else
 EIGEN_DEVICE_FUNC inline void check_that_malloc_is_allowed()
 {}
 #endif
 
 /** \internal Allocates \a size bytes. The returned pointer is guaranteed to have 16 or 32 bytes alignment depending on the requirements.
   * On allocation error, the returned pointer is null, and std::bad_alloc is thrown.
   */
 EIGEN_DEVICE_FUNC inline void* aligned_malloc(std::size_t size)
 {
   check_that_malloc_is_allowed();
 
   void *result;
   #if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED
-    result = std::malloc(size);
+
+    EIGEN_USING_STD(malloc)
+    result = malloc(size);
+
     #if EIGEN_DEFAULT_ALIGN_BYTES==16
-    eigen_assert((size<16 || (std::size_t(result)%16)==0) && "System's malloc returned an unaligned pointer. Compile with EIGEN_MALLOC_ALREADY_ALIGNED=0 to fallback to handmade alignd memory allocator.");
+    eigen_assert((size<16 || (std::size_t(result)%16)==0) && "System's malloc returned an unaligned pointer. Compile with EIGEN_MALLOC_ALREADY_ALIGNED=0 to fallback to handmade aligned memory allocator.");
     #endif
   #else
     result = handmade_aligned_malloc(size);
   #endif
 
   if(!result && size)
     throw_std_bad_alloc();
@@ -170,28 +194,31 @@
   return result;
 }
 
 /** \internal Frees memory allocated with aligned_malloc. */
 EIGEN_DEVICE_FUNC inline void aligned_free(void *ptr)
 {
   #if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED
-    std::free(ptr);
+
+    EIGEN_USING_STD(free)
+    free(ptr);
+
   #else
     handmade_aligned_free(ptr);
   #endif
 }
 
 /**
   * \internal
   * \brief Reallocates an aligned block of memory.
   * \throws std::bad_alloc on allocation failure
   */
 inline void* aligned_realloc(void *ptr, std::size_t new_size, std::size_t old_size)
 {
-  EIGEN_UNUSED_VARIABLE(old_size);
+  EIGEN_UNUSED_VARIABLE(old_size)
 
   void *result;
 #if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED
   result = std::realloc(ptr,new_size);
 #else
   result = handmade_aligned_realloc(ptr,new_size,old_size);
 #endif
@@ -214,29 +241,32 @@
   return aligned_malloc(size);
 }
 
 template<> EIGEN_DEVICE_FUNC inline void* conditional_aligned_malloc<false>(std::size_t size)
 {
   check_that_malloc_is_allowed();
 
-  void *result = std::malloc(size);
+  EIGEN_USING_STD(malloc)
+  void *result = malloc(size);
+
   if(!result && size)
     throw_std_bad_alloc();
   return result;
 }
 
 /** \internal Frees memory allocated with conditional_aligned_malloc */
 template<bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_free(void *ptr)
 {
   aligned_free(ptr);
 }
 
 template<> EIGEN_DEVICE_FUNC inline void conditional_aligned_free<false>(void *ptr)
 {
-  std::free(ptr);
+  EIGEN_USING_STD(free)
+  free(ptr);
 }
 
 template<bool Align> inline void* conditional_aligned_realloc(void* ptr, std::size_t new_size, std::size_t old_size)
 {
   return aligned_realloc(ptr, new_size, old_size);
 }
 
@@ -327,15 +357,15 @@
 
 /** \internal Deletes objects constructed with aligned_new
   * The \a size parameters tells on how many objects to call the destructor of T.
   */
 template<typename T> EIGEN_DEVICE_FUNC inline void aligned_delete(T *ptr, std::size_t size)
 {
   destruct_elements_of_array<T>(ptr, size);
-  aligned_free(ptr);
+  Eigen::internal::aligned_free(ptr);
 }
 
 /** \internal Deletes objects constructed with conditional_aligned_new
   * The \a size parameters tells on how many objects to call the destructor of T.
   */
 template<typename T, bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_delete(T *ptr, std::size_t size)
 {
@@ -467,16 +497,16 @@
 EIGEN_DEVICE_FUNC inline Index first_default_aligned(const Scalar* array, Index size)
 {
   typedef typename packet_traits<Scalar>::type DefaultPacketType;
   return first_aligned<unpacket_traits<DefaultPacketType>::alignment>(array, size);
 }
 
 /** \internal Returns the smallest integer multiple of \a base and greater or equal to \a size
-  */ 
-template<typename Index> 
+  */
+template<typename Index>
 inline Index first_multiple(Index size, Index base)
 {
   return ((size+base-1)/base)*base;
 }
 
 // std::copy is much slower than memcpy, so let's introduce a smart_copy which
 // use memcpy on trivial types, i.e., on types that does not require an initialization ctor.
@@ -489,24 +519,25 @@
 
 template<typename T> struct smart_copy_helper<T,true> {
   EIGEN_DEVICE_FUNC static inline void run(const T* start, const T* end, T* target)
   {
     IntPtr size = IntPtr(end)-IntPtr(start);
     if(size==0) return;
     eigen_internal_assert(start!=0 && end!=0 && target!=0);
-    std::memcpy(target, start, size);
+    EIGEN_USING_STD(memcpy)
+    memcpy(target, start, size);
   }
 };
 
 template<typename T> struct smart_copy_helper<T,false> {
   EIGEN_DEVICE_FUNC static inline void run(const T* start, const T* end, T* target)
   { std::copy(start, end, target); }
 };
 
-// intelligent memmove. falls back to std::memmove for POD types, uses std::copy otherwise. 
+// intelligent memmove. falls back to std::memmove for POD types, uses std::copy otherwise.
 template<typename T, bool UseMemmove> struct smart_memmove_helper;
 
 template<typename T> void smart_memmove(const T* start, const T* end, T* target)
 {
   smart_memmove_helper<T,!NumTraits<T>::RequireInitialization>::run(start, end, target);
 }
 
@@ -518,72 +549,148 @@
     eigen_internal_assert(start!=0 && end!=0 && target!=0);
     std::memmove(target, start, size);
   }
 };
 
 template<typename T> struct smart_memmove_helper<T,false> {
   static inline void run(const T* start, const T* end, T* target)
-  { 
+  {
     if (UIntPtr(target) < UIntPtr(start))
     {
       std::copy(start, end, target);
     }
-    else                                 
+    else
     {
       std::ptrdiff_t count = (std::ptrdiff_t(end)-std::ptrdiff_t(start)) / sizeof(T);
-      std::copy_backward(start, end, target + count); 
+      std::copy_backward(start, end, target + count);
     }
   }
 };
 
+#if EIGEN_HAS_RVALUE_REFERENCES
+template<typename T> EIGEN_DEVICE_FUNC T* smart_move(T* start, T* end, T* target)
+{
+  return std::move(start, end, target);
+}
+#else
+template<typename T> EIGEN_DEVICE_FUNC T* smart_move(T* start, T* end, T* target)
+{
+  return std::copy(start, end, target);
+}
+#endif
 
 /*****************************************************************************
 *** Implementation of runtime stack allocation (falling back to malloc)    ***
 *****************************************************************************/
 
 // you can overwrite Eigen's default behavior regarding alloca by defining EIGEN_ALLOCA
 // to the appropriate stack allocation function
-#ifndef EIGEN_ALLOCA
+#if ! defined EIGEN_ALLOCA && ! defined EIGEN_GPU_COMPILE_PHASE
   #if EIGEN_OS_LINUX || EIGEN_OS_MAC || (defined alloca)
     #define EIGEN_ALLOCA alloca
   #elif EIGEN_COMP_MSVC
     #define EIGEN_ALLOCA _alloca
   #endif
 #endif
 
+// With clang -Oz -mthumb, alloca changes the stack pointer in a way that is
+// not allowed in Thumb2. -DEIGEN_STACK_ALLOCATION_LIMIT=0 doesn't work because
+// the compiler still emits bad code because stack allocation checks use "<=".
+// TODO: Eliminate after https://bugs.llvm.org/show_bug.cgi?id=23772
+// is fixed.
+#if defined(__clang__) && defined(__thumb__)
+  #undef EIGEN_ALLOCA
+#endif
+
 // This helper class construct the allocated memory, and takes care of destructing and freeing the handled data
 // at destruction time. In practice this helper class is mainly useful to avoid memory leak in case of exceptions.
 template<typename T> class aligned_stack_memory_handler : noncopyable
 {
   public:
     /* Creates a stack_memory_handler responsible for the buffer \a ptr of size \a size.
      * Note that \a ptr can be 0 regardless of the other parameters.
      * This constructor takes care of constructing/initializing the elements of the buffer if required by the scalar type T (see NumTraits<T>::RequireInitialization).
      * In this case, the buffer elements will also be destructed when this handler will be destructed.
      * Finally, if \a dealloc is true, then the pointer \a ptr is freed.
      **/
+    EIGEN_DEVICE_FUNC
     aligned_stack_memory_handler(T* ptr, std::size_t size, bool dealloc)
       : m_ptr(ptr), m_size(size), m_deallocate(dealloc)
     {
       if(NumTraits<T>::RequireInitialization && m_ptr)
         Eigen::internal::construct_elements_of_array(m_ptr, size);
     }
+    EIGEN_DEVICE_FUNC
     ~aligned_stack_memory_handler()
     {
       if(NumTraits<T>::RequireInitialization && m_ptr)
         Eigen::internal::destruct_elements_of_array<T>(m_ptr, m_size);
       if(m_deallocate)
         Eigen::internal::aligned_free(m_ptr);
     }
   protected:
     T* m_ptr;
     std::size_t m_size;
     bool m_deallocate;
 };
 
+#ifdef EIGEN_ALLOCA
+
+template<typename Xpr, int NbEvaluations,
+         bool MapExternalBuffer = nested_eval<Xpr,NbEvaluations>::Evaluate && Xpr::MaxSizeAtCompileTime==Dynamic
+         >
+struct local_nested_eval_wrapper
+{
+  static const bool NeedExternalBuffer = false;
+  typedef typename Xpr::Scalar Scalar;
+  typedef typename nested_eval<Xpr,NbEvaluations>::type ObjectType;
+  ObjectType object;
+
+  EIGEN_DEVICE_FUNC
+  local_nested_eval_wrapper(const Xpr& xpr, Scalar* ptr) : object(xpr)
+  {
+    EIGEN_UNUSED_VARIABLE(ptr);
+    eigen_internal_assert(ptr==0);
+  }
+};
+
+template<typename Xpr, int NbEvaluations>
+struct local_nested_eval_wrapper<Xpr,NbEvaluations,true>
+{
+  static const bool NeedExternalBuffer = true;
+  typedef typename Xpr::Scalar Scalar;
+  typedef typename plain_object_eval<Xpr>::type PlainObject;
+  typedef Map<PlainObject,EIGEN_DEFAULT_ALIGN_BYTES> ObjectType;
+  ObjectType object;
+
+  EIGEN_DEVICE_FUNC
+  local_nested_eval_wrapper(const Xpr& xpr, Scalar* ptr)
+    : object(ptr==0 ? reinterpret_cast<Scalar*>(Eigen::internal::aligned_malloc(sizeof(Scalar)*xpr.size())) : ptr, xpr.rows(), xpr.cols()),
+      m_deallocate(ptr==0)
+  {
+    if(NumTraits<Scalar>::RequireInitialization && object.data())
+      Eigen::internal::construct_elements_of_array(object.data(), object.size());
+    object = xpr;
+  }
+
+  EIGEN_DEVICE_FUNC
+  ~local_nested_eval_wrapper()
+  {
+    if(NumTraits<Scalar>::RequireInitialization && object.data())
+      Eigen::internal::destruct_elements_of_array(object.data(), object.size());
+    if(m_deallocate)
+      Eigen::internal::aligned_free(object.data());
+  }
+
+private:
+  bool m_deallocate;
+};
+
+#endif // EIGEN_ALLOCA
+
 template<typename T> class scoped_array : noncopyable
 {
   T* m_ptr;
 public:
   explicit scoped_array(std::ptrdiff_t size)
   {
     m_ptr = new T[size];
@@ -599,34 +706,44 @@
   operator const T*() const { return m_ptr; }
 };
 
 template<typename T> void swap(scoped_array<T> &a,scoped_array<T> &b)
 {
   std::swap(a.ptr(),b.ptr());
 }
-    
+
 } // end namespace internal
 
 /** \internal
-  * Declares, allocates and construct an aligned buffer named NAME of SIZE elements of type TYPE on the stack
-  * if SIZE is smaller than EIGEN_STACK_ALLOCATION_LIMIT, and if stack allocation is supported by the platform
-  * (currently, this is Linux and Visual Studio only). Otherwise the memory is allocated on the heap.
+  *
+  * The macro ei_declare_aligned_stack_constructed_variable(TYPE,NAME,SIZE,BUFFER) declares, allocates,
+  * and construct an aligned buffer named NAME of SIZE elements of type TYPE on the stack
+  * if the size in bytes is smaller than EIGEN_STACK_ALLOCATION_LIMIT, and if stack allocation is supported by the platform
+  * (currently, this is Linux, OSX and Visual Studio only). Otherwise the memory is allocated on the heap.
   * The allocated buffer is automatically deleted when exiting the scope of this declaration.
   * If BUFFER is non null, then the declared variable is simply an alias for BUFFER, and no allocation/deletion occurs.
   * Here is an example:
   * \code
   * {
   *   ei_declare_aligned_stack_constructed_variable(float,data,size,0);
   *   // use data[0] to data[size-1]
   * }
   * \endcode
   * The underlying stack allocation function can controlled with the EIGEN_ALLOCA preprocessor token.
+  *
+  * The macro ei_declare_local_nested_eval(XPR_T,XPR,N,NAME) is analogue to
+  * \code
+  *   typename internal::nested_eval<XPRT_T,N>::type NAME(XPR);
+  * \endcode
+  * with the advantage of using aligned stack allocation even if the maximal size of XPR at compile time is unknown.
+  * This is accomplished through alloca if this later is supported and if the required number of bytes
+  * is below EIGEN_STACK_ALLOCATION_LIMIT.
   */
 #ifdef EIGEN_ALLOCA
-  
+
   #if EIGEN_DEFAULT_ALIGN_BYTES>0
     // We always manually re-align the result of EIGEN_ALLOCA.
     // If alloca is already aligned, the compiler should be smart enough to optimize away the re-alignment.
     #define EIGEN_ALIGNED_ALLOCA(SIZE) reinterpret_cast<void*>((internal::UIntPtr(EIGEN_ALLOCA(SIZE+EIGEN_DEFAULT_ALIGN_BYTES-1)) + EIGEN_DEFAULT_ALIGN_BYTES-1) & ~(std::size_t(EIGEN_DEFAULT_ALIGN_BYTES-1)))
   #else
     #define EIGEN_ALIGNED_ALLOCA(SIZE) EIGEN_ALLOCA(SIZE)
   #endif
@@ -635,85 +752,125 @@
     Eigen::internal::check_size_for_overflow<TYPE>(SIZE); \
     TYPE* NAME = (BUFFER)!=0 ? (BUFFER) \
                : reinterpret_cast<TYPE*>( \
                       (sizeof(TYPE)*SIZE<=EIGEN_STACK_ALLOCATION_LIMIT) ? EIGEN_ALIGNED_ALLOCA(sizeof(TYPE)*SIZE) \
                     : Eigen::internal::aligned_malloc(sizeof(TYPE)*SIZE) );  \
     Eigen::internal::aligned_stack_memory_handler<TYPE> EIGEN_CAT(NAME,_stack_memory_destructor)((BUFFER)==0 ? NAME : 0,SIZE,sizeof(TYPE)*SIZE>EIGEN_STACK_ALLOCATION_LIMIT)
 
+
+  #define ei_declare_local_nested_eval(XPR_T,XPR,N,NAME) \
+    Eigen::internal::local_nested_eval_wrapper<XPR_T,N> EIGEN_CAT(NAME,_wrapper)(XPR, reinterpret_cast<typename XPR_T::Scalar*>( \
+      ( (Eigen::internal::local_nested_eval_wrapper<XPR_T,N>::NeedExternalBuffer) && ((sizeof(typename XPR_T::Scalar)*XPR.size())<=EIGEN_STACK_ALLOCATION_LIMIT) ) \
+        ? EIGEN_ALIGNED_ALLOCA( sizeof(typename XPR_T::Scalar)*XPR.size() ) : 0 ) ) ; \
+    typename Eigen::internal::local_nested_eval_wrapper<XPR_T,N>::ObjectType NAME(EIGEN_CAT(NAME,_wrapper).object)
+
 #else
 
   #define ei_declare_aligned_stack_constructed_variable(TYPE,NAME,SIZE,BUFFER) \
     Eigen::internal::check_size_for_overflow<TYPE>(SIZE); \
     TYPE* NAME = (BUFFER)!=0 ? BUFFER : reinterpret_cast<TYPE*>(Eigen::internal::aligned_malloc(sizeof(TYPE)*SIZE));    \
     Eigen::internal::aligned_stack_memory_handler<TYPE> EIGEN_CAT(NAME,_stack_memory_destructor)((BUFFER)==0 ? NAME : 0,SIZE,true)
-    
+
+
+#define ei_declare_local_nested_eval(XPR_T,XPR,N,NAME) typename Eigen::internal::nested_eval<XPR_T,N>::type NAME(XPR)
+
 #endif
 
 
 /*****************************************************************************
 *** Implementation of EIGEN_MAKE_ALIGNED_OPERATOR_NEW [_IF]                ***
 *****************************************************************************/
 
-#if EIGEN_MAX_ALIGN_BYTES!=0
+#if EIGEN_HAS_CXX17_OVERALIGN
+
+// C++17 -> no need to bother about alignment anymore :)
+
+#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW(NeedsToAlign)
+#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
+#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW
+#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(Scalar,Size)
+
+#else
+
+// HIP does not support new/delete on device.
+#if EIGEN_MAX_ALIGN_BYTES!=0 && !defined(EIGEN_HIP_DEVICE_COMPILE)
   #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW(NeedsToAlign) \
+      EIGEN_DEVICE_FUNC \
       void* operator new(std::size_t size, const std::nothrow_t&) EIGEN_NO_THROW { \
         EIGEN_TRY { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } \
         EIGEN_CATCH (...) { return 0; } \
       }
   #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign) \
+      EIGEN_DEVICE_FUNC \
       void *operator new(std::size_t size) { \
         return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); \
       } \
+      EIGEN_DEVICE_FUNC \
       void *operator new[](std::size_t size) { \
         return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); \
       } \
+      EIGEN_DEVICE_FUNC \
       void operator delete(void * ptr) EIGEN_NO_THROW { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } \
+      EIGEN_DEVICE_FUNC \
       void operator delete[](void * ptr) EIGEN_NO_THROW { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } \
+      EIGEN_DEVICE_FUNC \
       void operator delete(void * ptr, std::size_t /* sz */) EIGEN_NO_THROW { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } \
+      EIGEN_DEVICE_FUNC \
       void operator delete[](void * ptr, std::size_t /* sz */) EIGEN_NO_THROW { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } \
       /* in-place new and delete. since (at least afaik) there is no actual   */ \
       /* memory allocated we can safely let the default implementation handle */ \
       /* this particular case. */ \
+      EIGEN_DEVICE_FUNC \
       static void *operator new(std::size_t size, void *ptr) { return ::operator new(size,ptr); } \
+      EIGEN_DEVICE_FUNC \
       static void *operator new[](std::size_t size, void* ptr) { return ::operator new[](size,ptr); } \
+      EIGEN_DEVICE_FUNC \
       void operator delete(void * memory, void *ptr) EIGEN_NO_THROW { return ::operator delete(memory,ptr); } \
+      EIGEN_DEVICE_FUNC \
       void operator delete[](void * memory, void *ptr) EIGEN_NO_THROW { return ::operator delete[](memory,ptr); } \
       /* nothrow-new (returns zero instead of std::bad_alloc) */ \
       EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW(NeedsToAlign) \
+      EIGEN_DEVICE_FUNC \
       void operator delete(void *ptr, const std::nothrow_t&) EIGEN_NO_THROW { \
         Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); \
       } \
       typedef void eigen_aligned_operator_new_marker_type;
 #else
   #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)
 #endif
 
 #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(true)
-#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(Scalar,Size) \
-  EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(bool(((Size)!=Eigen::Dynamic) && ((sizeof(Scalar)*(Size))%EIGEN_MAX_ALIGN_BYTES==0)))
+#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(Scalar,Size)                        \
+  EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(bool(                                                             \
+        ((Size)!=Eigen::Dynamic) &&                                                                    \
+        (((EIGEN_MAX_ALIGN_BYTES>=16) && ((sizeof(Scalar)*(Size))%(EIGEN_MAX_ALIGN_BYTES  )==0)) ||    \
+         ((EIGEN_MAX_ALIGN_BYTES>=32) && ((sizeof(Scalar)*(Size))%(EIGEN_MAX_ALIGN_BYTES/2)==0)) ||    \
+         ((EIGEN_MAX_ALIGN_BYTES>=64) && ((sizeof(Scalar)*(Size))%(EIGEN_MAX_ALIGN_BYTES/4)==0))   )))
+
+#endif
 
 /****************************************************************************/
 
 /** \class aligned_allocator
 * \ingroup Core_Module
 *
 * \brief STL compatible allocator to use with types requiring a non standrad alignment.
 *
 * The memory is aligned as for dynamically aligned matrix/array types such as MatrixXd.
 * By default, it will thus provide at least 16 bytes alignment and more in following cases:
 *  - 32 bytes alignment if AVX is enabled.
 *  - 64 bytes alignment if AVX512 is enabled.
 *
-* This can be controled using the \c EIGEN_MAX_ALIGN_BYTES macro as documented
+* This can be controlled using the \c EIGEN_MAX_ALIGN_BYTES macro as documented
 * \link TopicPreprocessorDirectivesPerformance there \endlink.
 *
 * Example:
 * \code
 * // Matrix4f requires 16 bytes alignment:
-* std::map< int, Matrix4f, std::less<int>, 
+* std::map< int, Matrix4f, std::less<int>,
 *           aligned_allocator<std::pair<const int, Matrix4f> > > my_map_mat4;
 * // Vector3f does not require 16 bytes alignment, no need to use Eigen's allocator:
 * std::map< int, Vector3f > my_map_vec3;
 * \endcode
 *
 * \sa \blank \ref TopicStlContainers.
 */
@@ -740,26 +897,27 @@
   aligned_allocator(const aligned_allocator& other) : std::allocator<T>(other) {}
 
   template<class U>
   aligned_allocator(const aligned_allocator<U>& other) : std::allocator<T>(other) {}
 
   ~aligned_allocator() {}
 
+  #if EIGEN_COMP_GNUC_STRICT && EIGEN_GNUC_AT_LEAST(7,0)
+  // In gcc std::allocator::max_size() is bugged making gcc triggers a warning:
+  // eigen/Eigen/src/Core/util/Memory.h:189:12: warning: argument 1 value '18446744073709551612' exceeds maximum object size 9223372036854775807
+  // See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87544
+  size_type max_size() const {
+    return (std::numeric_limits<std::ptrdiff_t>::max)()/sizeof(T);
+  }
+  #endif
+
   pointer allocate(size_type num, const void* /*hint*/ = 0)
   {
     internal::check_size_for_overflow<T>(num);
-    size_type size = num * sizeof(T);
-#if EIGEN_COMP_GNUC_STRICT && EIGEN_GNUC_AT_LEAST(7,0)
-    // workaround gcc bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87544
-    // It triggered eigen/Eigen/src/Core/util/Memory.h:189:12: warning: argument 1 value '18446744073709551612' exceeds maximum object size 9223372036854775807
-    if(size>=std::size_t((std::numeric_limits<std::ptrdiff_t>::max)()))
-      return 0;
-    else
-#endif
-      return static_cast<pointer>( internal::aligned_malloc(size) );
+    return static_cast<pointer>( internal::aligned_malloc(num * sizeof(T)) );
   }
 
   void deallocate(pointer p, size_type /*num*/)
   {
     internal::aligned_free(p);
   }
 };
@@ -910,28 +1068,40 @@
   l3 *= 1024;
 }
 
 inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)
 {
   if(max_std_funcs>=4)
     queryCacheSizes_intel_direct(l1,l2,l3);
-  else
+  else if(max_std_funcs>=2)
     queryCacheSizes_intel_codes(l1,l2,l3);
+  else
+    l1 = l2 = l3 = 0;
 }
 
 inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)
 {
   int abcd[4];
   abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
-  EIGEN_CPUID(abcd,0x80000005,0);
-  l1 = (abcd[2] >> 24) * 1024; // C[31:24] = L1 size in KB
-  abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
-  EIGEN_CPUID(abcd,0x80000006,0);
-  l2 = (abcd[2] >> 16) * 1024; // C[31;16] = l2 cache size in KB
-  l3 = ((abcd[3] & 0xFFFC000) >> 18) * 512 * 1024; // D[31;18] = l3 cache size in 512KB
+  
+  // First query the max supported function.
+  EIGEN_CPUID(abcd,0x80000000,0);
+  if(static_cast<numext::uint32_t>(abcd[0]) >= static_cast<numext::uint32_t>(0x80000006))
+  {
+    EIGEN_CPUID(abcd,0x80000005,0);
+    l1 = (abcd[2] >> 24) * 1024; // C[31:24] = L1 size in KB
+    abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;
+    EIGEN_CPUID(abcd,0x80000006,0);
+    l2 = (abcd[2] >> 16) * 1024; // C[31;16] = l2 cache size in KB
+    l3 = ((abcd[3] & 0xFFFC000) >> 18) * 512 * 1024; // D[31;18] = l3 cache size in 512KB
+  }
+  else
+  {
+    l1 = l2 = l3 = 0;
+  }
 }
 #endif
 
 /** \internal
  * Queries and returns the cache sizes in Bytes of the L1, L2, and L3 data caches respectively */
 inline void queryCacheSizes(int& l1, int& l2, int& l3)
 {
@@ -939,15 +1109,15 @@
   int abcd[4];
   const int GenuineIntel[] = {0x756e6547, 0x49656e69, 0x6c65746e};
   const int AuthenticAMD[] = {0x68747541, 0x69746e65, 0x444d4163};
   const int AMDisbetter_[] = {0x69444d41, 0x74656273, 0x21726574}; // "AMDisbetter!"
 
   // identify the CPU vendor
   EIGEN_CPUID(abcd,0x0,0);
-  int max_std_funcs = abcd[1];
+  int max_std_funcs = abcd[0];
   if(cpuid_is_vendor(abcd,GenuineIntel))
     queryCacheSizes_intel(l1,l2,l3,max_std_funcs);
   else if(cpuid_is_vendor(abcd,AuthenticAMD) || cpuid_is_vendor(abcd,AMDisbetter_))
     queryCacheSizes_amd(l1,l2,l3);
   else
     // by default let's use Intel's API
     queryCacheSizes_intel(l1,l2,l3,max_std_funcs);
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/Meta.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/Meta.h`

 * *Files 21% similar despite different names*

```diff
@@ -7,21 +7,62 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_META_H
 #define EIGEN_META_H
 
-#if defined(__CUDA_ARCH__)
-#include <cfloat>
-#include <math_constants.h>
+#if defined(EIGEN_GPU_COMPILE_PHASE)
+
+ #include <cfloat>
+
+ #if defined(EIGEN_CUDA_ARCH)
+  #include <math_constants.h>
+ #endif
+
+ #if defined(EIGEN_HIP_DEVICE_COMPILE)
+  #include "Eigen/src/Core/arch/HIP/hcc/math_constants.h"
+  #endif
+
 #endif
 
-#if EIGEN_COMP_ICC>=1600 &&  __cplusplus >= 201103L
+// Recent versions of ICC require <cstdint> for pointer types below.
+#define EIGEN_ICC_NEEDS_CSTDINT (EIGEN_COMP_ICC>=1600 && EIGEN_COMP_CXXVER >= 11)
+
+// Define portable (u)int{32,64} types
+#if EIGEN_HAS_CXX11 || EIGEN_ICC_NEEDS_CSTDINT
 #include <cstdint>
+namespace Eigen {
+namespace numext {
+typedef std::uint8_t  uint8_t;
+typedef std::int8_t   int8_t;
+typedef std::uint16_t uint16_t;
+typedef std::int16_t  int16_t;
+typedef std::uint32_t uint32_t;
+typedef std::int32_t  int32_t;
+typedef std::uint64_t uint64_t;
+typedef std::int64_t  int64_t;
+}
+}
+#else
+// Without c++11, all compilers able to compile Eigen also
+// provide the C99 stdint.h header file.
+#include <stdint.h>
+namespace Eigen {
+namespace numext {
+typedef ::uint8_t  uint8_t;
+typedef ::int8_t   int8_t;
+typedef ::uint16_t uint16_t;
+typedef ::int16_t  int16_t;
+typedef ::uint32_t uint32_t;
+typedef ::int32_t  int32_t;
+typedef ::uint64_t uint64_t;
+typedef ::int64_t  int64_t;
+}
+}
 #endif
 
 namespace Eigen {
 
 typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;
 
 /**
@@ -39,34 +80,41 @@
   * This file contains generic metaprogramming classes which are not specifically related to Eigen.
   * \note In case you wonder, yes we're aware that Boost already provides all these features,
   * we however don't want to add a dependency to Boost.
   */
 
 // Only recent versions of ICC complain about using ptrdiff_t to hold pointers,
 // and older versions do not provide *intptr_t types.
-#if EIGEN_COMP_ICC>=1600 &&  __cplusplus >= 201103L
+#if EIGEN_ICC_NEEDS_CSTDINT
 typedef std::intptr_t  IntPtr;
 typedef std::uintptr_t UIntPtr;
 #else
 typedef std::ptrdiff_t IntPtr;
 typedef std::size_t UIntPtr;
 #endif
+#undef EIGEN_ICC_NEEDS_CSTDINT
 
 struct true_type {  enum { value = 1 }; };
 struct false_type { enum { value = 0 }; };
 
+template<bool Condition>
+struct bool_constant;
+
+template<>
+struct bool_constant<true> : true_type {};
+
+template<>
+struct bool_constant<false> : false_type {};
+
 template<bool Condition, typename Then, typename Else>
 struct conditional { typedef Then type; };
 
 template<typename Then, typename Else>
 struct conditional <false, Then, Else> { typedef Else type; };
 
-template<typename T, typename U> struct is_same { enum { value = 0 }; };
-template<typename T> struct is_same<T,T> { enum { value = 1 }; };
-
 template<typename T> struct remove_reference { typedef T type; };
 template<typename T> struct remove_reference<T&> { typedef T type; };
 
 template<typename T> struct remove_pointer { typedef T type; };
 template<typename T> struct remove_pointer<T*> { typedef T type; };
 template<typename T> struct remove_pointer<T*const> { typedef T type; };
 
@@ -93,25 +141,41 @@
 template<> struct is_arithmetic<signed short>  { enum { value = true }; };
 template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };
 template<> struct is_arithmetic<signed int>    { enum { value = true }; };
 template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };
 template<> struct is_arithmetic<signed long>   { enum { value = true }; };
 template<> struct is_arithmetic<unsigned long> { enum { value = true }; };
 
-template<typename T> struct is_integral        { enum { value = false }; };
-template<> struct is_integral<bool>            { enum { value = true }; };
-template<> struct is_integral<char>            { enum { value = true }; };
-template<> struct is_integral<signed char>     { enum { value = true }; };
-template<> struct is_integral<unsigned char>   { enum { value = true }; };
-template<> struct is_integral<signed short>    { enum { value = true }; };
-template<> struct is_integral<unsigned short>  { enum { value = true }; };
-template<> struct is_integral<signed int>      { enum { value = true }; };
-template<> struct is_integral<unsigned int>    { enum { value = true }; };
-template<> struct is_integral<signed long>     { enum { value = true }; };
-template<> struct is_integral<unsigned long>   { enum { value = true }; };
+template<typename T, typename U> struct is_same { enum { value = 0 }; };
+template<typename T> struct is_same<T,T> { enum { value = 1 }; };
+
+template< class T >
+struct is_void : is_same<void, typename remove_const<T>::type> {};
+
+#if EIGEN_HAS_CXX11
+template<> struct is_arithmetic<signed long long>   { enum { value = true }; };
+template<> struct is_arithmetic<unsigned long long> { enum { value = true }; };
+using std::is_integral;
+#else
+template<typename T> struct is_integral               { enum { value = false }; };
+template<> struct is_integral<bool>                   { enum { value = true }; };
+template<> struct is_integral<char>                   { enum { value = true }; };
+template<> struct is_integral<signed char>            { enum { value = true }; };
+template<> struct is_integral<unsigned char>          { enum { value = true }; };
+template<> struct is_integral<signed short>           { enum { value = true }; };
+template<> struct is_integral<unsigned short>         { enum { value = true }; };
+template<> struct is_integral<signed int>             { enum { value = true }; };
+template<> struct is_integral<unsigned int>           { enum { value = true }; };
+template<> struct is_integral<signed long>            { enum { value = true }; };
+template<> struct is_integral<unsigned long>          { enum { value = true }; };
+#if EIGEN_COMP_MSVC
+template<> struct is_integral<signed __int64>         { enum { value = true }; };
+template<> struct is_integral<unsigned __int64>       { enum { value = true }; };
+#endif
+#endif
 
 #if EIGEN_HAS_CXX11
 using std::make_unsigned;
 #else
 // TODO: Possibly improve this implementation of make_unsigned.
 // It is currently used only by
 // template<typename Scalar> struct random_default_impl<Scalar, false, true>.
@@ -125,204 +189,359 @@
 template<> struct make_unsigned<unsigned int>     { typedef unsigned int type; };
 template<> struct make_unsigned<signed long>      { typedef unsigned long type; };
 template<> struct make_unsigned<unsigned long>    { typedef unsigned long type; };
 #if EIGEN_COMP_MSVC
 template<> struct make_unsigned<signed __int64>   { typedef unsigned __int64 type; };
 template<> struct make_unsigned<unsigned __int64> { typedef unsigned __int64 type; };
 #endif
+
+// Some platforms define int64_t as `long long` even for C++03, where
+// `long long` is not guaranteed by the standard. In this case we are missing
+// the definition for make_unsigned. If we just define it, we run into issues
+// where `long long` doesn't exist in some compilers for C++03. We therefore add
+// the specialization for these platforms only.
+#if EIGEN_OS_MAC || EIGEN_COMP_MINGW
+template<> struct make_unsigned<unsigned long long> { typedef unsigned long long type; };
+template<> struct make_unsigned<long long>          { typedef unsigned long long type; };
+#endif
 #endif
 
 template <typename T> struct add_const { typedef const T type; };
 template <typename T> struct add_const<T&> { typedef T& type; };
 
 template <typename T> struct is_const { enum { value = 0 }; };
 template <typename T> struct is_const<T const> { enum { value = 1 }; };
 
 template<typename T> struct add_const_on_value_type            { typedef const T type;  };
 template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };
 template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };
 template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };
 template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };
 
+#if EIGEN_HAS_CXX11
+
+using std::is_convertible;
+
+#else
 
 template<typename From, typename To>
 struct is_convertible_impl
 {
 private:
   struct any_conversion
   {
     template <typename T> any_conversion(const volatile T&);
     template <typename T> any_conversion(T&);
   };
   struct yes {int a[1];};
   struct no  {int a[2];};
 
-  static yes test(const To&, int);
+  template<typename T>
+  static yes test(T, int);
+
+  template<typename T>
   static no  test(any_conversion, ...);
 
 public:
-  static From ms_from;
+  static typename internal::remove_reference<From>::type* ms_from;
 #ifdef __INTEL_COMPILER
   #pragma warning push
   #pragma warning ( disable : 2259 )
 #endif
-  enum { value = sizeof(test(ms_from, 0))==sizeof(yes) };
+  enum { value = sizeof(test<To>(*ms_from, 0))==sizeof(yes) };
 #ifdef __INTEL_COMPILER
   #pragma warning pop
 #endif
 };
 
 template<typename From, typename To>
 struct is_convertible
 {
-  enum { value = is_convertible_impl<typename remove_all<From>::type,
-                                     typename remove_all<To  >::type>::value };
+  enum { value = is_convertible_impl<From,To>::value };
 };
 
+template<typename T>
+struct is_convertible<T,T&> { enum { value = false }; };
+
+template<typename T>
+struct is_convertible<const T,const T&> { enum { value = true }; };
+
+#endif
+
 /** \internal Allows to enable/disable an overload
   * according to a compile time condition.
   */
 template<bool Condition, typename T=void> struct enable_if;
 
 template<typename T> struct enable_if<true,T>
 { typedef T type; };
 
-#if defined(__CUDA_ARCH__)
+#if defined(EIGEN_GPU_COMPILE_PHASE) && !EIGEN_HAS_CXX11
 #if !defined(__FLT_EPSILON__)
 #define __FLT_EPSILON__ FLT_EPSILON
 #define __DBL_EPSILON__ DBL_EPSILON
 #endif
 
 namespace device {
 
 template<typename T> struct numeric_limits
 {
   EIGEN_DEVICE_FUNC
-  static T epsilon() { return 0; }
+  static EIGEN_CONSTEXPR T epsilon() { return 0; }
   static T (max)() { assert(false && "Highest not supported for this type"); }
   static T (min)() { assert(false && "Lowest not supported for this type"); }
   static T infinity() { assert(false && "Infinity not supported for this type"); }
   static T quiet_NaN() { assert(false && "quiet_NaN not supported for this type"); }
 };
 template<> struct numeric_limits<float>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static float epsilon() { return __FLT_EPSILON__; }
   EIGEN_DEVICE_FUNC
-  static float (max)() { return CUDART_MAX_NORMAL_F; }
-  EIGEN_DEVICE_FUNC
+  static float (max)() {
+  #if defined(EIGEN_CUDA_ARCH)
+    return CUDART_MAX_NORMAL_F;
+  #else
+    return HIPRT_MAX_NORMAL_F;
+  #endif
+  }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static float (min)() { return FLT_MIN; }
   EIGEN_DEVICE_FUNC
-  static float infinity() { return CUDART_INF_F; }
-  EIGEN_DEVICE_FUNC
-  static float quiet_NaN() { return CUDART_NAN_F; }
+  static float infinity() {
+  #if defined(EIGEN_CUDA_ARCH)
+    return CUDART_INF_F;
+  #else
+    return HIPRT_INF_F;
+  #endif
+  }
+  EIGEN_DEVICE_FUNC
+  static float quiet_NaN() {
+  #if defined(EIGEN_CUDA_ARCH)
+    return CUDART_NAN_F;
+  #else
+    return HIPRT_NAN_F;
+  #endif
+  }
 };
 template<> struct numeric_limits<double>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static double epsilon() { return __DBL_EPSILON__; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static double (max)() { return DBL_MAX; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static double (min)() { return DBL_MIN; }
   EIGEN_DEVICE_FUNC
-  static double infinity() { return CUDART_INF; }
-  EIGEN_DEVICE_FUNC
-  static double quiet_NaN() { return CUDART_NAN; }
+  static double infinity() {
+  #if defined(EIGEN_CUDA_ARCH)
+    return CUDART_INF;
+  #else
+    return HIPRT_INF;
+  #endif
+  }
+  EIGEN_DEVICE_FUNC
+  static double quiet_NaN() {
+  #if defined(EIGEN_CUDA_ARCH)
+    return CUDART_NAN;
+  #else
+    return HIPRT_NAN;
+  #endif
+  }
 };
 template<> struct numeric_limits<int>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static int epsilon() { return 0; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static int (max)() { return INT_MAX; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static int (min)() { return INT_MIN; }
 };
 template<> struct numeric_limits<unsigned int>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned int epsilon() { return 0; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned int (max)() { return UINT_MAX; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned int (min)() { return 0; }
 };
 template<> struct numeric_limits<long>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static long epsilon() { return 0; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static long (max)() { return LONG_MAX; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static long (min)() { return LONG_MIN; }
 };
 template<> struct numeric_limits<unsigned long>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned long epsilon() { return 0; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned long (max)() { return ULONG_MAX; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned long (min)() { return 0; }
 };
 template<> struct numeric_limits<long long>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static long long epsilon() { return 0; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static long long (max)() { return LLONG_MAX; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static long long (min)() { return LLONG_MIN; }
 };
 template<> struct numeric_limits<unsigned long long>
 {
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned long long epsilon() { return 0; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned long long (max)() { return ULLONG_MAX; }
-  EIGEN_DEVICE_FUNC
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
   static unsigned long long (min)() { return 0; }
 };
+template<> struct numeric_limits<bool>
+{
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  static bool epsilon() { return false; }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  static bool (max)() { return true; }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR 
+  static bool (min)() { return false; }
+};
 
 }
 
-#endif
+#endif // defined(EIGEN_GPU_COMPILE_PHASE) && !EIGEN_HAS_CXX11
 
 /** \internal
-  * A base class do disable default copy ctor and copy assignement operator.
+  * A base class do disable default copy ctor and copy assignment operator.
   */
 class noncopyable
 {
   EIGEN_DEVICE_FUNC noncopyable(const noncopyable&);
   EIGEN_DEVICE_FUNC const noncopyable& operator=(const noncopyable&);
 protected:
   EIGEN_DEVICE_FUNC noncopyable() {}
   EIGEN_DEVICE_FUNC ~noncopyable() {}
 };
 
 /** \internal
-  * Convenient struct to get the result type of a unary or binary functor.
+  * Provides access to the number of elements in the object of as a compile-time constant expression.
+  * It "returns" Eigen::Dynamic if the size cannot be resolved at compile-time (default).
+  *
+  * Similar to std::tuple_size, but more general.
+  *
+  * It currently supports:
+  *  - any types T defining T::SizeAtCompileTime
+  *  - plain C arrays as T[N]
+  *  - std::array (c++11)
+  *  - some internal types such as SingleRange and AllRange
+  *
+  * The second template parameter eases SFINAE-based specializations.
+  */
+template<typename T, typename EnableIf = void> struct array_size {
+  enum { value = Dynamic };
+};
+
+template<typename T> struct array_size<T,typename internal::enable_if<((T::SizeAtCompileTime&0)==0)>::type> {
+  enum { value = T::SizeAtCompileTime };
+};
+
+template<typename T, int N> struct array_size<const T (&)[N]> {
+  enum { value = N };
+};
+template<typename T, int N> struct array_size<T (&)[N]> {
+  enum { value = N };
+};
+
+#if EIGEN_HAS_CXX11
+template<typename T, std::size_t N> struct array_size<const std::array<T,N> > {
+  enum { value = N };
+};
+template<typename T, std::size_t N> struct array_size<std::array<T,N> > {
+  enum { value = N };
+};
+#endif
+
+/** \internal
+  * Analogue of the std::size free function.
+  * It returns the size of the container or view \a x of type \c T
+  *
+  * It currently supports:
+  *  - any types T defining a member T::size() const
+  *  - plain C arrays as T[N]
   *
-  * It supports both the current STL mechanism (using the result_type member) as well as
-  * upcoming next STL generation (using a templated result member).
-  * If none of these members is provided, then the type of the first argument is returned. FIXME, that behavior is a pretty bad hack.
   */
-#if EIGEN_HAS_STD_RESULT_OF
+template<typename T>
+EIGEN_CONSTEXPR Index size(const T& x) { return x.size(); }
+
+template<typename T,std::size_t N>
+EIGEN_CONSTEXPR Index size(const T (&) [N]) { return N; }
+
+/** \internal
+  * Convenient struct to get the result type of a nullary, unary, binary, or
+  * ternary functor.
+  * 
+  * Pre C++11:
+  * Supports both a Func::result_type member and templated
+  * Func::result<Func(ArgTypes...)>::type member.
+  * 
+  * If none of these members is provided, then the type of the first
+  * argument is returned.
+  * 
+  * Post C++11:
+  * This uses std::result_of. However, note the `type` member removes
+  * const and converts references/pointers to their corresponding value type.
+  */
+#if EIGEN_HAS_STD_INVOKE_RESULT
+template<typename T> struct result_of;
+
+template<typename F, typename... ArgTypes>
+struct result_of<F(ArgTypes...)> {
+  typedef typename std::invoke_result<F, ArgTypes...>::type type1;
+  typedef typename remove_all<type1>::type type;
+};
+#elif EIGEN_HAS_STD_RESULT_OF
 template<typename T> struct result_of {
   typedef typename std::result_of<T>::type type1;
   typedef typename remove_all<type1>::type type;
 };
 #else
 template<typename T> struct result_of { };
 
 struct has_none {int a[1];};
 struct has_std_result_type {int a[2];};
 struct has_tr1_result {int a[3];};
 
+template<typename Func, int SizeOf>
+struct nullary_result_of_select {};
+
+template<typename Func>
+struct nullary_result_of_select<Func, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};
+
+template<typename Func>
+struct nullary_result_of_select<Func, sizeof(has_tr1_result)> {typedef typename Func::template result<Func()>::type type;};
+
+template<typename Func>
+struct result_of<Func()> {
+    template<typename T>
+    static has_std_result_type    testFunctor(T const *, typename T::result_type const * = 0);
+    template<typename T>
+    static has_tr1_result         testFunctor(T const *, typename T::template result<T()>::type const * = 0);
+    static has_none               testFunctor(...);
+
+    // note that the following indirection is needed for gcc-3.3
+    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};
+    typedef typename nullary_result_of_select<Func, FunctorType>::type type;
+};
+
 template<typename Func, typename ArgType, int SizeOf=sizeof(has_none)>
 struct unary_result_of_select {typedef typename internal::remove_all<ArgType>::type type;};
 
 template<typename Func, typename ArgType>
 struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};
 
 template<typename Func, typename ArgType>
@@ -384,27 +603,66 @@
     static has_tr1_result         testFunctor(T const *, typename T::template result<T(ArgType0,ArgType1,ArgType2)>::type const * = 0);
     static has_none               testFunctor(...);
 
     // note that the following indirection is needed for gcc-3.3
     enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};
     typedef typename ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, FunctorType>::type type;
 };
+
+#endif
+
+#if EIGEN_HAS_STD_INVOKE_RESULT
+template<typename F, typename... ArgTypes>
+struct invoke_result {
+  typedef typename std::invoke_result<F, ArgTypes...>::type type1;
+  typedef typename remove_all<type1>::type type;
+};
+#elif EIGEN_HAS_CXX11
+template<typename F, typename... ArgTypes>
+struct invoke_result {
+  typedef typename result_of<F(ArgTypes...)>::type type1;
+  typedef typename remove_all<type1>::type type;
+};
+#else
+template<typename F, typename ArgType0 = void, typename ArgType1 = void, typename ArgType2 = void>
+struct invoke_result {
+  typedef typename result_of<F(ArgType0, ArgType1, ArgType2)>::type type1;
+  typedef typename remove_all<type1>::type type;
+};
+
+template<typename F>
+struct invoke_result<F, void, void, void> {
+  typedef typename result_of<F()>::type type1;
+  typedef typename remove_all<type1>::type type;
+};
+
+template<typename F, typename ArgType0>
+struct invoke_result<F, ArgType0, void, void> {
+  typedef typename result_of<F(ArgType0)>::type type1;
+  typedef typename remove_all<type1>::type type;
+};
+
+template<typename F, typename ArgType0, typename ArgType1>
+struct invoke_result<F, ArgType0, ArgType1, void> {
+  typedef typename result_of<F(ArgType0, ArgType1)>::type type1;
+  typedef typename remove_all<type1>::type type;
+};
 #endif
 
 struct meta_yes { char a[1]; };
 struct meta_no  { char a[2]; };
 
 // Check whether T::ReturnType does exist
 template <typename T>
 struct has_ReturnType
 {
-  template <typename C> static meta_yes testFunctor(typename C::ReturnType const *);
-  template <typename C> static meta_no testFunctor(...);
+  template <typename C> static meta_yes testFunctor(C const *, typename C::ReturnType const * = 0);
+  template <typename C> static meta_no  testFunctor(...);
 
-  enum { value = sizeof(testFunctor<T>(0)) == sizeof(meta_yes) };
+  enum { value = sizeof(testFunctor<T>(static_cast<T*>(0))) == sizeof(meta_yes) };
 };
 
 template<typename T> const T* return_ptr();
 
 template <typename T, typename IndexType=Index>
 struct has_nullary_operator
 {
@@ -453,82 +711,102 @@
 };
 
 template<int Y, int InfX, int SupX>
 class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };
 
 
 /** \internal Computes the least common multiple of two positive integer A and B
-  * at compile-time. It implements a naive algorithm testing all multiples of A.
-  * It thus works better if A>=B.
+  * at compile-time. 
   */
-template<int A, int B, int K=1, bool Done = ((A*K)%B)==0>
+template<int A, int B, int K=1, bool Done = ((A*K)%B)==0, bool Big=(A>=B)>
 struct meta_least_common_multiple
 {
   enum { ret = meta_least_common_multiple<A,B,K+1>::ret };
 };
+template<int A, int B, int K, bool Done>
+struct meta_least_common_multiple<A,B,K,Done,false>
+{
+  enum { ret = meta_least_common_multiple<B,A,K>::ret };
+};
 template<int A, int B, int K>
-struct meta_least_common_multiple<A,B,K,true>
+struct meta_least_common_multiple<A,B,K,true,true>
 {
   enum { ret = A*K };
 };
 
+
 /** \internal determines whether the product of two numeric types is allowed and what the return type is */
 template<typename T, typename U> struct scalar_product_traits
 {
   enum { Defined = 0 };
 };
 
 // FIXME quick workaround around current limitation of result_of
 // template<typename Scalar, typename ArgType0, typename ArgType1>
 // struct result_of<scalar_product_op<Scalar>(ArgType0,ArgType1)> {
 // typedef typename scalar_product_traits<typename remove_all<ArgType0>::type, typename remove_all<ArgType1>::type>::ReturnType type;
 // };
 
+/** \internal Obtains a POD type suitable to use as storage for an object of a size
+  * of at most Len bytes, aligned as specified by \c Align.
+  */
+template<unsigned Len, unsigned Align>
+struct aligned_storage {
+  struct type {
+    EIGEN_ALIGN_TO_BOUNDARY(Align) unsigned char data[Len];
+  };
+};
+
 } // end namespace internal
 
 namespace numext {
-  
-#if defined(__CUDA_ARCH__)
+
+#if defined(EIGEN_GPU_COMPILE_PHASE)
 template<typename T> EIGEN_DEVICE_FUNC   void swap(T &a, T &b) { T tmp = b; b = a; a = tmp; }
 #else
 template<typename T> EIGEN_STRONG_INLINE void swap(T &a, T &b) { std::swap(a,b); }
 #endif
 
-#if defined(__CUDA_ARCH__)
+#if defined(EIGEN_GPU_COMPILE_PHASE) && !EIGEN_HAS_CXX11
 using internal::device::numeric_limits;
 #else
 using std::numeric_limits;
 #endif
 
 // Integer division with rounding up.
 // T is assumed to be an integer type with a>=0, and b>0
 template<typename T>
+EIGEN_DEVICE_FUNC
 T div_ceil(const T &a, const T &b)
 {
   return (a+b-1) / b;
 }
 
 // The aim of the following functions is to bypass -Wfloat-equal warnings
 // when we really want a strict equality comparison on floating points.
-template<typename X, typename Y> EIGEN_STRONG_INLINE
+template<typename X, typename Y> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC
 bool equal_strict(const X& x,const Y& y) { return x == y; }
 
-template<> EIGEN_STRONG_INLINE
+#if !defined(EIGEN_GPU_COMPILE_PHASE) || (!defined(EIGEN_CUDA_ARCH) && defined(EIGEN_CONSTEXPR_ARE_DEVICE_FUNC))
+template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC
 bool equal_strict(const float& x,const float& y) { return std::equal_to<float>()(x,y); }
 
-template<> EIGEN_STRONG_INLINE
+template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC
 bool equal_strict(const double& x,const double& y) { return std::equal_to<double>()(x,y); }
+#endif
 
-template<typename X, typename Y> EIGEN_STRONG_INLINE
+template<typename X, typename Y> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC
 bool not_equal_strict(const X& x,const Y& y) { return x != y; }
 
-template<> EIGEN_STRONG_INLINE
+#if !defined(EIGEN_GPU_COMPILE_PHASE) || (!defined(EIGEN_CUDA_ARCH) && defined(EIGEN_CONSTEXPR_ARE_DEVICE_FUNC))
+template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC
 bool not_equal_strict(const float& x,const float& y) { return std::not_equal_to<float>()(x,y); }
 
-template<> EIGEN_STRONG_INLINE
+template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC
 bool not_equal_strict(const double& x,const double& y) { return std::not_equal_to<double>()(x,y); }
+#endif
 
 } // end namespace numext
 
 } // end namespace Eigen
 
 #endif // EIGEN_META_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/ReenableStupidWarnings.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/ReenableStupidWarnings.h`

 * *Files 17% similar despite different names*

```diff
@@ -1,8 +1,12 @@
-#ifdef EIGEN_WARNINGS_DISABLED
+#ifdef EIGEN_WARNINGS_DISABLED_2
+// "DisableStupidWarnings.h" was included twice recursively: Do not reenable warnings yet!
+#  undef EIGEN_WARNINGS_DISABLED_2
+
+#elif defined(EIGEN_WARNINGS_DISABLED)
 #undef EIGEN_WARNINGS_DISABLED
 
 #ifndef EIGEN_PERMANENTLY_DISABLE_STUPID_WARNINGS
   #ifdef _MSC_VER
     #pragma warning( pop )
   #elif defined __INTEL_COMPILER
     #pragma warning pop
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/StaticAssert.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/StaticAssert.h`

 * *Files 4% similar despite different names*

```diff
@@ -23,15 +23,15 @@
  *  - currently EIGEN_STATIC_ASSERT can only be used in function scope
  *
  */
 
 #ifndef EIGEN_STATIC_ASSERT
 #ifndef EIGEN_NO_STATIC_ASSERT
 
-  #if EIGEN_MAX_CPP_VER>=11 && (__has_feature(cxx_static_assert) || (defined(__cplusplus) && __cplusplus >= 201103L) || (EIGEN_COMP_MSVC >= 1600))
+  #if EIGEN_MAX_CPP_VER>=11 && (__has_feature(cxx_static_assert) || (EIGEN_COMP_CXXVER >= 11) || (EIGEN_COMP_MSVC >= 1600))
 
     // if native static_assert is enabled, let's use it
     #define EIGEN_STATIC_ASSERT(X,MSG) static_assert(X,#MSG);
 
   #else // not CXX0X
 
     namespace Eigen {
@@ -99,15 +99,18 @@
         EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT__INVALID_COST_VALUE=1,
         THIS_COEFFICIENT_ACCESSOR_TAKING_ONE_ACCESS_IS_ONLY_FOR_EXPRESSIONS_ALLOWING_LINEAR_ACCESS=1,
         MATRIX_FREE_CONJUGATE_GRADIENT_IS_COMPATIBLE_WITH_UPPER_UNION_LOWER_MODE_ONLY=1,
         THIS_TYPE_IS_NOT_SUPPORTED=1,
         STORAGE_KIND_MUST_MATCH=1,
         STORAGE_INDEX_MUST_MATCH=1,
         CHOLMOD_SUPPORTS_DOUBLE_PRECISION_ONLY=1,
-        SELFADJOINTVIEW_ACCEPTS_UPPER_AND_LOWER_MODE_ONLY=1
+        SELFADJOINTVIEW_ACCEPTS_UPPER_AND_LOWER_MODE_ONLY=1,
+        INVALID_TEMPLATE_PARAMETER=1,
+        GPU_TENSOR_CONTRACTION_DOES_NOT_SUPPORT_OUTPUT_KERNELS=1,
+        THE_ARRAY_SIZE_SHOULD_EQUAL_WITH_PACKET_SIZE=1
       };
     };
 
     } // end namespace internal
 
     } // end namespace Eigen
 
@@ -178,26 +181,26 @@
       &&  (int(TYPE0::ColsAtCompileTime)==Eigen::Dynamic \
         || int(TYPE1::ColsAtCompileTime)==Eigen::Dynamic \
         || int(TYPE0::ColsAtCompileTime)==int(TYPE1::ColsAtCompileTime))\
        ) \
      )
 
 #define EIGEN_STATIC_ASSERT_NON_INTEGER(TYPE) \
-    EIGEN_STATIC_ASSERT(!NumTraits<TYPE>::IsInteger, THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES)
+    EIGEN_STATIC_ASSERT(!Eigen::NumTraits<TYPE>::IsInteger, THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES)
 
 
 // static assertion failing if it is guaranteed at compile-time that the two matrix expression types have different sizes
 #define EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(TYPE0,TYPE1) \
   EIGEN_STATIC_ASSERT( \
      EIGEN_PREDICATE_SAME_MATRIX_SIZE(TYPE0,TYPE1),\
     YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES)
 
 #define EIGEN_STATIC_ASSERT_SIZE_1x1(TYPE) \
-      EIGEN_STATIC_ASSERT((TYPE::RowsAtCompileTime == 1 || TYPE::RowsAtCompileTime == Dynamic) && \
-                          (TYPE::ColsAtCompileTime == 1 || TYPE::ColsAtCompileTime == Dynamic), \
+      EIGEN_STATIC_ASSERT((TYPE::RowsAtCompileTime == 1 || TYPE::RowsAtCompileTime == Eigen::Dynamic) && \
+                          (TYPE::ColsAtCompileTime == 1 || TYPE::ColsAtCompileTime == Eigen::Dynamic), \
                           THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS)
 
 #define EIGEN_STATIC_ASSERT_LVALUE(Derived) \
       EIGEN_STATIC_ASSERT(Eigen::internal::is_lvalue<Derived>::value, \
                           THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY)
 
 #define EIGEN_STATIC_ASSERT_ARRAYXPR(Derived) \
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Core/util/XprHelper.h` & `chronogram-0.2.0/include/Eigen/src/Core/util/XprHelper.h`

 * *Files 3% similar despite different names*

```diff
@@ -30,14 +30,34 @@
 EIGEN_DEVICE_FUNC
 inline IndexDest convert_index(const IndexSrc& idx) {
   // for sizeof(IndexDest)>=sizeof(IndexSrc) compilers should be able to optimize this away:
   eigen_internal_assert(idx <= NumTraits<IndexDest>::highest() && "Index value to big for target type");
   return IndexDest(idx);
 }
 
+// true if T can be considered as an integral index (i.e., and integral type or enum)
+template<typename T> struct is_valid_index_type
+{
+  enum { value =
+#if EIGEN_HAS_TYPE_TRAITS
+    internal::is_integral<T>::value || std::is_enum<T>::value
+#elif EIGEN_COMP_MSVC
+    internal::is_integral<T>::value || __is_enum(T)
+#else
+    // without C++11, we use is_convertible to Index instead of is_integral in order to treat enums as Index.
+    internal::is_convertible<T,Index>::value && !internal::is_same<T,float>::value && !is_same<T,double>::value
+#endif
+  };
+};
+
+// true if both types are not valid index types
+template<typename RowIndices, typename ColIndices>
+struct valid_indexed_view_overload {
+  enum { value = !(internal::is_valid_index_type<RowIndices>::value && internal::is_valid_index_type<ColIndices>::value) };
+};
 
 // promote_scalar_arg is an helper used in operation between an expression and a scalar, like:
 //    expression * scalar
 // Its role is to determine how the type T of the scalar operand should be promoted given the scalar type ExprScalar of the given expression.
 // The IsSupported template parameter must be provided by the caller as: internal::has_ReturnType<ScalarBinaryOpTraits<ExprScalar,T,op> >::value using the proper order for ExprScalar and T.
 // Then the logic is as follows:
 //  - if the operation is natively supported as defined by IsSupported, then the scalar type is not promoted, and T is returned.
@@ -86,14 +106,17 @@
 struct promote_scalar_arg_unsupported<S,T,S,false,true> {};
 
 //classes inheriting no_assignment_operator don't generate a default operator=.
 class no_assignment_operator
 {
   private:
     no_assignment_operator& operator=(const no_assignment_operator&);
+  protected:
+    EIGEN_DEFAULT_COPY_CONSTRUCTOR(no_assignment_operator)
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(no_assignment_operator)
 };
 
 /** \internal return the index type with the largest number of bits */
 template<typename I1, typename I2>
 struct promote_index_type
 {
   typedef typename conditional<(sizeof(I1)<sizeof(I2)), I2, I1>::type type;
@@ -102,39 +125,45 @@
 /** \internal If the template parameter Value is Dynamic, this class is just a wrapper around a T variable that
   * can be accessed using value() and setValue().
   * Otherwise, this class is an empty structure and value() just returns the template parameter Value.
   */
 template<typename T, int Value> class variable_if_dynamic
 {
   public:
-    EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamic)
+    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(variable_if_dynamic)
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T v) { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }
-    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T value() { return T(Value); }
-    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T) {}
+    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    T value() { return T(Value); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    operator T() const { return T(Value); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    void setValue(T v) const { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }
 };
 
 template<typename T> class variable_if_dynamic<T, Dynamic>
 {
     T m_value;
-    EIGEN_DEVICE_FUNC variable_if_dynamic() { eigen_assert(false); }
   public:
-    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T value) : m_value(value) {}
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamic(T value = 0) EIGEN_NO_THROW : m_value(value) {}
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T value() const { return m_value; }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE operator T() const { return m_value; }
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T value) { m_value = value; }
 };
 
 /** \internal like variable_if_dynamic but for DynamicIndex
   */
 template<typename T, int Value> class variable_if_dynamicindex
 {
   public:
     EIGEN_EMPTY_STRUCT_CTOR(variable_if_dynamicindex)
     EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit variable_if_dynamicindex(T v) { EIGEN_ONLY_USED_FOR_DEBUG(v); eigen_assert(v == T(Value)); }
-    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE T value() { return T(Value); }
-    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void setValue(T) {}
+    EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE EIGEN_CONSTEXPR
+    T value() { return T(Value); }
+    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+    void setValue(T) {}
 };
 
 template<typename T> class variable_if_dynamicindex<T, DynamicIndex>
 {
     T m_value;
     EIGEN_DEVICE_FUNC variable_if_dynamicindex() { eigen_assert(false); }
   public:
@@ -151,24 +180,15 @@
     PacketAccess = false,
     IsRepeatable = false
   };
 };
 
 template<typename T> struct packet_traits;
 
-template<typename T> struct unpacket_traits
-{
-  typedef T type;
-  typedef T half;
-  enum
-  {
-    size = 1,
-    alignment = 1
-  };
-};
+template<typename T> struct unpacket_traits;
 
 template<int Size, typename PacketType,
          bool Stop = Size==Dynamic || (Size%unpacket_traits<PacketType>::size)==0 || is_same<PacketType,typename unpacket_traits<PacketType>::half>::value>
 struct find_best_packet_helper;
 
 template< int Size, typename PacketType>
 struct find_best_packet_helper<Size,PacketType,true>
@@ -379,15 +399,15 @@
          Cols = traits<T>::ColsAtCompileTime,
          MaxRows = traits<T>::MaxRowsAtCompileTime,
          MaxCols = traits<T>::MaxColsAtCompileTime
   };
   typedef Matrix<typename traits<T>::Scalar,
                 Rows,
                 Cols,
-                (MaxCols==1&&MaxRows!=1) ? RowMajor : ColMajor,
+                (MaxCols==1&&MaxRows!=1) ? ColMajor : RowMajor,
                 MaxRows,
                 MaxCols
           > type;
 };
 
 /** \internal The reference selector for template expressions. The idea is that we don't
   * need to use references for expressions since they are light weight proxy
@@ -396,15 +416,15 @@
 struct ref_selector
 {
   typedef typename conditional<
     bool(traits<T>::Flags & NestByRefBit),
     T const&,
     const T
   >::type type;
-  
+
   typedef typename conditional<
     bool(traits<T>::Flags & NestByRefBit),
     T &,
     T
   >::type non_const_type;
 };
 
@@ -434,15 +454,15 @@
   * \tparam n the number of coefficient accesses in the nested expression for each coefficient access in the bigger expression.
   * \tparam PlainObject the type of the temporary if needed.
   */
 template<typename T, int n, typename PlainObject = typename plain_object_eval<T>::type> struct nested_eval
 {
   enum {
     ScalarReadCost = NumTraits<typename traits<T>::Scalar>::ReadCost,
-    CoeffReadCost = evaluator<T>::CoeffReadCost,  // NOTE What if an evaluator evaluate itself into a tempory?
+    CoeffReadCost = evaluator<T>::CoeffReadCost,  // NOTE What if an evaluator evaluate itself into a temporary?
                                                   //      Then CoeffReadCost will be small (e.g., 1) but we still have to evaluate, especially if n>1.
                                                   //      This situation is already taken care by the EvalBeforeNestingBit flag, which is turned ON
                                                   //      for all evaluator creating a temporary. This flag is then propagated by the parent evaluators.
                                                   //      Another solution could be to count the number of temps?
     NAsInteger = n == Dynamic ? HugeCost : n,
     CostEval   = (NAsInteger+1) * ScalarReadCost + CoeffReadCost,
     CostNoEval = NAsInteger * CoeffReadCost,
@@ -575,37 +595,37 @@
 /** \internal gives the plain matrix or array type to store a row/column/diagonal of a matrix type.
   * \tparam Scalar optional parameter allowing to pass a different scalar type than the one of the MatrixType.
   */
 template<typename ExpressionType, typename Scalar = typename ExpressionType::Scalar>
 struct plain_row_type
 {
   typedef Matrix<Scalar, 1, ExpressionType::ColsAtCompileTime,
-                 ExpressionType::PlainObject::Options | RowMajor, 1, ExpressionType::MaxColsAtCompileTime> MatrixRowType;
+                 int(ExpressionType::PlainObject::Options) | int(RowMajor), 1, ExpressionType::MaxColsAtCompileTime> MatrixRowType;
   typedef Array<Scalar, 1, ExpressionType::ColsAtCompileTime,
-                 ExpressionType::PlainObject::Options | RowMajor, 1, ExpressionType::MaxColsAtCompileTime> ArrayRowType;
+                 int(ExpressionType::PlainObject::Options) | int(RowMajor), 1, ExpressionType::MaxColsAtCompileTime> ArrayRowType;
 
   typedef typename conditional<
     is_same< typename traits<ExpressionType>::XprKind, MatrixXpr >::value,
     MatrixRowType,
-    ArrayRowType 
+    ArrayRowType
   >::type type;
 };
 
 template<typename ExpressionType, typename Scalar = typename ExpressionType::Scalar>
 struct plain_col_type
 {
   typedef Matrix<Scalar, ExpressionType::RowsAtCompileTime, 1,
                  ExpressionType::PlainObject::Options & ~RowMajor, ExpressionType::MaxRowsAtCompileTime, 1> MatrixColType;
   typedef Array<Scalar, ExpressionType::RowsAtCompileTime, 1,
                  ExpressionType::PlainObject::Options & ~RowMajor, ExpressionType::MaxRowsAtCompileTime, 1> ArrayColType;
 
   typedef typename conditional<
     is_same< typename traits<ExpressionType>::XprKind, MatrixXpr >::value,
     MatrixColType,
-    ArrayColType 
+    ArrayColType
   >::type type;
 };
 
 template<typename ExpressionType, typename Scalar = typename ExpressionType::Scalar>
 struct plain_diag_type
 {
   enum { diag_size = EIGEN_SIZE_MIN_PREFER_DYNAMIC(ExpressionType::RowsAtCompileTime, ExpressionType::ColsAtCompileTime),
@@ -613,15 +633,15 @@
   };
   typedef Matrix<Scalar, diag_size, 1, ExpressionType::PlainObject::Options & ~RowMajor, max_diag_size, 1> MatrixDiagType;
   typedef Array<Scalar, diag_size, 1, ExpressionType::PlainObject::Options & ~RowMajor, max_diag_size, 1> ArrayDiagType;
 
   typedef typename conditional<
     is_same< typename traits<ExpressionType>::XprKind, MatrixXpr >::value,
     MatrixDiagType,
-    ArrayDiagType 
+    ArrayDiagType
   >::type type;
 };
 
 template<typename Expr,typename Scalar = typename Expr::Scalar>
 struct plain_constant_type
 {
   enum { Options = (traits<Expr>::Flags&RowMajorBit)?RowMajor:0 };
@@ -650,32 +670,47 @@
 
 template<typename T> struct is_diagonal<DiagonalWrapper<T> >
 { enum { ret = true }; };
 
 template<typename T, int S> struct is_diagonal<DiagonalMatrix<T,S> >
 { enum { ret = true }; };
 
+
+template<typename T> struct is_identity
+{ enum { value = false }; };
+
+template<typename T> struct is_identity<CwiseNullaryOp<internal::scalar_identity_op<typename T::Scalar>, T> >
+{ enum { value = true }; };
+
+
 template<typename S1, typename S2> struct glue_shapes;
 template<> struct glue_shapes<DenseShape,TriangularShape> { typedef TriangularShape type;  };
 
 template<typename T1, typename T2>
-bool is_same_dense(const T1 &mat1, const T2 &mat2, typename enable_if<has_direct_access<T1>::ret&&has_direct_access<T2>::ret, T1>::type * = 0)
+struct possibly_same_dense {
+  enum { value = has_direct_access<T1>::ret && has_direct_access<T2>::ret && is_same<typename T1::Scalar,typename T2::Scalar>::value };
+};
+
+template<typename T1, typename T2>
+EIGEN_DEVICE_FUNC
+bool is_same_dense(const T1 &mat1, const T2 &mat2, typename enable_if<possibly_same_dense<T1,T2>::value>::type * = 0)
 {
   return (mat1.data()==mat2.data()) && (mat1.innerStride()==mat2.innerStride()) && (mat1.outerStride()==mat2.outerStride());
 }
 
 template<typename T1, typename T2>
-bool is_same_dense(const T1 &, const T2 &, typename enable_if<!(has_direct_access<T1>::ret&&has_direct_access<T2>::ret), T1>::type * = 0)
+EIGEN_DEVICE_FUNC
+bool is_same_dense(const T1 &, const T2 &, typename enable_if<!possibly_same_dense<T1,T2>::value>::type * = 0)
 {
   return false;
 }
 
 // Internal helper defining the cost of a scalar division for the type T.
 // The default heuristic can be specialized for each scalar type and architecture.
-template<typename T,bool Vectorized=false,typename EnaleIf = void>
+template<typename T,bool Vectorized=false,typename EnableIf = void>
 struct scalar_div_cost {
   enum { value = 8*NumTraits<T>::MulCost };
 };
 
 template<typename T,bool Vectorized>
 struct scalar_div_cost<std::complex<T>, Vectorized> {
   enum { value = 2*scalar_div_cost<T>::value
@@ -714,15 +749,15 @@
   if(f&RowMajorBit)                 res += " | RowMajor";
   if(f&PacketAccessBit)             res += " | Packet";
   if(f&LinearAccessBit)             res += " | Linear";
   if(f&LvalueBit)                   res += " | Lvalue";
   if(f&DirectAccessBit)             res += " | Direct";
   if(f&NestByRefBit)                res += " | NestByRef";
   if(f&NoPreferredStorageOrderBit)  res += " | NoPreferredStorageOrderBit";
-  
+
   return res;
 }
 #endif
 
 } // end namespace internal
 
 
@@ -811,11 +846,11 @@
 // We require Lhs and Rhs to have "compatible" scalar types.
 // It is tempting to always allow mixing different types but remember that this is often impossible in the vectorized paths.
 // So allowing mixing different types gives very unexpected errors when enabling vectorization, when the user tries to
 // add together a float matrix and a double matrix.
 #define EIGEN_CHECK_BINARY_COMPATIBILIY(BINOP,LHS,RHS) \
   EIGEN_STATIC_ASSERT((Eigen::internal::has_ReturnType<ScalarBinaryOpTraits<LHS, RHS,BINOP> >::value), \
     YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY)
-    
+
 } // end namespace Eigen
 
 #endif // EIGEN_XPRHELPER_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/ComplexEigenSolver.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/ComplexEigenSolver.h`

 * *Files 0% similar despite different names*

```diff
@@ -210,15 +210,15 @@
       * Output: \verbinclude ComplexEigenSolver_compute.out
       */
     template<typename InputType>
     ComplexEigenSolver& compute(const EigenBase<InputType>& matrix, bool computeEigenvectors = true);
 
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful, \c NoConvergence otherwise.
+      * \returns \c Success if computation was successful, \c NoConvergence otherwise.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "ComplexEigenSolver is not initialized.");
       return m_schur.info();
     }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/ComplexSchur.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/ComplexSchur.h`

 * *Files 1% similar despite different names*

```diff
@@ -208,15 +208,15 @@
      * \sa compute(const MatrixType&, bool)
      */
     template<typename HessMatrixType, typename OrthMatrixType>
     ComplexSchur& computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU=true);
 
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful, \c NoConvergence otherwise.
+      * \returns \c Success if computation was successful, \c NoConvergence otherwise.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "ComplexSchur is not initialized.");
       return m_info;
     }
 
@@ -296,18 +296,21 @@
   ComplexScalar b = t.coeff(0,1) * t.coeff(1,0);
   ComplexScalar c = t.coeff(0,0) - t.coeff(1,1);
   ComplexScalar disc = sqrt(c*c + RealScalar(4)*b);
   ComplexScalar det = t.coeff(0,0) * t.coeff(1,1) - b;
   ComplexScalar trace = t.coeff(0,0) + t.coeff(1,1);
   ComplexScalar eival1 = (trace + disc) / RealScalar(2);
   ComplexScalar eival2 = (trace - disc) / RealScalar(2);
-
-  if(numext::norm1(eival1) > numext::norm1(eival2))
+  RealScalar eival1_norm = numext::norm1(eival1);
+  RealScalar eival2_norm = numext::norm1(eival2);
+  // A division by zero can only occur if eival1==eival2==0.
+  // In this case, det==0, and all we have to do is checking that eival2_norm!=0
+  if(eival1_norm > eival2_norm)
     eival2 = det / eival1;
-  else
+  else if(eival2_norm!=RealScalar(0))
     eival1 = det / eival2;
 
   // choose the eigenvalue closest to the bottom entry of the diagonal
   if(numext::norm1(eival1-t.coeff(1,1)) < numext::norm1(eival2-t.coeff(1,1)))
     return normt * eival1;
   else
     return normt * eival2;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/ComplexSchur_LAPACKE.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/EigenSolver.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/EigenSolver.h`

 * *Files 0% similar despite different names*

```diff
@@ -106,15 +106,15 @@
     /** \brief Default constructor.
       *
       * The default constructor is useful in cases in which the user intends to
       * perform decompositions via EigenSolver::compute(const MatrixType&, bool).
       *
       * \sa compute() for an example.
       */
-    EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}
+    EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_eigenvectorsOk(false), m_realSchur(), m_matT(), m_tmp() {}
 
     /** \brief Default constructor with memory preallocation
       *
       * Like the default constructor but with preallocation of the internal data
       * according to the specified problem \a size.
       * \sa EigenSolver()
       */
@@ -273,15 +273,15 @@
       *
       * Example: \include EigenSolver_compute.cpp
       * Output: \verbinclude EigenSolver_compute.out
       */
     template<typename InputType>
     EigenSolver& compute(const EigenBase<InputType>& matrix, bool computeEigenvectors = true);
 
-    /** \returns NumericalIssue if the input contains INF or NaN values or overflow occured. Returns Success otherwise. */
+    /** \returns NumericalIssue if the input contains INF or NaN values or overflow occurred. Returns Success otherwise. */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "EigenSolver is not initialized.");
       return m_info;
     }
 
     /** \brief Sets the maximum number of iterations allowed. */
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/GeneralizedEigenSolver.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h`

 * *Files 0% similar despite different names*

```diff
@@ -117,15 +117,15 @@
       * \param[in]  matB  Positive-definite matrix in matrix pencil.
       *                   Only the lower triangular part of the matrix is referenced.
       * \param[in]  options A or-ed set of flags {#ComputeEigenvectors,#EigenvaluesOnly} | {#Ax_lBx,#ABx_lx,#BAx_lx}.
       *                     Default is #ComputeEigenvectors|#Ax_lBx.
       *
       * \returns    Reference to \c *this
       *
-      * Accoring to \p options, this function computes eigenvalues and (if requested)
+      * According to \p options, this function computes eigenvalues and (if requested)
       * the eigenvectors of one of the following three generalized eigenproblems:
       * - \c Ax_lBx: \f$ Ax = \lambda B x \f$
       * - \c ABx_lx: \f$ ABx = \lambda x \f$
       * - \c BAx_lx: \f$ BAx = \lambda x \f$
       * with \a matA the selfadjoint matrix \f$ A \f$ and \a matB the positive definite
       * matrix \f$ B \f$.
       * In addition, each eigenvector \f$ x \f$ satisfies the property \f$ x^* B x = 1 \f$.
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/HessenbergDecomposition.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/HessenbergDecomposition.h`

 * *Files 0% similar despite different names*

```diff
@@ -263,15 +263,15 @@
     {
       eigen_assert(m_isInitialized && "HessenbergDecomposition is not initialized.");
       return MatrixHReturnType(*this);
     }
 
   private:
 
-    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;
+    typedef Matrix<Scalar, 1, Size, int(Options) | int(RowMajor), 1, MaxSize> VectorType;
     typedef typename NumTraits<Scalar>::Real RealScalar;
     static void _compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp);
 
   protected:
     MatrixType m_matrix;
     CoeffVectorType m_hCoeffs;
     VectorType m_temp;
@@ -311,15 +311,15 @@
 
     // A = H A
     matA.bottomRightCorner(remainingSize, remainingSize)
         .applyHouseholderOnTheLeft(matA.col(i).tail(remainingSize-1), h, &temp.coeffRef(0));
 
     // A = A H'
     matA.rightCols(remainingSize)
-        .applyHouseholderOnTheRight(matA.col(i).tail(remainingSize-1).conjugate(), numext::conj(h), &temp.coeffRef(0));
+        .applyHouseholderOnTheRight(matA.col(i).tail(remainingSize-1), numext::conj(h), &temp.coeffRef(0));
   }
 }
 
 namespace internal {
 
 /** \eigenvalues_module \ingroup Eigenvalues_Module
   *
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h`

 * *Files 2% similar despite different names*

```diff
@@ -80,15 +80,15 @@
   *
   * Example: \include SelfAdjointView_eigenvalues.cpp
   * Output: \verbinclude SelfAdjointView_eigenvalues.out
   *
   * \sa SelfAdjointEigenSolver::eigenvalues(), MatrixBase::eigenvalues()
   */
 template<typename MatrixType, unsigned int UpLo> 
-inline typename SelfAdjointView<MatrixType, UpLo>::EigenvaluesReturnType
+EIGEN_DEVICE_FUNC inline typename SelfAdjointView<MatrixType, UpLo>::EigenvaluesReturnType
 SelfAdjointView<MatrixType, UpLo>::eigenvalues() const
 {
   PlainObject thisAsMatrix(*this);
   return SelfAdjointEigenSolver<PlainObject>(thisAsMatrix, false).eigenvalues();
 }
 
 
@@ -143,15 +143,15 @@
   *
   * Example: \include SelfAdjointView_operatorNorm.cpp
   * Output: \verbinclude SelfAdjointView_operatorNorm.out
   *
   * \sa eigenvalues(), MatrixBase::operatorNorm()
   */
 template<typename MatrixType, unsigned int UpLo>
-inline typename SelfAdjointView<MatrixType, UpLo>::RealScalar
+EIGEN_DEVICE_FUNC inline typename SelfAdjointView<MatrixType, UpLo>::RealScalar
 SelfAdjointView<MatrixType, UpLo>::operatorNorm() const
 {
   return eigenvalues().cwiseAbs().maxCoeff();
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/RealQZ.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/RealQZ.h`

 * *Files 1% similar despite different names*

```diff
@@ -86,16 +86,17 @@
       explicit RealQZ(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime) :
         m_S(size, size),
         m_T(size, size),
         m_Q(size, size),
         m_Z(size, size),
         m_workspace(size*2),
         m_maxIters(400),
-        m_isInitialized(false)
-        { }
+        m_isInitialized(false),
+        m_computeQZ(true)
+      {}
 
       /** \brief Constructor; computes real QZ decomposition of given matrices
        * 
        * \param[in]  A          Matrix A.
        * \param[in]  B          Matrix B.
        * \param[in]  computeQZ  If false, A and Z are not computed.
        *
@@ -104,17 +105,19 @@
       RealQZ(const MatrixType& A, const MatrixType& B, bool computeQZ = true) :
         m_S(A.rows(),A.cols()),
         m_T(A.rows(),A.cols()),
         m_Q(A.rows(),A.cols()),
         m_Z(A.rows(),A.cols()),
         m_workspace(A.rows()*2),
         m_maxIters(400),
-        m_isInitialized(false) {
-          compute(A, B, computeQZ);
-        }
+        m_isInitialized(false),
+        m_computeQZ(true)
+      {
+        compute(A, B, computeQZ);
+      }
 
       /** \brief Returns matrix Q in the QZ decomposition. 
        *
        * \returns A const reference to the matrix Q.
        */
       const MatrixType& matrixQ() const {
         eigen_assert(m_isInitialized && "RealQZ is not initialized.");
@@ -157,15 +160,15 @@
        * \param[in]  computeQZ  If false, A and Z are not computed.
        * \returns    Reference to \c *this
        */
       RealQZ& compute(const MatrixType& A, const MatrixType& B, bool computeQZ = true);
 
       /** \brief Reports whether previous computation was successful.
        *
-       * \returns \c Success if computation was succesful, \c NoConvergence otherwise.
+       * \returns \c Success if computation was successful, \c NoConvergence otherwise.
        */
       ComputationInfo info() const
       {
         eigen_assert(m_isInitialized && "RealQZ is not initialized.");
         return m_info;
       }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/RealSchur.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/RealSchur.h`

 * *Files 2% similar despite different names*

```diff
@@ -186,15 +186,15 @@
      * 
      * \sa compute(const MatrixType&, bool)
      */
     template<typename HessMatrixType, typename OrthMatrixType>
     RealSchur& computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU);
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful, \c NoConvergence otherwise.
+      * \returns \c Success if computation was successful, \c NoConvergence otherwise.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "RealSchur is not initialized.");
       return m_info;
     }
 
@@ -232,15 +232,15 @@
     bool m_isInitialized;
     bool m_matUisUptodate;
     Index m_maxIters;
 
     typedef Matrix<Scalar,3,1> Vector3s;
 
     Scalar computeNormOfT();
-    Index findSmallSubdiagEntry(Index iu);
+    Index findSmallSubdiagEntry(Index iu, const Scalar& considerAsZero);
     void splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift);
     void computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo);
     void initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector);
     void performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace);
 };
 
 
@@ -266,52 +266,61 @@
     m_matUisUptodate = computeU;
     return *this;
   }
 
   // Step 1. Reduce to Hessenberg form
   m_hess.compute(matrix.derived()/scale);
 
-  // Step 2. Reduce to real Schur form  
-  computeFromHessenberg(m_hess.matrixH(), m_hess.matrixQ(), computeU);
+  // Step 2. Reduce to real Schur form
+  // Note: we copy m_hess.matrixQ() into m_matU here and not in computeFromHessenberg
+  //       to be able to pass our working-space buffer for the Householder to Dense evaluation.
+  m_workspaceVector.resize(matrix.cols());
+  if(computeU)
+    m_hess.matrixQ().evalTo(m_matU, m_workspaceVector);
+  computeFromHessenberg(m_hess.matrixH(), m_matU, computeU);
 
   m_matT *= scale;
   
   return *this;
 }
 template<typename MatrixType>
 template<typename HessMatrixType, typename OrthMatrixType>
 RealSchur<MatrixType>& RealSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU)
 {
   using std::abs;
 
   m_matT = matrixH;
-  if(computeU)
+  m_workspaceVector.resize(m_matT.cols());
+  if(computeU && !internal::is_same_dense(m_matU,matrixQ))
     m_matU = matrixQ;
   
   Index maxIters = m_maxIters;
   if (maxIters == -1)
     maxIters = m_maxIterationsPerRow * matrixH.rows();
-  m_workspaceVector.resize(m_matT.cols());
   Scalar* workspace = &m_workspaceVector.coeffRef(0);
 
   // The matrix m_matT is divided in three parts. 
   // Rows 0,...,il-1 are decoupled from the rest because m_matT(il,il-1) is zero. 
   // Rows il,...,iu is the part we are working on (the active window).
   // Rows iu+1,...,end are already brought in triangular form.
   Index iu = m_matT.cols() - 1;
   Index iter = 0;      // iteration count for current eigenvalue
   Index totalIter = 0; // iteration count for whole matrix
   Scalar exshift(0);   // sum of exceptional shifts
   Scalar norm = computeNormOfT();
+  // sub-diagonal entries smaller than considerAsZero will be treated as zero.
+  // We use eps^2 to enable more precision in small eigenvalues.
+  Scalar considerAsZero = numext::maxi<Scalar>( norm * numext::abs2(NumTraits<Scalar>::epsilon()),
+                                                (std::numeric_limits<Scalar>::min)() );
 
   if(norm!=Scalar(0))
   {
     while (iu >= 0)
     {
-      Index il = findSmallSubdiagEntry(iu);
+      Index il = findSmallSubdiagEntry(iu,considerAsZero);
 
       // Check for convergence
       if (il == iu) // One root found
       {
         m_matT.coeffRef(iu,iu) = m_matT.coeff(iu,iu) + exshift;
         if (iu > 0)
           m_matT.coeffRef(iu, iu-1) = Scalar(0);
@@ -360,22 +369,25 @@
   for (Index j = 0; j < size; ++j)
     norm += m_matT.col(j).segment(0, (std::min)(size,j+2)).cwiseAbs().sum();
   return norm;
 }
 
 /** \internal Look for single small sub-diagonal element and returns its index */
 template<typename MatrixType>
-inline Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu)
+inline Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu, const Scalar& considerAsZero)
 {
   using std::abs;
   Index res = iu;
   while (res > 0)
   {
     Scalar s = abs(m_matT.coeff(res-1,res-1)) + abs(m_matT.coeff(res,res));
-    if (abs(m_matT.coeff(res,res-1)) <= NumTraits<Scalar>::epsilon() * s)
+
+    s = numext::maxi<Scalar>(s * NumTraits<Scalar>::epsilon(), considerAsZero);
+    
+    if (abs(m_matT.coeff(res,res-1)) <= s)
       break;
     res--;
   }
   return res;
 }
 
 /** \internal Update T given that rows iu-1 and iu decouple from the rest. */
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/RealSchur_LAPACKE.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/RealSchur_LAPACKE.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h`

 * *Files 4% similar despite different names*

```diff
@@ -16,15 +16,17 @@
 namespace Eigen { 
 
 template<typename _MatrixType>
 class GeneralizedSelfAdjointEigenSolver;
 
 namespace internal {
 template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues;
+
 template<typename MatrixType, typename DiagType, typename SubDiagType>
+EIGEN_DEVICE_FUNC
 ComputationInfo computeFromTridiagonal_impl(DiagType& diag, SubDiagType& subdiag, const Index maxIterations, bool computeEigenvectors, MatrixType& eivec);
 }
 
 /** \eigenvalues_module \ingroup Eigenvalues_Module
   *
   *
   * \class SelfAdjointEigenSolver
@@ -38,18 +40,22 @@
   * A matrix \f$ A \f$ is selfadjoint if it equals its adjoint. For real
   * matrices, this means that the matrix is symmetric: it equals its
   * transpose. This class computes the eigenvalues and eigenvectors of a
   * selfadjoint matrix. These are the scalars \f$ \lambda \f$ and vectors
   * \f$ v \f$ such that \f$ Av = \lambda v \f$.  The eigenvalues of a
   * selfadjoint matrix are always real. If \f$ D \f$ is a diagonal matrix with
   * the eigenvalues on the diagonal, and \f$ V \f$ is a matrix with the
-  * eigenvectors as its columns, then \f$ A = V D V^{-1} \f$ (for selfadjoint
-  * matrices, the matrix \f$ V \f$ is always invertible). This is called the
+  * eigenvectors as its columns, then \f$ A = V D V^{-1} \f$. This is called the
   * eigendecomposition.
   *
+  * For a selfadjoint matrix, \f$ V \f$ is unitary, meaning its inverse is equal
+  * to its adjoint, \f$ V^{-1} = V^{\dagger} \f$. If \f$ A \f$ is real, then
+  * \f$ V \f$ is also real and therefore orthogonal, meaning its inverse is
+  * equal to its transpose, \f$ V^{-1} = V^T \f$.
+  *
   * The algorithm exploits the fact that the matrix is selfadjoint, making it
   * faster and more accurate than the general purpose eigenvalue algorithms
   * implemented in EigenSolver and ComplexEigenSolver.
   *
   * Only the \b lower \b triangular \b part of the input matrix is referenced.
   *
   * Call the function compute() to compute the eigenvalues and eigenvectors of
@@ -115,15 +121,18 @@
       * Output: \verbinclude SelfAdjointEigenSolver_SelfAdjointEigenSolver.out
       */
     EIGEN_DEVICE_FUNC
     SelfAdjointEigenSolver()
         : m_eivec(),
           m_eivalues(),
           m_subdiag(),
-          m_isInitialized(false)
+          m_hcoeffs(),
+          m_info(InvalidInput),
+          m_isInitialized(false),
+          m_eigenvectorsOk(false)
     { }
 
     /** \brief Constructor, pre-allocates memory for dynamic-size matrices.
       *
       * \param [in]  size  Positive integer, size of the matrix whose
       * eigenvalues and eigenvectors will be computed.
       *
@@ -135,15 +144,17 @@
       * \sa compute() for an example
       */
     EIGEN_DEVICE_FUNC
     explicit SelfAdjointEigenSolver(Index size)
         : m_eivec(size, size),
           m_eivalues(size),
           m_subdiag(size > 1 ? size - 1 : 1),
-          m_isInitialized(false)
+          m_hcoeffs(size > 1 ? size - 1 : 1),
+          m_isInitialized(false),
+          m_eigenvectorsOk(false)
     {}
 
     /** \brief Constructor; computes eigendecomposition of given matrix.
       *
       * \param[in]  matrix  Selfadjoint matrix whose eigendecomposition is to
       *    be computed. Only the lower triangular part of the matrix is referenced.
       * \param[in]  options Can be #ComputeEigenvectors (default) or #EigenvaluesOnly.
@@ -159,15 +170,17 @@
       */
     template<typename InputType>
     EIGEN_DEVICE_FUNC
     explicit SelfAdjointEigenSolver(const EigenBase<InputType>& matrix, int options = ComputeEigenvectors)
       : m_eivec(matrix.rows(), matrix.cols()),
         m_eivalues(matrix.cols()),
         m_subdiag(matrix.rows() > 1 ? matrix.rows() - 1 : 1),
-        m_isInitialized(false)
+        m_hcoeffs(matrix.cols() > 1 ? matrix.cols() - 1 : 1),
+        m_isInitialized(false),
+        m_eigenvectorsOk(false)
     {
       compute(matrix.derived(), options);
     }
 
     /** \brief Computes eigendecomposition of given matrix.
       *
       * \param[in]  matrix  Selfadjoint matrix whose eigendecomposition is to
@@ -246,14 +259,19 @@
       * Column \f$ k \f$ of the returned matrix is an eigenvector corresponding
       * to eigenvalue number \f$ k \f$ as returned by eigenvalues().  The
       * eigenvectors are normalized to have (Euclidean) norm equal to one. If
       * this object was used to solve the eigenproblem for the selfadjoint
       * matrix \f$ A \f$, then the matrix returned by this function is the
       * matrix \f$ V \f$ in the eigendecomposition \f$ A = V D V^{-1} \f$.
       *
+      * For a selfadjoint matrix, \f$ V \f$ is unitary, meaning its inverse is equal
+      * to its adjoint, \f$ V^{-1} = V^{\dagger} \f$. If \f$ A \f$ is real, then
+      * \f$ V \f$ is also real and therefore orthogonal, meaning its inverse is
+      * equal to its transpose, \f$ V^{-1} = V^T \f$.
+      *
       * Example: \include SelfAdjointEigenSolver_eigenvectors.cpp
       * Output: \verbinclude SelfAdjointEigenSolver_eigenvectors.out
       *
       * \sa eigenvalues()
       */
     EIGEN_DEVICE_FUNC
     const EigenvectorsType& eigenvectors() const
@@ -333,15 +351,15 @@
       eigen_assert(m_isInitialized && "SelfAdjointEigenSolver is not initialized.");
       eigen_assert(m_eigenvectorsOk && "The eigenvectors have not been computed together with the eigenvalues.");
       return m_eivec * m_eivalues.cwiseInverse().cwiseSqrt().asDiagonal() * m_eivec.adjoint();
     }
 
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful, \c NoConvergence otherwise.
+      * \returns \c Success if computation was successful, \c NoConvergence otherwise.
       */
     EIGEN_DEVICE_FUNC
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "SelfAdjointEigenSolver is not initialized.");
       return m_info;
     }
@@ -350,22 +368,24 @@
       *
       * The algorithm terminates if it does not converge within m_maxIterations * n iterations, where n
       * denotes the size of the matrix. This value is currently set to 30 (copied from LAPACK).
       */
     static const int m_maxIterations = 30;
 
   protected:
-    static void check_template_parameters()
+    static EIGEN_DEVICE_FUNC
+    void check_template_parameters()
     {
       EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar);
     }
     
     EigenvectorsType m_eivec;
     RealVectorType m_eivalues;
     typename TridiagonalizationType::SubDiagonalType m_subdiag;
+    typename TridiagonalizationType::CoeffVectorType m_hcoeffs;
     ComputationInfo m_info;
     bool m_isInitialized;
     bool m_eigenvectorsOk;
 };
 
 namespace internal {
 /** \internal
@@ -399,15 +419,15 @@
 SelfAdjointEigenSolver<MatrixType>& SelfAdjointEigenSolver<MatrixType>
 ::compute(const EigenBase<InputType>& a_matrix, int options)
 {
   check_template_parameters();
   
   const InputType &matrix(a_matrix.derived());
   
-  using std::abs;
+  EIGEN_USING_STD(abs);
   eigen_assert(matrix.cols() == matrix.rows());
   eigen_assert((options&~(EigVecMask|GenEigMask))==0
           && (options&EigVecMask)!=EigVecMask
           && "invalid option parameter");
   bool computeEigenvectors = (options&ComputeEigenvectors)==ComputeEigenvectors;
   Index n = matrix.cols();
   m_eivalues.resize(n,1);
@@ -430,15 +450,16 @@
 
   // map the matrix coefficients to [-1:1] to avoid over- and underflow.
   mat = matrix.template triangularView<Lower>();
   RealScalar scale = mat.cwiseAbs().maxCoeff();
   if(scale==RealScalar(0)) scale = RealScalar(1);
   mat.template triangularView<Lower>() /= scale;
   m_subdiag.resize(n-1);
-  internal::tridiagonalization_inplace(mat, diag, m_subdiag, computeEigenvectors);
+  m_hcoeffs.resize(n-1);
+  internal::tridiagonalization_inplace(mat, diag, m_subdiag, m_hcoeffs, computeEigenvectors);
 
   m_info = internal::computeFromTridiagonal_impl(diag, m_subdiag, m_maxIterations, computeEigenvectors, m_eivec);
   
   // scale back the eigen values
   m_eivalues *= scale;
 
   m_isInitialized = true;
@@ -475,37 +496,44 @@
   * \param[in,out] subdiag : The subdiagonal part of the matrix (entries are modified during the decomposition)
   * \param[in] maxIterations : the maximum number of iterations
   * \param[in] computeEigenvectors : whether the eigenvectors have to be computed or not
   * \param[out] eivec : The matrix to store the eigenvectors if computeEigenvectors==true. Must be allocated on input.
   * \returns \c Success or \c NoConvergence
   */
 template<typename MatrixType, typename DiagType, typename SubDiagType>
+EIGEN_DEVICE_FUNC
 ComputationInfo computeFromTridiagonal_impl(DiagType& diag, SubDiagType& subdiag, const Index maxIterations, bool computeEigenvectors, MatrixType& eivec)
 {
-  using std::abs;
-
   ComputationInfo info;
   typedef typename MatrixType::Scalar Scalar;
 
   Index n = diag.size();
   Index end = n-1;
   Index start = 0;
   Index iter = 0; // total number of iterations
   
   typedef typename DiagType::RealScalar RealScalar;
   const RealScalar considerAsZero = (std::numeric_limits<RealScalar>::min)();
-  const RealScalar precision = RealScalar(2)*NumTraits<RealScalar>::epsilon();
-  
+  const RealScalar precision_inv = RealScalar(1)/NumTraits<RealScalar>::epsilon();
   while (end>0)
   {
-    for (Index i = start; i<end; ++i)
-      if (internal::isMuchSmallerThan(abs(subdiag[i]),(abs(diag[i])+abs(diag[i+1])),precision) || abs(subdiag[i]) <= considerAsZero)
-        subdiag[i] = 0;
+    for (Index i = start; i<end; ++i) {
+      if (numext::abs(subdiag[i]) < considerAsZero) {
+        subdiag[i] = RealScalar(0);
+      } else {
+        // abs(subdiag[i]) <= epsilon * sqrt(abs(diag[i]) + abs(diag[i+1]))
+        // Scaled to prevent underflows.
+        const RealScalar scaled_subdiag = precision_inv * subdiag[i];
+        if (scaled_subdiag * scaled_subdiag <= (numext::abs(diag[i])+numext::abs(diag[i+1]))) {
+          subdiag[i] = RealScalar(0);
+        }
+      }
+    }
 
-    // find the largest unreduced block
+    // find the largest unreduced block at the end of the matrix.
     while (end>0 && subdiag[end-1]==RealScalar(0))
     {
       end--;
     }
     if (end<=0)
       break;
 
@@ -531,15 +559,15 @@
   {
     for (Index i = 0; i < n-1; ++i)
     {
       Index k;
       diag.segment(i,n-i).minCoeff(&k);
       if (k > 0)
       {
-        std::swap(diag[i], diag[k+i]);
+        numext::swap(diag[i], diag[k+i]);
         if(computeEigenvectors)
           eivec.col(i).swap(eivec.col(k+i));
       }
     }
   }
   return info;
 }
@@ -562,18 +590,18 @@
   /** \internal
    * Computes the roots of the characteristic polynomial of \a m.
    * For numerical stability m.trace() should be near zero and to avoid over- or underflow m should be normalized.
    */
   EIGEN_DEVICE_FUNC
   static inline void computeRoots(const MatrixType& m, VectorType& roots)
   {
-    EIGEN_USING_STD_MATH(sqrt)
-    EIGEN_USING_STD_MATH(atan2)
-    EIGEN_USING_STD_MATH(cos)
-    EIGEN_USING_STD_MATH(sin)
+    EIGEN_USING_STD(sqrt)
+    EIGEN_USING_STD(atan2)
+    EIGEN_USING_STD(cos)
+    EIGEN_USING_STD(sin)
     const Scalar s_inv3 = Scalar(1)/Scalar(3);
     const Scalar s_sqrt3 = sqrt(Scalar(3));
 
     // The characteristic equation is x^3 - c2*x^2 + c1*x - c0 = 0.  The
     // eigenvalues are the roots to this equation, all guaranteed to be
     // real-valued, because the matrix is symmetric.
     Scalar c0 = m(0,0)*m(1,1)*m(2,2) + Scalar(2)*m(1,0)*m(2,0)*m(2,1) - m(0,0)*m(2,1)*m(2,1) - m(1,1)*m(2,0)*m(2,0) - m(2,2)*m(1,0)*m(1,0);
@@ -601,27 +629,28 @@
     roots(1) = c2_over_3 - rho*(cos_theta - s_sqrt3*sin_theta); // == 2*rho*cos(theta+ pi/3)
     roots(2) = c2_over_3 + Scalar(2)*rho*cos_theta;
   }
 
   EIGEN_DEVICE_FUNC
   static inline bool extract_kernel(MatrixType& mat, Ref<VectorType> res, Ref<VectorType> representative)
   {
-    using std::abs;
+    EIGEN_USING_STD(abs);
+    EIGEN_USING_STD(sqrt);
     Index i0;
     // Find non-zero column i0 (by construction, there must exist a non zero coefficient on the diagonal):
     mat.diagonal().cwiseAbs().maxCoeff(&i0);
     // mat.col(i0) is a good candidate for an orthogonal vector to the current eigenvector,
     // so let's save it:
     representative = mat.col(i0);
     Scalar n0, n1;
     VectorType c0, c1;
     n0 = (c0 = representative.cross(mat.col((i0+1)%3))).squaredNorm();
     n1 = (c1 = representative.cross(mat.col((i0+2)%3))).squaredNorm();
-    if(n0>n1) res = c0/std::sqrt(n0);
-    else      res = c1/std::sqrt(n1);
+    if(n0>n1) res = c0/sqrt(n0);
+    else      res = c1/sqrt(n1);
 
     return true;
   }
 
   EIGEN_DEVICE_FUNC
   static inline void run(SolverType& solver, const MatrixType& mat, int options)
   {
@@ -715,26 +744,26 @@
   typedef typename SolverType::RealVectorType VectorType;
   typedef typename SolverType::Scalar Scalar;
   typedef typename SolverType::EigenvectorsType EigenvectorsType;
   
   EIGEN_DEVICE_FUNC
   static inline void computeRoots(const MatrixType& m, VectorType& roots)
   {
-    using std::sqrt;
+    EIGEN_USING_STD(sqrt);
     const Scalar t0 = Scalar(0.5) * sqrt( numext::abs2(m(0,0)-m(1,1)) + Scalar(4)*numext::abs2(m(1,0)));
     const Scalar t1 = Scalar(0.5) * (m(0,0) + m(1,1));
     roots(0) = t1 - t0;
     roots(1) = t1 + t0;
   }
   
   EIGEN_DEVICE_FUNC
   static inline void run(SolverType& solver, const MatrixType& mat, int options)
   {
-    EIGEN_USING_STD_MATH(sqrt);
-    EIGEN_USING_STD_MATH(abs);
+    EIGEN_USING_STD(sqrt);
+    EIGEN_USING_STD(abs);
     
     eigen_assert(mat.cols() == 2 && mat.cols() == mat.rows());
     eigen_assert((options&~(EigVecMask|GenEigMask))==0
             && (options&EigVecMask)!=EigVecMask
             && "invalid option parameter");
     bool computeEigenvectors = (options&ComputeEigenvectors)==ComputeEigenvectors;
     
@@ -799,58 +828,63 @@
 ::computeDirect(const MatrixType& matrix, int options)
 {
   internal::direct_selfadjoint_eigenvalues<SelfAdjointEigenSolver,Size,NumTraits<Scalar>::IsComplex>::run(*this,matrix,options);
   return *this;
 }
 
 namespace internal {
+
+// Francis implicit QR step.
 template<int StorageOrder,typename RealScalar, typename Scalar, typename Index>
 EIGEN_DEVICE_FUNC
 static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)
 {
-  using std::abs;
+  // Wilkinson Shift.
   RealScalar td = (diag[end-1] - diag[end])*RealScalar(0.5);
   RealScalar e = subdiag[end-1];
   // Note that thanks to scaling, e^2 or td^2 cannot overflow, however they can still
   // underflow thus leading to inf/NaN values when using the following commented code:
-//   RealScalar e2 = numext::abs2(subdiag[end-1]);
-//   RealScalar mu = diag[end] - e2 / (td + (td>0 ? 1 : -1) * sqrt(td*td + e2));
+  //   RealScalar e2 = numext::abs2(subdiag[end-1]);
+  //   RealScalar mu = diag[end] - e2 / (td + (td>0 ? 1 : -1) * sqrt(td*td + e2));
   // This explain the following, somewhat more complicated, version:
   RealScalar mu = diag[end];
-  if(td==RealScalar(0))
-    mu -= abs(e);
-  else
-  {
-    RealScalar e2 = numext::abs2(subdiag[end-1]);
-    RealScalar h = numext::hypot(td,e);
-    if(e2==RealScalar(0)) mu -= (e / (td + (td>RealScalar(0) ? RealScalar(1) : RealScalar(-1)))) * (e / h);
-    else                  mu -= e2 / (td + (td>RealScalar(0) ? h : -h));
+  if(td==RealScalar(0)) {
+    mu -= numext::abs(e);
+  } else if (e != RealScalar(0)) {
+    const RealScalar e2 = numext::abs2(e);
+    const RealScalar h = numext::hypot(td,e);
+    if(e2 == RealScalar(0)) {
+      mu -= e / ((td + (td>RealScalar(0) ? h : -h)) / e);
+    } else {
+      mu -= e2 / (td + (td>RealScalar(0) ? h : -h)); 
+    }
   }
-  
+
   RealScalar x = diag[start] - mu;
   RealScalar z = subdiag[start];
-  for (Index k = start; k < end; ++k)
+  // If z ever becomes zero, the Givens rotation will be the identity and
+  // z will stay zero for all future iterations.
+  for (Index k = start; k < end && z != RealScalar(0); ++k)
   {
     JacobiRotation<RealScalar> rot;
     rot.makeGivens(x, z);
 
     // do T = G' T G
     RealScalar sdk = rot.s() * diag[k] + rot.c() * subdiag[k];
     RealScalar dkp1 = rot.s() * subdiag[k] + rot.c() * diag[k+1];
 
     diag[k] = rot.c() * (rot.c() * diag[k] - rot.s() * subdiag[k]) - rot.s() * (rot.c() * subdiag[k] - rot.s() * diag[k+1]);
     diag[k+1] = rot.s() * sdk + rot.c() * dkp1;
     subdiag[k] = rot.c() * sdk - rot.s() * dkp1;
     
-
     if (k > start)
       subdiag[k - 1] = rot.c() * subdiag[k-1] - rot.s() * z;
 
+    // "Chasing the bulge" to return to triangular form.
     x = subdiag[k];
-
     if (k < end - 1)
     {
       z = -rot.s() * subdiag[k+1];
       subdiag[k + 1] = rot.c() * subdiag[k+1];
     }
     
     // apply the givens rotation to the unit matrix Q = Q * G
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver_LAPACKE.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Eigenvalues/Tridiagonalization.h` & `chronogram-0.2.0/include/Eigen/src/Eigenvalues/Tridiagonalization.h`

 * *Files 2% similar despite different names*

```diff
@@ -7,28 +7,29 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_TRIDIAGONALIZATION_H
 #define EIGEN_TRIDIAGONALIZATION_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
-  
+
 template<typename MatrixType> struct TridiagonalizationMatrixTReturnType;
 template<typename MatrixType>
 struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >
   : public traits<typename MatrixType::PlainObject>
 {
   typedef typename MatrixType::PlainObject ReturnType; // FIXME shall it be a BandMatrix?
   enum { Flags = 0 };
 };
 
 template<typename MatrixType, typename CoeffVectorType>
+EIGEN_DEVICE_FUNC
 void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs);
 }
 
 /** \eigenvalues_module \ingroup Eigenvalues_Module
   *
   *
   * \class Tridiagonalization
@@ -340,23 +341,24 @@
   *       \f$ v_i = [ 0, \ldots, 0, 1, matA(i+2,i), \ldots, matA(N-1,i) ]^T \f$.
   *
   * Implemented from Golub's "Matrix Computations", algorithm 8.3.1.
   *
   * \sa Tridiagonalization::packedMatrix()
   */
 template<typename MatrixType, typename CoeffVectorType>
+EIGEN_DEVICE_FUNC
 void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)
 {
   using numext::conj;
   typedef typename MatrixType::Scalar Scalar;
   typedef typename MatrixType::RealScalar RealScalar;
   Index n = matA.rows();
   eigen_assert(n==matA.cols());
   eigen_assert(n==hCoeffs.size()+1 || n==1);
-  
+
   for (Index i = 0; i<n-1; ++i)
   {
     Index remainingSize = n-i-1;
     RealScalar beta;
     Scalar h;
     matA.col(i).tail(remainingSize).makeHouseholderInPlace(h, beta);
 
@@ -419,34 +421,36 @@
   * Example (this uses the same matrix as the example in
   *    Tridiagonalization::Tridiagonalization(const MatrixType&)):
   *    \include Tridiagonalization_decomposeInPlace.cpp
   * Output: \verbinclude Tridiagonalization_decomposeInPlace.out
   *
   * \sa class Tridiagonalization
   */
-template<typename MatrixType, typename DiagonalType, typename SubDiagonalType>
-void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
+template<typename MatrixType, typename DiagonalType, typename SubDiagonalType, typename CoeffVectorType>
+EIGEN_DEVICE_FUNC
+void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag,
+                                CoeffVectorType& hcoeffs, bool extractQ)
 {
   eigen_assert(mat.cols()==mat.rows() && diag.size()==mat.rows() && subdiag.size()==mat.rows()-1);
-  tridiagonalization_inplace_selector<MatrixType>::run(mat, diag, subdiag, extractQ);
+  tridiagonalization_inplace_selector<MatrixType>::run(mat, diag, subdiag, hcoeffs, extractQ);
 }
 
 /** \internal
   * General full tridiagonalization
   */
 template<typename MatrixType, int Size, bool IsComplex>
 struct tridiagonalization_inplace_selector
 {
   typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;
   typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;
   template<typename DiagonalType, typename SubDiagonalType>
-  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
+  static EIGEN_DEVICE_FUNC
+      void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, CoeffVectorType& hCoeffs, bool extractQ)
   {
-    CoeffVectorType hCoeffs(mat.cols()-1);
-    tridiagonalization_inplace(mat,hCoeffs);
+    tridiagonalization_inplace(mat, hCoeffs);
     diag = mat.diagonal().real();
     subdiag = mat.template diagonal<-1>().real();
     if(extractQ)
       mat = HouseholderSequenceType(mat, hCoeffs.conjugate())
             .setLength(mat.rows() - 1)
             .setShift(1);
   }
@@ -458,16 +462,16 @@
   */
 template<typename MatrixType>
 struct tridiagonalization_inplace_selector<MatrixType,3,false>
 {
   typedef typename MatrixType::Scalar Scalar;
   typedef typename MatrixType::RealScalar RealScalar;
 
-  template<typename DiagonalType, typename SubDiagonalType>
-  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)
+  template<typename DiagonalType, typename SubDiagonalType, typename CoeffVectorType>
+  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, CoeffVectorType&, bool extractQ)
   {
     using std::sqrt;
     const RealScalar tol = (std::numeric_limits<RealScalar>::min)();
     diag[0] = mat(0,0);
     RealScalar v1norm2 = numext::abs2(mat(2,0));
     if(v1norm2 <= tol)
     {
@@ -503,16 +507,17 @@
   * Trivial specialization for 1x1 matrices
   */
 template<typename MatrixType, bool IsComplex>
 struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>
 {
   typedef typename MatrixType::Scalar Scalar;
 
-  template<typename DiagonalType, typename SubDiagonalType>
-  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)
+  template<typename DiagonalType, typename SubDiagonalType, typename CoeffVectorType>
+  static EIGEN_DEVICE_FUNC
+  void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, CoeffVectorType&, bool extractQ)
   {
     diag(0,0) = numext::real(mat(0,0));
     if(extractQ)
       mat(0,0) = Scalar(1);
   }
 };
 
@@ -538,16 +543,16 @@
     {
       result.setZero();
       result.template diagonal<1>() = m_matrix.template diagonal<-1>().conjugate();
       result.diagonal() = m_matrix.diagonal();
       result.template diagonal<-1>() = m_matrix.template diagonal<-1>();
     }
 
-    Index rows() const { return m_matrix.rows(); }
-    Index cols() const { return m_matrix.cols(); }
+    EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }
+    EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
 
   protected:
     typename MatrixType::Nested m_matrix;
 };
 
 } // end namespace internal
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/AlignedBox.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/AlignedBox.h`

 * *Files 23% similar despite different names*

```diff
@@ -3,18 +3,54 @@
 //
 // Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>
 //
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+// Function void Eigen::AlignedBox::transform(const Transform& transform)
+// is provided under the following license agreement:
+//
+// Software License Agreement (BSD License)
+//
+// Copyright (c) 2011-2014, Willow Garage, Inc.
+// Copyright (c) 2014-2015, Open Source Robotics Foundation
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+//
+//  * Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+//  * Redistributions in binary form must reproduce the above
+//    copyright notice, this list of conditions and the following
+//    disclaimer in the documentation and/or other materials provided
+//    with the distribution.
+//  * Neither the name of Open Source Robotics Foundation nor the names of its
+//    contributors may be used to endorse or promote products derived
+//    from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+// ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
 #ifndef EIGEN_ALIGNEDBOX_H
 #define EIGEN_ALIGNEDBOX_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \geometry_module \ingroup Geometry_Module
   *
   *
   * \class AlignedBox
   *
   * \brief An axis aligned box
@@ -59,15 +95,15 @@
     TopLeftCeil=6, TopRightCeil=7
     /** @} */
   };
 
 
   /** Default constructor initializing a null box. */
   EIGEN_DEVICE_FUNC inline AlignedBox()
-  { if (AmbientDimAtCompileTime!=Dynamic) setEmpty(); }
+  { if (EIGEN_CONST_CONDITIONAL(AmbientDimAtCompileTime!=Dynamic)) setEmpty(); }
 
   /** Constructs a null box with \a _dim the dimension of the ambient space. */
   EIGEN_DEVICE_FUNC inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)
   { setEmpty(); }
 
   /** Constructs a box with extremities \a _min and \a _max.
    * \warning If either component of \a _min is larger than the same component of \a _max, the constructed box is empty. */
@@ -227,29 +263,38 @@
   /** Returns an AlignedBox that is the intersection of \a b and \c *this
    * \note If the boxes don't intersect, the resulting box is empty.
    * \sa intersects(), clamp, contains()  */
   EIGEN_DEVICE_FUNC inline AlignedBox intersection(const AlignedBox& b) const
   {return AlignedBox(m_min.cwiseMax(b.m_min), m_max.cwiseMin(b.m_max)); }
 
   /** Returns an AlignedBox that is the union of \a b and \c *this.
-   * \note Merging with an empty box may result in a box bigger than \c *this. 
+   * \note Merging with an empty box may result in a box bigger than \c *this.
    * \sa extend(const AlignedBox&) */
   EIGEN_DEVICE_FUNC inline AlignedBox merged(const AlignedBox& b) const
   { return AlignedBox(m_min.cwiseMin(b.m_min), m_max.cwiseMax(b.m_max)); }
 
   /** Translate \c *this by the vector \a t and returns a reference to \c *this. */
   template<typename Derived>
   EIGEN_DEVICE_FUNC inline AlignedBox& translate(const MatrixBase<Derived>& a_t)
   {
     const typename internal::nested_eval<Derived,2>::type t(a_t.derived());
     m_min += t;
     m_max += t;
     return *this;
   }
 
+  /** \returns a copy of \c *this translated by the vector \a t. */
+  template<typename Derived>
+  EIGEN_DEVICE_FUNC inline AlignedBox translated(const MatrixBase<Derived>& a_t) const
+  {
+    AlignedBox result(m_min, m_max);
+    result.translate(a_t);
+    return result;
+  }
+
   /** \returns the squared distance between the point \a p and the box \c *this,
     * and zero if \a p is inside the box.
     * \sa exteriorDistance(const MatrixBase&), squaredExteriorDistance(const AlignedBox&)
     */
   template<typename Derived>
   EIGEN_DEVICE_FUNC inline Scalar squaredExteriorDistance(const MatrixBase<Derived>& p) const;
 
@@ -261,22 +306,71 @@
 
   /** \returns the distance between the point \a p and the box \c *this,
     * and zero if \a p is inside the box.
     * \sa squaredExteriorDistance(const MatrixBase&), exteriorDistance(const AlignedBox&)
     */
   template<typename Derived>
   EIGEN_DEVICE_FUNC inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const
-  { EIGEN_USING_STD_MATH(sqrt) return sqrt(NonInteger(squaredExteriorDistance(p))); }
+  { EIGEN_USING_STD(sqrt) return sqrt(NonInteger(squaredExteriorDistance(p))); }
 
   /** \returns the distance between the boxes \a b and \c *this,
     * and zero if the boxes intersect.
     * \sa squaredExteriorDistance(const AlignedBox&), exteriorDistance(const MatrixBase&)
     */
   EIGEN_DEVICE_FUNC inline NonInteger exteriorDistance(const AlignedBox& b) const
-  { EIGEN_USING_STD_MATH(sqrt) return sqrt(NonInteger(squaredExteriorDistance(b))); }
+  { EIGEN_USING_STD(sqrt) return sqrt(NonInteger(squaredExteriorDistance(b))); }
+
+  /**
+   * Specialization of transform for pure translation.
+   */
+  template<int Mode, int Options>
+  EIGEN_DEVICE_FUNC inline void transform(
+      const typename Transform<Scalar, AmbientDimAtCompileTime, Mode, Options>::TranslationType& translation)
+  {
+    this->translate(translation);
+  }
+
+  /**
+   * Transforms this box by \a transform and recomputes it to
+   * still be an axis-aligned box.
+   *
+   * \note This method is provided under BSD license (see the top of this file).
+   */
+  template<int Mode, int Options>
+  EIGEN_DEVICE_FUNC inline void transform(const Transform<Scalar, AmbientDimAtCompileTime, Mode, Options>& transform)
+  {
+    // Only Affine and Isometry transforms are currently supported.
+    EIGEN_STATIC_ASSERT(Mode == Affine || Mode == AffineCompact || Mode == Isometry, THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS);
+
+    // Method adapted from FCL src/shape/geometric_shapes_utility.cpp#computeBV<AABB, Box>(...)
+    // https://github.com/flexible-collision-library/fcl/blob/fcl-0.4/src/shape/geometric_shapes_utility.cpp#L292
+    //
+    // Here's a nice explanation why it works: https://zeuxcg.org/2010/10/17/aabb-from-obb-with-component-wise-abs/
+
+    // two times rotated extent
+    const VectorType rotated_extent_2 = transform.linear().cwiseAbs() * sizes();
+    // two times new center
+    const VectorType rotated_center_2 = transform.linear() * (this->m_max + this->m_min) +
+        Scalar(2) * transform.translation();
+
+    this->m_max = (rotated_center_2 + rotated_extent_2) / Scalar(2);
+    this->m_min = (rotated_center_2 - rotated_extent_2) / Scalar(2);
+  }
+
+  /**
+   * \returns a copy of \c *this transformed by \a transform and recomputed to
+   * still be an axis-aligned box.
+   */
+  template<int Mode, int Options>
+  EIGEN_DEVICE_FUNC AlignedBox transformed(const Transform<Scalar, AmbientDimAtCompileTime, Mode, Options>& transform) const
+  {
+    AlignedBox result(m_min, m_max);
+    result.transform(transform);
+    return result;
+  }
 
   /** \returns \c *this with scalar type casted to \a NewScalarType
     *
     * Note that if \a NewScalarType is equal to the current scalar type of \c *this
     * then this function smartly returns a const reference to \c *this.
     */
   template<typename NewScalarType>
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/AngleAxis.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/AngleAxis.h`

 * *Files 1% similar despite different names*

```diff
@@ -165,16 +165,16 @@
   * 
   * This function implicitly normalizes the quaternion \a q.
   */
 template<typename Scalar>
 template<typename QuatDerived>
 EIGEN_DEVICE_FUNC AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)
 {
-  EIGEN_USING_STD_MATH(atan2)
-  EIGEN_USING_STD_MATH(abs)
+  EIGEN_USING_STD(atan2)
+  EIGEN_USING_STD(abs)
   Scalar n = q.vec().norm();
   if(n<NumTraits<Scalar>::epsilon())
     n = q.vec().stableNorm();
 
   if (n != Scalar(0))
   {
     m_angle = Scalar(2)*atan2(n, abs(q.w()));
@@ -213,16 +213,16 @@
 
 /** Constructs and \returns an equivalent 3x3 rotation matrix.
   */
 template<typename Scalar>
 typename AngleAxis<Scalar>::Matrix3
 EIGEN_DEVICE_FUNC AngleAxis<Scalar>::toRotationMatrix(void) const
 {
-  EIGEN_USING_STD_MATH(sin)
-  EIGEN_USING_STD_MATH(cos)
+  EIGEN_USING_STD(sin)
+  EIGEN_USING_STD(cos)
   Matrix3 res;
   Vector3 sin_axis  = sin(m_angle) * m_axis;
   Scalar c = cos(m_angle);
   Vector3 cos1_axis = (Scalar(1)-c) * m_axis;
 
   Scalar tmp;
   tmp = cos1_axis.x() * m_axis.y();
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/EulerAngles.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/EulerAngles.h`

 * *Files 1% similar despite different names*

```diff
@@ -32,17 +32,17 @@
   * 
   * \sa class AngleAxis
   */
 template<typename Derived>
 EIGEN_DEVICE_FUNC inline Matrix<typename MatrixBase<Derived>::Scalar,3,1>
 MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const
 {
-  EIGEN_USING_STD_MATH(atan2)
-  EIGEN_USING_STD_MATH(sin)
-  EIGEN_USING_STD_MATH(cos)
+  EIGEN_USING_STD(atan2)
+  EIGEN_USING_STD(sin)
+  EIGEN_USING_STD(cos)
   /* Implemented from Graphics Gems IV */
   EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(Derived,3,3)
 
   Matrix<Scalar,3,1> res;
   typedef Matrix<typename Derived::Scalar,2,1> Vector2;
 
   const Index odd = ((a0+1)%3 == a1) ? 0 : 1;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/Homogeneous.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/Homogeneous.h`

 * *Files 2% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_HOMOGENEOUS_H
 #define EIGEN_HOMOGENEOUS_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \geometry_module \ingroup Geometry_Module
   *
   * \class Homogeneous
   *
   * \brief Expression of one (or a set of) homogeneous vector(s)
   *
@@ -68,17 +68,19 @@
     typedef MatrixBase<Homogeneous> Base;
     EIGEN_DENSE_PUBLIC_INTERFACE(Homogeneous)
 
     EIGEN_DEVICE_FUNC explicit inline Homogeneous(const MatrixType& matrix)
       : m_matrix(matrix)
     {}
 
-    EIGEN_DEVICE_FUNC inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }
-    EIGEN_DEVICE_FUNC inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }
-    
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }
+
     EIGEN_DEVICE_FUNC const NestedExpression& nestedExpression() const { return m_matrix; }
 
     template<typename Rhs>
     EIGEN_DEVICE_FUNC inline const Product<Homogeneous,Rhs>
     operator* (const MatrixBase<Rhs>& rhs) const
     {
       eigen_assert(int(Direction)==Horizontal);
@@ -258,16 +260,18 @@
   typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;
   typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;
   EIGEN_DEVICE_FUNC homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)
     : m_lhs(take_matrix_for_product<Lhs>::run(lhs)),
       m_rhs(rhs)
   {}
 
-  EIGEN_DEVICE_FUNC inline Index rows() const { return m_lhs.rows(); }
-  EIGEN_DEVICE_FUNC inline Index cols() const { return m_rhs.cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  inline Index rows() const EIGEN_NOEXCEPT { return m_lhs.rows(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  inline Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }
 
   template<typename Dest> EIGEN_DEVICE_FUNC void evalTo(Dest& dst) const
   {
     // FIXME investigate how to allow lazy evaluation of this product when possible
     dst = Block<const LhsMatrixTypeNested,
               LhsMatrixTypeNested::RowsAtCompileTime,
               LhsMatrixTypeNested::ColsAtCompileTime==Dynamic?Dynamic:LhsMatrixTypeNested::ColsAtCompileTime-1>
@@ -296,16 +300,16 @@
   : public ReturnByValue<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >
 {
   typedef typename remove_all<typename Rhs::Nested>::type RhsNested;
   EIGEN_DEVICE_FUNC homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)
     : m_lhs(lhs), m_rhs(rhs)
   {}
 
-  EIGEN_DEVICE_FUNC inline Index rows() const { return m_lhs.rows(); }
-  EIGEN_DEVICE_FUNC inline Index cols() const { return m_rhs.cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR inline Index rows() const EIGEN_NOEXCEPT { return m_lhs.rows(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR inline Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }
 
   template<typename Dest> EIGEN_DEVICE_FUNC void evalTo(Dest& dst) const
   {
     // FIXME investigate how to allow lazy evaluation of this product when possible
     dst = m_lhs * Block<const RhsNested,
                         RhsNested::RowsAtCompileTime==Dynamic?Dynamic:RhsNested::RowsAtCompileTime-1,
                         RhsNested::ColsAtCompileTime>
@@ -318,15 +322,15 @@
   typename Rhs::Nested m_rhs;
 };
 
 template<typename ArgType,int Direction>
 struct evaluator_traits<Homogeneous<ArgType,Direction> >
 {
   typedef typename storage_kind_to_evaluator_kind<typename ArgType::StorageKind>::Kind Kind;
-  typedef HomogeneousShape Shape;  
+  typedef HomogeneousShape Shape;
 };
 
 template<> struct AssignmentKind<DenseShape,HomogeneousShape> { typedef Dense2Dense Kind; };
 
 
 template<typename ArgType,int Direction>
 struct unary_evaluator<Homogeneous<ArgType,Direction>, IndexBased>
@@ -410,15 +414,15 @@
  : public evaluator<typename homogeneous_right_product_refactoring_helper<typename Lhs::NestedExpression,Rhs>::Xpr>
 {
   typedef Product<Lhs, Rhs, LazyProduct> XprType;
   typedef homogeneous_right_product_refactoring_helper<typename Lhs::NestedExpression,Rhs> helper;
   typedef typename helper::ConstantBlock ConstantBlock;
   typedef typename helper::Xpr RefactoredXpr;
   typedef evaluator<RefactoredXpr> Base;
-  
+
   EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)
     : Base(  xpr.lhs().nestedExpression() .lazyProduct(  xpr.rhs().template topRows<helper::Dim>(xpr.lhs().nestedExpression().cols()) )
             + ConstantBlock(xpr.rhs().row(xpr.rhs().rows()-1),xpr.lhs().rows(), 1) )
   {}
 };
 
 template<typename Lhs, typename RhsArg, int ProductTag>
@@ -463,15 +467,15 @@
  : public evaluator<typename homogeneous_left_product_refactoring_helper<Lhs,typename Rhs::NestedExpression>::Xpr>
 {
   typedef Product<Lhs, Rhs, LazyProduct> XprType;
   typedef homogeneous_left_product_refactoring_helper<Lhs,typename Rhs::NestedExpression> helper;
   typedef typename helper::ConstantBlock ConstantBlock;
   typedef typename helper::Xpr RefactoredXpr;
   typedef evaluator<RefactoredXpr> Base;
-  
+
   EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)
     : Base(   xpr.lhs().template leftCols<helper::Dim>(xpr.rhs().nestedExpression().rows()) .lazyProduct( xpr.rhs().nestedExpression() )
             + ConstantBlock(xpr.lhs().col(xpr.lhs().cols()-1),1,xpr.rhs().cols()) )
   {}
 };
 
 template<typename Scalar, int Dim, int Mode,int Options, typename RhsArg, int ProductTag>
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/Hyperplane.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/Hyperplane.h`

 * *Files 0% similar despite different names*

```diff
@@ -115,15 +115,15 @@
     return result;
   }
 
   /** Constructs a hyperplane passing through the parametrized line \a parametrized.
     * If the dimension of the ambient space is greater than 2, then there isn't uniqueness,
     * so an arbitrary choice is made.
     */
-  // FIXME to be consitent with the rest this could be implemented as a static Through function ??
+  // FIXME to be consistent with the rest this could be implemented as a static Through function ??
   EIGEN_DEVICE_FUNC explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)
   {
     normal() = parametrized.direction().unitOrthogonal();
     offset() = -parametrized.origin().dot(normal());
   }
 
   EIGEN_DEVICE_FUNC ~Hyperplane() {}
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/OrthoMethods.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/OrthoMethods.h`

 * *Files 0% similar despite different names*

```diff
@@ -23,17 +23,18 @@
   * \f$ (\mathbf{a}+i\mathbf{b}) \times (\mathbf{c}+i\mathbf{d}) = (\mathbf{a} \times \mathbf{c} - \mathbf{b} \times \mathbf{d}) - i(\mathbf{a} \times \mathbf{d} - \mathbf{b} \times \mathbf{c})\f$
   * 
   * \sa MatrixBase::cross3()
   */
 template<typename Derived>
 template<typename OtherDerived>
 #ifndef EIGEN_PARSED_BY_DOXYGEN
-EIGEN_DEVICE_FUNC inline typename MatrixBase<Derived>::template cross_product_return_type<OtherDerived>::type
+EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+typename MatrixBase<Derived>::template cross_product_return_type<OtherDerived>::type
 #else
-inline typename MatrixBase<Derived>::PlainObject
+typename MatrixBase<Derived>::PlainObject
 #endif
 MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const
 {
   EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Derived,3)
   EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(OtherDerived,3)
 
   // Note that there is no need for an expression here since the compiler
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/ParametrizedLine.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/ParametrizedLine.h`

 * *Files 10% similar despite different names*

```diff
@@ -83,15 +83,15 @@
   {
     VectorType diff = p - origin();
     return (diff - direction().dot(diff) * direction()).squaredNorm();
   }
   /** \returns the distance of a point \a p to its projection onto the line \c *this.
     * \sa squaredDistance()
     */
-  EIGEN_DEVICE_FUNC RealScalar distance(const VectorType& p) const { EIGEN_USING_STD_MATH(sqrt) return sqrt(squaredDistance(p)); }
+  EIGEN_DEVICE_FUNC RealScalar distance(const VectorType& p) const { EIGEN_USING_STD(sqrt) return sqrt(squaredDistance(p)); }
 
   /** \returns the projection of a point \a p onto the line \c *this. */
   EIGEN_DEVICE_FUNC VectorType projection(const VectorType& p) const
   { return origin() + direction().dot(p-origin()) * direction(); }
 
   EIGEN_DEVICE_FUNC VectorType pointAt(const Scalar& t) const;
   
@@ -100,15 +100,52 @@
  
   template <int OtherOptions>
   EIGEN_DEVICE_FUNC Scalar intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;
   
   template <int OtherOptions>
   EIGEN_DEVICE_FUNC VectorType intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const;
 
-  /** \returns \c *this with scalar type casted to \a NewScalarType
+  /** Applies the transformation matrix \a mat to \c *this and returns a reference to \c *this.
+    *
+    * \param mat the Dim x Dim transformation matrix
+    * \param traits specifies whether the matrix \a mat represents an #Isometry
+    *               or a more generic #Affine transformation. The default is #Affine.
+    */
+  template<typename XprType>
+  EIGEN_DEVICE_FUNC inline ParametrizedLine& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)
+  {
+    if (traits==Affine)
+      direction() = (mat * direction()).normalized();
+    else if (traits==Isometry)
+      direction() = mat * direction();
+    else
+    {
+      eigen_assert(0 && "invalid traits value in ParametrizedLine::transform()");
+    }
+    origin() = mat * origin();
+    return *this;
+  }
+
+  /** Applies the transformation \a t to \c *this and returns a reference to \c *this.
+    *
+    * \param t the transformation of dimension Dim
+    * \param traits specifies whether the transformation \a t represents an #Isometry
+    *               or a more generic #Affine transformation. The default is #Affine.
+    *               Other kind of transformations are not supported.
+    */
+  template<int TrOptions>
+  EIGEN_DEVICE_FUNC inline ParametrizedLine& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,
+                                                       TransformTraits traits = Affine)
+  {
+    transform(t.linear(), traits);
+    origin() += t.translation();
+    return *this;
+  }
+
+/** \returns \c *this with scalar type casted to \a NewScalarType
     *
     * Note that if \a NewScalarType is equal to the current scalar type of \c *this
     * then this function smartly returns a const reference to \c *this.
     */
   template<typename NewScalarType>
   EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<ParametrizedLine,
            ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/Quaternion.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/Quaternion.h`

 * *Files 5% similar despite different names*

```diff
@@ -137,15 +137,15 @@
     * \sa angularDistance()
     */
   template<class OtherDerived> EIGEN_DEVICE_FUNC inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }
 
   template<class OtherDerived> EIGEN_DEVICE_FUNC Scalar angularDistance(const QuaternionBase<OtherDerived>& other) const;
 
   /** \returns an equivalent 3x3 rotation matrix */
-  EIGEN_DEVICE_FUNC Matrix3 toRotationMatrix() const;
+  EIGEN_DEVICE_FUNC inline Matrix3 toRotationMatrix() const;
 
   /** \returns the quaternion which transform \a a into \a b through a rotation */
   template<typename Derived1, typename Derived2>
   EIGEN_DEVICE_FUNC Derived& setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);
 
   template<class OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Quaternion<Scalar> operator* (const QuaternionBase<OtherDerived>& q) const;
   template<class OtherDerived> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& operator*= (const QuaternionBase<OtherDerived>& q);
@@ -154,39 +154,80 @@
   EIGEN_DEVICE_FUNC Quaternion<Scalar> inverse() const;
 
   /** \returns the conjugated quaternion */
   EIGEN_DEVICE_FUNC Quaternion<Scalar> conjugate() const;
 
   template<class OtherDerived> EIGEN_DEVICE_FUNC Quaternion<Scalar> slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const;
 
+  /** \returns true if each coefficients of \c *this and \a other are all exactly equal.
+    * \warning When using floating point scalar values you probably should rather use a
+    *          fuzzy comparison such as isApprox()
+    * \sa isApprox(), operator!= */
+  template<class OtherDerived>
+  EIGEN_DEVICE_FUNC inline bool operator==(const QuaternionBase<OtherDerived>& other) const
+  { return coeffs() == other.coeffs(); }
+
+  /** \returns true if at least one pair of coefficients of \c *this and \a other are not exactly equal to each other.
+    * \warning When using floating point scalar values you probably should rather use a
+    *          fuzzy comparison such as isApprox()
+    * \sa isApprox(), operator== */
+  template<class OtherDerived>
+  EIGEN_DEVICE_FUNC inline bool operator!=(const QuaternionBase<OtherDerived>& other) const
+  { return coeffs() != other.coeffs(); }
+
   /** \returns \c true if \c *this is approximately equal to \a other, within the precision
     * determined by \a prec.
     *
     * \sa MatrixBase::isApprox() */
   template<class OtherDerived>
   EIGEN_DEVICE_FUNC bool isApprox(const QuaternionBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const
   { return coeffs().isApprox(other.coeffs(), prec); }
 
   /** return the result vector of \a v through the rotation*/
   EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Vector3 _transformVector(const Vector3& v) const;
 
+  #ifdef EIGEN_PARSED_BY_DOXYGEN
   /** \returns \c *this with scalar type casted to \a NewScalarType
     *
     * Note that if \a NewScalarType is equal to the current scalar type of \c *this
     * then this function smartly returns a const reference to \c *this.
     */
   template<typename NewScalarType>
-  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const
+  EIGEN_DEVICE_FUNC inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const;
+
+  #else
+
+  template<typename NewScalarType>
+  EIGEN_DEVICE_FUNC inline
+  typename internal::enable_if<internal::is_same<Scalar,NewScalarType>::value,const Derived&>::type cast() const
   {
-    return typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type(derived());
+    return derived();
   }
 
+  template<typename NewScalarType>
+  EIGEN_DEVICE_FUNC inline
+  typename internal::enable_if<!internal::is_same<Scalar,NewScalarType>::value,Quaternion<NewScalarType> >::type cast() const
+  {
+    return Quaternion<NewScalarType>(coeffs().template cast<NewScalarType>());
+  }
+  #endif
+
+#ifndef EIGEN_NO_IO
+  friend std::ostream& operator<<(std::ostream& s, const QuaternionBase<Derived>& q) {
+    s << q.x() << "i + " << q.y() << "j + " << q.z() << "k" << " + " << q.w();
+    return s;
+  }
+#endif
+
 #ifdef EIGEN_QUATERNIONBASE_PLUGIN
 # include EIGEN_QUATERNIONBASE_PLUGIN
 #endif
+protected:
+  EIGEN_DEFAULT_COPY_CONSTRUCTOR(QuaternionBase)
+  EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(QuaternionBase)
 };
 
 /***************************************************************************
 * Definition/implementation of Quaternion<Scalar>
 ***************************************************************************/
 
 /** \geometry_module \ingroup Geometry_Module
@@ -272,14 +313,29 @@
   EIGEN_DEVICE_FUNC explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }
 
   /** Explicit copy constructor with scalar conversion */
   template<typename OtherScalar, int OtherOptions>
   EIGEN_DEVICE_FUNC explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)
   { m_coeffs = other.coeffs().template cast<Scalar>(); }
 
+#if EIGEN_HAS_RVALUE_REFERENCES
+  // We define a copy constructor, which means we don't get an implicit move constructor or assignment operator.
+  /** Default move constructor */
+  EIGEN_DEVICE_FUNC inline Quaternion(Quaternion&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)
+    : m_coeffs(std::move(other.coeffs()))
+  {}
+
+  /** Default move assignment operator */
+  EIGEN_DEVICE_FUNC Quaternion& operator=(Quaternion&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)
+  {
+    m_coeffs = std::move(other.coeffs());
+    return *this;
+  }
+#endif
+
   EIGEN_DEVICE_FUNC static Quaternion UnitRandom();
 
   template<typename Derived1, typename Derived2>
   EIGEN_DEVICE_FUNC static Quaternion FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b);
 
   EIGEN_DEVICE_FUNC inline Coefficients& coeffs() { return m_coeffs;}
   EIGEN_DEVICE_FUNC inline const Coefficients& coeffs() const { return m_coeffs;}
@@ -500,16 +556,16 @@
 }
 
 /** Set \c *this from an angle-axis \a aa and returns a reference to \c *this
   */
 template<class Derived>
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)
 {
-  EIGEN_USING_STD_MATH(cos)
-  EIGEN_USING_STD_MATH(sin)
+  EIGEN_USING_STD(cos)
+  EIGEN_USING_STD(sin)
   Scalar ha = Scalar(0.5)*aa.angle(); // Scalar(0.5) to suppress precision loss warnings
   this->w() = cos(ha);
   this->vec() = sin(ha) * aa.axis();
   return derived();
 }
 
 /** Set \c *this from the expression \a xpr:
@@ -577,15 +633,15 @@
   * Note that the two input vectors do \b not have to be normalized, and
   * do not need to have the same norm.
   */
 template<class Derived>
 template<typename Derived1, typename Derived2>
 EIGEN_DEVICE_FUNC inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)
 {
-  EIGEN_USING_STD_MATH(sqrt)
+  EIGEN_USING_STD(sqrt)
   Vector3 v0 = a.normalized();
   Vector3 v1 = b.normalized();
   Scalar c = v1.dot(v0);
 
   // if dot == -1, vectors are nearly opposites
   // => accurately compute the rotation axis by computing the
   //    intersection of the two planes. This is done by solving:
@@ -618,21 +674,21 @@
 /** \returns a random unit quaternion following a uniform distribution law on SO(3)
   *
   * \note The implementation is based on http://planning.cs.uiuc.edu/node198.html
   */
 template<typename Scalar, int Options>
 EIGEN_DEVICE_FUNC Quaternion<Scalar,Options> Quaternion<Scalar,Options>::UnitRandom()
 {
-  EIGEN_USING_STD_MATH(sqrt)
-  EIGEN_USING_STD_MATH(sin)
-  EIGEN_USING_STD_MATH(cos)
+  EIGEN_USING_STD(sqrt)
+  EIGEN_USING_STD(sin)
+  EIGEN_USING_STD(cos)
   const Scalar u1 = internal::random<Scalar>(0, 1),
                u2 = internal::random<Scalar>(0, 2*EIGEN_PI),
                u3 = internal::random<Scalar>(0, 2*EIGEN_PI);
-  const Scalar a = sqrt(1 - u1),
+  const Scalar a = sqrt(Scalar(1) - u1),
                b = sqrt(u1);
   return Quaternion (a * sin(u2), a * cos(u2), b * sin(u3), b * cos(u3));
 }
 
 
 /** Returns a quaternion representing a rotation between
   * the two arbitrary vectors \a a and \a b. In other words, the built
@@ -703,15 +759,15 @@
   * \sa dot()
   */
 template <class Derived>
 template <class OtherDerived>
 EIGEN_DEVICE_FUNC inline typename internal::traits<Derived>::Scalar
 QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const
 {
-  EIGEN_USING_STD_MATH(atan2)
+  EIGEN_USING_STD(atan2)
   Quaternion<Scalar> d = (*this) * other.conjugate();
   return Scalar(2) * atan2( d.vec().norm(), numext::abs(d.w()) );
 }
 
  
     
 /** \returns the spherical linear interpolation between the two quaternions
@@ -721,16 +777,16 @@
   * see also http://en.wikipedia.org/wiki/Slerp.
   */
 template <class Derived>
 template <class OtherDerived>
 EIGEN_DEVICE_FUNC Quaternion<typename internal::traits<Derived>::Scalar>
 QuaternionBase<Derived>::slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const
 {
-  EIGEN_USING_STD_MATH(acos)
-  EIGEN_USING_STD_MATH(sin)
+  EIGEN_USING_STD(acos)
+  EIGEN_USING_STD(sin)
   const Scalar one = Scalar(1) - NumTraits<Scalar>::epsilon();
   Scalar d = this->dot(other);
   Scalar absD = numext::abs(d);
 
   Scalar scale0;
   Scalar scale1;
 
@@ -759,15 +815,15 @@
 template<typename Other>
 struct quaternionbase_assign_impl<Other,3,3>
 {
   typedef typename Other::Scalar Scalar;
   template<class Derived> EIGEN_DEVICE_FUNC static inline void run(QuaternionBase<Derived>& q, const Other& a_mat)
   {
     const typename internal::nested_eval<Other,2>::type mat(a_mat);
-    EIGEN_USING_STD_MATH(sqrt)
+    EIGEN_USING_STD(sqrt)
     // This algorithm comes from  "Quaternion Calculus and Fast Animation",
     // Ken Shoemake, 1987 SIGGRAPH course notes
     Scalar t = mat.trace();
     if (t > Scalar(0))
     {
       t = sqrt(t + Scalar(1.0));
       q.w() = Scalar(0.5)*t;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/Rotation2D.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/Rotation2D.h`

 * *Files 2% similar despite different names*

```diff
@@ -171,28 +171,28 @@
   * In other words, this function extract the rotation angle
   * from the rotation matrix.
   */
 template<typename Scalar>
 template<typename Derived>
 EIGEN_DEVICE_FUNC Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)
 {
-  EIGEN_USING_STD_MATH(atan2)
+  EIGEN_USING_STD(atan2)
   EIGEN_STATIC_ASSERT(Derived::RowsAtCompileTime==2 && Derived::ColsAtCompileTime==2,YOU_MADE_A_PROGRAMMING_MISTAKE)
   m_angle = atan2(mat.coeff(1,0), mat.coeff(0,0));
   return *this;
 }
 
 /** Constructs and \returns an equivalent 2x2 rotation matrix.
   */
 template<typename Scalar>
 typename Rotation2D<Scalar>::Matrix2
 EIGEN_DEVICE_FUNC Rotation2D<Scalar>::toRotationMatrix(void) const
 {
-  EIGEN_USING_STD_MATH(sin)
-  EIGEN_USING_STD_MATH(cos)
+  EIGEN_USING_STD(sin)
+  EIGEN_USING_STD(cos)
   Scalar sinA = sin(m_angle);
   Scalar cosA = cos(m_angle);
   return (Matrix2() << cosA, -sinA, sinA, cosA).finished();
 }
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/RotationBase.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/RotationBase.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/Scaling.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/Scaling.h`

 * *Files 4% similar despite different names*

```diff
@@ -10,29 +10,45 @@
 #ifndef EIGEN_SCALING_H
 #define EIGEN_SCALING_H
 
 namespace Eigen { 
 
 /** \geometry_module \ingroup Geometry_Module
   *
-  * \class Scaling
+  * \class UniformScaling
   *
   * \brief Represents a generic uniform scaling transformation
   *
   * \tparam _Scalar the scalar type, i.e., the type of the coefficients.
   *
   * This class represent a uniform scaling transformation. It is the return
   * type of Scaling(Scalar), and most of the time this is the only way it
   * is used. In particular, this class is not aimed to be used to store a scaling transformation,
   * but rather to make easier the constructions and updates of Transform objects.
   *
   * To represent an axis aligned scaling, use the DiagonalMatrix class.
   *
   * \sa Scaling(), class DiagonalMatrix, MatrixBase::asDiagonal(), class Translation, class Transform
   */
+
+namespace internal
+{
+  // This helper helps nvcc+MSVC to properly parse this file.
+  // See bug 1412.
+  template <typename Scalar, int Dim, int Mode>
+  struct uniformscaling_times_affine_returntype
+  {
+    enum
+    {
+      NewMode = int(Mode) == int(Isometry) ? Affine : Mode
+    };
+    typedef Transform <Scalar, Dim, NewMode> type;
+  };
+}
+
 template<typename _Scalar>
 class UniformScaling
 {
 public:
   /** the scalar type of the coefficients */
   typedef _Scalar Scalar;
 
@@ -56,25 +72,27 @@
 
   /** Concatenates a uniform scaling and a translation */
   template<int Dim>
   inline Transform<Scalar,Dim,Affine> operator* (const Translation<Scalar,Dim>& t) const;
 
   /** Concatenates a uniform scaling and an affine transformation */
   template<int Dim, int Mode, int Options>
-  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Mode)> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const
+  inline typename
+	internal::uniformscaling_times_affine_returntype<Scalar,Dim,Mode>::type
+	operator* (const Transform<Scalar, Dim, Mode, Options>& t) const
   {
-    Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Mode)> res = t;
+    typename internal::uniformscaling_times_affine_returntype<Scalar,Dim,Mode>::type res = t;
     res.prescale(factor());
     return res;
   }
 
   /** Concatenates a uniform scaling and a linear transformation matrix */
   // TODO returns an expression
   template<typename Derived>
-  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const
+  inline typename Eigen::internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const
   { return other * m_factor; }
 
   template<typename Derived,int Dim>
   inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const
   { return r.toRotationMatrix() * m_factor; }
 
   /** \returns the inverse scaling */
@@ -106,15 +124,15 @@
 
 /** \addtogroup Geometry_Module */
 //@{
 
 /** Concatenates a linear transformation matrix and a uniform scaling
   * \relates UniformScaling
   */
-// NOTE this operator is defiend in MatrixBase and not as a friend function
+// NOTE this operator is defined in MatrixBase and not as a friend function
 // of UniformScaling to fix an internal crash of Intel's ICC
 template<typename Derived,typename Scalar>
 EIGEN_EXPR_BINARYOP_SCALAR_RETURN_TYPE(Derived,Scalar,product)
 operator*(const MatrixBase<Derived>& matrix, const UniformScaling<Scalar>& s)
 { return matrix.derived() * s.factor(); }
 
 /** Constructs a uniform scaling from scale factor \a s */
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/Transform.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/Transform.h`

 * *Files 2% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_TRANSFORM_H
 #define EIGEN_TRANSFORM_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 
 template<typename Transform>
 struct transform_traits
 {
   enum
@@ -43,15 +43,15 @@
           int HDim,
           int OtherRows=Other::RowsAtCompileTime,
           int OtherCols=Other::ColsAtCompileTime>
 struct transform_left_product_impl;
 
 template< typename Lhs,
           typename Rhs,
-          bool AnyProjective = 
+          bool AnyProjective =
             transform_traits<Lhs>::IsProjective ||
             transform_traits<Rhs>::IsProjective>
 struct transform_transform_product_impl;
 
 template< typename Other,
           int Mode,
           int Options,
@@ -93,14 +93,17 @@
   * \tparam _Dim the dimension of the space
   * \tparam _Mode the type of the transformation. Can be:
   *              - #Affine: the transformation is stored as a (Dim+1)^2 matrix,
   *                         where the last row is assumed to be [0 ... 0 1].
   *              - #AffineCompact: the transformation is stored as a (Dim)x(Dim+1) matrix.
   *              - #Projective: the transformation is stored as a (Dim+1)^2 matrix
   *                             without any assumption.
+  *              - #Isometry: same as #Affine with the additional assumption that
+  *                           the linear part represents a rotation. This assumption is exploited
+  *                           to speed up some functions such as inverse() and rotation().
   * \tparam _Options has the same meaning as in class Matrix. It allows to specify DontAlign and/or RowMajor.
   *                  These Options are passed directly to the underlying matrix type.
   *
   * The homography is internally represented and stored by a matrix which
   * is available through the matrix() method. To understand the behavior of
   * this class you have to think a Transform object as its internal
   * matrix representation. The chosen convention is right multiply:
@@ -111,15 +114,15 @@
   *
   * \f$ \left( \begin{array}{cc}
   * linear & translation\\
   * 0 ... 0 & 1
   * \end{array} \right) \f$
   *
   * Note that for a projective transformation the last row can be anything,
-  * and then the interpretation of different parts might be sightly different.
+  * and then the interpretation of different parts might be slightly different.
   *
   * However, unlike a plain matrix, the Transform class provides many features
   * simplifying both its assembly and usage. In particular, it can be composed
   * with any other transformations (Transform,Translation,RotationBase,DiagonalMatrix)
   * and can be directly used to transform implicit homogeneous vectors. All these
   * operations are handled via the operator*. For the composition of transformations,
   * its principle consists to first convert the right/left hand sides of the product
@@ -216,17 +219,17 @@
   /** type of the matrix used to represent the transformation */
   typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;
   /** constified MatrixType */
   typedef const MatrixType ConstMatrixType;
   /** type of the matrix used to represent the linear part of the transformation */
   typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;
   /** type of read/write reference to the linear part of the transformation */
-  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> LinearPart;
+  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (int(Options)&RowMajor)==0> LinearPart;
   /** type of read reference to the linear part of the transformation */
-  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> ConstLinearPart;
+  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (int(Options)&RowMajor)==0> ConstLinearPart;
   /** type of read/write reference to the affine part of the transformation */
   typedef typename internal::conditional<int(Mode)==int(AffineCompact),
                               MatrixType&,
                               Block<MatrixType,Dim,HDim> >::type AffinePart;
   /** type of read reference to the affine part of the transformation */
   typedef typename internal::conditional<int(Mode)==int(AffineCompact),
                               const MatrixType&,
@@ -235,38 +238,32 @@
   typedef Matrix<Scalar,Dim,1> VectorType;
   /** type of a read/write reference to the translation part of the rotation */
   typedef Block<MatrixType,Dim,1,!(internal::traits<MatrixType>::Flags & RowMajorBit)> TranslationPart;
   /** type of a read reference to the translation part of the rotation */
   typedef const Block<ConstMatrixType,Dim,1,!(internal::traits<MatrixType>::Flags & RowMajorBit)> ConstTranslationPart;
   /** corresponding translation type */
   typedef Translation<Scalar,Dim> TranslationType;
-  
+
   // this intermediate enum is needed to avoid an ICE with gcc 3.4 and 4.0
   enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };
   /** The return type of the product between a diagonal matrix and a transform */
   typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;
 
 protected:
 
   MatrixType m_matrix;
 
 public:
 
   /** Default constructor without initialization of the meaningful coefficients.
-    * If Mode==Affine, then the last row is set to [0 ... 0 1] */
+    * If Mode==Affine or Mode==Isometry, then the last row is set to [0 ... 0 1] */
   EIGEN_DEVICE_FUNC inline Transform()
   {
     check_template_params();
-    internal::transform_make_affine<(int(Mode)==Affine) ? Affine : AffineCompact>::run(m_matrix);
-  }
-
-  EIGEN_DEVICE_FUNC inline Transform(const Transform& other)
-  {
-    check_template_params();
-    m_matrix = other.m_matrix;
+    internal::transform_make_affine<(int(Mode)==Affine || int(Mode)==Isometry) ? Affine : AffineCompact>::run(m_matrix);
   }
 
   EIGEN_DEVICE_FUNC inline explicit Transform(const TranslationType& t)
   {
     check_template_params();
     *this = t;
   }
@@ -278,17 +275,14 @@
   template<typename Derived>
   EIGEN_DEVICE_FUNC inline explicit Transform(const RotationBase<Derived, Dim>& r)
   {
     check_template_params();
     *this = r;
   }
 
-  EIGEN_DEVICE_FUNC inline Transform& operator=(const Transform& other)
-  { m_matrix = other.m_matrix; return *this; }
-
   typedef internal::transform_take_affine_part<Transform> take_affine_part;
 
   /** Constructs and initializes a transformation from a Dim^2 or a (Dim+1)^2 matrix. */
   template<typename OtherDerived>
   EIGEN_DEVICE_FUNC inline explicit Transform(const EigenBase<OtherDerived>& other)
   {
     EIGEN_STATIC_ASSERT((internal::is_same<Scalar,typename OtherDerived::Scalar>::value),
@@ -304,15 +298,15 @@
   {
     EIGEN_STATIC_ASSERT((internal::is_same<Scalar,typename OtherDerived::Scalar>::value),
       YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY);
 
     internal::transform_construct_from_matrix<OtherDerived,Mode,Options,Dim,HDim>::run(this, other.derived());
     return *this;
   }
-  
+
   template<int OtherOptions>
   EIGEN_DEVICE_FUNC inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)
   {
     check_template_params();
     // only the options change, we can directly copy the matrices
     m_matrix = other.matrix();
   }
@@ -331,23 +325,23 @@
     EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(OtherMode==int(Affine)||OtherMode==int(AffineCompact), Mode!=int(Isometry)),
                         YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION)
 
     enum { ModeIsAffineCompact = Mode == int(AffineCompact),
            OtherModeIsAffineCompact = OtherMode == int(AffineCompact)
     };
 
-    if(ModeIsAffineCompact == OtherModeIsAffineCompact)
+    if(EIGEN_CONST_CONDITIONAL(ModeIsAffineCompact == OtherModeIsAffineCompact))
     {
       // We need the block expression because the code is compiled for all
       // combinations of transformations and will trigger a compile time error
       // if one tries to assign the matrices directly
       m_matrix.template block<Dim,Dim+1>(0,0) = other.matrix().template block<Dim,Dim+1>(0,0);
       makeAffine();
     }
-    else if(OtherModeIsAffineCompact)
+    else if(EIGEN_CONST_CONDITIONAL(OtherModeIsAffineCompact))
     {
       typedef typename Transform<Scalar,Dim,OtherMode,OtherOptions>::MatrixType OtherMatrixType;
       internal::transform_construct_from_matrix<OtherMatrixType,Mode,Options,Dim,HDim>::run(this, other.matrix());
     }
     else
     {
       // here we know that Mode == AffineCompact and OtherMode != AffineCompact.
@@ -376,17 +370,17 @@
   inline Transform(const QMatrix& other);
   inline Transform& operator=(const QMatrix& other);
   inline QMatrix toQMatrix(void) const;
   inline Transform(const QTransform& other);
   inline Transform& operator=(const QTransform& other);
   inline QTransform toQTransform(void) const;
   #endif
-  
-  EIGEN_DEVICE_FUNC Index rows() const { return int(Mode)==int(Projective) ? m_matrix.cols() : (m_matrix.cols()-1); }
-  EIGEN_DEVICE_FUNC Index cols() const { return m_matrix.cols(); }
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return int(Mode)==int(Projective) ? m_matrix.cols() : (m_matrix.cols()-1); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }
 
   /** shortcut for m_matrix(row,col);
     * \sa MatrixBase::operator(Index,Index) const */
   EIGEN_DEVICE_FUNC inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }
   /** shortcut for m_matrix(row,col);
     * \sa MatrixBase::operator(Index,Index) */
   EIGEN_DEVICE_FUNC inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }
@@ -452,68 +446,68 @@
   EIGEN_DEVICE_FUNC inline const typename internal::transform_left_product_impl<OtherDerived,Mode,Options,_Dim,_Dim+1>::ResultType
     operator * (const EigenBase<OtherDerived> &a, const Transform &b)
   { return internal::transform_left_product_impl<OtherDerived,Mode,Options,Dim,HDim>::run(a.derived(),b); }
 
   /** \returns The product expression of a transform \a a times a diagonal matrix \a b
     *
     * The rhs diagonal matrix is interpreted as an affine scaling transformation. The
-    * product results in a Transform of the same type (mode) as the lhs only if the lhs 
+    * product results in a Transform of the same type (mode) as the lhs only if the lhs
     * mode is no isometry. In that case, the returned transform is an affinity.
     */
   template<typename DiagonalDerived>
   EIGEN_DEVICE_FUNC inline const TransformTimeDiagonalReturnType
     operator * (const DiagonalBase<DiagonalDerived> &b) const
   {
     TransformTimeDiagonalReturnType res(*this);
     res.linearExt() *= b;
     return res;
   }
 
   /** \returns The product expression of a diagonal matrix \a a times a transform \a b
     *
     * The lhs diagonal matrix is interpreted as an affine scaling transformation. The
-    * product results in a Transform of the same type (mode) as the lhs only if the lhs 
+    * product results in a Transform of the same type (mode) as the lhs only if the lhs
     * mode is no isometry. In that case, the returned transform is an affinity.
     */
   template<typename DiagonalDerived>
   EIGEN_DEVICE_FUNC friend inline TransformTimeDiagonalReturnType
     operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)
   {
     TransformTimeDiagonalReturnType res;
     res.linear().noalias() = a*b.linear();
     res.translation().noalias() = a*b.translation();
-    if (Mode!=int(AffineCompact))
+    if (EIGEN_CONST_CONDITIONAL(Mode!=int(AffineCompact)))
       res.matrix().row(Dim) = b.matrix().row(Dim);
     return res;
   }
 
   template<typename OtherDerived>
   EIGEN_DEVICE_FUNC inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }
 
   /** Concatenates two transformations */
   EIGEN_DEVICE_FUNC inline const Transform operator * (const Transform& other) const
   {
     return internal::transform_transform_product_impl<Transform,Transform>::run(*this,other);
   }
-  
+
   #if EIGEN_COMP_ICC
 private:
   // this intermediate structure permits to workaround a bug in ICC 11:
   //   error: template instantiation resulted in unexpected function type of "Eigen::Transform<double, 3, 32, 0>
   //             (const Eigen::Transform<double, 3, 2, 0> &) const"
   //  (the meaning of a name may have changed since the template declaration -- the type of the template is:
   // "Eigen::internal::transform_transform_product_impl<Eigen::Transform<double, 3, 32, 0>,
   //     Eigen::Transform<double, 3, Mode, Options>, <expression>>::ResultType (const Eigen::Transform<double, 3, Mode, Options> &) const")
-  // 
+  //
   template<int OtherMode,int OtherOptions> struct icc_11_workaround
   {
     typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;
     typedef typename ProductType::ResultType ResultType;
   };
-  
+
 public:
   /** Concatenates two different transformations */
   template<int OtherMode,int OtherOptions>
   inline typename icc_11_workaround<OtherMode,OtherOptions>::ResultType
     operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const
   {
     typedef typename icc_11_workaround<OtherMode,OtherOptions>::ProductType ProductType;
@@ -538,15 +532,15 @@
    */
   EIGEN_DEVICE_FUNC static const Transform Identity()
   {
     return Transform(MatrixType::Identity());
   }
 
   template<typename OtherDerived>
-  EIGEN_DEVICE_FUNC 
+  EIGEN_DEVICE_FUNC
   inline Transform& scale(const MatrixBase<OtherDerived> &other);
 
   template<typename OtherDerived>
   EIGEN_DEVICE_FUNC
   inline Transform& prescale(const MatrixBase<OtherDerived> &other);
 
   EIGEN_DEVICE_FUNC inline Transform& scale(const Scalar& s);
@@ -568,26 +562,26 @@
   EIGEN_DEVICE_FUNC
   inline Transform& prerotate(const RotationType& rotation);
 
   EIGEN_DEVICE_FUNC Transform& shear(const Scalar& sx, const Scalar& sy);
   EIGEN_DEVICE_FUNC Transform& preshear(const Scalar& sx, const Scalar& sy);
 
   EIGEN_DEVICE_FUNC inline Transform& operator=(const TranslationType& t);
-  
+
   EIGEN_DEVICE_FUNC
   inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }
-  
+
   EIGEN_DEVICE_FUNC inline Transform operator*(const TranslationType& t) const;
 
-  EIGEN_DEVICE_FUNC 
+  EIGEN_DEVICE_FUNC
   inline Transform& operator=(const UniformScaling<Scalar>& t);
-  
+
   EIGEN_DEVICE_FUNC
   inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }
-  
+
   EIGEN_DEVICE_FUNC
   inline TransformTimeDiagonalReturnType operator*(const UniformScaling<Scalar>& s) const
   {
     TransformTimeDiagonalReturnType res = *this;
     res.scale(s.factor());
     return res;
   }
@@ -598,15 +592,17 @@
   template<typename Derived>
   EIGEN_DEVICE_FUNC inline Transform& operator=(const RotationBase<Derived,Dim>& r);
   template<typename Derived>
   EIGEN_DEVICE_FUNC inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }
   template<typename Derived>
   EIGEN_DEVICE_FUNC inline Transform operator*(const RotationBase<Derived,Dim>& r) const;
 
-  EIGEN_DEVICE_FUNC const LinearMatrixType rotation() const;
+  typedef typename internal::conditional<int(Mode)==Isometry,ConstLinearPart,const LinearMatrixType>::type RotationReturnType;
+  EIGEN_DEVICE_FUNC RotationReturnType rotation() const;
+
   template<typename RotationMatrixType, typename ScalingMatrixType>
   EIGEN_DEVICE_FUNC
   void computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const;
   template<typename ScalingMatrixType, typename RotationMatrixType>
   EIGEN_DEVICE_FUNC
   void computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const;
 
@@ -680,15 +676,15 @@
   EIGEN_DEVICE_FUNC inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const
   { return m_matrix.template block<int(Mode)==int(Projective)?HDim:Dim,1>(0,Dim); }
 
 
   #ifdef EIGEN_TRANSFORM_PLUGIN
   #include EIGEN_TRANSFORM_PLUGIN
   #endif
-  
+
 protected:
   #ifndef EIGEN_PARSED_BY_DOXYGEN
     EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void check_template_params()
     {
       EIGEN_STATIC_ASSERT((Options & (DontAlign|RowMajor)) == Options, INVALID_MATRIX_TEMPLATE_PARAMETERS)
     }
   #endif
@@ -751,15 +747,15 @@
   *
   * This function is available only if the token EIGEN_QT_SUPPORT is defined.
   */
 template<typename Scalar, int Dim, int Mode,int Options>
 Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)
 {
   EIGEN_STATIC_ASSERT(Dim==2, YOU_MADE_A_PROGRAMMING_MISTAKE)
-  if (Mode == int(AffineCompact))
+  if (EIGEN_CONST_CONDITIONAL(Mode == int(AffineCompact)))
     m_matrix << other.m11(), other.m21(), other.dx(),
                 other.m12(), other.m22(), other.dy();
   else
     m_matrix << other.m11(), other.m21(), other.dx(),
                 other.m12(), other.m22(), other.dy(),
                 0, 0, 1;
   return *this;
@@ -797,15 +793,15 @@
   * This function is available only if the token EIGEN_QT_SUPPORT is defined.
   */
 template<typename Scalar, int Dim, int Mode, int Options>
 Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)
 {
   check_template_params();
   EIGEN_STATIC_ASSERT(Dim==2, YOU_MADE_A_PROGRAMMING_MISTAKE)
-  if (Mode == int(AffineCompact))
+  if (EIGEN_CONST_CONDITIONAL(Mode == int(AffineCompact)))
     m_matrix << other.m11(), other.m21(), other.dx(),
                 other.m12(), other.m22(), other.dy();
   else
     m_matrix << other.m11(), other.m21(), other.dx(),
                 other.m12(), other.m22(), other.dy(),
                 other.m13(), other.m23(), other.m33();
   return *this;
@@ -815,15 +811,15 @@
   *
   * This function is available only if the token EIGEN_QT_SUPPORT is defined.
   */
 template<typename Scalar, int Dim, int Mode, int Options>
 QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const
 {
   EIGEN_STATIC_ASSERT(Dim==2, YOU_MADE_A_PROGRAMMING_MISTAKE)
-  if (Mode == int(AffineCompact))
+  if (EIGEN_CONST_CONDITIONAL(Mode == int(AffineCompact)))
     return QTransform(m_matrix.coeff(0,0), m_matrix.coeff(1,0),
                       m_matrix.coeff(0,1), m_matrix.coeff(1,1),
                       m_matrix.coeff(0,2), m_matrix.coeff(1,2));
   else
     return QTransform(m_matrix.coeff(0,0), m_matrix.coeff(1,0), m_matrix.coeff(2,0),
                       m_matrix.coeff(0,1), m_matrix.coeff(1,1), m_matrix.coeff(2,1),
                       m_matrix.coeff(0,2), m_matrix.coeff(1,2), m_matrix.coeff(2,2));
@@ -908,15 +904,15 @@
   */
 template<typename Scalar, int Dim, int Mode, int Options>
 template<typename OtherDerived>
 EIGEN_DEVICE_FUNC Transform<Scalar,Dim,Mode,Options>&
 Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)
 {
   EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(OtherDerived,int(Dim))
-  if(int(Mode)==int(Projective))
+  if(EIGEN_CONST_CONDITIONAL(int(Mode)==int(Projective)))
     affine() += other * m_matrix.row(Dim);
   else
     translation() += other;
   return *this;
 }
 
 /** Applies on the right the rotation represented by the rotation \a rotation
@@ -1042,28 +1038,51 @@
   return res;
 }
 
 /************************
 *** Special functions ***
 ************************/
 
+namespace internal {
+template<int Mode> struct transform_rotation_impl {
+  template<typename TransformType>
+  EIGEN_DEVICE_FUNC static inline
+  const typename TransformType::LinearMatrixType run(const TransformType& t)
+  {
+    typedef typename TransformType::LinearMatrixType LinearMatrixType;
+    LinearMatrixType result;
+    t.computeRotationScaling(&result, (LinearMatrixType*)0);
+    return result;
+  }
+};
+template<> struct transform_rotation_impl<Isometry> {
+  template<typename TransformType>
+  EIGEN_DEVICE_FUNC static inline
+  typename TransformType::ConstLinearPart run(const TransformType& t)
+  {
+    return t.linear();
+  }
+};
+}
 /** \returns the rotation part of the transformation
   *
+  * If Mode==Isometry, then this method is an alias for linear(),
+  * otherwise it calls computeRotationScaling() to extract the rotation
+  * through a SVD decomposition.
   *
   * \svd_module
   *
   * \sa computeRotationScaling(), computeScalingRotation(), class SVD
   */
 template<typename Scalar, int Dim, int Mode, int Options>
-EIGEN_DEVICE_FUNC const typename Transform<Scalar,Dim,Mode,Options>::LinearMatrixType
+EIGEN_DEVICE_FUNC
+typename Transform<Scalar,Dim,Mode,Options>::RotationReturnType
 Transform<Scalar,Dim,Mode,Options>::rotation() const
 {
-  LinearMatrixType result;
-  computeRotationScaling(&result, (LinearMatrixType*)0);
-  return result;
+  return internal::transform_rotation_impl<Mode>::run(*this);
 }
 
 
 /** decomposes the linear part of the transformation as a product rotation x scaling, the scaling being
   * not necessarily positive.
   *
   * If either pointer is zero, the corresponding computation is skipped.
@@ -1074,25 +1093,26 @@
   *
   * \sa computeScalingRotation(), rotation(), class SVD
   */
 template<typename Scalar, int Dim, int Mode, int Options>
 template<typename RotationMatrixType, typename ScalingMatrixType>
 EIGEN_DEVICE_FUNC void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const
 {
+  // Note that JacobiSVD is faster than BDCSVD for small matrices.
   JacobiSVD<LinearMatrixType> svd(linear(), ComputeFullU | ComputeFullV);
 
-  Scalar x = (svd.matrixU() * svd.matrixV().adjoint()).determinant(); // so x has absolute value 1
+  Scalar x = (svd.matrixU() * svd.matrixV().adjoint()).determinant() < Scalar(0) ? Scalar(-1) : Scalar(1); // so x has absolute value 1
   VectorType sv(svd.singularValues());
-  sv.coeffRef(0) *= x;
-  if(scaling) scaling->lazyAssign(svd.matrixV() * sv.asDiagonal() * svd.matrixV().adjoint());
+  sv.coeffRef(Dim-1) *= x;
+  if(scaling) *scaling = svd.matrixV() * sv.asDiagonal() * svd.matrixV().adjoint();
   if(rotation)
   {
     LinearMatrixType m(svd.matrixU());
-    m.col(0) /= x;
-    rotation->lazyAssign(m * svd.matrixV().adjoint());
+    m.col(Dim-1) *= x;
+    *rotation = m * svd.matrixV().adjoint();
   }
 }
 
 /** decomposes the linear part of the transformation as a product scaling x rotation, the scaling being
   * not necessarily positive.
   *
   * If either pointer is zero, the corresponding computation is skipped.
@@ -1103,25 +1123,26 @@
   *
   * \sa computeRotationScaling(), rotation(), class SVD
   */
 template<typename Scalar, int Dim, int Mode, int Options>
 template<typename ScalingMatrixType, typename RotationMatrixType>
 EIGEN_DEVICE_FUNC void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const
 {
+  // Note that JacobiSVD is faster than BDCSVD for small matrices.
   JacobiSVD<LinearMatrixType> svd(linear(), ComputeFullU | ComputeFullV);
 
-  Scalar x = (svd.matrixU() * svd.matrixV().adjoint()).determinant(); // so x has absolute value 1
+  Scalar x = (svd.matrixU() * svd.matrixV().adjoint()).determinant() < Scalar(0) ? Scalar(-1) : Scalar(1); // so x has absolute value 1
   VectorType sv(svd.singularValues());
-  sv.coeffRef(0) *= x;
-  if(scaling) scaling->lazyAssign(svd.matrixU() * sv.asDiagonal() * svd.matrixU().adjoint());
+  sv.coeffRef(Dim-1) *= x;
+  if(scaling) *scaling = svd.matrixU() * sv.asDiagonal() * svd.matrixU().adjoint();
   if(rotation)
   {
     LinearMatrixType m(svd.matrixU());
-    m.col(0) /= x;
-    rotation->lazyAssign(m * svd.matrixV().adjoint());
+    m.col(Dim-1) *= x;
+    *rotation = m * svd.matrixV().adjoint();
   }
 }
 
 /** Convenient method to set \c *this from a position, orientation and scale
   * of a 3D object.
   */
 template<typename Scalar, int Dim, int Mode, int Options>
@@ -1152,15 +1173,15 @@
 };
 
 template<>
 struct transform_make_affine<AffineCompact>
 {
   template<typename MatrixType> EIGEN_DEVICE_FUNC static void run(MatrixType &) { }
 };
-    
+
 // selector needed to avoid taking the inverse of a 3x4 matrix
 template<typename TransformType, int Mode=TransformType::Mode>
 struct projective_transform_inverse
 {
   EIGEN_DEVICE_FUNC static inline void run(const TransformType&, TransformType&)
   {}
 };
@@ -1293,74 +1314,74 @@
 /**********************************************************
 ***   Specializations of operator* with rhs EigenBase   ***
 **********************************************************/
 
 template<int LhsMode,int RhsMode>
 struct transform_product_result
 {
-  enum 
-  { 
+  enum
+  {
     Mode =
       (LhsMode == (int)Projective    || RhsMode == (int)Projective    ) ? Projective :
       (LhsMode == (int)Affine        || RhsMode == (int)Affine        ) ? Affine :
       (LhsMode == (int)AffineCompact || RhsMode == (int)AffineCompact ) ? AffineCompact :
       (LhsMode == (int)Isometry      || RhsMode == (int)Isometry      ) ? Isometry : Projective
   };
 };
 
 template< typename TransformType, typename MatrixType, int RhsCols>
 struct transform_right_product_impl< TransformType, MatrixType, 0, RhsCols>
 {
   typedef typename MatrixType::PlainObject ResultType;
 
-  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)
   {
     return T.matrix() * other;
   }
 };
 
 template< typename TransformType, typename MatrixType, int RhsCols>
 struct transform_right_product_impl< TransformType, MatrixType, 1, RhsCols>
 {
-  enum { 
-    Dim = TransformType::Dim, 
+  enum {
+    Dim = TransformType::Dim,
     HDim = TransformType::HDim,
     OtherRows = MatrixType::RowsAtCompileTime,
     OtherCols = MatrixType::ColsAtCompileTime
   };
 
   typedef typename MatrixType::PlainObject ResultType;
 
-  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)
   {
     EIGEN_STATIC_ASSERT(OtherRows==HDim, YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES);
 
     typedef Block<ResultType, Dim, OtherCols, int(MatrixType::RowsAtCompileTime)==Dim> TopLeftLhs;
 
     ResultType res(other.rows(),other.cols());
     TopLeftLhs(res, 0, 0, Dim, other.cols()).noalias() = T.affine() * other;
     res.row(OtherRows-1) = other.row(OtherRows-1);
-    
+
     return res;
   }
 };
 
 template< typename TransformType, typename MatrixType, int RhsCols>
 struct transform_right_product_impl< TransformType, MatrixType, 2, RhsCols>
 {
-  enum { 
-    Dim = TransformType::Dim, 
+  enum {
+    Dim = TransformType::Dim,
     HDim = TransformType::HDim,
     OtherRows = MatrixType::RowsAtCompileTime,
     OtherCols = MatrixType::ColsAtCompileTime
   };
 
   typedef typename MatrixType::PlainObject ResultType;
 
-  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)
   {
     EIGEN_STATIC_ASSERT(OtherRows==Dim, YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES);
 
     typedef Block<ResultType, Dim, OtherCols, true> TopLeftLhs;
     ResultType res(Replicate<typename TransformType::ConstTranslationPart, 1, OtherCols>(T.translation(),1,other.cols()));
     TopLeftLhs(res, 0, 0, Dim, other.cols()).noalias() += T.linear() * other;
 
@@ -1377,15 +1398,15 @@
     HDim = TransformType::HDim,
     OtherRows = MatrixType::RowsAtCompileTime,
     WorkingRows = EIGEN_PLAIN_ENUM_MIN(TransformMatrix::RowsAtCompileTime,HDim)
   };
 
   typedef typename MatrixType::PlainObject ResultType;
 
-  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)
   {
     EIGEN_STATIC_ASSERT(OtherRows==Dim, YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES);
 
     Matrix<typename ResultType::Scalar, Dim+1, 1> rhs;
     rhs.template head<Dim>() = other; rhs[Dim] = typename ResultType::Scalar(1);
     Matrix<typename ResultType::Scalar, WorkingRows, 1> res(T.matrix() * rhs);
     return res.template head<Dim>();
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/Translation.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/Translation.h`

 * *Files 3% similar despite different names*

```diff
@@ -66,26 +66,26 @@
     m_coeffs.x() = sx;
     m_coeffs.y() = sy;
     m_coeffs.z() = sz;
   }
   /** Constructs and initialize the translation transformation from a vector of translation coefficients */
   EIGEN_DEVICE_FUNC explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}
 
-  /** \brief Retruns the x-translation by value. **/
+  /** \brief Returns the x-translation by value. **/
   EIGEN_DEVICE_FUNC inline Scalar x() const { return m_coeffs.x(); }
-  /** \brief Retruns the y-translation by value. **/
+  /** \brief Returns the y-translation by value. **/
   EIGEN_DEVICE_FUNC inline Scalar y() const { return m_coeffs.y(); }
-  /** \brief Retruns the z-translation by value. **/
+  /** \brief Returns the z-translation by value. **/
   EIGEN_DEVICE_FUNC inline Scalar z() const { return m_coeffs.z(); }
 
-  /** \brief Retruns the x-translation as a reference. **/
+  /** \brief Returns the x-translation as a reference. **/
   EIGEN_DEVICE_FUNC inline Scalar& x() { return m_coeffs.x(); }
-  /** \brief Retruns the y-translation as a reference. **/
+  /** \brief Returns the y-translation as a reference. **/
   EIGEN_DEVICE_FUNC inline Scalar& y() { return m_coeffs.y(); }
-  /** \brief Retruns the z-translation as a reference. **/
+  /** \brief Returns the z-translation as a reference. **/
   EIGEN_DEVICE_FUNC inline Scalar& z() { return m_coeffs.z(); }
 
   EIGEN_DEVICE_FUNC const VectorType& vector() const { return m_coeffs; }
   EIGEN_DEVICE_FUNC VectorType& vector() { return m_coeffs; }
 
   EIGEN_DEVICE_FUNC const VectorType& translation() const { return m_coeffs; }
   EIGEN_DEVICE_FUNC VectorType& translation() { return m_coeffs; }
@@ -134,20 +134,14 @@
   inline typename internal::enable_if<Derived::IsVectorAtCompileTime,VectorType>::type
   operator* (const MatrixBase<Derived>& vec) const
   { return m_coeffs + vec.derived(); }
 
   /** \returns the inverse translation (opposite) */
   Translation inverse() const { return Translation(-m_coeffs); }
 
-  Translation& operator=(const Translation& other)
-  {
-    m_coeffs = other.m_coeffs;
-    return *this;
-  }
-
   static const Translation Identity() { return Translation(VectorType::Zero()); }
 
   /** \returns \c *this with scalar type casted to \a NewScalarType
     *
     * Note that if \a NewScalarType is equal to the current scalar type of \c *this
     * then this function smartly returns a const reference to \c *this.
     */
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Geometry/Umeyama.h` & `chronogram-0.2.0/include/Eigen/src/Geometry/Umeyama.h`

 * *Files 1% similar despite different names*

```diff
@@ -83,15 +83,15 @@
 * \param src Source points \f$ \mathbf{x} = \left( x_1, \hdots, x_n \right) \f$.
 * \param dst Destination points \f$ \mathbf{y} = \left( y_1, \hdots, y_n \right) \f$.
 * \param with_scaling Sets \f$ c=1 \f$ when <code>false</code> is passed.
 * \return The homogeneous transformation 
 * \f{align*}
 *   T = \begin{bmatrix} c\mathbf{R} & \mathbf{t} \\ \mathbf{0} & 1 \end{bmatrix}
 * \f}
-* minimizing the resudiual above. This transformation is always returned as an 
+* minimizing the residual above. This transformation is always returned as an 
 * Eigen::Matrix.
 */
 template <typename Derived, typename OtherDerived>
 typename internal::umeyama_transform_matrix_type<Derived, OtherDerived>::type
 umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)
 {
   typedef typename internal::umeyama_transform_matrix_type<Derived, OtherDerived>::type TransformationMatrixType;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Householder/BlockHouseholder.h` & `chronogram-0.2.0/include/Eigen/src/Householder/BlockHouseholder.h`

 * *Files 7% similar despite different names*

```diff
@@ -59,16 +59,23 @@
     Index rt = nbVecs-i-1;
 
     if(rt>0)
     {
       triFactor.row(i).tail(rt).noalias() = -hCoeffs(i) * vectors.col(i).tail(rs).adjoint()
                                                         * vectors.bottomRightCorner(rs, rt).template triangularView<UnitLower>();
             
-      // FIXME add .noalias() once the triangular product can work inplace
-      triFactor.row(i).tail(rt) = triFactor.row(i).tail(rt) * triFactor.bottomRightCorner(rt,rt).template triangularView<Upper>();
+      // FIXME use the following line with .noalias() once the triangular product can work inplace
+      // triFactor.row(i).tail(rt) = triFactor.row(i).tail(rt) * triFactor.bottomRightCorner(rt,rt).template triangularView<Upper>();
+      for(Index j=nbVecs-1; j>i; --j)
+      {
+        typename TriangularFactorType::Scalar z = triFactor(i,j);
+        triFactor(i,j) = z * triFactor(j,j);
+        if(nbVecs-j-1>0)
+          triFactor.row(i).tail(nbVecs-j-1) += z * triFactor.row(j).tail(nbVecs-j-1);
+      }
       
     }
     triFactor(i,i) = hCoeffs(i);
   }
 }
 
 /** \internal
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Householder/Householder.h` & `chronogram-0.2.0/include/Eigen/src/Householder/Householder.h`

 * *Files 8% similar despite different names*

```diff
@@ -35,14 +35,15 @@
   * \param tau the scaling factor of the Householder transformation
   * \param beta the result of H * \c *this
   *
   * \sa MatrixBase::makeHouseholder(), MatrixBase::applyHouseholderOnTheLeft(),
   *     MatrixBase::applyHouseholderOnTheRight()
   */
 template<typename Derived>
+EIGEN_DEVICE_FUNC
 void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)
 {
   VectorBlock<Derived, internal::decrement_size<Base::SizeAtCompileTime>::ret> essentialPart(derived(), 1, size()-1);
   makeHouseholder(essentialPart, tau, beta);
 }
 
 /** Computes the elementary reflector H such that:
@@ -58,14 +59,15 @@
   * \param beta the result of H * \c *this
   *
   * \sa MatrixBase::makeHouseholderInPlace(), MatrixBase::applyHouseholderOnTheLeft(),
   *     MatrixBase::applyHouseholderOnTheRight()
   */
 template<typename Derived>
 template<typename EssentialPart>
+EIGEN_DEVICE_FUNC
 void MatrixBase<Derived>::makeHouseholder(
   EssentialPart& essential,
   Scalar& tau,
   RealScalar& beta) const
 {
   using std::sqrt;
   using numext::conj;
@@ -99,21 +101,22 @@
   * \f$ v^T = [1 essential^T] \f$
   * from the left to a vector or matrix.
   *
   * On input:
   * \param essential the essential part of the vector \c v
   * \param tau the scaling factor of the Householder transformation
   * \param workspace a pointer to working space with at least
-  *                  this->cols() * essential.size() entries
+  *                  this->cols() entries
   *
   * \sa MatrixBase::makeHouseholder(), MatrixBase::makeHouseholderInPlace(), 
   *     MatrixBase::applyHouseholderOnTheRight()
   */
 template<typename Derived>
 template<typename EssentialPart>
+EIGEN_DEVICE_FUNC
 void MatrixBase<Derived>::applyHouseholderOnTheLeft(
   const EssentialPart& essential,
   const Scalar& tau,
   Scalar* workspace)
 {
   if(rows() == 1)
   {
@@ -136,37 +139,38 @@
   * \f$ v^T = [1 essential^T] \f$
   * from the right to a vector or matrix.
   *
   * On input:
   * \param essential the essential part of the vector \c v
   * \param tau the scaling factor of the Householder transformation
   * \param workspace a pointer to working space with at least
-  *                  this->cols() * essential.size() entries
+  *                  this->rows() entries
   *
   * \sa MatrixBase::makeHouseholder(), MatrixBase::makeHouseholderInPlace(), 
   *     MatrixBase::applyHouseholderOnTheLeft()
   */
 template<typename Derived>
 template<typename EssentialPart>
+EIGEN_DEVICE_FUNC
 void MatrixBase<Derived>::applyHouseholderOnTheRight(
   const EssentialPart& essential,
   const Scalar& tau,
   Scalar* workspace)
 {
   if(cols() == 1)
   {
     *this *= Scalar(1)-tau;
   }
   else if(tau!=Scalar(0))
   {
     Map<typename internal::plain_col_type<PlainObject>::type> tmp(workspace,rows());
     Block<Derived, Derived::RowsAtCompileTime, EssentialPart::SizeAtCompileTime> right(derived(), 0, 1, rows(), cols()-1);
-    tmp.noalias() = right * essential.conjugate();
+    tmp.noalias() = right * essential;
     tmp += this->col(0);
     this->col(0) -= tau * tmp;
-    right.noalias() -= tau * tmp * essential.transpose();
+    right.noalias() -= tau * tmp * essential.adjoint();
   }
 }
 
 } // end namespace Eigen
 
 #endif // EIGEN_HOUSEHOLDER_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Householder/HouseholderSequence.h` & `chronogram-0.2.0/include/Eigen/src/Householder/HouseholderSequence.h`

 * *Files 10% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_HOUSEHOLDER_SEQUENCE_H
 #define EIGEN_HOUSEHOLDER_SEQUENCE_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \ingroup Householder_Module
   * \householder_module
   * \class HouseholderSequence
   * \brief Sequence of Householder reflections acting on subspaces with decreasing size
   * \tparam VectorsType type of matrix containing the Householder vectors
   * \tparam CoeffsType  type of vector containing the Householder coefficients
@@ -30,16 +30,16 @@
   * HessenbergDecomposition::matrixQ(), Tridiagonalization::matrixQ(), HouseholderQR::householderQ(),
   * and ColPivHouseholderQR::householderQ() all return a %HouseholderSequence.
   *
   * More precisely, the class %HouseholderSequence represents an \f$ n \times n \f$ matrix \f$ H \f$ of the
   * form \f$ H = \prod_{i=0}^{n-1} H_i \f$ where the i-th Householder reflection is \f$ H_i = I - h_i v_i
   * v_i^* \f$. The i-th Householder coefficient \f$ h_i \f$ is a scalar and the i-th Householder vector \f$
   * v_i \f$ is a vector of the form
-  * \f[ 
-  * v_i = [\underbrace{0, \ldots, 0}_{i-1\mbox{ zeros}}, 1, \underbrace{*, \ldots,*}_{n-i\mbox{ arbitrary entries}} ]. 
+  * \f[
+  * v_i = [\underbrace{0, \ldots, 0}_{i-1\mbox{ zeros}}, 1, \underbrace{*, \ldots,*}_{n-i\mbox{ arbitrary entries}} ].
   * \f]
   * The last \f$ n-i \f$ entries of \f$ v_i \f$ are called the essential part of the Householder vector.
   *
   * Typical usages are listed below, where H is a HouseholderSequence:
   * \code
   * A.applyOnTheRight(H);             // A = A * H
   * A.applyOnTheLeft(H);              // A = H * A
@@ -83,15 +83,15 @@
 };
 
 template<typename VectorsType, typename CoeffsType, int Side>
 struct hseq_side_dependent_impl
 {
   typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;
   typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;
-  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)
+  static EIGEN_DEVICE_FUNC inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)
   {
     Index start = k+1+h.m_shift;
     return Block<const VectorsType,Dynamic,1>(h.m_vectors, start, k, h.rows()-start, 1);
   }
 };
 
 template<typename VectorsType, typename CoeffsType>
@@ -116,15 +116,15 @@
 
 } // end namespace internal
 
 template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence
   : public EigenBase<HouseholderSequence<VectorsType,CoeffsType,Side> >
 {
     typedef typename internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::EssentialVectorType EssentialVectorType;
-  
+
   public:
     enum {
       RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,
       ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,
       MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime
     };
@@ -136,14 +136,36 @@
         VectorsType>::type,
       typename internal::conditional<NumTraits<Scalar>::IsComplex,
         typename internal::remove_all<typename CoeffsType::ConjugateReturnType>::type,
         CoeffsType>::type,
       Side
     > ConjugateReturnType;
 
+    typedef HouseholderSequence<
+      VectorsType,
+      typename internal::conditional<NumTraits<Scalar>::IsComplex,
+        typename internal::remove_all<typename CoeffsType::ConjugateReturnType>::type,
+        CoeffsType>::type,
+      Side
+    > AdjointReturnType;
+
+    typedef HouseholderSequence<
+      typename internal::conditional<NumTraits<Scalar>::IsComplex,
+        typename internal::remove_all<typename VectorsType::ConjugateReturnType>::type,
+        VectorsType>::type,
+      CoeffsType,
+      Side
+    > TransposeReturnType;
+
+    typedef HouseholderSequence<
+      typename internal::add_const<VectorsType>::type,
+      typename internal::add_const<CoeffsType>::type,
+      Side
+    > ConstHouseholderSequence;
+
     /** \brief Constructor.
       * \param[in]  v      %Matrix containing the essential parts of the Householder vectors
       * \param[in]  h      Vector containing the Householder coefficients
       *
       * Constructs the Householder sequence with coefficients given by \p h and vectors given by \p v. The
       * i-th Householder coefficient \f$ h_i \f$ is given by \p h(i) and the essential part of the i-th
       * Householder vector \f$ v_i \f$ is given by \p v(k,i) with \p k > \p i (the subdiagonal part of the
@@ -153,134 +175,168 @@
       * \note The %HouseholderSequence object stores \p v and \p h by reference.
       *
       * Example: \include HouseholderSequence_HouseholderSequence.cpp
       * Output: \verbinclude HouseholderSequence_HouseholderSequence.out
       *
       * \sa setLength(), setShift()
       */
+    EIGEN_DEVICE_FUNC
     HouseholderSequence(const VectorsType& v, const CoeffsType& h)
-      : m_vectors(v), m_coeffs(h), m_trans(false), m_length(v.diagonalSize()),
+      : m_vectors(v), m_coeffs(h), m_reverse(false), m_length(v.diagonalSize()),
         m_shift(0)
     {
     }
 
     /** \brief Copy constructor. */
+    EIGEN_DEVICE_FUNC
     HouseholderSequence(const HouseholderSequence& other)
       : m_vectors(other.m_vectors),
         m_coeffs(other.m_coeffs),
-        m_trans(other.m_trans),
+        m_reverse(other.m_reverse),
         m_length(other.m_length),
         m_shift(other.m_shift)
     {
     }
 
     /** \brief Number of rows of transformation viewed as a matrix.
-      * \returns Number of rows 
+      * \returns Number of rows
       * \details This equals the dimension of the space that the transformation acts on.
       */
-    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index rows() const EIGEN_NOEXCEPT { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }
 
     /** \brief Number of columns of transformation viewed as a matrix.
       * \returns Number of columns
       * \details This equals the dimension of the space that the transformation acts on.
       */
-    Index cols() const { return rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    Index cols() const EIGEN_NOEXCEPT { return rows(); }
 
     /** \brief Essential part of a Householder vector.
       * \param[in]  k  Index of Householder reflection
       * \returns    Vector containing non-trivial entries of k-th Householder vector
       *
       * This function returns the essential part of the Householder vector \f$ v_i \f$. This is a vector of
       * length \f$ n-i \f$ containing the last \f$ n-i \f$ entries of the vector
-      * \f[ 
-      * v_i = [\underbrace{0, \ldots, 0}_{i-1\mbox{ zeros}}, 1, \underbrace{*, \ldots,*}_{n-i\mbox{ arbitrary entries}} ]. 
+      * \f[
+      * v_i = [\underbrace{0, \ldots, 0}_{i-1\mbox{ zeros}}, 1, \underbrace{*, \ldots,*}_{n-i\mbox{ arbitrary entries}} ].
       * \f]
       * The index \f$ i \f$ equals \p k + shift(), corresponding to the k-th column of the matrix \p v
       * passed to the constructor.
       *
       * \sa setShift(), shift()
       */
+    EIGEN_DEVICE_FUNC
     const EssentialVectorType essentialVector(Index k) const
     {
       eigen_assert(k >= 0 && k < m_length);
       return internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::essentialVector(*this, k);
     }
 
     /** \brief %Transpose of the Householder sequence. */
-    HouseholderSequence transpose() const
+    TransposeReturnType transpose() const
     {
-      return HouseholderSequence(*this).setTrans(!m_trans);
+      return TransposeReturnType(m_vectors.conjugate(), m_coeffs)
+              .setReverseFlag(!m_reverse)
+              .setLength(m_length)
+              .setShift(m_shift);
     }
 
     /** \brief Complex conjugate of the Householder sequence. */
     ConjugateReturnType conjugate() const
     {
       return ConjugateReturnType(m_vectors.conjugate(), m_coeffs.conjugate())
-             .setTrans(m_trans)
+             .setReverseFlag(m_reverse)
              .setLength(m_length)
              .setShift(m_shift);
     }
 
+    /** \returns an expression of the complex conjugate of \c *this if Cond==true,
+     *           returns \c *this otherwise.
+     */
+    template<bool Cond>
+    EIGEN_DEVICE_FUNC
+    inline typename internal::conditional<Cond,ConjugateReturnType,ConstHouseholderSequence>::type
+    conjugateIf() const
+    {
+      typedef typename internal::conditional<Cond,ConjugateReturnType,ConstHouseholderSequence>::type ReturnType;
+      return ReturnType(m_vectors.template conjugateIf<Cond>(), m_coeffs.template conjugateIf<Cond>());
+    }
+
     /** \brief Adjoint (conjugate transpose) of the Householder sequence. */
-    ConjugateReturnType adjoint() const
+    AdjointReturnType adjoint() const
     {
-      return conjugate().setTrans(!m_trans);
+      return AdjointReturnType(m_vectors, m_coeffs.conjugate())
+              .setReverseFlag(!m_reverse)
+              .setLength(m_length)
+              .setShift(m_shift);
     }
 
     /** \brief Inverse of the Householder sequence (equals the adjoint). */
-    ConjugateReturnType inverse() const { return adjoint(); }
+    AdjointReturnType inverse() const { return adjoint(); }
 
     /** \internal */
-    template<typename DestType> inline void evalTo(DestType& dst) const
+    template<typename DestType>
+    inline EIGEN_DEVICE_FUNC
+    void evalTo(DestType& dst) const
     {
       Matrix<Scalar, DestType::RowsAtCompileTime, 1,
              AutoAlign|ColMajor, DestType::MaxRowsAtCompileTime, 1> workspace(rows());
       evalTo(dst, workspace);
     }
 
     /** \internal */
     template<typename Dest, typename Workspace>
+    EIGEN_DEVICE_FUNC
     void evalTo(Dest& dst, Workspace& workspace) const
     {
       workspace.resize(rows());
       Index vecs = m_length;
       if(internal::is_same_dense(dst,m_vectors))
       {
         // in-place
         dst.diagonal().setOnes();
         dst.template triangularView<StrictlyUpper>().setZero();
         for(Index k = vecs-1; k >= 0; --k)
         {
           Index cornerSize = rows() - k - m_shift;
-          if(m_trans)
+          if(m_reverse)
             dst.bottomRightCorner(cornerSize, cornerSize)
                .applyHouseholderOnTheRight(essentialVector(k), m_coeffs.coeff(k), workspace.data());
           else
             dst.bottomRightCorner(cornerSize, cornerSize)
                .applyHouseholderOnTheLeft(essentialVector(k), m_coeffs.coeff(k), workspace.data());
 
           // clear the off diagonal vector
           dst.col(k).tail(rows()-k-1).setZero();
         }
         // clear the remaining columns if needed
         for(Index k = 0; k<cols()-vecs ; ++k)
           dst.col(k).tail(rows()-k-1).setZero();
       }
+      else if(m_length>BlockSize)
+      {
+        dst.setIdentity(rows(), rows());
+        if(m_reverse)
+          applyThisOnTheLeft(dst,workspace,true);
+        else
+          applyThisOnTheLeft(dst,workspace,true);
+      }
       else
       {
         dst.setIdentity(rows(), rows());
         for(Index k = vecs-1; k >= 0; --k)
         {
           Index cornerSize = rows() - k - m_shift;
-          if(m_trans)
+          if(m_reverse)
             dst.bottomRightCorner(cornerSize, cornerSize)
-               .applyHouseholderOnTheRight(essentialVector(k), m_coeffs.coeff(k), &workspace.coeffRef(0));
+               .applyHouseholderOnTheRight(essentialVector(k), m_coeffs.coeff(k), workspace.data());
           else
             dst.bottomRightCorner(cornerSize, cornerSize)
-               .applyHouseholderOnTheLeft(essentialVector(k), m_coeffs.coeff(k), &workspace.coeffRef(0));
+               .applyHouseholderOnTheLeft(essentialVector(k), m_coeffs.coeff(k), workspace.data());
         }
       }
     }
 
     /** \internal */
     template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const
     {
@@ -291,59 +347,70 @@
     /** \internal */
     template<typename Dest, typename Workspace>
     inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const
     {
       workspace.resize(dst.rows());
       for(Index k = 0; k < m_length; ++k)
       {
-        Index actual_k = m_trans ? m_length-k-1 : k;
+        Index actual_k = m_reverse ? m_length-k-1 : k;
         dst.rightCols(rows()-m_shift-actual_k)
            .applyHouseholderOnTheRight(essentialVector(actual_k), m_coeffs.coeff(actual_k), workspace.data());
       }
     }
 
     /** \internal */
-    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const
+    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst, bool inputIsIdentity = false) const
     {
       Matrix<Scalar,1,Dest::ColsAtCompileTime,RowMajor,1,Dest::MaxColsAtCompileTime> workspace;
-      applyThisOnTheLeft(dst, workspace);
+      applyThisOnTheLeft(dst, workspace, inputIsIdentity);
     }
 
     /** \internal */
     template<typename Dest, typename Workspace>
-    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const
+    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace, bool inputIsIdentity = false) const
     {
-      const Index BlockSize = 48;
+      if(inputIsIdentity && m_reverse)
+        inputIsIdentity = false;
       // if the entries are large enough, then apply the reflectors by block
       if(m_length>=BlockSize && dst.cols()>1)
       {
-        for(Index i = 0; i < m_length; i+=BlockSize)
+        // Make sure we have at least 2 useful blocks, otherwise it is point-less:
+        Index blockSize = m_length<Index(2*BlockSize) ? (m_length+1)/2 : Index(BlockSize);
+        for(Index i = 0; i < m_length; i+=blockSize)
         {
-          Index end = m_trans ? (std::min)(m_length,i+BlockSize) : m_length-i;
-          Index k = m_trans ? i : (std::max)(Index(0),end-BlockSize);
+          Index end = m_reverse ? (std::min)(m_length,i+blockSize) : m_length-i;
+          Index k = m_reverse ? i : (std::max)(Index(0),end-blockSize);
           Index bs = end-k;
           Index start = k + m_shift;
-          
+
           typedef Block<typename internal::remove_all<VectorsType>::type,Dynamic,Dynamic> SubVectorsType;
           SubVectorsType sub_vecs1(m_vectors.const_cast_derived(), Side==OnTheRight ? k : start,
                                                                    Side==OnTheRight ? start : k,
                                                                    Side==OnTheRight ? bs : m_vectors.rows()-start,
                                                                    Side==OnTheRight ? m_vectors.cols()-start : bs);
           typename internal::conditional<Side==OnTheRight, Transpose<SubVectorsType>, SubVectorsType&>::type sub_vecs(sub_vecs1);
-          Block<Dest,Dynamic,Dynamic> sub_dst(dst,dst.rows()-rows()+m_shift+k,0, rows()-m_shift-k,dst.cols());
-          apply_block_householder_on_the_left(sub_dst, sub_vecs, m_coeffs.segment(k, bs), !m_trans);
+
+          Index dstStart = dst.rows()-rows()+m_shift+k;
+          Index dstRows  = rows()-m_shift-k;
+          Block<Dest,Dynamic,Dynamic> sub_dst(dst,
+                                              dstStart,
+                                              inputIsIdentity ? dstStart : 0,
+                                              dstRows,
+                                              inputIsIdentity ? dstRows : dst.cols());
+          apply_block_householder_on_the_left(sub_dst, sub_vecs, m_coeffs.segment(k, bs), !m_reverse);
         }
       }
       else
       {
         workspace.resize(dst.cols());
         for(Index k = 0; k < m_length; ++k)
         {
-          Index actual_k = m_trans ? k : m_length-k-1;
-          dst.bottomRows(rows()-m_shift-actual_k)
+          Index actual_k = m_reverse ? k : m_length-k-1;
+          Index dstStart = rows()-m_shift-actual_k;
+          dst.bottomRightCorner(dstStart, inputIsIdentity ? dstStart : dst.cols())
             .applyHouseholderOnTheLeft(essentialVector(actual_k), m_coeffs.coeff(actual_k), workspace.data());
         }
       }
     }
 
     /** \brief Computes the product of a Householder sequence with a matrix.
       * \param[in]  other  %Matrix being multiplied.
@@ -353,29 +420,30 @@
       * and \f$ M \f$ is the matrix \p other.
       */
     template<typename OtherDerived>
     typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const
     {
       typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type
         res(other.template cast<typename internal::matrix_type_times_scalar_type<Scalar,OtherDerived>::ResultScalar>());
-      applyThisOnTheLeft(res);
+      applyThisOnTheLeft(res, internal::is_identity<OtherDerived>::value && res.rows()==res.cols());
       return res;
     }
 
     template<typename _VectorsType, typename _CoeffsType, int _Side> friend struct internal::hseq_side_dependent_impl;
 
     /** \brief Sets the length of the Householder sequence.
       * \param [in]  length  New value for the length.
       *
       * By default, the length \f$ n \f$ of the Householder sequence \f$ H = H_0 H_1 \ldots H_{n-1} \f$ is set
       * to the number of columns of the matrix \p v passed to the constructor, or the number of rows if that
       * is smaller. After this function is called, the length equals \p length.
       *
       * \sa length()
       */
+    EIGEN_DEVICE_FUNC
     HouseholderSequence& setLength(Index length)
     {
       m_length = length;
       return *this;
     }
 
     /** \brief Sets the shift of the Householder sequence.
@@ -385,49 +453,56 @@
       * column of the matrix \p v passed to the constructor corresponds to the i-th Householder
       * reflection. After this function is called, the object represents \f$ H = H_{\mathrm{shift}}
       * H_{\mathrm{shift}+1} \ldots H_{n-1} \f$ and the i-th column of \p v corresponds to the (shift+i)-th
       * Householder reflection.
       *
       * \sa shift()
       */
+    EIGEN_DEVICE_FUNC
     HouseholderSequence& setShift(Index shift)
     {
       m_shift = shift;
       return *this;
     }
 
+    EIGEN_DEVICE_FUNC
     Index length() const { return m_length; }  /**< \brief Returns the length of the Householder sequence. */
+
+    EIGEN_DEVICE_FUNC
     Index shift() const { return m_shift; }    /**< \brief Returns the shift of the Householder sequence. */
 
     /* Necessary for .adjoint() and .conjugate() */
     template <typename VectorsType2, typename CoeffsType2, int Side2> friend class HouseholderSequence;
 
   protected:
 
-    /** \brief Sets the transpose flag.
-      * \param [in]  trans  New value of the transpose flag.
-      *
-      * By default, the transpose flag is not set. If the transpose flag is set, then this object represents 
-      * \f$ H^T = H_{n-1}^T \ldots H_1^T H_0^T \f$ instead of \f$ H = H_0 H_1 \ldots H_{n-1} \f$.
+    /** \internal
+      * \brief Sets the reverse flag.
+      * \param [in]  reverse  New value of the reverse flag.
+      *
+      * By default, the reverse flag is not set. If the reverse flag is set, then this object represents
+      * \f$ H^r = H_{n-1} \ldots H_1 H_0 \f$ instead of \f$ H = H_0 H_1 \ldots H_{n-1} \f$.
+      * \note For real valued HouseholderSequence this is equivalent to transposing \f$ H \f$.
       *
-      * \sa trans()
+      * \sa reverseFlag(), transpose(), adjoint()
       */
-    HouseholderSequence& setTrans(bool trans)
+    HouseholderSequence& setReverseFlag(bool reverse)
     {
-      m_trans = trans;
+      m_reverse = reverse;
       return *this;
     }
 
-    bool trans() const { return m_trans; }     /**< \brief Returns the transpose flag. */
+    bool reverseFlag() const { return m_reverse; }     /**< \internal \brief Returns the reverse flag. */
 
     typename VectorsType::Nested m_vectors;
     typename CoeffsType::Nested m_coeffs;
-    bool m_trans;
+    bool m_reverse;
     Index m_length;
     Index m_shift;
+    enum { BlockSize = 48 };
 };
 
 /** \brief Computes the product of a matrix with a Householder sequence.
   * \param[in]  other  %Matrix being multiplied.
   * \param[in]  h      %HouseholderSequence being multiplied.
   * \returns    Expression object representing the product.
   *
@@ -440,25 +515,25 @@
   typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type
     res(other.template cast<typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::ResultScalar>());
   h.applyThisOnTheRight(res);
   return res;
 }
 
 /** \ingroup Householder_Module \householder_module
-  * \brief Convenience function for constructing a Householder sequence. 
+  * \brief Convenience function for constructing a Householder sequence.
   * \returns A HouseholderSequence constructed from the specified arguments.
   */
 template<typename VectorsType, typename CoeffsType>
 HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)
 {
   return HouseholderSequence<VectorsType,CoeffsType,OnTheLeft>(v, h);
 }
 
 /** \ingroup Householder_Module \householder_module
-  * \brief Convenience function for constructing a Householder sequence. 
+  * \brief Convenience function for constructing a Householder sequence.
   * \returns A HouseholderSequence constructed from the specified arguments.
   * \details This function differs from householderSequence() in that the template argument \p OnTheSide of
   * the constructed HouseholderSequence is set to OnTheRight, instead of the default OnTheLeft.
   */
 template<typename VectorsType, typename CoeffsType>
 HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)
 {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h` & `chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_BASIC_PRECONDITIONERS_H
 #define EIGEN_BASIC_PRECONDITIONERS_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \ingroup IterativeLinearSolvers_Module
   * \brief A preconditioner based on the digonal entries
   *
   * This class allows to approximately solve for A.x = b problems assuming A is a diagonal matrix.
   * In other words, this preconditioner neglects all off diagonal entries and, in Eigen's language, solves for:
     \code
@@ -48,23 +48,23 @@
 
     template<typename MatType>
     explicit DiagonalPreconditioner(const MatType& mat) : m_invdiag(mat.cols())
     {
       compute(mat);
     }
 
-    Index rows() const { return m_invdiag.size(); }
-    Index cols() const { return m_invdiag.size(); }
-    
+    EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_invdiag.size(); }
+    EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_invdiag.size(); }
+
     template<typename MatType>
     DiagonalPreconditioner& analyzePattern(const MatType& )
     {
       return *this;
     }
-    
+
     template<typename MatType>
     DiagonalPreconditioner& factorize(const MatType& mat)
     {
       m_invdiag.resize(mat.cols());
       for(int j=0; j<mat.outerSize(); ++j)
       {
         typename MatType::InnerIterator it(mat,j);
@@ -73,15 +73,15 @@
           m_invdiag(j) = Scalar(1)/it.value();
         else
           m_invdiag(j) = Scalar(1);
       }
       m_isInitialized = true;
       return *this;
     }
-    
+
     template<typename MatType>
     DiagonalPreconditioner& compute(const MatType& mat)
     {
       return factorize(mat);
     }
 
     /** \internal */
@@ -95,15 +95,15 @@
     solve(const MatrixBase<Rhs>& b) const
     {
       eigen_assert(m_isInitialized && "DiagonalPreconditioner is not initialized.");
       eigen_assert(m_invdiag.size()==b.rows()
                 && "DiagonalPreconditioner::solve(): invalid number of rows of the right hand side matrix b");
       return Solve<DiagonalPreconditioner, Rhs>(*this, b.derived());
     }
-    
+
     ComputationInfo info() { return Success; }
 
   protected:
     Vector m_invdiag;
     bool m_isInitialized;
 };
 
@@ -117,15 +117,15 @@
     \endcode
   *
   * \tparam _Scalar the type of the scalar.
   *
   * \implsparsesolverconcept
   *
   * The diagonal entries are pre-inverted and stored into a dense vector.
-  * 
+  *
   * \sa class LeastSquaresConjugateGradient, class DiagonalPreconditioner
   */
 template <typename _Scalar>
 class LeastSquareDiagonalPreconditioner : public DiagonalPreconditioner<_Scalar>
 {
     typedef _Scalar Scalar;
     typedef typename NumTraits<Scalar>::Real RealScalar;
@@ -142,15 +142,15 @@
     }
 
     template<typename MatType>
     LeastSquareDiagonalPreconditioner& analyzePattern(const MatType& )
     {
       return *this;
     }
-    
+
     template<typename MatType>
     LeastSquareDiagonalPreconditioner& factorize(const MatType& mat)
     {
       // Compute the inverse squared-norm of each column of mat
       m_invdiag.resize(mat.cols());
       if(MatType::IsRowMajor)
       {
@@ -174,21 +174,21 @@
           else
             m_invdiag(j) = RealScalar(1);
         }
       }
       Base::m_isInitialized = true;
       return *this;
     }
-    
+
     template<typename MatType>
     LeastSquareDiagonalPreconditioner& compute(const MatType& mat)
     {
       return factorize(mat);
     }
-    
+
     ComputationInfo info() { return Success; }
 
   protected:
 };
 
 /** \ingroup IterativeLinearSolvers_Module
   * \brief A naive preconditioner which approximates any matrix as the identity matrix
@@ -201,26 +201,26 @@
 {
   public:
 
     IdentityPreconditioner() {}
 
     template<typename MatrixType>
     explicit IdentityPreconditioner(const MatrixType& ) {}
-    
+
     template<typename MatrixType>
     IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }
-    
+
     template<typename MatrixType>
     IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }
 
     template<typename MatrixType>
     IdentityPreconditioner& compute(const MatrixType& ) { return *this; }
-    
+
     template<typename Rhs>
     inline const Rhs& solve(const Rhs& b) const { return b; }
-    
+
     ComputationInfo info() { return Success; }
 };
 
 } // end namespace Eigen
 
 #endif // EIGEN_BASIC_PRECONDITIONERS_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h` & `chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/BiCGSTAB.h`

 * *Files 3% similar despite different names*

```diff
@@ -187,40 +187,24 @@
   template<typename MatrixDerived>
   explicit BiCGSTAB(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}
 
   ~BiCGSTAB() {}
 
   /** \internal */
   template<typename Rhs,typename Dest>
-  void _solve_with_guess_impl(const Rhs& b, Dest& x) const
+  void _solve_vector_with_guess_impl(const Rhs& b, Dest& x) const
   {    
-    bool failed = false;
-    for(Index j=0; j<b.cols(); ++j)
-    {
-      m_iterations = Base::maxIterations();
-      m_error = Base::m_tolerance;
-      
-      typename Dest::ColXpr xj(x,j);
-      if(!internal::bicgstab(matrix(), b.col(j), xj, Base::m_preconditioner, m_iterations, m_error))
-        failed = true;
-    }
-    m_info = failed ? NumericalIssue
+    m_iterations = Base::maxIterations();
+    m_error = Base::m_tolerance;
+    
+    bool ret = internal::bicgstab(matrix(), b, x, Base::m_preconditioner, m_iterations, m_error);
+
+    m_info = (!ret) ? NumericalIssue
            : m_error <= Base::m_tolerance ? Success
            : NoConvergence;
-    m_isInitialized = true;
-  }
-
-  /** \internal */
-  using Base::_solve_impl;
-  template<typename Rhs,typename Dest>
-  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const
-  {
-    x.resize(this->rows(),b.cols());
-    x.setZero();
-    _solve_with_guess_impl(b,x);
   }
 
 protected:
 
 };
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h` & `chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/ConjugateGradient.h`

 * *Files 2% similar despite different names*

```diff
@@ -47,15 +47,15 @@
   {
     x.setZero();
     iters = 0;
     tol_error = 0;
     return;
   }
   const RealScalar considerAsZero = (std::numeric_limits<RealScalar>::min)();
-  RealScalar threshold = numext::maxi(tol*tol*rhsNorm2,considerAsZero);
+  RealScalar threshold = numext::maxi(RealScalar(tol*tol*rhsNorm2),considerAsZero);
   RealScalar residualNorm2 = residual.squaredNorm();
   if (residualNorm2 < threshold)
   {
     iters = 0;
     tol_error = sqrt(residualNorm2 / rhsNorm2);
     return;
   }
@@ -191,15 +191,15 @@
   template<typename MatrixDerived>
   explicit ConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}
 
   ~ConjugateGradient() {}
 
   /** \internal */
   template<typename Rhs,typename Dest>
-  void _solve_with_guess_impl(const Rhs& b, Dest& x) const
+  void _solve_vector_with_guess_impl(const Rhs& b, Dest& x) const
   {
     typedef typename Base::MatrixWrapper MatrixWrapper;
     typedef typename Base::ActualMatrixType ActualMatrixType;
     enum {
       TransposeInput  =   (!MatrixWrapper::MatrixFree)
                       &&  (UpLo==(Lower|Upper))
                       &&  (!MatrixType::IsRowMajor)
@@ -207,39 +207,22 @@
     };
     typedef typename internal::conditional<TransposeInput,Transpose<const ActualMatrixType>, ActualMatrixType const&>::type RowMajorWrapper;
     EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(MatrixWrapper::MatrixFree,UpLo==(Lower|Upper)),MATRIX_FREE_CONJUGATE_GRADIENT_IS_COMPATIBLE_WITH_UPPER_UNION_LOWER_MODE_ONLY);
     typedef typename internal::conditional<UpLo==(Lower|Upper),
                                            RowMajorWrapper,
                                            typename MatrixWrapper::template ConstSelfAdjointViewReturnType<UpLo>::Type
                                           >::type SelfAdjointWrapper;
+
     m_iterations = Base::maxIterations();
     m_error = Base::m_tolerance;
 
-    for(Index j=0; j<b.cols(); ++j)
-    {
-      m_iterations = Base::maxIterations();
-      m_error = Base::m_tolerance;
-
-      typename Dest::ColXpr xj(x,j);
-      RowMajorWrapper row_mat(matrix());
-      internal::conjugate_gradient(SelfAdjointWrapper(row_mat), b.col(j), xj, Base::m_preconditioner, m_iterations, m_error);
-    }
-
-    m_isInitialized = true;
+    RowMajorWrapper row_mat(matrix());
+    internal::conjugate_gradient(SelfAdjointWrapper(row_mat), b, x, Base::m_preconditioner, m_iterations, m_error);
     m_info = m_error <= Base::m_tolerance ? Success : NoConvergence;
   }
-  
-  /** \internal */
-  using Base::_solve_impl;
-  template<typename Rhs,typename Dest>
-  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const
-  {
-    x.setZero();
-    _solve_with_guess_impl(b.derived(),x);
-  }
 
 protected:
 
 };
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h` & `chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/IncompleteCholesky.h`

 * *Files 3% similar despite different names*

```diff
@@ -10,16 +10,16 @@
 
 #ifndef EIGEN_INCOMPLETE_CHOlESKY_H
 #define EIGEN_INCOMPLETE_CHOlESKY_H
 
 #include <vector>
 #include <list>
 
-namespace Eigen {  
-/** 
+namespace Eigen {
+/**
   * \brief Modified Incomplete Cholesky with dual threshold
   *
   * References : C-J. Lin and J. J. Mor, Incomplete Cholesky Factorizations with
   *              Limited memory, SIAM J. Sci. Comput.  21(1), pp. 24-45, 1999
   *
   * \tparam Scalar the scalar type of the input matrices
   * \tparam _UpLo The triangular part that will be used for the computations. It can be Lower
@@ -37,123 +37,117 @@
   * and \f$ \beta \f$ be the minimum value of the diagonal. If \f$ \beta > 0 \f$ then, the factorization is directly performed
   * on the matrix B. Otherwise, the factorization is performed on the shifted matrix \f$ B + (\sigma+|\beta| I \f$ where
   * \f$ \sigma \f$ is the initial shift value as returned and set by setInitialShift() method. The default value is \f$ \sigma = 10^{-3} \f$.
   * If the factorization fails, then the shift in doubled until it succeed or a maximum of ten attempts. If it still fails, as returned by
   * the info() method, then you can either increase the initial shift, or better use another preconditioning technique.
   *
   */
-template <typename Scalar, int _UpLo = Lower, typename _OrderingType =
-#ifndef EIGEN_MPL2_ONLY
-AMDOrdering<int>
-#else
-NaturalOrdering<int>
-#endif
->
+template <typename Scalar, int _UpLo = Lower, typename _OrderingType = AMDOrdering<int> >
 class IncompleteCholesky : public SparseSolverBase<IncompleteCholesky<Scalar,_UpLo,_OrderingType> >
 {
   protected:
     typedef SparseSolverBase<IncompleteCholesky<Scalar,_UpLo,_OrderingType> > Base;
     using Base::m_isInitialized;
   public:
-    typedef typename NumTraits<Scalar>::Real RealScalar; 
+    typedef typename NumTraits<Scalar>::Real RealScalar;
     typedef _OrderingType OrderingType;
     typedef typename OrderingType::PermutationType PermutationType;
-    typedef typename PermutationType::StorageIndex StorageIndex; 
+    typedef typename PermutationType::StorageIndex StorageIndex;
     typedef SparseMatrix<Scalar,ColMajor,StorageIndex> FactorType;
     typedef Matrix<Scalar,Dynamic,1> VectorSx;
     typedef Matrix<RealScalar,Dynamic,1> VectorRx;
     typedef Matrix<StorageIndex,Dynamic, 1> VectorIx;
-    typedef std::vector<std::list<StorageIndex> > VectorList; 
+    typedef std::vector<std::list<StorageIndex> > VectorList;
     enum { UpLo = _UpLo };
     enum {
       ColsAtCompileTime = Dynamic,
       MaxColsAtCompileTime = Dynamic
     };
   public:
 
     /** Default constructor leaving the object in a partly non-initialized stage.
       *
       * You must call compute() or the pair analyzePattern()/factorize() to make it valid.
       *
       * \sa IncompleteCholesky(const MatrixType&)
       */
-    IncompleteCholesky() : m_initialShift(1e-3),m_factorizationIsOk(false) {}
-    
+    IncompleteCholesky() : m_initialShift(1e-3),m_analysisIsOk(false),m_factorizationIsOk(false) {}
+
     /** Constructor computing the incomplete factorization for the given matrix \a matrix.
       */
     template<typename MatrixType>
-    IncompleteCholesky(const MatrixType& matrix) : m_initialShift(1e-3),m_factorizationIsOk(false)
+    IncompleteCholesky(const MatrixType& matrix) : m_initialShift(1e-3),m_analysisIsOk(false),m_factorizationIsOk(false)
     {
       compute(matrix);
     }
-    
+
     /** \returns number of rows of the factored matrix */
-    Index rows() const { return m_L.rows(); }
-    
+    EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_L.rows(); }
+
     /** \returns number of columns of the factored matrix */
-    Index cols() const { return m_L.cols(); }
-    
+    EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_L.cols(); }
+
 
     /** \brief Reports whether previous computation was successful.
       *
       * It triggers an assertion if \c *this has not been initialized through the respective constructor,
       * or a call to compute() or analyzePattern().
       *
       * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the matrix appears to be negative.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "IncompleteCholesky is not initialized.");
       return m_info;
     }
-    
+
     /** \brief Set the initial shift parameter \f$ \sigma \f$.
       */
     void setInitialShift(RealScalar shift) { m_initialShift = shift; }
-    
+
     /** \brief Computes the fill reducing permutation vector using the sparsity pattern of \a mat
       */
     template<typename MatrixType>
     void analyzePattern(const MatrixType& mat)
     {
-      OrderingType ord; 
+      OrderingType ord;
       PermutationType pinv;
-      ord(mat.template selfadjointView<UpLo>(), pinv); 
+      ord(mat.template selfadjointView<UpLo>(), pinv);
       if(pinv.size()>0) m_perm = pinv.inverse();
       else              m_perm.resize(0);
       m_L.resize(mat.rows(), mat.cols());
       m_analysisIsOk = true;
       m_isInitialized = true;
       m_info = Success;
     }
-    
+
     /** \brief Performs the numerical factorization of the input matrix \a mat
       *
       * The method analyzePattern() or compute() must have been called beforehand
       * with a matrix having the same pattern.
       *
       * \sa compute(), analyzePattern()
       */
     template<typename MatrixType>
     void factorize(const MatrixType& mat);
-    
+
     /** Computes or re-computes the incomplete Cholesky factorization of the input matrix \a mat
       *
       * It is a shortcut for a sequential call to the analyzePattern() and factorize() methods.
       *
       * \sa analyzePattern(), factorize()
       */
     template<typename MatrixType>
     void compute(const MatrixType& mat)
     {
       analyzePattern(mat);
       factorize(mat);
     }
-    
+
     // internal
     template<typename Rhs, typename Dest>
     void _solve_impl(const Rhs& b, Dest& x) const
     {
       eigen_assert(m_factorizationIsOk && "factorize() should be called first");
       if (m_perm.rows() == b.rows())  x = m_perm * b;
       else                            x = b;
@@ -172,98 +166,98 @@
     const VectorRx& scalingS() const { eigen_assert("m_factorizationIsOk"); return m_scale; }
 
     /** \returns the fill-in reducing permutation P (can be empty for a natural ordering) */
     const PermutationType& permutationP() const { eigen_assert("m_analysisIsOk"); return m_perm; }
 
   protected:
     FactorType m_L;              // The lower part stored in CSC
-    VectorRx m_scale;            // The vector for scaling the matrix 
+    VectorRx m_scale;            // The vector for scaling the matrix
     RealScalar m_initialShift;   // The initial shift parameter
-    bool m_analysisIsOk; 
-    bool m_factorizationIsOk; 
+    bool m_analysisIsOk;
+    bool m_factorizationIsOk;
     ComputationInfo m_info;
-    PermutationType m_perm; 
+    PermutationType m_perm;
 
   private:
-    inline void updateList(Ref<const VectorIx> colPtr, Ref<VectorIx> rowIdx, Ref<VectorSx> vals, const Index& col, const Index& jk, VectorIx& firstElt, VectorList& listCol); 
-}; 
+    inline void updateList(Ref<const VectorIx> colPtr, Ref<VectorIx> rowIdx, Ref<VectorSx> vals, const Index& col, const Index& jk, VectorIx& firstElt, VectorList& listCol);
+};
 
 // Based on the following paper:
 //   C-J. Lin and J. J. Mor, Incomplete Cholesky Factorizations with
 //   Limited memory, SIAM J. Sci. Comput.  21(1), pp. 24-45, 1999
 //   http://ftp.mcs.anl.gov/pub/tech_reports/reports/P682.pdf
 template<typename Scalar, int _UpLo, typename OrderingType>
 template<typename _MatrixType>
 void IncompleteCholesky<Scalar,_UpLo, OrderingType>::factorize(const _MatrixType& mat)
 {
   using std::sqrt;
-  eigen_assert(m_analysisIsOk && "analyzePattern() should be called first"); 
-    
+  eigen_assert(m_analysisIsOk && "analyzePattern() should be called first");
+
   // Dropping strategy : Keep only the p largest elements per column, where p is the number of elements in the column of the original matrix. Other strategies will be added
-  
+
   // Apply the fill-reducing permutation computed in analyzePattern()
   if (m_perm.rows() == mat.rows() ) // To detect the null permutation
   {
     // The temporary is needed to make sure that the diagonal entry is properly sorted
     FactorType tmp(mat.rows(), mat.cols());
     tmp = mat.template selfadjointView<_UpLo>().twistedBy(m_perm);
     m_L.template selfadjointView<Lower>() = tmp.template selfadjointView<Lower>();
   }
   else
   {
     m_L.template selfadjointView<Lower>() = mat.template selfadjointView<_UpLo>();
   }
-  
-  Index n = m_L.cols(); 
+
+  Index n = m_L.cols();
   Index nnz = m_L.nonZeros();
   Map<VectorSx> vals(m_L.valuePtr(), nnz);         //values
   Map<VectorIx> rowIdx(m_L.innerIndexPtr(), nnz);  //Row indices
   Map<VectorIx> colPtr( m_L.outerIndexPtr(), n+1); // Pointer to the beginning of each row
   VectorIx firstElt(n-1); // for each j, points to the next entry in vals that will be used in the factorization
   VectorList listCol(n);  // listCol(j) is a linked list of columns to update column j
   VectorSx col_vals(n);   // Store a  nonzero values in each column
   VectorIx col_irow(n);   // Row indices of nonzero elements in each column
   VectorIx col_pattern(n);
   col_pattern.fill(-1);
   StorageIndex col_nnz;
-  
-  
-  // Computes the scaling factors 
+
+
+  // Computes the scaling factors
   m_scale.resize(n);
   m_scale.setZero();
   for (Index j = 0; j < n; j++)
     for (Index k = colPtr[j]; k < colPtr[j+1]; k++)
     {
       m_scale(j) += numext::abs2(vals(k));
       if(rowIdx[k]!=j)
         m_scale(rowIdx[k]) += numext::abs2(vals(k));
     }
-  
+
   m_scale = m_scale.cwiseSqrt().cwiseSqrt();
 
   for (Index j = 0; j < n; ++j)
     if(m_scale(j)>(std::numeric_limits<RealScalar>::min)())
       m_scale(j) = RealScalar(1)/m_scale(j);
     else
       m_scale(j) = 1;
 
   // TODO disable scaling if not needed, i.e., if it is roughly uniform? (this will make solve() faster)
-  
-  // Scale and compute the shift for the matrix 
+
+  // Scale and compute the shift for the matrix
   RealScalar mindiag = NumTraits<RealScalar>::highest();
   for (Index j = 0; j < n; j++)
   {
     for (Index k = colPtr[j]; k < colPtr[j+1]; k++)
       vals[k] *= (m_scale(j)*m_scale(rowIdx[k]));
     eigen_internal_assert(rowIdx[colPtr[j]]==j && "IncompleteCholesky: only the lower triangular part must be stored");
     mindiag = numext::mini(numext::real(vals[colPtr[j]]), mindiag);
   }
 
   FactorType L_save = m_L;
-  
+
   RealScalar shift = 0;
   if(mindiag <= RealScalar(0.))
     shift = m_initialShift - mindiag;
 
   m_info = NumericalIssue;
 
   // Try to perform the incomplete factorization using the current shift
@@ -377,24 +371,24 @@
 
 template<typename Scalar, int _UpLo, typename OrderingType>
 inline void IncompleteCholesky<Scalar,_UpLo, OrderingType>::updateList(Ref<const VectorIx> colPtr, Ref<VectorIx> rowIdx, Ref<VectorSx> vals, const Index& col, const Index& jk, VectorIx& firstElt, VectorList& listCol)
 {
   if (jk < colPtr(col+1) )
   {
     Index p = colPtr(col+1) - jk;
-    Index minpos; 
+    Index minpos;
     rowIdx.segment(jk,p).minCoeff(&minpos);
     minpos += jk;
     if (rowIdx(minpos) != rowIdx(jk))
     {
       //Swap
       std::swap(rowIdx(jk),rowIdx(minpos));
       std::swap(vals(jk),vals(minpos));
     }
     firstElt(col) = internal::convert_index<StorageIndex,Index>(jk);
     listCol[rowIdx(jk)].push_back(internal::convert_index<StorageIndex,Index>(col));
   }
 }
 
-} // end namespace Eigen 
+} // end namespace Eigen
 
 #endif
```

### Comparing `chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h` & `chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/IncompleteLUT.h`

 * *Files 7% similar despite different names*

```diff
@@ -8,90 +8,90 @@
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_INCOMPLETE_LUT_H
 #define EIGEN_INCOMPLETE_LUT_H
 
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
-    
+
 /** \internal
-  * Compute a quick-sort split of a vector 
+  * Compute a quick-sort split of a vector
   * On output, the vector row is permuted such that its elements satisfy
   * abs(row(i)) >= abs(row(ncut)) if i<ncut
-  * abs(row(i)) <= abs(row(ncut)) if i>ncut 
+  * abs(row(i)) <= abs(row(ncut)) if i>ncut
   * \param row The vector of values
   * \param ind The array of index for the elements in @p row
   * \param ncut  The number of largest elements to keep
-  **/ 
+  **/
 template <typename VectorV, typename VectorI>
 Index QuickSplit(VectorV &row, VectorI &ind, Index ncut)
 {
   typedef typename VectorV::RealScalar RealScalar;
   using std::swap;
   using std::abs;
   Index mid;
   Index n = row.size(); /* length of the vector */
   Index first, last ;
-  
+
   ncut--; /* to fit the zero-based indices */
-  first = 0; 
-  last = n-1; 
+  first = 0;
+  last = n-1;
   if (ncut < first || ncut > last ) return 0;
-  
+
   do {
-    mid = first; 
-    RealScalar abskey = abs(row(mid)); 
+    mid = first;
+    RealScalar abskey = abs(row(mid));
     for (Index j = first + 1; j <= last; j++) {
       if ( abs(row(j)) > abskey) {
         ++mid;
         swap(row(mid), row(j));
         swap(ind(mid), ind(j));
       }
     }
     /* Interchange for the pivot element */
     swap(row(mid), row(first));
     swap(ind(mid), ind(first));
-    
+
     if (mid > ncut) last = mid - 1;
-    else if (mid < ncut ) first = mid + 1; 
+    else if (mid < ncut ) first = mid + 1;
   } while (mid != ncut );
-  
-  return 0; /* mid is equal to ncut */ 
+
+  return 0; /* mid is equal to ncut */
 }
 
 }// end namespace internal
 
 /** \ingroup IterativeLinearSolvers_Module
   * \class IncompleteLUT
   * \brief Incomplete LU factorization with dual-threshold strategy
   *
   * \implsparsesolverconcept
   *
   * During the numerical factorization, two dropping rules are used :
   *  1) any element whose magnitude is less than some tolerance is dropped.
-  *    This tolerance is obtained by multiplying the input tolerance @p droptol 
+  *    This tolerance is obtained by multiplying the input tolerance @p droptol
   *    by the average magnitude of all the original elements in the current row.
-  *  2) After the elimination of the row, only the @p fill largest elements in 
-  *    the L part and the @p fill largest elements in the U part are kept 
-  *    (in addition to the diagonal element ). Note that @p fill is computed from 
-  *    the input parameter @p fillfactor which is used the ratio to control the fill_in 
+  *  2) After the elimination of the row, only the @p fill largest elements in
+  *    the L part and the @p fill largest elements in the U part are kept
+  *    (in addition to the diagonal element ). Note that @p fill is computed from
+  *    the input parameter @p fillfactor which is used the ratio to control the fill_in
   *    relatively to the initial number of nonzero elements.
-  * 
+  *
   * The two extreme cases are when @p droptol=0 (to keep all the @p fill*2 largest elements)
-  * and when @p fill=n/2 with @p droptol being different to zero. 
-  * 
-  * References : Yousef Saad, ILUT: A dual threshold incomplete LU factorization, 
+  * and when @p fill=n/2 with @p droptol being different to zero.
+  *
+  * References : Yousef Saad, ILUT: A dual threshold incomplete LU factorization,
   *              Numerical Linear Algebra with Applications, 1(4), pp 387-402, 1994.
-  * 
+  *
   * NOTE : The following implementation is derived from the ILUT implementation
-  * in the SPARSKIT package, Copyright (C) 2005, the Regents of the University of Minnesota 
-  *  released under the terms of the GNU LGPL: 
+  * in the SPARSKIT package, Copyright (C) 2005, the Regents of the University of Minnesota
+  *  released under the terms of the GNU LGPL:
   *    http://www-users.cs.umn.edu/~saad/software/SPARSKIT/README
   * However, Yousef Saad gave us permission to relicense his ILUT code to MPL2.
   * See the Eigen mailing list archive, thread: ILUT, date: July 8, 2012:
   *   http://listengine.tuxfamily.org/lists.tuxfamily.org/eigen/2012/07/msg00064.html
   * alternatively, on GMANE:
   *   http://comments.gmane.org/gmane.comp.lib.eigen/3302
   */
@@ -111,73 +111,73 @@
 
     enum {
       ColsAtCompileTime = Dynamic,
       MaxColsAtCompileTime = Dynamic
     };
 
   public:
-    
+
     IncompleteLUT()
       : m_droptol(NumTraits<Scalar>::dummy_precision()), m_fillfactor(10),
         m_analysisIsOk(false), m_factorizationIsOk(false)
     {}
-    
+
     template<typename MatrixType>
     explicit IncompleteLUT(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)
       : m_droptol(droptol),m_fillfactor(fillfactor),
         m_analysisIsOk(false),m_factorizationIsOk(false)
     {
       eigen_assert(fillfactor != 0);
-      compute(mat); 
+      compute(mat);
     }
-    
-    Index rows() const { return m_lu.rows(); }
-    
-    Index cols() const { return m_lu.cols(); }
+
+    EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_lu.rows(); }
+
+    EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_lu.cols(); }
 
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the matrix.appears to be negative.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "IncompleteLUT is not initialized.");
       return m_info;
     }
-    
+
     template<typename MatrixType>
     void analyzePattern(const MatrixType& amat);
-    
+
     template<typename MatrixType>
     void factorize(const MatrixType& amat);
-    
+
     /**
       * Compute an incomplete LU factorization with dual threshold on the matrix mat
       * No pivoting is done in this version
-      * 
+      *
       **/
     template<typename MatrixType>
     IncompleteLUT& compute(const MatrixType& amat)
     {
-      analyzePattern(amat); 
+      analyzePattern(amat);
       factorize(amat);
       return *this;
     }
 
-    void setDroptol(const RealScalar& droptol); 
-    void setFillfactor(int fillfactor); 
-    
+    void setDroptol(const RealScalar& droptol);
+    void setFillfactor(int fillfactor);
+
     template<typename Rhs, typename Dest>
     void _solve_impl(const Rhs& b, Dest& x) const
     {
       x = m_Pinv * b;
       x = m_lu.template triangularView<UnitLower>().solve(x);
       x = m_lu.template triangularView<Upper>().solve(x);
-      x = m_P * x; 
+      x = m_P * x;
     }
 
 protected:
 
     /** keeps off-diagonal entries; drops diagonal entries */
     struct keep_diag {
       inline bool operator() (const Index& row, const Index& col, const Scalar&) const
@@ -196,57 +196,48 @@
     ComputationInfo m_info;
     PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_P;     // Fill-reducing permutation
     PermutationMatrix<Dynamic,Dynamic,StorageIndex> m_Pinv;  // Inverse permutation
 };
 
 /**
  * Set control parameter droptol
- *  \param droptol   Drop any element whose magnitude is less than this tolerance 
- **/ 
+ *  \param droptol   Drop any element whose magnitude is less than this tolerance
+ **/
 template<typename Scalar, typename StorageIndex>
 void IncompleteLUT<Scalar,StorageIndex>::setDroptol(const RealScalar& droptol)
 {
-  this->m_droptol = droptol;   
+  this->m_droptol = droptol;
 }
 
 /**
  * Set control parameter fillfactor
- * \param fillfactor  This is used to compute the  number @p fill_in of largest elements to keep on each row. 
- **/ 
+ * \param fillfactor  This is used to compute the  number @p fill_in of largest elements to keep on each row.
+ **/
 template<typename Scalar, typename StorageIndex>
 void IncompleteLUT<Scalar,StorageIndex>::setFillfactor(int fillfactor)
 {
-  this->m_fillfactor = fillfactor;   
+  this->m_fillfactor = fillfactor;
 }
 
 template <typename Scalar, typename StorageIndex>
 template<typename _MatrixType>
 void IncompleteLUT<Scalar,StorageIndex>::analyzePattern(const _MatrixType& amat)
 {
   // Compute the Fill-reducing permutation
   // Since ILUT does not perform any numerical pivoting,
   // it is highly preferable to keep the diagonal through symmetric permutations.
-#ifndef EIGEN_MPL2_ONLY
   // To this end, let's symmetrize the pattern and perform AMD on it.
   SparseMatrix<Scalar,ColMajor, StorageIndex> mat1 = amat;
   SparseMatrix<Scalar,ColMajor, StorageIndex> mat2 = amat.transpose();
   // FIXME for a matrix with nearly symmetric pattern, mat2+mat1 is the appropriate choice.
-  //       on the other hand for a really non-symmetric pattern, mat2*mat1 should be prefered...
+  //       on the other hand for a really non-symmetric pattern, mat2*mat1 should be preferred...
   SparseMatrix<Scalar,ColMajor, StorageIndex> AtA = mat2 + mat1;
   AMDOrdering<StorageIndex> ordering;
   ordering(AtA,m_P);
   m_Pinv  = m_P.inverse(); // cache the inverse permutation
-#else
-  // If AMD is not available, (MPL2-only), then let's use the slower COLAMD routine.
-  SparseMatrix<Scalar,ColMajor, StorageIndex> mat1 = amat;
-  COLAMDOrdering<StorageIndex> ordering;
-  ordering(mat1,m_Pinv);
-  m_P = m_Pinv.inverse();
-#endif
-
   m_analysisIsOk = true;
   m_factorizationIsOk = false;
   m_isInitialized = true;
 }
 
 template <typename Scalar, typename StorageIndex>
 template<typename _MatrixType>
```

### Comparing `chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h` & `chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h`

 * *Files 15% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_ITERATIVE_SOLVER_BASE_H
 #define EIGEN_ITERATIVE_SOLVER_BASE_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 
 template<typename MatrixType>
 struct is_ref_compatible_impl
 {
 private:
@@ -141,15 +141,15 @@
   */
 template< typename Derived>
 class IterativeSolverBase : public SparseSolverBase<Derived>
 {
 protected:
   typedef SparseSolverBase<Derived> Base;
   using Base::m_isInitialized;
-  
+
 public:
   typedef typename internal::traits<Derived>::MatrixType MatrixType;
   typedef typename internal::traits<Derived>::Preconditioner Preconditioner;
   typedef typename MatrixType::Scalar Scalar;
   typedef typename MatrixType::StorageIndex StorageIndex;
   typedef typename MatrixType::RealScalar RealScalar;
 
@@ -165,33 +165,33 @@
   /** Default constructor. */
   IterativeSolverBase()
   {
     init();
   }
 
   /** Initialize the solver with matrix \a A for further \c Ax=b solving.
-    * 
+    *
     * This constructor is a shortcut for the default constructor followed
     * by a call to compute().
-    * 
+    *
     * \warning this class stores a reference to the matrix A as well as some
     * precomputed values that depend on it. Therefore, if \a A is changed
     * this class becomes invalid. Call compute() to update it with the new
     * matrix A, or modify a copy of A.
     */
   template<typename MatrixDerived>
   explicit IterativeSolverBase(const EigenBase<MatrixDerived>& A)
     : m_matrixWrapper(A.derived())
   {
     init();
     compute(matrix());
   }
 
   ~IterativeSolverBase() {}
-  
+
   /** Initializes the iterative solver for the sparsity pattern of the matrix \a A for further solving \c Ax=b problems.
     *
     * Currently, this function mostly calls analyzePattern on the preconditioner. In the future
     * we might, for instance, implement column reordering for faster matrix vector products.
     */
   template<typename MatrixDerived>
   Derived& analyzePattern(const EigenBase<MatrixDerived>& A)
@@ -199,28 +199,28 @@
     grab(A.derived());
     m_preconditioner.analyzePattern(matrix());
     m_isInitialized = true;
     m_analysisIsOk = true;
     m_info = m_preconditioner.info();
     return derived();
   }
-  
+
   /** Initializes the iterative solver with the numerical values of the matrix \a A for further solving \c Ax=b problems.
     *
     * Currently, this function mostly calls factorize on the preconditioner.
     *
     * \warning this class stores a reference to the matrix A as well as some
     * precomputed values that depend on it. Therefore, if \a A is changed
     * this class becomes invalid. Call compute() to update it with the new
     * matrix A, or modify a copy of A.
     */
   template<typename MatrixDerived>
   Derived& factorize(const EigenBase<MatrixDerived>& A)
   {
-    eigen_assert(m_analysisIsOk && "You must first call analyzePattern()"); 
+    eigen_assert(m_analysisIsOk && "You must first call analyzePattern()");
     grab(A.derived());
     m_preconditioner.factorize(matrix());
     m_factorizationIsOk = true;
     m_info = m_preconditioner.info();
     return derived();
   }
 
@@ -243,50 +243,50 @@
     m_analysisIsOk = true;
     m_factorizationIsOk = true;
     m_info = m_preconditioner.info();
     return derived();
   }
 
   /** \internal */
-  Index rows() const { return matrix().rows(); }
+  EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return matrix().rows(); }
 
   /** \internal */
-  Index cols() const { return matrix().cols(); }
+  EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return matrix().cols(); }
 
   /** \returns the tolerance threshold used by the stopping criteria.
     * \sa setTolerance()
     */
   RealScalar tolerance() const { return m_tolerance; }
-  
+
   /** Sets the tolerance threshold used by the stopping criteria.
     *
     * This value is used as an upper bound to the relative residual error: |Ax-b|/|b|.
     * The default value is the machine precision given by NumTraits<Scalar>::epsilon()
     */
   Derived& setTolerance(const RealScalar& tolerance)
   {
     m_tolerance = tolerance;
     return derived();
   }
 
   /** \returns a read-write reference to the preconditioner for custom configuration. */
   Preconditioner& preconditioner() { return m_preconditioner; }
-  
+
   /** \returns a read-only reference to the preconditioner. */
   const Preconditioner& preconditioner() const { return m_preconditioner; }
 
   /** \returns the max number of iterations.
-    * It is either the value setted by setMaxIterations or, by default,
+    * It is either the value set by setMaxIterations or, by default,
     * twice the number of columns of the matrix.
     */
   Index maxIterations() const
   {
     return (m_maxIterations<0) ? 2*matrix().cols() : m_maxIterations;
   }
-  
+
   /** Sets the max number of iterations.
     * Default is twice the number of columns of the matrix.
     */
   Derived& setMaxIterations(Index maxIters)
   {
     m_maxIterations = maxIters;
     return derived();
@@ -324,39 +324,89 @@
 
   /** \returns Success if the iterations converged, and NoConvergence otherwise. */
   ComputationInfo info() const
   {
     eigen_assert(m_isInitialized && "IterativeSolverBase is not initialized.");
     return m_info;
   }
-  
+
   /** \internal */
   template<typename Rhs, typename DestDerived>
-  void _solve_impl(const Rhs& b, SparseMatrixBase<DestDerived> &aDest) const
+  void _solve_with_guess_impl(const Rhs& b, SparseMatrixBase<DestDerived> &aDest) const
   {
     eigen_assert(rows()==b.rows());
-    
+
     Index rhsCols = b.cols();
     Index size = b.rows();
     DestDerived& dest(aDest.derived());
     typedef typename DestDerived::Scalar DestScalar;
     Eigen::Matrix<DestScalar,Dynamic,1> tb(size);
     Eigen::Matrix<DestScalar,Dynamic,1> tx(cols());
     // We do not directly fill dest because sparse expressions have to be free of aliasing issue.
     // For non square least-square problems, b and dest might not have the same size whereas they might alias each-other.
     typename DestDerived::PlainObject tmp(cols(),rhsCols);
+    ComputationInfo global_info = Success;
     for(Index k=0; k<rhsCols; ++k)
     {
       tb = b.col(k);
-      tx = derived().solve(tb);
+      tx = dest.col(k);
+      derived()._solve_vector_with_guess_impl(tb,tx);
       tmp.col(k) = tx.sparseView(0);
+
+      // The call to _solve_vector_with_guess_impl updates m_info, so if it failed for a previous column
+      // we need to restore it to the worst value.
+      if(m_info==NumericalIssue)
+        global_info = NumericalIssue;
+      else if(m_info==NoConvergence)
+        global_info = NoConvergence;
     }
+    m_info = global_info;
     dest.swap(tmp);
   }
 
+  template<typename Rhs, typename DestDerived>
+  typename internal::enable_if<Rhs::ColsAtCompileTime!=1 && DestDerived::ColsAtCompileTime!=1>::type
+  _solve_with_guess_impl(const Rhs& b, MatrixBase<DestDerived> &aDest) const
+  {
+    eigen_assert(rows()==b.rows());
+
+    Index rhsCols = b.cols();
+    DestDerived& dest(aDest.derived());
+    ComputationInfo global_info = Success;
+    for(Index k=0; k<rhsCols; ++k)
+    {
+      typename DestDerived::ColXpr xk(dest,k);
+      typename Rhs::ConstColXpr bk(b,k);
+      derived()._solve_vector_with_guess_impl(bk,xk);
+
+      // The call to _solve_vector_with_guess updates m_info, so if it failed for a previous column
+      // we need to restore it to the worst value.
+      if(m_info==NumericalIssue)
+        global_info = NumericalIssue;
+      else if(m_info==NoConvergence)
+        global_info = NoConvergence;
+    }
+    m_info = global_info;
+  }
+
+  template<typename Rhs, typename DestDerived>
+  typename internal::enable_if<Rhs::ColsAtCompileTime==1 || DestDerived::ColsAtCompileTime==1>::type
+  _solve_with_guess_impl(const Rhs& b, MatrixBase<DestDerived> &dest) const
+  {
+    derived()._solve_vector_with_guess_impl(b,dest.derived());
+  }
+
+  /** \internal default initial guess = 0 */
+  template<typename Rhs,typename Dest>
+  void _solve_impl(const Rhs& b, Dest& x) const
+  {
+    x.setZero();
+    derived()._solve_with_guess_impl(b,x);
+  }
+
 protected:
   void init()
   {
     m_isInitialized = false;
     m_analysisIsOk = false;
     m_factorizationIsOk = false;
     m_maxIterations = -1;
@@ -366,27 +416,27 @@
   typedef internal::generic_matrix_wrapper<MatrixType> MatrixWrapper;
   typedef typename MatrixWrapper::ActualMatrixType ActualMatrixType;
 
   const ActualMatrixType& matrix() const
   {
     return m_matrixWrapper.matrix();
   }
-  
+
   template<typename InputType>
   void grab(const InputType &A)
   {
     m_matrixWrapper.grab(A);
   }
-  
+
   MatrixWrapper m_matrixWrapper;
   Preconditioner m_preconditioner;
 
   Index m_maxIterations;
   RealScalar m_tolerance;
-  
+
   mutable RealScalar m_error;
   mutable Index m_iterations;
   mutable ComputationInfo m_info;
   mutable bool m_analysisIsOk, m_factorizationIsOk;
 };
 
 } // end namespace Eigen
```

### Comparing `chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h` & `chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/LeastSquareConjugateGradient.h`

 * *Files 4% similar despite different names*

```diff
@@ -178,39 +178,21 @@
   template<typename MatrixDerived>
   explicit LeastSquaresConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}
 
   ~LeastSquaresConjugateGradient() {}
 
   /** \internal */
   template<typename Rhs,typename Dest>
-  void _solve_with_guess_impl(const Rhs& b, Dest& x) const
+  void _solve_vector_with_guess_impl(const Rhs& b, Dest& x) const
   {
     m_iterations = Base::maxIterations();
     m_error = Base::m_tolerance;
 
-    for(Index j=0; j<b.cols(); ++j)
-    {
-      m_iterations = Base::maxIterations();
-      m_error = Base::m_tolerance;
-
-      typename Dest::ColXpr xj(x,j);
-      internal::least_square_conjugate_gradient(matrix(), b.col(j), xj, Base::m_preconditioner, m_iterations, m_error);
-    }
-
-    m_isInitialized = true;
+    internal::least_square_conjugate_gradient(matrix(), b, x, Base::m_preconditioner, m_iterations, m_error);
     m_info = m_error <= Base::m_tolerance ? Success : NoConvergence;
   }
-  
-  /** \internal */
-  using Base::_solve_impl;
-  template<typename Rhs,typename Dest>
-  void _solve_impl(const MatrixBase<Rhs>& b, Dest& x) const
-  {
-    x.setZero();
-    _solve_with_guess_impl(b.derived(),x);
-  }
 
 };
 
 } // end namespace Eigen
 
 #endif // EIGEN_LEAST_SQUARE_CONJUGATE_GRADIENT_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h` & `chronogram-0.2.0/include/Eigen/src/IterativeLinearSolvers/SolveWithGuess.h`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 
 #ifndef EIGEN_SOLVEWITHGUESS_H
 #define EIGEN_SOLVEWITHGUESS_H
 
 namespace Eigen {
 
 template<typename Decomposition, typename RhsType, typename GuessType> class SolveWithGuess;
-  
+
 /** \class SolveWithGuess
   * \ingroup IterativeLinearSolvers_Module
   *
   * \brief Pseudo expression representing a solving operation
   *
   * \tparam Decomposition the type of the matrix or decomposion object
   * \tparam Rhstype the type of the right-hand side
@@ -41,31 +41,33 @@
 class SolveWithGuess : public internal::generic_xpr_base<SolveWithGuess<Decomposition,RhsType,GuessType>, MatrixXpr, typename internal::traits<RhsType>::StorageKind>::type
 {
 public:
   typedef typename internal::traits<SolveWithGuess>::Scalar Scalar;
   typedef typename internal::traits<SolveWithGuess>::PlainObject PlainObject;
   typedef typename internal::generic_xpr_base<SolveWithGuess<Decomposition,RhsType,GuessType>, MatrixXpr, typename internal::traits<RhsType>::StorageKind>::type Base;
   typedef typename internal::ref_selector<SolveWithGuess>::type Nested;
-  
+
   SolveWithGuess(const Decomposition &dec, const RhsType &rhs, const GuessType &guess)
     : m_dec(dec), m_rhs(rhs), m_guess(guess)
   {}
-  
-  EIGEN_DEVICE_FUNC Index rows() const { return m_dec.cols(); }
-  EIGEN_DEVICE_FUNC Index cols() const { return m_rhs.cols(); }
+
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  Index rows() const EIGEN_NOEXCEPT { return m_dec.cols(); }
+  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+  Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }
 
   EIGEN_DEVICE_FUNC const Decomposition& dec()   const { return m_dec; }
   EIGEN_DEVICE_FUNC const RhsType&       rhs()   const { return m_rhs; }
   EIGEN_DEVICE_FUNC const GuessType&     guess() const { return m_guess; }
 
 protected:
   const Decomposition &m_dec;
   const RhsType       &m_rhs;
   const GuessType     &m_guess;
-  
+
 private:
   Scalar coeff(Index row, Index col) const;
   Scalar coeff(Index i) const;
 };
 
 namespace internal {
 
@@ -81,16 +83,16 @@
   evaluator(const SolveType& solve)
     : m_result(solve.rows(), solve.cols())
   {
     ::new (static_cast<Base*>(this)) Base(m_result);
     m_result = solve.guess();
     solve.dec()._solve_with_guess_impl(solve.rhs(), m_result);
   }
-  
-protected:  
+
+protected:
   PlainObject m_result;
 };
 
 // Specialization for "dst = dec.solveWithGuess(rhs)"
 // NOTE we need to specialize it for Dense2Dense to avoid ambiguous specialization error and a Sparse2Sparse specialization must exist somewhere
 template<typename DstXprType, typename DecType, typename RhsType, typename GuessType, typename Scalar>
 struct Assignment<DstXprType, SolveWithGuess<DecType,RhsType,GuessType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>
@@ -104,12 +106,12 @@
       dst.resize(dstRows, dstCols);
 
     dst = src.guess();
     src.dec()._solve_with_guess_impl(src.rhs(), dst/*, src.guess()*/);
   }
 };
 
-} // end namepsace internal
+} // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_SOLVEWITHGUESS_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/Jacobi/Jacobi.h` & `chronogram-0.2.0/include/Eigen/src/Jacobi/Jacobi.h`

 * *Files 8% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_JACOBI_H
 #define EIGEN_JACOBI_H
 
-namespace Eigen { 
+namespace Eigen {
 
 /** \ingroup Jacobi_Module
   * \jacobi_module
   * \class JacobiRotation
   * \brief Rotation given by a cosine-sine pair.
   *
   * This class represents a Jacobi or Givens rotation.
@@ -33,61 +33,73 @@
   */
 template<typename Scalar> class JacobiRotation
 {
   public:
     typedef typename NumTraits<Scalar>::Real RealScalar;
 
     /** Default constructor without any initialization. */
+    EIGEN_DEVICE_FUNC
     JacobiRotation() {}
 
     /** Construct a planar rotation from a cosine-sine pair (\a c, \c s). */
+    EIGEN_DEVICE_FUNC
     JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}
 
-    Scalar& c() { return m_c; }
-    Scalar c() const { return m_c; }
-    Scalar& s() { return m_s; }
-    Scalar s() const { return m_s; }
+    EIGEN_DEVICE_FUNC Scalar& c() { return m_c; }
+    EIGEN_DEVICE_FUNC Scalar c() const { return m_c; }
+    EIGEN_DEVICE_FUNC Scalar& s() { return m_s; }
+    EIGEN_DEVICE_FUNC Scalar s() const { return m_s; }
 
     /** Concatenates two planar rotation */
+    EIGEN_DEVICE_FUNC
     JacobiRotation operator*(const JacobiRotation& other)
     {
       using numext::conj;
       return JacobiRotation(m_c * other.m_c - conj(m_s) * other.m_s,
                             conj(m_c * conj(other.m_s) + conj(m_s) * conj(other.m_c)));
     }
 
     /** Returns the transposed transformation */
+    EIGEN_DEVICE_FUNC
     JacobiRotation transpose() const { using numext::conj; return JacobiRotation(m_c, -conj(m_s)); }
 
     /** Returns the adjoint transformation */
+    EIGEN_DEVICE_FUNC
     JacobiRotation adjoint() const { using numext::conj; return JacobiRotation(conj(m_c), -m_s); }
 
     template<typename Derived>
+    EIGEN_DEVICE_FUNC
     bool makeJacobi(const MatrixBase<Derived>&, Index p, Index q);
+    EIGEN_DEVICE_FUNC
     bool makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z);
 
+    EIGEN_DEVICE_FUNC
     void makeGivens(const Scalar& p, const Scalar& q, Scalar* r=0);
 
   protected:
+    EIGEN_DEVICE_FUNC
     void makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type);
+    EIGEN_DEVICE_FUNC
     void makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type);
 
     Scalar m_c, m_s;
 };
 
 /** Makes \c *this as a Jacobi rotation \a J such that applying \a J on both the right and left sides of the selfadjoint 2x2 matrix
   * \f$ B = \left ( \begin{array}{cc} x & y \\ \overline y & z \end{array} \right )\f$ yields a diagonal matrix \f$ A = J^* B J \f$
   *
   * \sa MatrixBase::makeJacobi(const MatrixBase<Derived>&, Index, Index), MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()
   */
 template<typename Scalar>
+EIGEN_DEVICE_FUNC
 bool JacobiRotation<Scalar>::makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z)
 {
   using std::sqrt;
   using std::abs;
+
   RealScalar deno = RealScalar(2)*abs(y);
   if(deno < (std::numeric_limits<RealScalar>::min)())
   {
     m_c = Scalar(1);
     m_s = Scalar(0);
     return false;
   }
@@ -119,14 +131,15 @@
   * Example: \include Jacobi_makeJacobi.cpp
   * Output: \verbinclude Jacobi_makeJacobi.out
   *
   * \sa JacobiRotation::makeJacobi(RealScalar, Scalar, RealScalar), MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()
   */
 template<typename Scalar>
 template<typename Derived>
+EIGEN_DEVICE_FUNC
 inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, Index p, Index q)
 {
   return makeJacobi(numext::real(m.coeff(p,p)), m.coeff(p,q), numext::real(m.coeff(q,q)));
 }
 
 /** Makes \c *this as a Givens rotation \c G such that applying \f$ G^* \f$ to the left of the vector
   * \f$ V = \left ( \begin{array}{c} p \\ q \end{array} \right )\f$ yields:
@@ -141,28 +154,30 @@
   * This function implements the continuous Givens rotation generation algorithm
   * found in Anderson (2000), Discontinuous Plane Rotations and the Symmetric Eigenvalue Problem.
   * LAPACK Working Note 150, University of Tennessee, UT-CS-00-454, December 4, 2000.
   *
   * \sa MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()
   */
 template<typename Scalar>
+EIGEN_DEVICE_FUNC
 void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r)
 {
   makeGivens(p, q, r, typename internal::conditional<NumTraits<Scalar>::IsComplex, internal::true_type, internal::false_type>::type());
 }
 
 
 // specialization for complexes
 template<typename Scalar>
+EIGEN_DEVICE_FUNC
 void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)
 {
   using std::sqrt;
   using std::abs;
   using numext::conj;
-  
+
   if(q==Scalar(0))
   {
     m_c = numext::real(p)<0 ? Scalar(-1) : Scalar(1);
     m_s = 0;
     if(r) *r = m_c * p;
   }
   else if(p==Scalar(0))
@@ -208,14 +223,15 @@
       if(r) *r = ps * u;
     }
   }
 }
 
 // specialization for reals
 template<typename Scalar>
+EIGEN_DEVICE_FUNC
 void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)
 {
   using std::sqrt;
   using std::abs;
   if(q==Scalar(0))
   {
     m_c = p<Scalar(0) ? Scalar(-1) : Scalar(1);
@@ -253,31 +269,33 @@
 
 /****************************************************************************************
 *   Implementation of MatrixBase methods
 ****************************************************************************************/
 
 namespace internal {
 /** \jacobi_module
-  * Applies the clock wise 2D rotation \a j to the set of 2D vectors of cordinates \a x and \a y:
+  * Applies the clock wise 2D rotation \a j to the set of 2D vectors of coordinates \a x and \a y:
   * \f$ \left ( \begin{array}{cc} x \\ y \end{array} \right )  =  J \left ( \begin{array}{cc} x \\ y \end{array} \right ) \f$
   *
   * \sa MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()
   */
 template<typename VectorX, typename VectorY, typename OtherScalar>
+EIGEN_DEVICE_FUNC
 void apply_rotation_in_the_plane(DenseBase<VectorX>& xpr_x, DenseBase<VectorY>& xpr_y, const JacobiRotation<OtherScalar>& j);
 }
 
 /** \jacobi_module
   * Applies the rotation in the plane \a j to the rows \a p and \a q of \c *this, i.e., it computes B = J * B,
   * with \f$ B = \left ( \begin{array}{cc} \text{*this.row}(p) \\ \text{*this.row}(q) \end{array} \right ) \f$.
   *
   * \sa class JacobiRotation, MatrixBase::applyOnTheRight(), internal::apply_rotation_in_the_plane()
   */
 template<typename Derived>
 template<typename OtherScalar>
+EIGEN_DEVICE_FUNC
 inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)
 {
   RowXpr x(this->row(p));
   RowXpr y(this->row(q));
   internal::apply_rotation_in_the_plane(x, y, j);
 }
 
@@ -285,28 +303,30 @@
   * Applies the rotation in the plane \a j to the columns \a p and \a q of \c *this, i.e., it computes B = B * J
   * with \f$ B = \left ( \begin{array}{cc} \text{*this.col}(p) & \text{*this.col}(q) \end{array} \right ) \f$.
   *
   * \sa class JacobiRotation, MatrixBase::applyOnTheLeft(), internal::apply_rotation_in_the_plane()
   */
 template<typename Derived>
 template<typename OtherScalar>
+EIGEN_DEVICE_FUNC
 inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)
 {
   ColXpr x(this->col(p));
   ColXpr y(this->col(q));
   internal::apply_rotation_in_the_plane(x, y, j.transpose());
 }
 
 namespace internal {
 
 template<typename Scalar, typename OtherScalar,
          int SizeAtCompileTime, int MinAlignment, bool Vectorizable>
 struct apply_rotation_in_the_plane_selector
 {
-  static inline void run(Scalar *x, Index incrx, Scalar *y, Index incry, Index size, OtherScalar c, OtherScalar s)
+  static EIGEN_DEVICE_FUNC
+  inline void run(Scalar *x, Index incrx, Scalar *y, Index incry, Index size, OtherScalar c, OtherScalar s)
   {
     for(Index i=0; i<size; ++i)
     {
       Scalar xi = *x;
       Scalar yi = *y;
       *x =  c * xi + numext::conj(s) * yi;
       *y = -s * xi + numext::conj(c) * yi;
@@ -425,28 +445,29 @@
     {
       apply_rotation_in_the_plane_selector<Scalar,OtherScalar,SizeAtCompileTime,MinAlignment,false>::run(x,incrx,y,incry,size,c,s);
     }
   }
 };
 
 template<typename VectorX, typename VectorY, typename OtherScalar>
+EIGEN_DEVICE_FUNC
 void /*EIGEN_DONT_INLINE*/ apply_rotation_in_the_plane(DenseBase<VectorX>& xpr_x, DenseBase<VectorY>& xpr_y, const JacobiRotation<OtherScalar>& j)
 {
   typedef typename VectorX::Scalar Scalar;
-  const bool Vectorizable =    (VectorX::Flags & VectorY::Flags & PacketAccessBit)
+  const bool Vectorizable =    (int(VectorX::Flags) & int(VectorY::Flags) & PacketAccessBit)
                             && (int(packet_traits<Scalar>::size) == int(packet_traits<OtherScalar>::size));
 
   eigen_assert(xpr_x.size() == xpr_y.size());
   Index size = xpr_x.size();
   Index incrx = xpr_x.derived().innerStride();
   Index incry = xpr_y.derived().innerStride();
 
   Scalar* EIGEN_RESTRICT x = &xpr_x.derived().coeffRef(0);
   Scalar* EIGEN_RESTRICT y = &xpr_y.derived().coeffRef(0);
-  
+
   OtherScalar c = j.c();
   OtherScalar s = j.s();
   if (c==OtherScalar(1) && s==OtherScalar(0))
     return;
 
   apply_rotation_in_the_plane_selector<
     Scalar,OtherScalar,
```

### Comparing `chronogram-0.1.7/include/Eigen/src/LU/Determinant.h` & `chronogram-0.2.0/include/Eigen/src/LU/Determinant.h`

 * *Files 18% similar despite different names*

```diff
@@ -11,88 +11,104 @@
 #define EIGEN_DETERMINANT_H
 
 namespace Eigen { 
 
 namespace internal {
 
 template<typename Derived>
+EIGEN_DEVICE_FUNC
 inline const typename Derived::Scalar bruteforce_det3_helper
 (const MatrixBase<Derived>& matrix, int a, int b, int c)
 {
   return matrix.coeff(0,a)
          * (matrix.coeff(1,b) * matrix.coeff(2,c) - matrix.coeff(1,c) * matrix.coeff(2,b));
 }
 
-template<typename Derived>
-const typename Derived::Scalar bruteforce_det4_helper
-(const MatrixBase<Derived>& matrix, int j, int k, int m, int n)
-{
-  return (matrix.coeff(j,0) * matrix.coeff(k,1) - matrix.coeff(k,0) * matrix.coeff(j,1))
-       * (matrix.coeff(m,2) * matrix.coeff(n,3) - matrix.coeff(n,2) * matrix.coeff(m,3));
-}
-
 template<typename Derived,
          int DeterminantType = Derived::RowsAtCompileTime
 > struct determinant_impl
 {
   static inline typename traits<Derived>::Scalar run(const Derived& m)
   {
     if(Derived::ColsAtCompileTime==Dynamic && m.rows()==0)
       return typename traits<Derived>::Scalar(1);
     return m.partialPivLu().determinant();
   }
 };
 
 template<typename Derived> struct determinant_impl<Derived, 1>
 {
-  static inline typename traits<Derived>::Scalar run(const Derived& m)
+  static inline EIGEN_DEVICE_FUNC
+  typename traits<Derived>::Scalar run(const Derived& m)
   {
     return m.coeff(0,0);
   }
 };
 
 template<typename Derived> struct determinant_impl<Derived, 2>
 {
-  static inline typename traits<Derived>::Scalar run(const Derived& m)
+  static inline EIGEN_DEVICE_FUNC
+  typename traits<Derived>::Scalar run(const Derived& m)
   {
     return m.coeff(0,0) * m.coeff(1,1) - m.coeff(1,0) * m.coeff(0,1);
   }
 };
 
 template<typename Derived> struct determinant_impl<Derived, 3>
 {
-  static inline typename traits<Derived>::Scalar run(const Derived& m)
+  static inline EIGEN_DEVICE_FUNC
+  typename traits<Derived>::Scalar run(const Derived& m)
   {
     return bruteforce_det3_helper(m,0,1,2)
           - bruteforce_det3_helper(m,1,0,2)
           + bruteforce_det3_helper(m,2,0,1);
   }
 };
 
 template<typename Derived> struct determinant_impl<Derived, 4>
 {
-  static typename traits<Derived>::Scalar run(const Derived& m)
+  typedef typename traits<Derived>::Scalar Scalar;
+  static EIGEN_DEVICE_FUNC
+  Scalar run(const Derived& m)
+  {
+    Scalar d2_01 = det2(m, 0, 1);
+    Scalar d2_02 = det2(m, 0, 2);
+    Scalar d2_03 = det2(m, 0, 3);
+    Scalar d2_12 = det2(m, 1, 2);
+    Scalar d2_13 = det2(m, 1, 3);
+    Scalar d2_23 = det2(m, 2, 3);
+    Scalar d3_0 = det3(m, 1,d2_23, 2,d2_13, 3,d2_12);
+    Scalar d3_1 = det3(m, 0,d2_23, 2,d2_03, 3,d2_02);
+    Scalar d3_2 = det3(m, 0,d2_13, 1,d2_03, 3,d2_01);
+    Scalar d3_3 = det3(m, 0,d2_12, 1,d2_02, 2,d2_01);
+    return internal::pmadd(-m(0,3),d3_0, m(1,3)*d3_1) +
+           internal::pmadd(-m(2,3),d3_2, m(3,3)*d3_3);
+  }
+protected:
+  static EIGEN_DEVICE_FUNC
+  Scalar det2(const Derived& m, Index i0, Index i1)
+  {
+    return m(i0,0) * m(i1,1) - m(i1,0) * m(i0,1);
+  }
+
+  static EIGEN_DEVICE_FUNC
+  Scalar det3(const Derived& m, Index i0, const Scalar& d0, Index i1, const Scalar& d1, Index i2, const Scalar& d2)
   {
-    // trick by Martin Costabel to compute 4x4 det with only 30 muls
-    return bruteforce_det4_helper(m,0,1,2,3)
-          - bruteforce_det4_helper(m,0,2,1,3)
-          + bruteforce_det4_helper(m,0,3,1,2)
-          + bruteforce_det4_helper(m,1,2,0,3)
-          - bruteforce_det4_helper(m,1,3,0,2)
-          + bruteforce_det4_helper(m,2,3,0,1);
+    return internal::pmadd(m(i0,2), d0, internal::pmadd(-m(i1,2), d1, m(i2,2)*d2));
   }
 };
 
 } // end namespace internal
 
 /** \lu_module
   *
   * \returns the determinant of this matrix
   */
 template<typename Derived>
+EIGEN_DEVICE_FUNC
 inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const
 {
   eigen_assert(rows() == cols());
   typedef typename internal::nested_eval<Derived,Base::RowsAtCompileTime>::type Nested;
   return internal::determinant_impl<typename internal::remove_all<Nested>::type>::run(derived());
 }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/LU/FullPivLU.h` & `chronogram-0.2.0/include/Eigen/src/LU/FullPivLU.h`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 
 namespace internal {
 template<typename _MatrixType> struct traits<FullPivLU<_MatrixType> >
  : traits<_MatrixType>
 {
   typedef MatrixXpr XprKind;
   typedef SolverStorage StorageKind;
+  typedef int StorageIndex;
   enum { Flags = 0 };
 };
 
 } // end namespace internal
 
 /** \ingroup LU_Module
   *
@@ -44,31 +45,31 @@
   * decomposition is inherently more stable and/or flexible. For example, when computing the kernel of a matrix,
   * working with the SVD allows to select the smallest singular values of the matrix, something that
   * the LU decomposition doesn't see.
   *
   * The data of the LU decomposition can be directly accessed through the methods matrixLU(),
   * permutationP(), permutationQ().
   *
-  * As an exemple, here is how the original matrix can be retrieved:
+  * As an example, here is how the original matrix can be retrieved:
   * \include class_FullPivLU.cpp
   * Output: \verbinclude class_FullPivLU.out
   *
   * This class supports the \link InplaceDecomposition inplace decomposition \endlink mechanism.
-  * 
+  *
   * \sa MatrixBase::fullPivLu(), MatrixBase::determinant(), MatrixBase::inverse()
   */
 template<typename _MatrixType> class FullPivLU
   : public SolverBase<FullPivLU<_MatrixType> >
 {
   public:
     typedef _MatrixType MatrixType;
     typedef SolverBase<FullPivLU> Base;
+    friend class SolverBase<FullPivLU>;
 
     EIGEN_GENERIC_PUBLIC_INTERFACE(FullPivLU)
-    // FIXME StorageIndex defined in EIGEN_GENERIC_PUBLIC_INTERFACE should be int
     enum {
       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
     };
     typedef typename internal::plain_row_type<MatrixType, StorageIndex>::type IntRowVectorType;
     typedef typename internal::plain_col_type<MatrixType, StorageIndex>::type IntColVectorType;
     typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;
@@ -214,14 +215,15 @@
     inline const internal::image_retval<FullPivLU>
       image(const MatrixType& originalMatrix) const
     {
       eigen_assert(m_isInitialized && "LU is not initialized.");
       return internal::image_retval<FullPivLU>(*this, originalMatrix);
     }
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
     /** \return a solution x to the equation Ax=b, where A is the matrix of which
       * *this is the LU decomposition.
       *
       * \param b the right-hand-side of the equation to solve. Can be a vector or a matrix,
       *          the only requirement in order for the equation to make sense is that
       *          b.rows()==A.rows(), where A is the matrix of which *this is the LU decomposition.
       *
@@ -233,22 +235,18 @@
       * \note_about_using_kernel_to_study_multiple_solutions
       *
       * Example: \include FullPivLU_solve.cpp
       * Output: \verbinclude FullPivLU_solve.out
       *
       * \sa TriangularView::solve(), kernel(), inverse()
       */
-    // FIXME this is a copy-paste of the base-class member to add the isInitialized assertion.
     template<typename Rhs>
     inline const Solve<FullPivLU, Rhs>
-    solve(const MatrixBase<Rhs>& b) const
-    {
-      eigen_assert(m_isInitialized && "LU is not initialized.");
-      return Solve<FullPivLU, Rhs>(*this, b.derived());
-    }
+    solve(const MatrixBase<Rhs>& b) const;
+    #endif
 
     /** \returns an estimate of the reciprocal condition number of the matrix of which \c *this is
         the LU decomposition.
       */
     inline RealScalar rcond() const
     {
       eigen_assert(m_isInitialized && "PartialPivLU is not initialized.");
@@ -316,15 +314,15 @@
       */
     RealScalar threshold() const
     {
       eigen_assert(m_isInitialized || m_usePrescribedThreshold);
       return m_usePrescribedThreshold ? m_prescribedThreshold
       // this formula comes from experimenting (see "LU precision tuning" thread on the list)
       // and turns out to be identical to Higham's formula used already in LDLt.
-                                      : NumTraits<Scalar>::epsilon() * m_lu.diagonalSize();
+          : NumTraits<Scalar>::epsilon() * RealScalar(m_lu.diagonalSize());
     }
 
     /** \returns the rank of the matrix of which *this is the LU decomposition.
       *
       * \note This method has to determine which pivots should be considered nonzero.
       *       For that, it uses the threshold value that you can control by calling
       *       setThreshold(const RealScalar&).
@@ -402,24 +400,24 @@
       eigen_assert(m_isInitialized && "LU is not initialized.");
       eigen_assert(m_lu.rows() == m_lu.cols() && "You can't take the inverse of a non-square matrix!");
       return Inverse<FullPivLU>(*this);
     }
 
     MatrixType reconstructedMatrix() const;
 
-    EIGEN_DEVICE_FUNC inline Index rows() const { return m_lu.rows(); }
-    EIGEN_DEVICE_FUNC inline Index cols() const { return m_lu.cols(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index rows() const EIGEN_NOEXCEPT { return m_lu.rows(); }
+    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR
+    inline Index cols() const EIGEN_NOEXCEPT { return m_lu.cols(); }
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename RhsType, typename DstType>
-    EIGEN_DEVICE_FUNC
     void _solve_impl(const RhsType &rhs, DstType &dst) const;
 
     template<bool Conjugate, typename RhsType, typename DstType>
-    EIGEN_DEVICE_FUNC
     void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;
     #endif
 
   protected:
 
     static void check_template_parameters()
     {
@@ -527,28 +525,28 @@
     if(biggest_in_corner==Score(0))
     {
       // before exiting, make sure to initialize the still uninitialized transpositions
       // in a sane state without destroying what we already have.
       m_nonzero_pivots = k;
       for(Index i = k; i < size; ++i)
       {
-        m_rowsTranspositions.coeffRef(i) = i;
-        m_colsTranspositions.coeffRef(i) = i;
+        m_rowsTranspositions.coeffRef(i) = internal::convert_index<StorageIndex>(i);
+        m_colsTranspositions.coeffRef(i) = internal::convert_index<StorageIndex>(i);
       }
       break;
     }
 
     RealScalar abs_pivot = internal::abs_knowing_score<Scalar>()(m_lu(row_of_biggest_in_corner, col_of_biggest_in_corner), biggest_in_corner);
     if(abs_pivot > m_maxpivot) m_maxpivot = abs_pivot;
 
     // Now that we've found the pivot, we need to apply the row/col swaps to
     // bring it to the location (k,k).
 
-    m_rowsTranspositions.coeffRef(k) = row_of_biggest_in_corner;
-    m_colsTranspositions.coeffRef(k) = col_of_biggest_in_corner;
+    m_rowsTranspositions.coeffRef(k) = internal::convert_index<StorageIndex>(row_of_biggest_in_corner);
+    m_colsTranspositions.coeffRef(k) = internal::convert_index<StorageIndex>(col_of_biggest_in_corner);
     if(k != row_of_biggest_in_corner) {
       m_lu.row(k).swap(m_lu.row(row_of_biggest_in_corner));
       ++number_of_transpositions;
     }
     if(k != col_of_biggest_in_corner) {
       m_lu.col(k).swap(m_lu.col(col_of_biggest_in_corner));
       ++number_of_transpositions;
@@ -753,15 +751,14 @@
   * Step 3: replace c by the solution x to Ux = c. May or may not exist.
   * Step 4: result = Q * c;
   */
 
   const Index rows = this->rows(),
               cols = this->cols(),
               nonzero_pivots = this->rank();
-  eigen_assert(rhs.rows() == rows);
   const Index smalldim = (std::min)(rows, cols);
 
   if(nonzero_pivots == 0)
   {
     dst.setZero();
     return;
   }
@@ -803,51 +800,40 @@
    * Step 3: replace c by the solution x to L^T x = c.
    * Step 4: result = P^T c.
    * If Conjugate is true, replace "^T" by "^*" above.
    */
 
   const Index rows = this->rows(), cols = this->cols(),
     nonzero_pivots = this->rank();
-   eigen_assert(rhs.rows() == cols);
   const Index smalldim = (std::min)(rows, cols);
 
   if(nonzero_pivots == 0)
   {
     dst.setZero();
     return;
   }
 
   typename RhsType::PlainObject c(rhs.rows(), rhs.cols());
 
   // Step 1
   c = permutationQ().inverse() * rhs;
 
-  if (Conjugate) {
-    // Step 2
-    m_lu.topLeftCorner(nonzero_pivots, nonzero_pivots)
-        .template triangularView<Upper>()
-        .adjoint()
-        .solveInPlace(c.topRows(nonzero_pivots));
-    // Step 3
-    m_lu.topLeftCorner(smalldim, smalldim)
-        .template triangularView<UnitLower>()
-        .adjoint()
-        .solveInPlace(c.topRows(smalldim));
-  } else {
-    // Step 2
-    m_lu.topLeftCorner(nonzero_pivots, nonzero_pivots)
-        .template triangularView<Upper>()
-        .transpose()
-        .solveInPlace(c.topRows(nonzero_pivots));
-    // Step 3
-    m_lu.topLeftCorner(smalldim, smalldim)
-        .template triangularView<UnitLower>()
-        .transpose()
-        .solveInPlace(c.topRows(smalldim));
-  }
+  // Step 2
+  m_lu.topLeftCorner(nonzero_pivots, nonzero_pivots)
+      .template triangularView<Upper>()
+      .transpose()
+      .template conjugateIf<Conjugate>()
+      .solveInPlace(c.topRows(nonzero_pivots));
+
+  // Step 3
+  m_lu.topLeftCorner(smalldim, smalldim)
+      .template triangularView<UnitLower>()
+      .transpose()
+      .template conjugateIf<Conjugate>()
+      .solveInPlace(c.topRows(smalldim));
 
   // Step 4
   PermutationPType invp = permutationP().inverse().eval();
   for(Index i = 0; i < smalldim; ++i)
     dst.row(invp.indices().coeff(i)) = c.row(i);
   for(Index i = smalldim; i < rows; ++i)
     dst.row(invp.indices().coeff(i)).setZero();
```

### Comparing `chronogram-0.1.7/include/Eigen/src/LU/InverseImpl.h` & `chronogram-0.2.0/include/Eigen/src/LU/InverseImpl.h`

 * *Files 2% similar despite different names*

```diff
@@ -73,18 +73,19 @@
 
 template<typename MatrixType, typename ResultType>
 EIGEN_DEVICE_FUNC 
 inline void compute_inverse_size2_helper(
     const MatrixType& matrix, const typename ResultType::Scalar& invdet,
     ResultType& result)
 {
+  typename ResultType::Scalar temp = matrix.coeff(0,0);
   result.coeffRef(0,0) =  matrix.coeff(1,1) * invdet;
   result.coeffRef(1,0) = -matrix.coeff(1,0) * invdet;
   result.coeffRef(0,1) = -matrix.coeff(0,1) * invdet;
-  result.coeffRef(1,1) =  matrix.coeff(0,0) * invdet;
+  result.coeffRef(1,1) =  temp * invdet;
 }
 
 template<typename MatrixType, typename ResultType>
 struct compute_inverse<MatrixType, ResultType, 2>
 {
   EIGEN_DEVICE_FUNC
   static inline void run(const MatrixType& matrix, ResultType& result)
@@ -139,21 +140,26 @@
 EIGEN_DEVICE_FUNC
 inline void compute_inverse_size3_helper(
     const MatrixType& matrix,
     const typename ResultType::Scalar& invdet,
     const Matrix<typename ResultType::Scalar,3,1>& cofactors_col0,
     ResultType& result)
 {
-  result.row(0) = cofactors_col0 * invdet;
-  result.coeffRef(1,0) =  cofactor_3x3<MatrixType,0,1>(matrix) * invdet;
-  result.coeffRef(1,1) =  cofactor_3x3<MatrixType,1,1>(matrix) * invdet;
+  // Compute cofactors in a way that avoids aliasing issues.
+  typedef typename ResultType::Scalar Scalar;
+  const Scalar c01 = cofactor_3x3<MatrixType,0,1>(matrix) * invdet;
+  const Scalar c11 = cofactor_3x3<MatrixType,1,1>(matrix) * invdet;
+  const Scalar c02 = cofactor_3x3<MatrixType,0,2>(matrix) * invdet;
   result.coeffRef(1,2) =  cofactor_3x3<MatrixType,2,1>(matrix) * invdet;
-  result.coeffRef(2,0) =  cofactor_3x3<MatrixType,0,2>(matrix) * invdet;
   result.coeffRef(2,1) =  cofactor_3x3<MatrixType,1,2>(matrix) * invdet;
   result.coeffRef(2,2) =  cofactor_3x3<MatrixType,2,2>(matrix) * invdet;
+  result.coeffRef(1,0) =  c01;
+  result.coeffRef(1,1) =  c11;
+  result.coeffRef(2,0) =  c02;  
+  result.row(0) = cofactors_col0 * invdet;
 }
 
 template<typename MatrixType, typename ResultType>
 struct compute_inverse<MatrixType, ResultType, 3>
 {
   EIGEN_DEVICE_FUNC
   static inline void run(const MatrixType& matrix, ResultType& result)
@@ -177,22 +183,21 @@
     const MatrixType& matrix,
     const typename MatrixType::RealScalar& absDeterminantThreshold,
     ResultType& inverse,
     typename ResultType::Scalar& determinant,
     bool& invertible
   )
   {
-    using std::abs;
     typedef typename ResultType::Scalar Scalar;
     Matrix<Scalar,3,1> cofactors_col0;
     cofactors_col0.coeffRef(0) =  cofactor_3x3<MatrixType,0,0>(matrix);
     cofactors_col0.coeffRef(1) =  cofactor_3x3<MatrixType,1,0>(matrix);
     cofactors_col0.coeffRef(2) =  cofactor_3x3<MatrixType,2,0>(matrix);
     determinant = (cofactors_col0.cwiseProduct(matrix.col(0))).sum();
-    invertible = abs(determinant) > absDeterminantThreshold;
+    invertible = Eigen::numext::abs(determinant) > absDeterminantThreshold;
     if(!invertible) return;
     const Scalar invdet = Scalar(1) / determinant;
     compute_inverse_size3_helper(matrix, invdet, cofactors_col0, inverse);
   }
 };
 
 /****************************
@@ -269,15 +274,21 @@
     typename ResultType::Scalar& determinant,
     bool& invertible
   )
   {
     using std::abs;
     determinant = matrix.determinant();
     invertible = abs(determinant) > absDeterminantThreshold;
-    if(invertible) compute_inverse<MatrixType, ResultType>::run(matrix, inverse);
+    if(invertible && extract_data(matrix) != extract_data(inverse)) {
+      compute_inverse<MatrixType, ResultType>::run(matrix, inverse);
+    }
+    else if(invertible) {
+      MatrixType matrix_t = matrix;
+      compute_inverse<MatrixType, ResultType>::run(matrix_t, inverse);
+    }
   }
 };
 
 /*************************
 *** MatrixBase methods ***
 *************************/
 
@@ -286,14 +297,15 @@
 namespace internal {
 
 // Specialization for "dense = dense_xpr.inverse()"
 template<typename DstXprType, typename XprType>
 struct Assignment<DstXprType, Inverse<XprType>, internal::assign_op<typename DstXprType::Scalar,typename XprType::Scalar>, Dense2Dense>
 {
   typedef Inverse<XprType> SrcXprType;
+  EIGEN_DEVICE_FUNC
   static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename XprType::Scalar> &)
   {
     Index dstRows = src.rows();
     Index dstCols = src.cols();
     if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
       dst.resize(dstRows, dstCols);
     
@@ -328,27 +340,30 @@
   *
   * Example: \include MatrixBase_inverse.cpp
   * Output: \verbinclude MatrixBase_inverse.out
   *
   * \sa computeInverseAndDetWithCheck()
   */
 template<typename Derived>
+EIGEN_DEVICE_FUNC
 inline const Inverse<Derived> MatrixBase<Derived>::inverse() const
 {
   EIGEN_STATIC_ASSERT(!NumTraits<Scalar>::IsInteger,THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES)
   eigen_assert(rows() == cols());
   return Inverse<Derived>(derived());
 }
 
 /** \lu_module
   *
   * Computation of matrix inverse and determinant, with invertibility check.
   *
   * This is only for fixed-size square matrices of size up to 4x4.
   *
+  * Notice that it will trigger a copy of input matrix when trying to do the inverse in place.
+  *
   * \param inverse Reference to the matrix in which to store the inverse.
   * \param determinant Reference to the variable in which to store the determinant.
   * \param invertible Reference to the bool variable in which to store whether the matrix is invertible.
   * \param absDeterminantThreshold Optional parameter controlling the invertibility check.
   *                                The matrix will be declared invertible if the absolute value of its
   *                                determinant is greater than this threshold.
   *
@@ -381,14 +396,16 @@
 
 /** \lu_module
   *
   * Computation of matrix inverse, with invertibility check.
   *
   * This is only for fixed-size square matrices of size up to 4x4.
   *
+  * Notice that it will trigger a copy of input matrix when trying to do the inverse in place.
+  *
   * \param inverse Reference to the matrix in which to store the inverse.
   * \param invertible Reference to the bool variable in which to store whether the matrix is invertible.
   * \param absDeterminantThreshold Optional parameter controlling the invertibility check.
   *                                The matrix will be declared invertible if the absolute value of its
   *                                determinant is greater than this threshold.
   *
   * Example: \include MatrixBase_computeInverseWithCheck.cpp
```

### Comparing `chronogram-0.1.7/include/Eigen/src/LU/PartialPivLU.h` & `chronogram-0.2.0/include/Eigen/src/LU/PartialPivLU.h`

 * *Files 3% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 
 namespace internal {
 template<typename _MatrixType> struct traits<PartialPivLU<_MatrixType> >
  : traits<_MatrixType>
 {
   typedef MatrixXpr XprKind;
   typedef SolverStorage StorageKind;
+  typedef int StorageIndex;
   typedef traits<_MatrixType> BaseTraits;
   enum {
     Flags = BaseTraits::Flags & RowMajorBit,
     CoeffReadCost = Dynamic
   };
 };
 
@@ -65,26 +66,27 @@
   * This LU decomposition is suitable to invert invertible matrices. It is what MatrixBase::inverse() uses
   * in the general case.
   * On the other hand, it is \b not suitable to determine whether a given matrix is invertible.
   *
   * The data of the LU decomposition can be directly accessed through the methods matrixLU(), permutationP().
   *
   * This class supports the \link InplaceDecomposition inplace decomposition \endlink mechanism.
-  * 
+  *
   * \sa MatrixBase::partialPivLu(), MatrixBase::determinant(), MatrixBase::inverse(), MatrixBase::computeInverse(), class FullPivLU
   */
 template<typename _MatrixType> class PartialPivLU
   : public SolverBase<PartialPivLU<_MatrixType> >
 {
   public:
 
     typedef _MatrixType MatrixType;
     typedef SolverBase<PartialPivLU> Base;
+    friend class SolverBase<PartialPivLU>;
+
     EIGEN_GENERIC_PUBLIC_INTERFACE(PartialPivLU)
-    // FIXME StorageIndex defined in EIGEN_GENERIC_PUBLIC_INTERFACE should be int
     enum {
       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
     };
     typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;
     typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;
     typedef typename MatrixType::PlainObject PlainObject;
@@ -148,14 +150,15 @@
       */
     inline const PermutationType& permutationP() const
     {
       eigen_assert(m_isInitialized && "PartialPivLU is not initialized.");
       return m_p;
     }
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
     /** This method returns the solution x to the equation Ax=b, where A is the matrix of which
       * *this is the LU decomposition.
       *
       * \param b the right-hand-side of the equation to solve. Can be a vector or a matrix,
       *          the only requirement in order for the equation to make sense is that
       *          b.rows()==A.rows(), where A is the matrix of which *this is the LU decomposition.
       *
@@ -165,22 +168,18 @@
       * Output: \verbinclude PartialPivLU_solve.out
       *
       * Since this PartialPivLU class assumes anyway that the matrix A is invertible, the solution
       * theoretically exists and is unique regardless of b.
       *
       * \sa TriangularView::solve(), inverse(), computeInverse()
       */
-    // FIXME this is a copy-paste of the base-class member to add the isInitialized assertion.
     template<typename Rhs>
     inline const Solve<PartialPivLU, Rhs>
-    solve(const MatrixBase<Rhs>& b) const
-    {
-      eigen_assert(m_isInitialized && "PartialPivLU is not initialized.");
-      return Solve<PartialPivLU, Rhs>(*this, b.derived());
-    }
+    solve(const MatrixBase<Rhs>& b) const;
+    #endif
 
     /** \returns an estimate of the reciprocal condition number of the matrix of which \c *this is
         the LU decomposition.
       */
     inline RealScalar rcond() const
     {
       eigen_assert(m_isInitialized && "PartialPivLU is not initialized.");
@@ -213,63 +212,56 @@
       *
       * \sa MatrixBase::determinant()
       */
     Scalar determinant() const;
 
     MatrixType reconstructedMatrix() const;
 
-    inline Index rows() const { return m_lu.rows(); }
-    inline Index cols() const { return m_lu.cols(); }
+    EIGEN_CONSTEXPR inline Index rows() const EIGEN_NOEXCEPT { return m_lu.rows(); }
+    EIGEN_CONSTEXPR inline Index cols() const EIGEN_NOEXCEPT { return m_lu.cols(); }
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename RhsType, typename DstType>
     EIGEN_DEVICE_FUNC
     void _solve_impl(const RhsType &rhs, DstType &dst) const {
      /* The decomposition PA = LU can be rewritten as A = P^{-1} L U.
       * So we proceed as follows:
       * Step 1: compute c = Pb.
       * Step 2: replace c by the solution x to Lx = c.
       * Step 3: replace c by the solution x to Ux = c.
       */
 
-      eigen_assert(rhs.rows() == m_lu.rows());
-
       // Step 1
       dst = permutationP() * rhs;
 
       // Step 2
       m_lu.template triangularView<UnitLower>().solveInPlace(dst);
 
       // Step 3
       m_lu.template triangularView<Upper>().solveInPlace(dst);
     }
 
     template<bool Conjugate, typename RhsType, typename DstType>
     EIGEN_DEVICE_FUNC
     void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const {
-     /* The decomposition PA = LU can be rewritten as A = P^{-1} L U.
+     /* The decomposition PA = LU can be rewritten as A^T = U^T L^T P.
       * So we proceed as follows:
-      * Step 1: compute c = Pb.
-      * Step 2: replace c by the solution x to Lx = c.
-      * Step 3: replace c by the solution x to Ux = c.
+      * Step 1: compute c as the solution to L^T c = b
+      * Step 2: replace c by the solution x to U^T x = c.
+      * Step 3: update  c = P^-1 c.
       */
 
       eigen_assert(rhs.rows() == m_lu.cols());
 
-      if (Conjugate) {
-        // Step 1
-        dst = m_lu.template triangularView<Upper>().adjoint().solve(rhs);
-        // Step 2
-        m_lu.template triangularView<UnitLower>().adjoint().solveInPlace(dst);
-      } else {
-        // Step 1
-        dst = m_lu.template triangularView<Upper>().transpose().solve(rhs);
-        // Step 2
-        m_lu.template triangularView<UnitLower>().transpose().solveInPlace(dst);
-      }
+      // Step 1
+      dst = m_lu.template triangularView<Upper>().transpose()
+                .template conjugateIf<Conjugate>().solve(rhs);
+      // Step 2
+      m_lu.template triangularView<UnitLower>().transpose()
+          .template conjugateIf<Conjugate>().solveInPlace(dst);
       // Step 3
       dst = permutationP().transpose() * dst;
     }
     #endif
 
   protected:
 
@@ -335,50 +327,54 @@
 {
   compute();
 }
 
 namespace internal {
 
 /** \internal This is the blocked version of fullpivlu_unblocked() */
-template<typename Scalar, int StorageOrder, typename PivIndex>
+template<typename Scalar, int StorageOrder, typename PivIndex, int SizeAtCompileTime=Dynamic>
 struct partial_lu_impl
 {
-  // FIXME add a stride to Map, so that the following mapping becomes easier,
-  // another option would be to create an expression being able to automatically
-  // warp any Map, Matrix, and Block expressions as a unique type, but since that's exactly
-  // a Map + stride, why not adding a stride to Map, and convenient ctors from a Matrix,
-  // and Block.
-  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;
-  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;
-  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;
+  static const int UnBlockedBound = 16;
+  static const bool UnBlockedAtCompileTime = SizeAtCompileTime!=Dynamic && SizeAtCompileTime<=UnBlockedBound;
+  static const int ActualSizeAtCompileTime = UnBlockedAtCompileTime ? SizeAtCompileTime : Dynamic;
+  // Remaining rows and columns at compile-time:
+  static const int RRows = SizeAtCompileTime==2 ? 1 : Dynamic;
+  static const int RCols = SizeAtCompileTime==2 ? 1 : Dynamic;
+  typedef Matrix<Scalar, ActualSizeAtCompileTime, ActualSizeAtCompileTime, StorageOrder> MatrixType;
+  typedef Ref<MatrixType> MatrixTypeRef;
+  typedef Ref<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > BlockType;
   typedef typename MatrixType::RealScalar RealScalar;
 
   /** \internal performs the LU decomposition in-place of the matrix \a lu
     * using an unblocked algorithm.
     *
     * In addition, this function returns the row transpositions in the
     * vector \a row_transpositions which must have a size equal to the number
     * of columns of the matrix \a lu, and an integer \a nb_transpositions
     * which returns the actual number of transpositions.
     *
     * \returns The index of the first pivot which is exactly zero if any, or a negative number otherwise.
     */
-  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)
+  static Index unblocked_lu(MatrixTypeRef& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)
   {
     typedef scalar_score_coeff_op<Scalar> Scoring;
     typedef typename Scoring::result_type Score;
     const Index rows = lu.rows();
     const Index cols = lu.cols();
     const Index size = (std::min)(rows,cols);
+    // For small compile-time matrices it is worth processing the last row separately:
+    //  speedup: +100% for 2x2, +10% for others.
+    const Index endk = UnBlockedAtCompileTime ? size-1 : size;
     nb_transpositions = 0;
     Index first_zero_pivot = -1;
-    for(Index k = 0; k < size; ++k)
+    for(Index k = 0; k < endk; ++k)
     {
-      Index rrows = rows-k-1;
-      Index rcols = cols-k-1;
+      int rrows = internal::convert_index<int>(rows-k-1);
+      int rcols = internal::convert_index<int>(cols-k-1);
 
       Index row_of_biggest_in_col;
       Score biggest_in_corner
         = lu.col(k).tail(rows-k).unaryExpr(Scoring()).maxCoeff(&row_of_biggest_in_col);
       row_of_biggest_in_col += k;
 
       row_transpositions[k] = PivIndex(row_of_biggest_in_col);
@@ -387,28 +383,36 @@
       {
         if(k != row_of_biggest_in_col)
         {
           lu.row(k).swap(lu.row(row_of_biggest_in_col));
           ++nb_transpositions;
         }
 
-        // FIXME shall we introduce a safe quotient expression in cas 1/lu.coeff(k,k)
-        // overflow but not the actual quotient?
-        lu.col(k).tail(rrows) /= lu.coeff(k,k);
+        lu.col(k).tail(fix<RRows>(rrows)) /= lu.coeff(k,k);
       }
       else if(first_zero_pivot==-1)
       {
         // the pivot is exactly zero, we record the index of the first pivot which is exactly 0,
         // and continue the factorization such we still have A = PLU
         first_zero_pivot = k;
       }
 
       if(k<rows-1)
-        lu.bottomRightCorner(rrows,rcols).noalias() -= lu.col(k).tail(rrows) * lu.row(k).tail(rcols);
+        lu.bottomRightCorner(fix<RRows>(rrows),fix<RCols>(rcols)).noalias() -= lu.col(k).tail(fix<RRows>(rrows)) * lu.row(k).tail(fix<RCols>(rcols));
+    }
+
+    // special handling of the last entry
+    if(UnBlockedAtCompileTime)
+    {
+      Index k = endk;
+      row_transpositions[k] = PivIndex(k);
+      if (Scoring()(lu(k, k)) == Score(0) && first_zero_pivot == -1)
+        first_zero_pivot = k;
     }
+
     return first_zero_pivot;
   }
 
   /** \internal performs the LU decomposition in-place of the matrix represented
     * by the variables \a rows, \a cols, \a lu_data, and \a lu_stride using a
     * recursive, blocked algorithm.
     *
@@ -416,26 +420,25 @@
     * vector \a row_transpositions which must have a size equal to the number
     * of columns of the matrix \a lu, and an integer \a nb_transpositions
     * which returns the actual number of transpositions.
     *
     * \returns The index of the first pivot which is exactly zero if any, or a negative number otherwise.
     *
     * \note This very low level interface using pointers, etc. is to:
-    *   1 - reduce the number of instanciations to the strict minimum
-    *   2 - avoid infinite recursion of the instanciations with Block<Block<Block<...> > >
+    *   1 - reduce the number of instantiations to the strict minimum
+    *   2 - avoid infinite recursion of the instantiations with Block<Block<Block<...> > >
     */
   static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)
   {
-    MapLU lu1(lu_data,StorageOrder==RowMajor?rows:luStride,StorageOrder==RowMajor?luStride:cols);
-    MatrixType lu(lu1,0,0,rows,cols);
+    MatrixTypeRef lu = MatrixType::Map(lu_data,rows, cols, OuterStride<>(luStride));
 
     const Index size = (std::min)(rows,cols);
 
     // if the matrix is too small, no blocking:
-    if(size<=16)
+    if(UnBlockedAtCompileTime || size<=UnBlockedBound)
     {
       return unblocked_lu(lu, row_transpositions, nb_transpositions);
     }
 
     // automatically adjust the number of subdivisions to the size
     // of the matrix so that there is enough sub blocks:
     Index blockSize;
@@ -453,20 +456,20 @@
       Index trows = rows - k - bs; // trailing rows
       Index tsize = size - k - bs; // trailing size
 
       // partition the matrix:
       //                          A00 | A01 | A02
       // lu  = A_0 | A_1 | A_2 =  A10 | A11 | A12
       //                          A20 | A21 | A22
-      BlockType A_0(lu,0,0,rows,k);
-      BlockType A_2(lu,0,k+bs,rows,tsize);
-      BlockType A11(lu,k,k,bs,bs);
-      BlockType A12(lu,k,k+bs,bs,tsize);
-      BlockType A21(lu,k+bs,k,trows,bs);
-      BlockType A22(lu,k+bs,k+bs,trows,tsize);
+      BlockType A_0 = lu.block(0,0,rows,k);
+      BlockType A_2 = lu.block(0,k+bs,rows,tsize);
+      BlockType A11 = lu.block(k,k,bs,bs);
+      BlockType A12 = lu.block(k,k+bs,bs,tsize);
+      BlockType A21 = lu.block(k+bs,k,trows,bs);
+      BlockType A22 = lu.block(k+bs,k+bs,trows,tsize);
 
       PivIndex nb_transpositions_in_panel;
       // recursively call the blocked LU algorithm on [A11^T A21^T]^T
       // with a very small blocking size:
       Index ret = blocked_lu(trows+bs, bs, &lu.coeffRef(k,k), luStride,
                    row_transpositions+k, nb_transpositions_in_panel, 16);
       if(ret>=0 && first_zero_pivot==-1)
@@ -497,33 +500,43 @@
 };
 
 /** \internal performs the LU decomposition with partial pivoting in-place.
   */
 template<typename MatrixType, typename TranspositionType>
 void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::StorageIndex& nb_transpositions)
 {
+  // Special-case of zero matrix.
+  if (lu.rows() == 0 || lu.cols() == 0) {
+    nb_transpositions = 0;
+    return;
+  }
   eigen_assert(lu.cols() == row_transpositions.size());
-  eigen_assert((&row_transpositions.coeffRef(1)-&row_transpositions.coeffRef(0)) == 1);
+  eigen_assert(row_transpositions.size() < 2 || (&row_transpositions.coeffRef(1)-&row_transpositions.coeffRef(0)) == 1);
 
   partial_lu_impl
-    <typename MatrixType::Scalar, MatrixType::Flags&RowMajorBit?RowMajor:ColMajor, typename TranspositionType::StorageIndex>
+    < typename MatrixType::Scalar, MatrixType::Flags&RowMajorBit?RowMajor:ColMajor,
+      typename TranspositionType::StorageIndex,
+      EIGEN_SIZE_MIN_PREFER_FIXED(MatrixType::RowsAtCompileTime,MatrixType::ColsAtCompileTime)>
     ::blocked_lu(lu.rows(), lu.cols(), &lu.coeffRef(0,0), lu.outerStride(), &row_transpositions.coeffRef(0), nb_transpositions);
 }
 
 } // end namespace internal
 
 template<typename MatrixType>
 void PartialPivLU<MatrixType>::compute()
 {
   check_template_parameters();
 
   // the row permutation is stored as int indices, so just to be sure:
   eigen_assert(m_lu.rows()<NumTraits<int>::highest());
 
-  m_l1_norm = m_lu.cwiseAbs().colwise().sum().maxCoeff();
+  if(m_lu.cols()>0)
+    m_l1_norm = m_lu.cwiseAbs().colwise().sum().maxCoeff();
+  else
+    m_l1_norm = RealScalar(0);
 
   eigen_assert(m_lu.rows() == m_lu.cols() && "PartialPivLU is only for square (and moreover invertible) matrices");
   const Index size = m_lu.rows();
 
   m_rowsTranspositions.resize(size);
 
   typename TranspositionType::StorageIndex nb_transpositions;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/LU/PartialPivLU_LAPACKE.h` & `chronogram-0.2.0/include/Eigen/src/LU/PartialPivLU_LAPACKE.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/MetisSupport/MetisSupport.h` & `chronogram-0.2.0/include/Eigen/src/MetisSupport/MetisSupport.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/OrderingMethods/Amd.h` & `chronogram-0.2.0/include/Eigen/src/OrderingMethods/Amd.h`

 * *Files 2% similar despite different names*

```diff
@@ -1,37 +1,27 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
 // Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>
+//
+// This Source Code Form is subject to the terms of the Mozilla
+// Public License v. 2.0. If a copy of the MPL was not distributed
+// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 /*
-
 NOTE: this routine has been adapted from the CSparse library:
 
 Copyright (c) 2006, Timothy A. Davis.
 http://www.suitesparse.com
 
-CSparse is free software; you can redistribute it and/or
-modify it under the terms of the GNU Lesser General Public
-License as published by the Free Software Foundation; either
-version 2.1 of the License, or (at your option) any later version.
-
-CSparse is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Lesser General Public License for more details.
-
-You should have received a copy of the GNU Lesser General Public
-License along with this Module; if not, write to the Free Software
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
+The author of CSparse, Timothy A. Davis., has executed a license with Google LLC
+to permit distribution of this code and derivative works as part of Eigen under
+the Mozilla Public License v. 2.0, as stated at the top of this file.
 */
 
-#include "../Core/util/NonMPL2.h"
-
 #ifndef EIGEN_SPARSE_AMD_H
 #define EIGEN_SPARSE_AMD_H
 
 namespace Eigen { 
 
 namespace internal {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/OrderingMethods/Eigen_Colamd.h` & `chronogram-0.2.0/include/Eigen/src/OrderingMethods/Eigen_Colamd.h`

 * *Files 8% similar despite different names*

```diff
@@ -9,133 +9,137 @@
 
 // This file is modified from the colamd/symamd library. The copyright is below
 
 //   The authors of the code itself are Stefan I. Larimore and Timothy A.
 //   Davis (davis@cise.ufl.edu), University of Florida.  The algorithm was
 //   developed in collaboration with John Gilbert, Xerox PARC, and Esmond
 //   Ng, Oak Ridge National Laboratory.
-// 
+//
 //     Date:
-// 
+//
 //   September 8, 2003.  Version 2.3.
-// 
+//
 //     Acknowledgements:
-// 
+//
 //   This work was supported by the National Science Foundation, under
 //   grants DMS-9504974 and DMS-9803599.
-// 
+//
 //     Notice:
-// 
+//
 //   Copyright (c) 1998-2003 by the University of Florida.
 //   All Rights Reserved.
-// 
+//
 //   THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY
 //   EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.
-// 
+//
 //   Permission is hereby granted to use, copy, modify, and/or distribute
 //   this program, provided that the Copyright, this License, and the
 //   Availability of the original version is retained on all copies and made
 //   accessible to the end-user of any code or package that includes COLAMD
-//   or any modified version of COLAMD. 
-// 
+//   or any modified version of COLAMD.
+//
 //     Availability:
-// 
+//
 //   The colamd/symamd library is available at
-// 
+//
 //       http://www.suitesparse.com
 
-  
+
 #ifndef EIGEN_COLAMD_H
 #define EIGEN_COLAMD_H
 
 namespace internal {
+
+namespace Colamd {
+
 /* Ensure that debugging is turned off: */
 #ifndef COLAMD_NDEBUG
 #define COLAMD_NDEBUG
 #endif /* NDEBUG */
+
+
 /* ========================================================================== */
 /* === Knob and statistics definitions ====================================== */
 /* ========================================================================== */
 
 /* size of the knobs [ ] array.  Only knobs [0..1] are currently used. */
-#define COLAMD_KNOBS 20
+const int NKnobs = 20;
 
 /* number of output statistics.  Only stats [0..6] are currently used. */
-#define COLAMD_STATS 20 
-
-/* knobs [0] and stats [0]: dense row knob and output statistic. */
-#define COLAMD_DENSE_ROW 0
-
-/* knobs [1] and stats [1]: dense column knob and output statistic. */
-#define COLAMD_DENSE_COL 1
-
-/* stats [2]: memory defragmentation count output statistic */
-#define COLAMD_DEFRAG_COUNT 2
-
-/* stats [3]: colamd status:  zero OK, > 0 warning or notice, < 0 error */
-#define COLAMD_STATUS 3
+const int NStats = 20;
 
-/* stats [4..6]: error info, or info on jumbled columns */ 
-#define COLAMD_INFO1 4
-#define COLAMD_INFO2 5
-#define COLAMD_INFO3 6
+/* Indices into knobs and stats array. */
+enum KnobsStatsIndex {
+  /* knobs [0] and stats [0]: dense row knob and output statistic. */
+  DenseRow = 0,
+
+  /* knobs [1] and stats [1]: dense column knob and output statistic. */
+  DenseCol = 1,
+
+  /* stats [2]: memory defragmentation count output statistic */
+  DefragCount = 2,
+
+  /* stats [3]: colamd status:  zero OK, > 0 warning or notice, < 0 error */
+  Status = 3,
+
+  /* stats [4..6]: error info, or info on jumbled columns */
+  Info1 = 4,
+  Info2 = 5,
+  Info3 = 6
+};
 
 /* error codes returned in stats [3]: */
-#define COLAMD_OK       (0)
-#define COLAMD_OK_BUT_JUMBLED     (1)
-#define COLAMD_ERROR_A_not_present    (-1)
-#define COLAMD_ERROR_p_not_present    (-2)
-#define COLAMD_ERROR_nrow_negative    (-3)
-#define COLAMD_ERROR_ncol_negative    (-4)
-#define COLAMD_ERROR_nnz_negative   (-5)
-#define COLAMD_ERROR_p0_nonzero     (-6)
-#define COLAMD_ERROR_A_too_small    (-7)
-#define COLAMD_ERROR_col_length_negative  (-8)
-#define COLAMD_ERROR_row_index_out_of_bounds  (-9)
-#define COLAMD_ERROR_out_of_memory    (-10)
-#define COLAMD_ERROR_internal_error   (-999)
-
+enum Status {
+  Ok = 0,
+  OkButJumbled = 1,
+  ErrorANotPresent = -1,
+  ErrorPNotPresent = -2,
+  ErrorNrowNegative = -3,
+  ErrorNcolNegative = -4,
+  ErrorNnzNegative = -5,
+  ErrorP0Nonzero = -6,
+  ErrorATooSmall = -7,
+  ErrorColLengthNegative = -8,
+  ErrorRowIndexOutOfBounds = -9,
+  ErrorOutOfMemory = -10,
+  ErrorInternalError = -999
+};
 /* ========================================================================== */
 /* === Definitions ========================================================== */
 /* ========================================================================== */
 
-#define ONES_COMPLEMENT(r) (-(r)-1)
+template <typename IndexType>
+IndexType ones_complement(const IndexType r) {
+  return (-(r)-1);
+}
 
 /* -------------------------------------------------------------------------- */
-
-#define COLAMD_EMPTY (-1)
+const int Empty = -1;
 
 /* Row and column status */
-#define ALIVE (0)
-#define DEAD  (-1)
+enum RowColumnStatus {
+  Alive = 0,
+  Dead = -1
+};
 
 /* Column status */
-#define DEAD_PRINCIPAL    (-1)
-#define DEAD_NON_PRINCIPAL  (-2)
-
-/* Macros for row and column status update and checking. */
-#define ROW_IS_DEAD(r)      ROW_IS_MARKED_DEAD (Row[r].shared2.mark)
-#define ROW_IS_MARKED_DEAD(row_mark)  (row_mark < ALIVE)
-#define ROW_IS_ALIVE(r)     (Row [r].shared2.mark >= ALIVE)
-#define COL_IS_DEAD(c)      (Col [c].start < ALIVE)
-#define COL_IS_ALIVE(c)     (Col [c].start >= ALIVE)
-#define COL_IS_DEAD_PRINCIPAL(c)  (Col [c].start == DEAD_PRINCIPAL)
-#define KILL_ROW(r)     { Row [r].shared2.mark = DEAD ; }
-#define KILL_PRINCIPAL_COL(c)   { Col [c].start = DEAD_PRINCIPAL ; }
-#define KILL_NON_PRINCIPAL_COL(c) { Col [c].start = DEAD_NON_PRINCIPAL ; }
+enum ColumnStatus {
+  DeadPrincipal = -1,
+  DeadNonPrincipal = -2
+};
 
 /* ========================================================================== */
 /* === Colamd reporting mechanism =========================================== */
 /* ========================================================================== */
 
 // == Row and Column structures ==
 template <typename IndexType>
-struct colamd_col
+struct ColStructure
 {
-  IndexType start ;   /* index for A of first row in this column, or DEAD */
+  IndexType start ;   /* index for A of first row in this column, or Dead */
   /* if column is dead */
   IndexType length ;  /* number of rows in this column */
   union
   {
     IndexType thickness ; /* number of original columns represented by this */
     /* col, if the column is alive */
     IndexType parent ;  /* parent in parent tree super-column structure, if */
@@ -155,321 +159,336 @@
     /* degree list (but not at the head of a degree list) */
   } shared3 ;
   union
   {
     IndexType degree_next ; /* next column, if col is in a degree list */
     IndexType hash_next ;   /* next column, if col is in a hash list */
   } shared4 ;
-  
+
+  inline bool is_dead() const { return start < Alive; }
+
+  inline bool is_alive() const { return start >= Alive; }
+
+  inline bool is_dead_principal() const { return start == DeadPrincipal; }
+
+  inline void kill_principal() { start = DeadPrincipal; }
+
+  inline void kill_non_principal() { start = DeadNonPrincipal; }
+
 };
- 
+
 template <typename IndexType>
-struct Colamd_Row
+struct RowStructure
 {
   IndexType start ;   /* index for A of first col in this row */
   IndexType length ;  /* number of principal columns in this row */
   union
   {
     IndexType degree ;  /* number of principal & non-principal columns in row */
     IndexType p ;   /* used as a row pointer in init_rows_cols () */
   } shared1 ;
   union
   {
     IndexType mark ;  /* for computing set differences and marking dead rows*/
     IndexType first_column ;/* first column in row (used in garbage collection) */
   } shared2 ;
-  
+
+  inline bool is_dead() const { return shared2.mark < Alive; }
+
+  inline bool is_alive() const { return shared2.mark >= Alive; }
+
+  inline void kill() { shared2.mark = Dead; }
+
 };
- 
+
 /* ========================================================================== */
 /* === Colamd recommended memory size ======================================= */
 /* ========================================================================== */
- 
+
 /*
   The recommended length Alen of the array A passed to colamd is given by
   the COLAMD_RECOMMENDED (nnz, n_row, n_col) macro.  It returns -1 if any
   argument is negative.  2*nnz space is required for the row and column
   indices of the matrix. colamd_c (n_col) + colamd_r (n_row) space is
   required for the Col and Row arrays, respectively, which are internal to
   colamd.  An additional n_col space is the minimal amount of "elbow room",
   and nnz/5 more space is recommended for run time efficiency.
-  
+
   This macro is not needed when using symamd.
-  
+
   Explicit typecast to IndexType added Sept. 23, 2002, COLAMD version 2.2, to avoid
   gcc -pedantic warning messages.
 */
 template <typename IndexType>
-inline IndexType colamd_c(IndexType n_col) 
-{ return IndexType( ((n_col) + 1) * sizeof (colamd_col<IndexType>) / sizeof (IndexType) ) ; }
+inline IndexType colamd_c(IndexType n_col)
+{ return IndexType( ((n_col) + 1) * sizeof (ColStructure<IndexType>) / sizeof (IndexType) ) ; }
 
 template <typename IndexType>
 inline IndexType  colamd_r(IndexType n_row)
-{ return IndexType(((n_row) + 1) * sizeof (Colamd_Row<IndexType>) / sizeof (IndexType)); }
+{ return IndexType(((n_row) + 1) * sizeof (RowStructure<IndexType>) / sizeof (IndexType)); }
 
 // Prototypes of non-user callable routines
 template <typename IndexType>
-static IndexType init_rows_cols (IndexType n_row, IndexType n_col, Colamd_Row<IndexType> Row [], colamd_col<IndexType> col [], IndexType A [], IndexType p [], IndexType stats[COLAMD_STATS] ); 
+static IndexType init_rows_cols (IndexType n_row, IndexType n_col, RowStructure<IndexType> Row [], ColStructure<IndexType> col [], IndexType A [], IndexType p [], IndexType stats[NStats] );
 
 template <typename IndexType>
-static void init_scoring (IndexType n_row, IndexType n_col, Colamd_Row<IndexType> Row [], colamd_col<IndexType> Col [], IndexType A [], IndexType head [], double knobs[COLAMD_KNOBS], IndexType *p_n_row2, IndexType *p_n_col2, IndexType *p_max_deg);
+static void init_scoring (IndexType n_row, IndexType n_col, RowStructure<IndexType> Row [], ColStructure<IndexType> Col [], IndexType A [], IndexType head [], double knobs[NKnobs], IndexType *p_n_row2, IndexType *p_n_col2, IndexType *p_max_deg);
 
 template <typename IndexType>
-static IndexType find_ordering (IndexType n_row, IndexType n_col, IndexType Alen, Colamd_Row<IndexType> Row [], colamd_col<IndexType> Col [], IndexType A [], IndexType head [], IndexType n_col2, IndexType max_deg, IndexType pfree);
+static IndexType find_ordering (IndexType n_row, IndexType n_col, IndexType Alen, RowStructure<IndexType> Row [], ColStructure<IndexType> Col [], IndexType A [], IndexType head [], IndexType n_col2, IndexType max_deg, IndexType pfree);
 
 template <typename IndexType>
-static void order_children (IndexType n_col, colamd_col<IndexType> Col [], IndexType p []);
+static void order_children (IndexType n_col, ColStructure<IndexType> Col [], IndexType p []);
 
 template <typename IndexType>
-static void detect_super_cols (colamd_col<IndexType> Col [], IndexType A [], IndexType head [], IndexType row_start, IndexType row_length ) ;
+static void detect_super_cols (ColStructure<IndexType> Col [], IndexType A [], IndexType head [], IndexType row_start, IndexType row_length ) ;
 
 template <typename IndexType>
-static IndexType garbage_collection (IndexType n_row, IndexType n_col, Colamd_Row<IndexType> Row [], colamd_col<IndexType> Col [], IndexType A [], IndexType *pfree) ;
+static IndexType garbage_collection (IndexType n_row, IndexType n_col, RowStructure<IndexType> Row [], ColStructure<IndexType> Col [], IndexType A [], IndexType *pfree) ;
 
 template <typename IndexType>
-static inline  IndexType clear_mark (IndexType n_row, Colamd_Row<IndexType> Row [] ) ;
+static inline  IndexType clear_mark (IndexType n_row, RowStructure<IndexType> Row [] ) ;
 
 /* === No debugging ========================================================= */
 
 #define COLAMD_DEBUG0(params) ;
 #define COLAMD_DEBUG1(params) ;
 #define COLAMD_DEBUG2(params) ;
 #define COLAMD_DEBUG3(params) ;
 #define COLAMD_DEBUG4(params) ;
 
 #define COLAMD_ASSERT(expression) ((void) 0)
 
 
 /**
- * \brief Returns the recommended value of Alen 
- * 
- * Returns recommended value of Alen for use by colamd.  
- * Returns -1 if any input argument is negative.  
- * The use of this routine or macro is optional.  
- * Note that the macro uses its arguments   more than once, 
- * so be careful for side effects, if you pass expressions as arguments to COLAMD_RECOMMENDED.  
- * 
+ * \brief Returns the recommended value of Alen
+ *
+ * Returns recommended value of Alen for use by colamd.
+ * Returns -1 if any input argument is negative.
+ * The use of this routine or macro is optional.
+ * Note that the macro uses its arguments   more than once,
+ * so be careful for side effects, if you pass expressions as arguments to COLAMD_RECOMMENDED.
+ *
  * \param nnz nonzeros in A
  * \param n_row number of rows in A
  * \param n_col number of columns in A
  * \return recommended value of Alen for use by colamd
  */
 template <typename IndexType>
-inline IndexType colamd_recommended ( IndexType nnz, IndexType n_row, IndexType n_col)
+inline IndexType recommended ( IndexType nnz, IndexType n_row, IndexType n_col)
 {
   if ((nnz) < 0 || (n_row) < 0 || (n_col) < 0)
     return (-1);
   else
-    return (2 * (nnz) + colamd_c (n_col) + colamd_r (n_row) + (n_col) + ((nnz) / 5)); 
+    return (2 * (nnz) + colamd_c (n_col) + colamd_r (n_row) + (n_col) + ((nnz) / 5));
 }
 
 /**
  * \brief set default parameters  The use of this routine is optional.
- * 
- * Colamd: rows with more than (knobs [COLAMD_DENSE_ROW] * n_col)
+ *
+ * Colamd: rows with more than (knobs [DenseRow] * n_col)
  * entries are removed prior to ordering.  Columns with more than
- * (knobs [COLAMD_DENSE_COL] * n_row) entries are removed prior to
- * ordering, and placed last in the output column ordering. 
+ * (knobs [DenseCol] * n_row) entries are removed prior to
+ * ordering, and placed last in the output column ordering.
  *
- * COLAMD_DENSE_ROW and COLAMD_DENSE_COL are defined as 0 and 1,
+ * DenseRow and DenseCol are defined as 0 and 1,
  * respectively, in colamd.h.  Default values of these two knobs
  * are both 0.5.  Currently, only knobs [0] and knobs [1] are
  * used, but future versions may use more knobs.  If so, they will
  * be properly set to their defaults by the future version of
  * colamd_set_defaults, so that the code that calls colamd will
  * not need to change, assuming that you either use
  * colamd_set_defaults, or pass a (double *) NULL pointer as the
  * knobs array to colamd or symamd.
- * 
+ *
  * \param knobs parameter settings for colamd
  */
 
-static inline void colamd_set_defaults(double knobs[COLAMD_KNOBS])
+static inline void set_defaults(double knobs[NKnobs])
 {
   /* === Local variables ================================================== */
-  
+
   int i ;
 
   if (!knobs)
   {
     return ;      /* no knobs to initialize */
   }
-  for (i = 0 ; i < COLAMD_KNOBS ; i++)
+  for (i = 0 ; i < NKnobs ; i++)
   {
     knobs [i] = 0 ;
   }
-  knobs [COLAMD_DENSE_ROW] = 0.5 ;  /* ignore rows over 50% dense */
-  knobs [COLAMD_DENSE_COL] = 0.5 ;  /* ignore columns over 50% dense */
+  knobs [Colamd::DenseRow] = 0.5 ;  /* ignore rows over 50% dense */
+  knobs [Colamd::DenseCol] = 0.5 ;  /* ignore columns over 50% dense */
 }
 
-/** 
+/**
  * \brief  Computes a column ordering using the column approximate minimum degree ordering
- * 
+ *
  * Computes a column ordering (Q) of A such that P(AQ)=LU or
  * (AQ)'AQ=LL' have less fill-in and require fewer floating point
  * operations than factorizing the unpermuted matrix A or A'A,
  * respectively.
- * 
- * 
+ *
+ *
  * \param n_row number of rows in A
  * \param n_col number of columns in A
  * \param Alen, size of the array A
  * \param A row indices of the matrix, of size ALen
  * \param p column pointers of A, of size n_col+1
  * \param knobs parameter settings for colamd
  * \param stats colamd output statistics and error codes
  */
 template <typename IndexType>
-static bool colamd(IndexType n_row, IndexType n_col, IndexType Alen, IndexType *A, IndexType *p, double knobs[COLAMD_KNOBS], IndexType stats[COLAMD_STATS])
+static bool compute_ordering(IndexType n_row, IndexType n_col, IndexType Alen, IndexType *A, IndexType *p, double knobs[NKnobs], IndexType stats[NStats])
 {
   /* === Local variables ================================================== */
-  
+
   IndexType i ;     /* loop index */
   IndexType nnz ;     /* nonzeros in A */
   IndexType Row_size ;    /* size of Row [], in integers */
   IndexType Col_size ;    /* size of Col [], in integers */
   IndexType need ;      /* minimum required length of A */
-  Colamd_Row<IndexType> *Row ;   /* pointer into A of Row [0..n_row] array */
-  colamd_col<IndexType> *Col ;   /* pointer into A of Col [0..n_col] array */
+  Colamd::RowStructure<IndexType> *Row ;   /* pointer into A of Row [0..n_row] array */
+  Colamd::ColStructure<IndexType> *Col ;   /* pointer into A of Col [0..n_col] array */
   IndexType n_col2 ;    /* number of non-dense, non-empty columns */
   IndexType n_row2 ;    /* number of non-dense, non-empty rows */
   IndexType ngarbage ;    /* number of garbage collections performed */
   IndexType max_deg ;   /* maximum row degree */
-  double default_knobs [COLAMD_KNOBS] ; /* default knobs array */
-  
-  
+  double default_knobs [NKnobs] ; /* default knobs array */
+
+
   /* === Check the input arguments ======================================== */
-  
+
   if (!stats)
   {
     COLAMD_DEBUG0 (("colamd: stats not present\n")) ;
     return (false) ;
   }
-  for (i = 0 ; i < COLAMD_STATS ; i++)
+  for (i = 0 ; i < NStats ; i++)
   {
     stats [i] = 0 ;
   }
-  stats [COLAMD_STATUS] = COLAMD_OK ;
-  stats [COLAMD_INFO1] = -1 ;
-  stats [COLAMD_INFO2] = -1 ;
-  
+  stats [Colamd::Status] = Colamd::Ok ;
+  stats [Colamd::Info1] = -1 ;
+  stats [Colamd::Info2] = -1 ;
+
   if (!A)   /* A is not present */
   {
-    stats [COLAMD_STATUS] = COLAMD_ERROR_A_not_present ;
+    stats [Colamd::Status] = Colamd::ErrorANotPresent ;
     COLAMD_DEBUG0 (("colamd: A not present\n")) ;
     return (false) ;
   }
-  
+
   if (!p)   /* p is not present */
   {
-    stats [COLAMD_STATUS] = COLAMD_ERROR_p_not_present ;
+    stats [Colamd::Status] = Colamd::ErrorPNotPresent ;
     COLAMD_DEBUG0 (("colamd: p not present\n")) ;
     return (false) ;
   }
-  
+
   if (n_row < 0)  /* n_row must be >= 0 */
   {
-    stats [COLAMD_STATUS] = COLAMD_ERROR_nrow_negative ;
-    stats [COLAMD_INFO1] = n_row ;
+    stats [Colamd::Status] = Colamd::ErrorNrowNegative ;
+    stats [Colamd::Info1] = n_row ;
     COLAMD_DEBUG0 (("colamd: nrow negative %d\n", n_row)) ;
     return (false) ;
   }
-  
+
   if (n_col < 0)  /* n_col must be >= 0 */
   {
-    stats [COLAMD_STATUS] = COLAMD_ERROR_ncol_negative ;
-    stats [COLAMD_INFO1] = n_col ;
+    stats [Colamd::Status] = Colamd::ErrorNcolNegative ;
+    stats [Colamd::Info1] = n_col ;
     COLAMD_DEBUG0 (("colamd: ncol negative %d\n", n_col)) ;
     return (false) ;
   }
-  
+
   nnz = p [n_col] ;
   if (nnz < 0)  /* nnz must be >= 0 */
   {
-    stats [COLAMD_STATUS] = COLAMD_ERROR_nnz_negative ;
-    stats [COLAMD_INFO1] = nnz ;
+    stats [Colamd::Status] = Colamd::ErrorNnzNegative ;
+    stats [Colamd::Info1] = nnz ;
     COLAMD_DEBUG0 (("colamd: number of entries negative %d\n", nnz)) ;
     return (false) ;
   }
-  
+
   if (p [0] != 0)
   {
-    stats [COLAMD_STATUS] = COLAMD_ERROR_p0_nonzero ;
-    stats [COLAMD_INFO1] = p [0] ;
+    stats [Colamd::Status] = Colamd::ErrorP0Nonzero ;
+    stats [Colamd::Info1] = p [0] ;
     COLAMD_DEBUG0 (("colamd: p[0] not zero %d\n", p [0])) ;
     return (false) ;
   }
-  
+
   /* === If no knobs, set default knobs =================================== */
-  
+
   if (!knobs)
   {
-    colamd_set_defaults (default_knobs) ;
+    set_defaults (default_knobs) ;
     knobs = default_knobs ;
   }
-  
+
   /* === Allocate the Row and Col arrays from array A ===================== */
-  
+
   Col_size = colamd_c (n_col) ;
   Row_size = colamd_r (n_row) ;
   need = 2*nnz + n_col + Col_size + Row_size ;
-  
+
   if (need > Alen)
   {
     /* not enough space in array A to perform the ordering */
-    stats [COLAMD_STATUS] = COLAMD_ERROR_A_too_small ;
-    stats [COLAMD_INFO1] = need ;
-    stats [COLAMD_INFO2] = Alen ;
+    stats [Colamd::Status] = Colamd::ErrorATooSmall ;
+    stats [Colamd::Info1] = need ;
+    stats [Colamd::Info2] = Alen ;
     COLAMD_DEBUG0 (("colamd: Need Alen >= %d, given only Alen = %d\n", need,Alen));
     return (false) ;
   }
-  
+
   Alen -= Col_size + Row_size ;
-  Col = (colamd_col<IndexType> *) &A [Alen] ;
-  Row = (Colamd_Row<IndexType> *) &A [Alen + Col_size] ;
+  Col = (ColStructure<IndexType> *) &A [Alen] ;
+  Row = (RowStructure<IndexType> *) &A [Alen + Col_size] ;
 
   /* === Construct the row and column data structures ===================== */
-  
-  if (!Eigen::internal::init_rows_cols (n_row, n_col, Row, Col, A, p, stats))
+
+  if (!Colamd::init_rows_cols (n_row, n_col, Row, Col, A, p, stats))
   {
     /* input matrix is invalid */
     COLAMD_DEBUG0 (("colamd: Matrix invalid\n")) ;
     return (false) ;
   }
-  
+
   /* === Initialize scores, kill dense rows/columns ======================= */
 
-  Eigen::internal::init_scoring (n_row, n_col, Row, Col, A, p, knobs,
+  Colamd::init_scoring (n_row, n_col, Row, Col, A, p, knobs,
 		&n_row2, &n_col2, &max_deg) ;
-  
+
   /* === Order the supercolumns =========================================== */
-  
-  ngarbage = Eigen::internal::find_ordering (n_row, n_col, Alen, Row, Col, A, p,
+
+  ngarbage = Colamd::find_ordering (n_row, n_col, Alen, Row, Col, A, p,
 			    n_col2, max_deg, 2*nnz) ;
-  
+
   /* === Order the non-principal columns ================================== */
-  
-  Eigen::internal::order_children (n_col, Col, p) ;
-  
+
+  Colamd::order_children (n_col, Col, p) ;
+
   /* === Return statistics in stats ======================================= */
-  
-  stats [COLAMD_DENSE_ROW] = n_row - n_row2 ;
-  stats [COLAMD_DENSE_COL] = n_col - n_col2 ;
-  stats [COLAMD_DEFRAG_COUNT] = ngarbage ;
-  COLAMD_DEBUG0 (("colamd: done.\n")) ; 
+
+  stats [Colamd::DenseRow] = n_row - n_row2 ;
+  stats [Colamd::DenseCol] = n_col - n_col2 ;
+  stats [Colamd::DefragCount] = ngarbage ;
+  COLAMD_DEBUG0 (("colamd: done.\n")) ;
   return (true) ;
 }
 
 /* ========================================================================== */
 /* === NON-USER-CALLABLE ROUTINES: ========================================== */
 /* ========================================================================== */
 
 /* There are no user-callable routines beyond this point in the file */
 
-
 /* ========================================================================== */
 /* === init_rows_cols ======================================================= */
 /* ========================================================================== */
 
 /*
   Takes the column form of the matrix in A and creates the row form of the
   matrix.  Also, row and column attributes are stored in the Col and Row
@@ -481,19 +500,19 @@
 template <typename IndexType>
 static IndexType init_rows_cols  /* returns true if OK, or false otherwise */
   (
     /* === Parameters ======================================================= */
 
     IndexType n_row,      /* number of rows of A */
     IndexType n_col,      /* number of columns of A */
-    Colamd_Row<IndexType> Row [],    /* of size n_row+1 */
-    colamd_col<IndexType> Col [],    /* of size n_col+1 */
+    RowStructure<IndexType> Row [],    /* of size n_row+1 */
+    ColStructure<IndexType> Col [],    /* of size n_col+1 */
     IndexType A [],     /* row indices of A, of size Alen */
     IndexType p [],     /* pointers to columns in A, of size n_col+1 */
-    IndexType stats [COLAMD_STATS]  /* colamd statistics */ 
+    IndexType stats [NStats]  /* colamd statistics */
     )
 {
   /* === Local variables ================================================== */
 
   IndexType col ;     /* a column index */
   IndexType row ;     /* a row index */
   IndexType *cp ;     /* a column pointer */
@@ -508,32 +527,32 @@
   {
     Col [col].start = p [col] ;
     Col [col].length = p [col+1] - p [col] ;
 
     if ((Col [col].length) < 0) // extra parentheses to work-around gcc bug 10200
     {
       /* column pointers must be non-decreasing */
-      stats [COLAMD_STATUS] = COLAMD_ERROR_col_length_negative ;
-      stats [COLAMD_INFO1] = col ;
-      stats [COLAMD_INFO2] = Col [col].length ;
+      stats [Colamd::Status] = Colamd::ErrorColLengthNegative ;
+      stats [Colamd::Info1] = col ;
+      stats [Colamd::Info2] = Col [col].length ;
       COLAMD_DEBUG0 (("colamd: col %d length %d < 0\n", col, Col [col].length)) ;
       return (false) ;
     }
 
     Col [col].shared1.thickness = 1 ;
     Col [col].shared2.score = 0 ;
-    Col [col].shared3.prev = COLAMD_EMPTY ;
-    Col [col].shared4.degree_next = COLAMD_EMPTY ;
+    Col [col].shared3.prev = Empty ;
+    Col [col].shared4.degree_next = Empty ;
   }
 
   /* p [0..n_col] no longer needed, used as "head" in subsequent routines */
 
   /* === Scan columns, compute row degrees, and check row indices ========= */
 
-  stats [COLAMD_INFO3] = 0 ;  /* number of duplicate or unsorted row indices*/
+  stats [Info3] = 0 ;  /* number of duplicate or unsorted row indices*/
 
   for (row = 0 ; row < n_row ; row++)
   {
     Row [row].length = 0 ;
     Row [row].shared2.mark = -1 ;
   }
 
@@ -547,30 +566,30 @@
     while (cp < cp_end)
     {
       row = *cp++ ;
 
       /* make sure row indices within range */
       if (row < 0 || row >= n_row)
       {
-	stats [COLAMD_STATUS] = COLAMD_ERROR_row_index_out_of_bounds ;
-	stats [COLAMD_INFO1] = col ;
-	stats [COLAMD_INFO2] = row ;
-	stats [COLAMD_INFO3] = n_row ;
+	stats [Colamd::Status] = Colamd::ErrorRowIndexOutOfBounds ;
+	stats [Colamd::Info1] = col ;
+	stats [Colamd::Info2] = row ;
+	stats [Colamd::Info3] = n_row ;
 	COLAMD_DEBUG0 (("colamd: row %d col %d out of bounds\n", row, col)) ;
 	return (false) ;
       }
 
       if (row <= last_row || Row [row].shared2.mark == col)
       {
 	/* row index are unsorted or repeated (or both), thus col */
 	/* is jumbled.  This is a notice, not an error condition. */
-	stats [COLAMD_STATUS] = COLAMD_OK_BUT_JUMBLED ;
-	stats [COLAMD_INFO1] = col ;
-	stats [COLAMD_INFO2] = row ;
-	(stats [COLAMD_INFO3]) ++ ;
+	stats [Colamd::Status] = Colamd::OkButJumbled ;
+	stats [Colamd::Info1] = col ;
+	stats [Colamd::Info2] = row ;
+	(stats [Colamd::Info3]) ++ ;
 	COLAMD_DEBUG1 (("colamd: row %d col %d unsorted/duplicate\n",row,col));
       }
 
       if (Row [row].shared2.mark != col)
       {
 	Row [row].length++ ;
       }
@@ -600,15 +619,15 @@
     Row [row].start = Row [row-1].start + Row [row-1].length ;
     Row [row].shared1.p = Row [row].start ;
     Row [row].shared2.mark = -1 ;
   }
 
   /* === Create row form ================================================== */
 
-  if (stats [COLAMD_STATUS] == COLAMD_OK_BUT_JUMBLED)
+  if (stats [Status] == OkButJumbled)
   {
     /* if cols jumbled, watch for repeated row indices */
     for (col = 0 ; col < n_col ; col++)
     {
       cp = &A [p [col]] ;
       cp_end = &A [p [col+1]] ;
       while (cp < cp_end)
@@ -642,15 +661,15 @@
   {
     Row [row].shared2.mark = 0 ;
     Row [row].shared1.degree = Row [row].length ;
   }
 
   /* === See if we need to re-create columns ============================== */
 
-  if (stats [COLAMD_STATUS] == COLAMD_OK_BUT_JUMBLED)
+  if (stats [Status] == OkButJumbled)
   {
     COLAMD_DEBUG0 (("colamd: reconstructing column form, matrix jumbled\n")) ;
 
 
     /* === Compute col pointers ========================================= */
 
     /* col form of the matrix starts at A [0]. */
@@ -697,19 +716,19 @@
 template <typename IndexType>
 static void init_scoring
   (
     /* === Parameters ======================================================= */
 
     IndexType n_row,      /* number of rows of A */
     IndexType n_col,      /* number of columns of A */
-    Colamd_Row<IndexType> Row [],    /* of size n_row+1 */
-    colamd_col<IndexType> Col [],    /* of size n_col+1 */
+    RowStructure<IndexType> Row [],    /* of size n_row+1 */
+    ColStructure<IndexType> Col [],    /* of size n_col+1 */
     IndexType A [],     /* column form and row form of A */
     IndexType head [],    /* of size n_col+1 */
-    double knobs [COLAMD_KNOBS],/* parameters */
+    double knobs [NKnobs],/* parameters */
     IndexType *p_n_row2,    /* number of non-dense, non-empty rows */
     IndexType *p_n_col2,    /* number of non-dense, non-empty columns */
     IndexType *p_max_deg    /* maximum row degree */
     )
 {
   /* === Local variables ================================================== */
 
@@ -728,16 +747,16 @@
   IndexType min_score ;   /* smallest column score */
   IndexType max_deg ;   /* maximum row degree */
   IndexType next_col ;    /* Used to add to degree list.*/
 
 
   /* === Extract knobs ==================================================== */
 
-  dense_row_count = numext::maxi(IndexType(0), numext::mini(IndexType(knobs [COLAMD_DENSE_ROW] * n_col), n_col)) ;
-  dense_col_count = numext::maxi(IndexType(0), numext::mini(IndexType(knobs [COLAMD_DENSE_COL] * n_row), n_row)) ;
+  dense_row_count = numext::maxi(IndexType(0), numext::mini(IndexType(knobs [Colamd::DenseRow] * n_col), n_col)) ;
+  dense_col_count = numext::maxi(IndexType(0), numext::mini(IndexType(knobs [Colamd::DenseCol] * n_row), n_row)) ;
   COLAMD_DEBUG1 (("colamd: densecount: %d %d\n", dense_row_count, dense_col_count)) ;
   max_deg = 0 ;
   n_col2 = n_col ;
   n_row2 = n_row ;
 
   /* === Kill empty columns =============================================== */
 
@@ -746,26 +765,26 @@
   for (c = n_col-1 ; c >= 0 ; c--)
   {
     deg = Col [c].length ;
     if (deg == 0)
     {
       /* this is a empty column, kill and order it last */
       Col [c].shared2.order = --n_col2 ;
-      KILL_PRINCIPAL_COL (c) ;
+      Col[c].kill_principal() ;
     }
   }
   COLAMD_DEBUG1 (("colamd: null columns killed: %d\n", n_col - n_col2)) ;
 
   /* === Kill dense columns =============================================== */
 
   /* Put the dense columns at the end, in their natural order */
   for (c = n_col-1 ; c >= 0 ; c--)
   {
     /* skip any dead columns */
-    if (COL_IS_DEAD (c))
+    if (Col[c].is_dead())
     {
       continue ;
     }
     deg = Col [c].length ;
     if (deg > dense_col_count)
     {
       /* this is a dense column, kill and order it last */
@@ -773,29 +792,29 @@
       /* decrement the row degrees */
       cp = &A [Col [c].start] ;
       cp_end = cp + Col [c].length ;
       while (cp < cp_end)
       {
 	Row [*cp++].shared1.degree-- ;
       }
-      KILL_PRINCIPAL_COL (c) ;
+      Col[c].kill_principal() ;
     }
   }
   COLAMD_DEBUG1 (("colamd: Dense and null columns killed: %d\n", n_col - n_col2)) ;
 
   /* === Kill dense and empty rows ======================================== */
 
   for (r = 0 ; r < n_row ; r++)
   {
     deg = Row [r].shared1.degree ;
     COLAMD_ASSERT (deg >= 0 && deg <= n_col) ;
     if (deg > dense_row_count || deg == 0)
     {
       /* kill a dense or empty row */
-      KILL_ROW (r) ;
+      Row[r].kill() ;
       --n_row2 ;
     }
     else
     {
       /* keep track of max degree of remaining rows */
       max_deg = numext::maxi(max_deg, deg) ;
     }
@@ -809,28 +828,28 @@
   /* Some "live" columns may contain only dead rows, however.  These are */
   /* pruned in the code below. */
 
   /* now find the initial matlab score for each column */
   for (c = n_col-1 ; c >= 0 ; c--)
   {
     /* skip dead column */
-    if (COL_IS_DEAD (c))
+    if (Col[c].is_dead())
     {
       continue ;
     }
     score = 0 ;
     cp = &A [Col [c].start] ;
     new_cp = cp ;
     cp_end = cp + Col [c].length ;
     while (cp < cp_end)
     {
       /* get a row */
       row = *cp++ ;
       /* skip if dead */
-      if (ROW_IS_DEAD (row))
+      if (Row[row].is_dead())
       {
 	continue ;
       }
       /* compact the column */
       *new_cp++ = row ;
       /* add row's external degree */
       score += Row [row].shared1.degree - 1 ;
@@ -841,15 +860,15 @@
     col_length = (IndexType) (new_cp - &A [Col [c].start]) ;
     if (col_length == 0)
     {
       /* a newly-made null column (all rows in this col are "dense" */
       /* and have already been killed) */
       COLAMD_DEBUG2 (("Newly null killed: %d\n", c)) ;
       Col [c].shared2.order = --n_col2 ;
-      KILL_PRINCIPAL_COL (c) ;
+      Col[c].kill_principal() ;
     }
     else
     {
       /* set column length and set score */
       COLAMD_ASSERT (score >= 0) ;
       COLAMD_ASSERT (score <= n_col) ;
       Col [c].length = col_length ;
@@ -866,45 +885,45 @@
 
   /* === Initialize degree lists ========================================== */
 
 
   /* clear the hash buckets */
   for (c = 0 ; c <= n_col ; c++)
   {
-    head [c] = COLAMD_EMPTY ;
+    head [c] = Empty ;
   }
   min_score = n_col ;
   /* place in reverse order, so low column indices are at the front */
   /* of the lists.  This is to encourage natural tie-breaking */
   for (c = n_col-1 ; c >= 0 ; c--)
   {
     /* only add principal columns to degree lists */
-    if (COL_IS_ALIVE (c))
+    if (Col[c].is_alive())
     {
       COLAMD_DEBUG4 (("place %d score %d minscore %d ncol %d\n",
 		      c, Col [c].shared2.score, min_score, n_col)) ;
 
       /* === Add columns score to DList =============================== */
 
       score = Col [c].shared2.score ;
 
       COLAMD_ASSERT (min_score >= 0) ;
       COLAMD_ASSERT (min_score <= n_col) ;
       COLAMD_ASSERT (score >= 0) ;
       COLAMD_ASSERT (score <= n_col) ;
-      COLAMD_ASSERT (head [score] >= COLAMD_EMPTY) ;
+      COLAMD_ASSERT (head [score] >= Empty) ;
 
       /* now add this column to dList at proper score location */
       next_col = head [score] ;
-      Col [c].shared3.prev = COLAMD_EMPTY ;
+      Col [c].shared3.prev = Empty ;
       Col [c].shared4.degree_next = next_col ;
 
       /* if there already was a column with the same score, set its */
       /* previous pointer to this new column */
-      if (next_col != COLAMD_EMPTY)
+      if (next_col != Empty)
       {
 	Col [next_col].shared3.prev = c ;
       }
       head [score] = c ;
 
       /* see if this score is less than current min */
       min_score = numext::mini(min_score, score) ;
@@ -935,16 +954,16 @@
 static IndexType find_ordering /* return the number of garbage collections */
   (
     /* === Parameters ======================================================= */
 
     IndexType n_row,      /* number of rows of A */
     IndexType n_col,      /* number of columns of A */
     IndexType Alen,     /* size of A, 2*nnz + n_col or larger */
-    Colamd_Row<IndexType> Row [],    /* of size n_row+1 */
-    colamd_col<IndexType> Col [],    /* of size n_col+1 */
+    RowStructure<IndexType> Row [],    /* of size n_row+1 */
+    ColStructure<IndexType> Col [],    /* of size n_col+1 */
     IndexType A [],     /* column form and row form of A */
     IndexType head [],    /* of size n_col+1 */
     IndexType n_col2,     /* Remaining columns to order */
     IndexType max_deg,    /* Maximum row degree */
     IndexType pfree     /* index of first free slot (2*nnz on entry) */
     )
 {
@@ -982,46 +1001,46 @@
   IndexType next_col ;    /* Used by Dlist operations. */
   IndexType ngarbage ;    /* number of garbage collections performed */
 
 
   /* === Initialization and clear mark ==================================== */
 
   max_mark = INT_MAX - n_col ;  /* INT_MAX defined in <limits.h> */
-  tag_mark = Eigen::internal::clear_mark (n_row, Row) ;
+  tag_mark = Colamd::clear_mark (n_row, Row) ;
   min_score = 0 ;
   ngarbage = 0 ;
   COLAMD_DEBUG1 (("colamd: Ordering, n_col2=%d\n", n_col2)) ;
 
   /* === Order the columns ================================================ */
 
   for (k = 0 ; k < n_col2 ; /* 'k' is incremented below */)
   {
 
     /* === Select pivot column, and order it ============================ */
 
     /* make sure degree list isn't empty */
     COLAMD_ASSERT (min_score >= 0) ;
     COLAMD_ASSERT (min_score <= n_col) ;
-    COLAMD_ASSERT (head [min_score] >= COLAMD_EMPTY) ;
+    COLAMD_ASSERT (head [min_score] >= Empty) ;
 
     /* get pivot column from head of minimum degree list */
-    while (min_score < n_col && head [min_score] == COLAMD_EMPTY)
+    while (min_score < n_col && head [min_score] == Empty)
     {
       min_score++ ;
     }
     pivot_col = head [min_score] ;
     COLAMD_ASSERT (pivot_col >= 0 && pivot_col <= n_col) ;
     next_col = Col [pivot_col].shared4.degree_next ;
     head [min_score] = next_col ;
-    if (next_col != COLAMD_EMPTY)
+    if (next_col != Empty)
     {
-      Col [next_col].shared3.prev = COLAMD_EMPTY ;
+      Col [next_col].shared3.prev = Empty ;
     }
 
-    COLAMD_ASSERT (COL_IS_ALIVE (pivot_col)) ;
+    COLAMD_ASSERT (Col[pivot_col].is_alive()) ;
     COLAMD_DEBUG3 (("Pivot col: %d\n", pivot_col)) ;
 
     /* remember score for defrag check */
     pivot_col_score = Col [pivot_col].shared2.score ;
 
     /* the pivot column is the kth column in the pivot order */
     Col [pivot_col].shared2.order = k ;
@@ -1032,20 +1051,20 @@
     COLAMD_ASSERT (pivot_col_thickness > 0) ;
 
     /* === Garbage_collection, if necessary ============================= */
 
     needed_memory = numext::mini(pivot_col_score, n_col - k) ;
     if (pfree + needed_memory >= Alen)
     {
-      pfree = Eigen::internal::garbage_collection (n_row, n_col, Row, Col, A, &A [pfree]) ;
+      pfree = Colamd::garbage_collection (n_row, n_col, Row, Col, A, &A [pfree]) ;
       ngarbage++ ;
       /* after garbage collection we will have enough */
       COLAMD_ASSERT (pfree + needed_memory < Alen) ;
       /* garbage collection has wiped out the Row[].shared2.mark array */
-      tag_mark = Eigen::internal::clear_mark (n_row, Row) ;
+      tag_mark = Colamd::clear_mark (n_row, Row) ;
 
     }
 
     /* === Compute pivot row pattern ==================================== */
 
     /* get starting location for this new merged row */
     pivot_row_start = pfree ;
@@ -1060,29 +1079,29 @@
     /* pivot row is the union of all rows in the pivot column pattern */
     cp = &A [Col [pivot_col].start] ;
     cp_end = cp + Col [pivot_col].length ;
     while (cp < cp_end)
     {
       /* get a row */
       row = *cp++ ;
-      COLAMD_DEBUG4 (("Pivot col pattern %d %d\n", ROW_IS_ALIVE (row), row)) ;
+      COLAMD_DEBUG4 (("Pivot col pattern %d %d\n", Row[row].is_alive(), row)) ;
       /* skip if row is dead */
-      if (ROW_IS_DEAD (row))
+      if (Row[row].is_dead())
       {
 	continue ;
       }
       rp = &A [Row [row].start] ;
       rp_end = rp + Row [row].length ;
       while (rp < rp_end)
       {
 	/* get a column */
 	col = *rp++ ;
 	/* add the column, if alive and untagged */
 	col_thickness = Col [col].shared1.thickness ;
-	if (col_thickness > 0 && COL_IS_ALIVE (col))
+	if (col_thickness > 0 && Col[col].is_alive())
 	{
 	  /* tag column in pivot row */
 	  Col [col].shared1.thickness = -col_thickness ;
 	  COLAMD_ASSERT (pfree < Alen) ;
 	  /* place column in pivot row */
 	  A [pfree++] = col ;
 	  pivot_row_degree += col_thickness ;
@@ -1101,30 +1120,30 @@
     cp = &A [Col [pivot_col].start] ;
     cp_end = cp + Col [pivot_col].length ;
     while (cp < cp_end)
     {
       /* may be killing an already dead row */
       row = *cp++ ;
       COLAMD_DEBUG3 (("Kill row in pivot col: %d\n", row)) ;
-      KILL_ROW (row) ;
+      Row[row].kill() ;
     }
 
     /* === Select a row index to use as the new pivot row =============== */
 
     pivot_row_length = pfree - pivot_row_start ;
     if (pivot_row_length > 0)
     {
       /* pick the "pivot" row arbitrarily (first row in col) */
       pivot_row = A [Col [pivot_col].start] ;
       COLAMD_DEBUG3 (("Pivotal row is %d\n", pivot_row)) ;
     }
     else
     {
       /* there is no pivot row, since it is of zero length */
-      pivot_row = COLAMD_EMPTY ;
+      pivot_row = Empty ;
       COLAMD_ASSERT (pivot_row_length == 0) ;
     }
     COLAMD_ASSERT (Col [pivot_col].length > 0 || pivot_row_length == 0) ;
 
     /* === Approximate degree computation =============================== */
 
     /* Here begins the computation of the approximate degree.  The column */
@@ -1153,57 +1172,57 @@
     COLAMD_DEBUG3 (("Pivot row: ")) ;
     /* for each column in pivot row */
     rp = &A [pivot_row_start] ;
     rp_end = rp + pivot_row_length ;
     while (rp < rp_end)
     {
       col = *rp++ ;
-      COLAMD_ASSERT (COL_IS_ALIVE (col) && col != pivot_col) ;
+      COLAMD_ASSERT (Col[col].is_alive() && col != pivot_col) ;
       COLAMD_DEBUG3 (("Col: %d\n", col)) ;
 
       /* clear tags used to construct pivot row pattern */
       col_thickness = -Col [col].shared1.thickness ;
       COLAMD_ASSERT (col_thickness > 0) ;
       Col [col].shared1.thickness = col_thickness ;
 
       /* === Remove column from degree list =========================== */
 
       cur_score = Col [col].shared2.score ;
       prev_col = Col [col].shared3.prev ;
       next_col = Col [col].shared4.degree_next ;
       COLAMD_ASSERT (cur_score >= 0) ;
       COLAMD_ASSERT (cur_score <= n_col) ;
-      COLAMD_ASSERT (cur_score >= COLAMD_EMPTY) ;
-      if (prev_col == COLAMD_EMPTY)
+      COLAMD_ASSERT (cur_score >= Empty) ;
+      if (prev_col == Empty)
       {
 	head [cur_score] = next_col ;
       }
       else
       {
 	Col [prev_col].shared4.degree_next = next_col ;
       }
-      if (next_col != COLAMD_EMPTY)
+      if (next_col != Empty)
       {
 	Col [next_col].shared3.prev = prev_col ;
       }
 
       /* === Scan the column ========================================== */
 
       cp = &A [Col [col].start] ;
       cp_end = cp + Col [col].length ;
       while (cp < cp_end)
       {
 	/* get a row */
 	row = *cp++ ;
-	row_mark = Row [row].shared2.mark ;
 	/* skip if dead */
-	if (ROW_IS_MARKED_DEAD (row_mark))
+	if (Row[row].is_dead())
 	{
 	  continue ;
 	}
+  row_mark = Row [row].shared2.mark ;
 	COLAMD_ASSERT (row != pivot_row) ;
 	set_difference = row_mark - tag_mark ;
 	/* check if the row has been seen yet */
 	if (set_difference < 0)
 	{
 	  COLAMD_ASSERT (Row [row].shared1.degree <= max_deg) ;
 	  set_difference = Row [row].shared1.degree ;
@@ -1211,15 +1230,15 @@
 	/* subtract column thickness from this row's set difference */
 	set_difference -= col_thickness ;
 	COLAMD_ASSERT (set_difference >= 0) ;
 	/* absorb this row if the set difference becomes zero */
 	if (set_difference == 0)
 	{
 	  COLAMD_DEBUG3 (("aggressive absorption. Row: %d\n", row)) ;
-	  KILL_ROW (row) ;
+	  Row[row].kill() ;
 	}
 	else
 	{
 	  /* save the new mark */
 	  Row [row].shared2.mark = set_difference + tag_mark ;
 	}
       }
@@ -1233,35 +1252,35 @@
     /* for each column in pivot row */
     rp = &A [pivot_row_start] ;
     rp_end = rp + pivot_row_length ;
     while (rp < rp_end)
     {
       /* get a column */
       col = *rp++ ;
-      COLAMD_ASSERT (COL_IS_ALIVE (col) && col != pivot_col) ;
+      COLAMD_ASSERT (Col[col].is_alive() && col != pivot_col) ;
       hash = 0 ;
       cur_score = 0 ;
       cp = &A [Col [col].start] ;
       /* compact the column */
       new_cp = cp ;
       cp_end = cp + Col [col].length ;
 
       COLAMD_DEBUG4 (("Adding set diffs for Col: %d.\n", col)) ;
 
       while (cp < cp_end)
       {
 	/* get a row */
 	row = *cp++ ;
 	COLAMD_ASSERT(row >= 0 && row < n_row) ;
-	row_mark = Row [row].shared2.mark ;
 	/* skip if dead */
-	if (ROW_IS_MARKED_DEAD (row_mark))
+	if (Row [row].is_dead())
 	{
 	  continue ;
 	}
+  row_mark = Row [row].shared2.mark ;
 	COLAMD_ASSERT (row_mark > tag_mark) ;
 	/* compact the column */
 	*new_cp++ = row ;
 	/* compute hash function */
 	hash += row ;
 	/* add set difference */
 	cur_score += row_mark - tag_mark ;
@@ -1274,15 +1293,15 @@
 
       /* === Further mass elimination ================================= */
 
       if (Col [col].length == 0)
       {
 	COLAMD_DEBUG4 (("further mass elimination. Col: %d\n", col)) ;
 	/* nothing left but the pivot row in this column */
-	KILL_PRINCIPAL_COL (col) ;
+	Col[col].kill_principal() ;
 	pivot_row_degree -= Col [col].shared1.thickness ;
 	COLAMD_ASSERT (pivot_row_degree >= 0) ;
 	/* order it */
 	Col [col].shared2.order = k ;
 	/* increment order count by column thickness */
 	k += Col [col].shared1.thickness ;
       }
@@ -1298,15 +1317,15 @@
 	/* add column to hash table, for supercolumn detection */
 	hash %= n_col + 1 ;
 
 	COLAMD_DEBUG4 ((" Hash = %d, n_col = %d.\n", hash, n_col)) ;
 	COLAMD_ASSERT (hash <= n_col) ;
 
 	head_column = head [hash] ;
-	if (head_column > COLAMD_EMPTY)
+	if (head_column > Empty)
 	{
 	  /* degree list "hash" is non-empty, use prev (shared3) of */
 	  /* first column in degree list as head of hash bucket */
 	  first_col = Col [head_column].shared3.headhash ;
 	  Col [head_column].shared3.headhash = col ;
 	}
 	else
@@ -1315,37 +1334,37 @@
 	  first_col = - (head_column + 2) ;
 	  head [hash] = - (col + 2) ;
 	}
 	Col [col].shared4.hash_next = first_col ;
 
 	/* save hash function in Col [col].shared3.hash */
 	Col [col].shared3.hash = (IndexType) hash ;
-	COLAMD_ASSERT (COL_IS_ALIVE (col)) ;
+	COLAMD_ASSERT (Col[col].is_alive()) ;
       }
     }
 
     /* The approximate external column degree is now computed.  */
 
     /* === Supercolumn detection ======================================== */
 
     COLAMD_DEBUG3 (("** Supercolumn detection phase. **\n")) ;
 
-    Eigen::internal::detect_super_cols (Col, A, head, pivot_row_start, pivot_row_length) ;
+    Colamd::detect_super_cols (Col, A, head, pivot_row_start, pivot_row_length) ;
 
     /* === Kill the pivotal column ====================================== */
 
-    KILL_PRINCIPAL_COL (pivot_col) ;
+    Col[pivot_col].kill_principal() ;
 
     /* === Clear mark =================================================== */
 
     tag_mark += (max_deg + 1) ;
     if (tag_mark >= max_mark)
     {
       COLAMD_DEBUG2 (("clearing tag_mark\n")) ;
-      tag_mark = Eigen::internal::clear_mark (n_row, Row) ;
+      tag_mark = Colamd::clear_mark (n_row, Row) ;
     }
 
     /* === Finalize the new pivot row, and column scores ================ */
 
     COLAMD_DEBUG3 (("** Finalize scores phase. **\n")) ;
 
     /* for each column in pivot row */
@@ -1353,15 +1372,15 @@
     /* compact the pivot row */
     new_rp = rp ;
     rp_end = rp + pivot_row_length ;
     while (rp < rp_end)
     {
       col = *rp++ ;
       /* skip dead columns */
-      if (COL_IS_DEAD (col))
+      if (Col[col].is_dead())
       {
 	continue ;
       }
       *new_rp++ = col ;
       /* add new pivot row to column */
       A [Col [col].start + (Col [col].length++)] = pivot_row ;
 
@@ -1387,19 +1406,19 @@
 
       /* === Place column back in degree list ========================= */
 
       COLAMD_ASSERT (min_score >= 0) ;
       COLAMD_ASSERT (min_score <= n_col) ;
       COLAMD_ASSERT (cur_score >= 0) ;
       COLAMD_ASSERT (cur_score <= n_col) ;
-      COLAMD_ASSERT (head [cur_score] >= COLAMD_EMPTY) ;
+      COLAMD_ASSERT (head [cur_score] >= Empty) ;
       next_col = head [cur_score] ;
       Col [col].shared4.degree_next = next_col ;
-      Col [col].shared3.prev = COLAMD_EMPTY ;
-      if (next_col != COLAMD_EMPTY)
+      Col [col].shared3.prev = Empty ;
+      if (next_col != Empty)
       {
 	Col [next_col].shared3.prev = col ;
       }
       head [cur_score] = col ;
 
       /* see if this score is less than current min */
       min_score = numext::mini(min_score, cur_score) ;
@@ -1444,15 +1463,15 @@
 */
 template <typename IndexType>
 static inline  void order_children
 (
   /* === Parameters ======================================================= */
 
   IndexType n_col,      /* number of columns of A */
-  colamd_col<IndexType> Col [],    /* of size n_col+1 */
+  ColStructure<IndexType> Col [],    /* of size n_col+1 */
   IndexType p []      /* p [0 ... n_col-1] is the column permutation*/
   )
 {
   /* === Local variables ================================================== */
 
   IndexType i ;     /* loop counter for all columns */
   IndexType c ;     /* column index */
@@ -1460,46 +1479,46 @@
   IndexType order ;     /* column's order */
 
   /* === Order each non-principal column ================================== */
 
   for (i = 0 ; i < n_col ; i++)
   {
     /* find an un-ordered non-principal column */
-    COLAMD_ASSERT (COL_IS_DEAD (i)) ;
-    if (!COL_IS_DEAD_PRINCIPAL (i) && Col [i].shared2.order == COLAMD_EMPTY)
+    COLAMD_ASSERT (col_is_dead(Col, i)) ;
+    if (!Col[i].is_dead_principal() && Col [i].shared2.order == Empty)
     {
       parent = i ;
       /* once found, find its principal parent */
       do
       {
 	parent = Col [parent].shared1.parent ;
-      } while (!COL_IS_DEAD_PRINCIPAL (parent)) ;
+      } while (!Col[parent].is_dead_principal()) ;
 
       /* now, order all un-ordered non-principal columns along path */
       /* to this parent.  collapse tree at the same time */
       c = i ;
       /* get order of parent */
       order = Col [parent].shared2.order ;
 
       do
       {
-	COLAMD_ASSERT (Col [c].shared2.order == COLAMD_EMPTY) ;
+	COLAMD_ASSERT (Col [c].shared2.order == Empty) ;
 
 	/* order this column */
 	Col [c].shared2.order = order++ ;
 	/* collaps tree */
 	Col [c].shared1.parent = parent ;
 
 	/* get immediate parent of this column */
 	c = Col [c].shared1.parent ;
 
 	/* continue until we hit an ordered column.  There are */
-	/* guarranteed not to be anymore unordered columns */
+	/* guaranteed not to be anymore unordered columns */
 	/* above an ordered column */
-      } while (Col [c].shared2.order == COLAMD_EMPTY) ;
+      } while (Col [c].shared2.order == Empty) ;
 
       /* re-order the super_col parent to largest order for this group */
       Col [parent].shared2.order = order ;
     }
   }
 
   /* === Generate the permutation ========================================= */
@@ -1543,16 +1562,16 @@
   just been computed in the approximate degree computation.
   Not user-callable.
 */
 template <typename IndexType>
 static void detect_super_cols
 (
   /* === Parameters ======================================================= */
-  
-  colamd_col<IndexType> Col [],    /* of size n_col+1 */
+
+  ColStructure<IndexType> Col [],    /* of size n_col+1 */
   IndexType A [],     /* row indices of A */
   IndexType head [],    /* head of degree lists and hash buckets */
   IndexType row_start,    /* pointer to set of columns to check */
   IndexType row_length    /* number of columns to check */
 )
 {
   /* === Local variables ================================================== */
@@ -1574,54 +1593,54 @@
   /* === Consider each column in the row ================================== */
 
   rp = &A [row_start] ;
   rp_end = rp + row_length ;
   while (rp < rp_end)
   {
     col = *rp++ ;
-    if (COL_IS_DEAD (col))
+    if (Col[col].is_dead())
     {
       continue ;
     }
 
     /* get hash number for this column */
     hash = Col [col].shared3.hash ;
     COLAMD_ASSERT (hash <= n_col) ;
 
     /* === Get the first column in this hash bucket ===================== */
 
     head_column = head [hash] ;
-    if (head_column > COLAMD_EMPTY)
+    if (head_column > Empty)
     {
       first_col = Col [head_column].shared3.headhash ;
     }
     else
     {
       first_col = - (head_column + 2) ;
     }
 
     /* === Consider each column in the hash bucket ====================== */
 
-    for (super_c = first_col ; super_c != COLAMD_EMPTY ;
+    for (super_c = first_col ; super_c != Empty ;
 	 super_c = Col [super_c].shared4.hash_next)
     {
-      COLAMD_ASSERT (COL_IS_ALIVE (super_c)) ;
+      COLAMD_ASSERT (Col [super_c].is_alive()) ;
       COLAMD_ASSERT (Col [super_c].shared3.hash == hash) ;
       length = Col [super_c].length ;
 
       /* prev_c is the column preceding column c in the hash bucket */
       prev_c = super_c ;
 
       /* === Compare super_c with all columns after it ================ */
 
       for (c = Col [super_c].shared4.hash_next ;
-	   c != COLAMD_EMPTY ; c = Col [c].shared4.hash_next)
+	   c != Empty ; c = Col [c].shared4.hash_next)
       {
 	COLAMD_ASSERT (c != super_c) ;
-	COLAMD_ASSERT (COL_IS_ALIVE (c)) ;
+	COLAMD_ASSERT (Col[c].is_alive()) ;
 	COLAMD_ASSERT (Col [c].shared3.hash == hash) ;
 
 	/* not identical if lengths or scores are different */
 	if (Col [c].length != length ||
 	    Col [c].shared2.score != Col [super_c].shared2.score)
 	{
 	  prev_c = c ;
@@ -1631,18 +1650,18 @@
 	/* compare the two columns */
 	cp1 = &A [Col [super_c].start] ;
 	cp2 = &A [Col [c].start] ;
 
 	for (i = 0 ; i < length ; i++)
 	{
 	  /* the columns are "clean" (no dead rows) */
-	  COLAMD_ASSERT (ROW_IS_ALIVE (*cp1))  ;
-	  COLAMD_ASSERT (ROW_IS_ALIVE (*cp2))  ;
+	  COLAMD_ASSERT ( cp1->is_alive() );
+	  COLAMD_ASSERT ( cp2->is_alive() );
 	  /* row indices will same order for both supercols, */
-	  /* no gather scatter nessasary */
+	  /* no gather scatter necessary */
 	  if (*cp1++ != *cp2++)
 	  {
 	    break ;
 	  }
 	}
 
 	/* the two columns are different if the for-loop "broke" */
@@ -1654,59 +1673,59 @@
 
 	/* === Got it!  two columns are identical =================== */
 
 	COLAMD_ASSERT (Col [c].shared2.score == Col [super_c].shared2.score) ;
 
 	Col [super_c].shared1.thickness += Col [c].shared1.thickness ;
 	Col [c].shared1.parent = super_c ;
-	KILL_NON_PRINCIPAL_COL (c) ;
+	Col[c].kill_non_principal() ;
 	/* order c later, in order_children() */
-	Col [c].shared2.order = COLAMD_EMPTY ;
+	Col [c].shared2.order = Empty ;
 	/* remove c from hash bucket */
 	Col [prev_c].shared4.hash_next = Col [c].shared4.hash_next ;
       }
     }
 
     /* === Empty this hash bucket ======================================= */
 
-    if (head_column > COLAMD_EMPTY)
+    if (head_column > Empty)
     {
       /* corresponding degree list "hash" is not empty */
-      Col [head_column].shared3.headhash = COLAMD_EMPTY ;
+      Col [head_column].shared3.headhash = Empty ;
     }
     else
     {
       /* corresponding degree list "hash" is empty */
-      head [hash] = COLAMD_EMPTY ;
+      head [hash] = Empty ;
     }
   }
 }
 
 
 /* ========================================================================== */
 /* === garbage_collection =================================================== */
 /* ========================================================================== */
 
 /*
   Defragments and compacts columns and rows in the workspace A.  Used when
-  all avaliable memory has been used while performing row merging.  Returns
+  all available memory has been used while performing row merging.  Returns
   the index of the first free position in A, after garbage collection.  The
   time taken by this routine is linear is the size of the array A, which is
   itself linear in the number of nonzeros in the input matrix.
   Not user-callable.
 */
 template <typename IndexType>
 static IndexType garbage_collection  /* returns the new value of pfree */
   (
     /* === Parameters ======================================================= */
-    
+
     IndexType n_row,      /* number of rows */
     IndexType n_col,      /* number of columns */
-    Colamd_Row<IndexType> Row [],    /* row info */
-    colamd_col<IndexType> Col [],    /* column info */
+    RowStructure<IndexType> Row [],    /* row info */
+    ColStructure<IndexType> Col [],    /* column info */
     IndexType A [],     /* A [0 ... Alen-1] holds the matrix */
     IndexType *pfree      /* &A [0] ... pfree is in use */
     )
 {
   /* === Local variables ================================================== */
 
   IndexType *psrc ;     /* source pointer */
@@ -1717,54 +1736,54 @@
   IndexType length ;    /* length of a row or column */
 
   /* === Defragment the columns =========================================== */
 
   pdest = &A[0] ;
   for (c = 0 ; c < n_col ; c++)
   {
-    if (COL_IS_ALIVE (c))
+    if (Col[c].is_alive())
     {
       psrc = &A [Col [c].start] ;
 
       /* move and compact the column */
       COLAMD_ASSERT (pdest <= psrc) ;
       Col [c].start = (IndexType) (pdest - &A [0]) ;
       length = Col [c].length ;
       for (j = 0 ; j < length ; j++)
       {
 	r = *psrc++ ;
-	if (ROW_IS_ALIVE (r))
+	if (Row[r].is_alive())
 	{
 	  *pdest++ = r ;
 	}
       }
       Col [c].length = (IndexType) (pdest - &A [Col [c].start]) ;
     }
   }
 
   /* === Prepare to defragment the rows =================================== */
 
   for (r = 0 ; r < n_row ; r++)
   {
-    if (ROW_IS_ALIVE (r))
+    if (Row[r].is_alive())
     {
       if (Row [r].length == 0)
       {
-	/* this row is of zero length.  cannot compact it, so kill it */
-	COLAMD_DEBUG3 (("Defrag row kill\n")) ;
-	KILL_ROW (r) ;
+        /* this row is of zero length.  cannot compact it, so kill it */
+        COLAMD_DEBUG3 (("Defrag row kill\n")) ;
+        Row[r].kill() ;
       }
       else
       {
-	/* save first column index in Row [r].shared2.first_column */
-	psrc = &A [Row [r].start] ;
-	Row [r].shared2.first_column = *psrc ;
-	COLAMD_ASSERT (ROW_IS_ALIVE (r)) ;
-	/* flag the start of the row with the one's complement of row */
-	*psrc = ONES_COMPLEMENT (r) ;
+        /* save first column index in Row [r].shared2.first_column */
+        psrc = &A [Row [r].start] ;
+        Row [r].shared2.first_column = *psrc ;
+        COLAMD_ASSERT (Row[r].is_alive()) ;
+        /* flag the start of the row with the one's complement of row */
+        *psrc = ones_complement(r) ;
 
       }
     }
   }
 
   /* === Defragment the rows ============================================== */
 
@@ -1772,28 +1791,28 @@
   while (psrc < pfree)
   {
     /* find a negative number ... the start of a row */
     if (*psrc++ < 0)
     {
       psrc-- ;
       /* get the row index */
-      r = ONES_COMPLEMENT (*psrc) ;
+      r = ones_complement(*psrc) ;
       COLAMD_ASSERT (r >= 0 && r < n_row) ;
       /* restore first column index */
       *psrc = Row [r].shared2.first_column ;
-      COLAMD_ASSERT (ROW_IS_ALIVE (r)) ;
+      COLAMD_ASSERT (Row[r].is_alive()) ;
 
       /* move and compact the row */
       COLAMD_ASSERT (pdest <= psrc) ;
       Row [r].start = (IndexType) (pdest - &A [0]) ;
       length = Row [r].length ;
       for (j = 0 ; j < length ; j++)
       {
 	c = *psrc++ ;
-	if (COL_IS_ALIVE (c))
+	if (Col[c].is_alive())
 	{
 	  *pdest++ = c ;
 	}
       }
       Row [r].length = (IndexType) (pdest - &A [Row [r].start]) ;
 
     }
@@ -1817,27 +1836,28 @@
 */
 template <typename IndexType>
 static inline  IndexType clear_mark  /* return the new value for tag_mark */
   (
       /* === Parameters ======================================================= */
 
     IndexType n_row,    /* number of rows in A */
-    Colamd_Row<IndexType> Row [] /* Row [0 ... n_row-1].shared2.mark is set to zero */
+    RowStructure<IndexType> Row [] /* Row [0 ... n_row-1].shared2.mark is set to zero */
     )
 {
   /* === Local variables ================================================== */
 
   IndexType r ;
 
   for (r = 0 ; r < n_row ; r++)
   {
-    if (ROW_IS_ALIVE (r))
+    if (Row[r].is_alive())
     {
       Row [r].shared2.mark = 0 ;
     }
   }
   return (1) ;
 }
 
+} // namespace Colamd
 
-} // namespace internal 
+} // namespace internal
 #endif
```

### Comparing `chronogram-0.1.7/include/Eigen/src/OrderingMethods/Ordering.h` & `chronogram-0.2.0/include/Eigen/src/OrderingMethods/Ordering.h`

 * *Files 6% similar despite different names*

```diff
@@ -27,23 +27,21 @@
 void ordering_helper_at_plus_a(const MatrixType& A, MatrixType& symmat)
 {
   MatrixType C;
   C = A.transpose(); // NOTE: Could be  costly
   for (int i = 0; i < C.rows(); i++) 
   {
       for (typename MatrixType::InnerIterator it(C, i); it; ++it)
-        it.valueRef() = 0.0;
+        it.valueRef() = typename MatrixType::Scalar(0);
   }
   symmat = C + A;
 }
     
 }
 
-#ifndef EIGEN_MPL2_ONLY
-
 /** \ingroup OrderingMethods_Module
   * \class AMDOrdering
   *
   * Functor computing the \em approximate \em minimum \em degree ordering
   * If the matrix is not structurally symmetric, an ordering of A^T+A is computed
   * \tparam  StorageIndex The type of indices of the matrix 
   * \sa COLAMDOrdering
@@ -77,16 +75,14 @@
       
       // Call the AMD routine 
       // m_mat.prune(keep_diag()); //Remove the diagonal elements 
       internal::minimum_degree_ordering(C, perm);
     }
 };
 
-#endif // EIGEN_MPL2_ONLY
-
 /** \ingroup OrderingMethods_Module
   * \class NaturalOrdering
   *
   * Functor computing the natural ordering (identity)
   * 
   * \note Returns an empty permutation matrix
   * \tparam  StorageIndex The type of indices of the matrix 
@@ -129,25 +125,25 @@
     {
       eigen_assert(mat.isCompressed() && "COLAMDOrdering requires a sparse matrix in compressed mode. Call .makeCompressed() before passing it to COLAMDOrdering");
       
       StorageIndex m = StorageIndex(mat.rows());
       StorageIndex n = StorageIndex(mat.cols());
       StorageIndex nnz = StorageIndex(mat.nonZeros());
       // Get the recommended value of Alen to be used by colamd
-      StorageIndex Alen = internal::colamd_recommended(nnz, m, n); 
+      StorageIndex Alen = internal::Colamd::recommended(nnz, m, n); 
       // Set the default parameters
-      double knobs [COLAMD_KNOBS]; 
-      StorageIndex stats [COLAMD_STATS];
-      internal::colamd_set_defaults(knobs);
+      double knobs [internal::Colamd::NKnobs]; 
+      StorageIndex stats [internal::Colamd::NStats];
+      internal::Colamd::set_defaults(knobs);
       
       IndexVector p(n+1), A(Alen); 
       for(StorageIndex i=0; i <= n; i++)   p(i) = mat.outerIndexPtr()[i];
       for(StorageIndex i=0; i < nnz; i++)  A(i) = mat.innerIndexPtr()[i];
       // Call Colamd routine to compute the ordering 
-      StorageIndex info = internal::colamd(m, n, Alen, A.data(), p.data(), knobs, stats); 
+      StorageIndex info = internal::Colamd::compute_ordering(m, n, Alen, A.data(), p.data(), knobs, stats); 
       EIGEN_UNUSED_VARIABLE(info);
       eigen_assert( info && "COLAMD failed " );
       
       perm.resize(n);
       for (StorageIndex i = 0; i < n; i++) perm.indices()(p(i)) = i;
     }
 };
```

### Comparing `chronogram-0.1.7/include/Eigen/src/PaStiXSupport/PaStiXSupport.h` & `chronogram-0.2.0/include/Eigen/src/PaStiXSupport/PaStiXSupport.h`

 * *Files 0% similar despite different names*

```diff
@@ -199,15 +199,15 @@
     }
     
     inline Index cols() const { return m_size; }
     inline Index rows() const { return m_size; }
     
      /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the PaStiX reports a problem
       *          \c InvalidInput if the input matrix is invalid
       *
       * \sa iparm()          
       */
     ComputationInfo info() const
     {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/PardisoSupport/PardisoSupport.h` & `chronogram-0.2.0/include/Eigen/src/PardisoSupport/PardisoSupport.h`

 * *Files 1% similar despite different names*

```diff
@@ -119,14 +119,15 @@
     enum {
       ScalarIsComplex = NumTraits<Scalar>::IsComplex,
       ColsAtCompileTime = Dynamic,
       MaxColsAtCompileTime = Dynamic
     };
 
     PardisoImpl()
+      : m_analysisIsOk(false), m_factorizationIsOk(false)
     {
       eigen_assert((sizeof(StorageIndex) >= sizeof(_INTEGER_t) && sizeof(StorageIndex) <= 8) && "Non-supported index type");
       m_iparm.setZero();
       m_msglvl = 0; // No output
       m_isInitialized = false;
     }
 
@@ -136,15 +137,15 @@
     }
 
     inline Index cols() const { return m_size; }
     inline Index rows() const { return m_size; }
   
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the matrix appears to be negative.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "Decomposition is not initialized.");
       return m_info;
     }
@@ -381,22 +382,23 @@
   * \sa \ref TutorialSparseSolverConcept, class SparseLU
   */
 template<typename MatrixType>
 class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >
 {
   protected:
     typedef PardisoImpl<PardisoLU> Base;
-    typedef typename Base::Scalar Scalar;
-    typedef typename Base::RealScalar RealScalar;
     using Base::pardisoInit;
     using Base::m_matrix;
     friend class PardisoImpl< PardisoLU<MatrixType> >;
 
   public:
 
+    typedef typename Base::Scalar Scalar;
+    typedef typename Base::RealScalar RealScalar;
+
     using Base::compute;
     using Base::solve;
 
     PardisoLU()
       : Base()
     {
       pardisoInit(Base::ScalarIsComplex ? 13 : 11);
@@ -436,22 +438,22 @@
   * \sa \ref TutorialSparseSolverConcept, class SimplicialLLT
   */
 template<typename MatrixType, int _UpLo>
 class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >
 {
   protected:
     typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;
-    typedef typename Base::Scalar Scalar;
-    typedef typename Base::RealScalar RealScalar;
     using Base::pardisoInit;
     using Base::m_matrix;
     friend class PardisoImpl< PardisoLLT<MatrixType,_UpLo> >;
 
   public:
 
+    typedef typename Base::Scalar Scalar;
+    typedef typename Base::RealScalar RealScalar;
     typedef typename Base::StorageIndex StorageIndex;
     enum { UpLo = _UpLo };
     using Base::compute;
 
     PardisoLLT()
       : Base()
     {
@@ -499,22 +501,22 @@
   * \sa \ref TutorialSparseSolverConcept, class SimplicialLDLT
   */
 template<typename MatrixType, int Options>
 class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >
 {
   protected:
     typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;
-    typedef typename Base::Scalar Scalar;
-    typedef typename Base::RealScalar RealScalar;
     using Base::pardisoInit;
     using Base::m_matrix;
     friend class PardisoImpl< PardisoLDLT<MatrixType,Options> >;
 
   public:
 
+    typedef typename Base::Scalar Scalar;
+    typedef typename Base::RealScalar RealScalar;
     typedef typename Base::StorageIndex StorageIndex;
     using Base::compute;
     enum { UpLo = Options&(Upper|Lower) };
 
     PardisoLDLT()
       : Base()
     {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/QR/ColPivHouseholderQR.h` & `chronogram-0.2.0/include/Eigen/src/QR/ColPivHouseholderQR.h`

 * *Files 5% similar despite different names*

```diff
@@ -13,14 +13,17 @@
 
 namespace Eigen {
 
 namespace internal {
 template<typename _MatrixType> struct traits<ColPivHouseholderQR<_MatrixType> >
  : traits<_MatrixType>
 {
+  typedef MatrixXpr XprKind;
+  typedef SolverStorage StorageKind;
+  typedef int StorageIndex;
   enum { Flags = 0 };
 };
 
 } // end namespace internal
 
 /** \ingroup QR_Module
   *
@@ -42,28 +45,27 @@
   * numerical stability. It is slower than HouseholderQR, and faster than FullPivHouseholderQR.
   *
   * This class supports the \link InplaceDecomposition inplace decomposition \endlink mechanism.
   * 
   * \sa MatrixBase::colPivHouseholderQr()
   */
 template<typename _MatrixType> class ColPivHouseholderQR
+        : public SolverBase<ColPivHouseholderQR<_MatrixType> >
 {
   public:
 
     typedef _MatrixType MatrixType;
+    typedef SolverBase<ColPivHouseholderQR> Base;
+    friend class SolverBase<ColPivHouseholderQR>;
+
+    EIGEN_GENERIC_PUBLIC_INTERFACE(ColPivHouseholderQR)
     enum {
-      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
-      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
     };
-    typedef typename MatrixType::Scalar Scalar;
-    typedef typename MatrixType::RealScalar RealScalar;
-    // FIXME should be int
-    typedef typename MatrixType::StorageIndex StorageIndex;
     typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;
     typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;
     typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;
     typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;
     typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;
     typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;
     typedef typename MatrixType::PlainObject PlainObject;
@@ -152,14 +154,15 @@
         m_colNormsDirect(matrix.cols()),
         m_isInitialized(false),
         m_usePrescribedThreshold(false)
     {
       computeInPlace();
     }
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
     /** This method finds a solution x to the equation Ax=b, where A is the matrix of which
       * *this is the QR decomposition, if any exists.
       *
       * \param b the right-hand-side of the equation to solve.
       *
       * \returns a solution.
       *
@@ -168,19 +171,16 @@
       * \note_about_arbitrary_choice_of_solution
       *
       * Example: \include ColPivHouseholderQR_solve.cpp
       * Output: \verbinclude ColPivHouseholderQR_solve.out
       */
     template<typename Rhs>
     inline const Solve<ColPivHouseholderQR, Rhs>
-    solve(const MatrixBase<Rhs>& b) const
-    {
-      eigen_assert(m_isInitialized && "ColPivHouseholderQR is not initialized.");
-      return Solve<ColPivHouseholderQR, Rhs>(*this, b.derived());
-    }
+    solve(const MatrixBase<Rhs>& b) const;
+    #endif
 
     HouseholderSequenceType householderQ() const;
     HouseholderSequenceType matrixQ() const
     {
       return householderQ();
     }
 
@@ -398,30 +398,32 @@
     }
 
     /** \returns the absolute value of the biggest pivot, i.e. the biggest
       *          diagonal coefficient of R.
       */
     RealScalar maxPivot() const { return m_maxpivot; }
 
-    /** \brief Reports whether the QR factorization was succesful.
+    /** \brief Reports whether the QR factorization was successful.
       *
       * \note This function always returns \c Success. It is provided for compatibility
       * with other factorization routines.
       * \returns \c Success
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "Decomposition is not initialized.");
       return Success;
     }
 
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename RhsType, typename DstType>
-    EIGEN_DEVICE_FUNC
     void _solve_impl(const RhsType &rhs, DstType &dst) const;
+
+    template<bool Conjugate, typename RhsType, typename DstType>
+    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;
     #endif
 
   protected:
 
     friend class CompleteOrthogonalDecomposition<MatrixType>;
 
     static void check_template_parameters()
@@ -580,39 +582,58 @@
 }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template<typename _MatrixType>
 template<typename RhsType, typename DstType>
 void ColPivHouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const
 {
-  eigen_assert(rhs.rows() == rows());
-
   const Index nonzero_pivots = nonzeroPivots();
 
   if(nonzero_pivots == 0)
   {
     dst.setZero();
     return;
   }
 
   typename RhsType::PlainObject c(rhs);
 
-  // Note that the matrix Q = H_0^* H_1^*... so its inverse is Q^* = (H_0 H_1 ...)^T
-  c.applyOnTheLeft(householderSequence(m_qr, m_hCoeffs)
-                    .setLength(nonzero_pivots)
-                    .transpose()
-    );
+  c.applyOnTheLeft(householderQ().setLength(nonzero_pivots).adjoint() );
 
   m_qr.topLeftCorner(nonzero_pivots, nonzero_pivots)
       .template triangularView<Upper>()
       .solveInPlace(c.topRows(nonzero_pivots));
 
   for(Index i = 0; i < nonzero_pivots; ++i) dst.row(m_colsPermutation.indices().coeff(i)) = c.row(i);
   for(Index i = nonzero_pivots; i < cols(); ++i) dst.row(m_colsPermutation.indices().coeff(i)).setZero();
 }
+
+template<typename _MatrixType>
+template<bool Conjugate, typename RhsType, typename DstType>
+void ColPivHouseholderQR<_MatrixType>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const
+{
+  const Index nonzero_pivots = nonzeroPivots();
+
+  if(nonzero_pivots == 0)
+  {
+    dst.setZero();
+    return;
+  }
+
+  typename RhsType::PlainObject c(m_colsPermutation.transpose()*rhs);
+
+  m_qr.topLeftCorner(nonzero_pivots, nonzero_pivots)
+        .template triangularView<Upper>()
+        .transpose().template conjugateIf<Conjugate>()
+        .solveInPlace(c.topRows(nonzero_pivots));
+
+  dst.topRows(nonzero_pivots) = c.topRows(nonzero_pivots);
+  dst.bottomRows(rows()-nonzero_pivots).setZero();
+
+  dst.applyOnTheLeft(householderQ().setLength(nonzero_pivots).template conjugateIf<!Conjugate>() );
+}
 #endif
 
 namespace internal {
 
 template<typename DstXprType, typename MatrixType>
 struct Assignment<DstXprType, Inverse<ColPivHouseholderQR<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename ColPivHouseholderQR<MatrixType>::Scalar>, Dense2Dense>
 {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h` & `chronogram-0.2.0/include/Eigen/src/QR/ColPivHouseholderQR_LAPACKE.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/QR/CompleteOrthogonalDecomposition.h` & `chronogram-0.2.0/include/Eigen/src/QR/CompleteOrthogonalDecomposition.h`

 * *Files 10% similar despite different names*

```diff
@@ -12,14 +12,17 @@
 
 namespace Eigen {
 
 namespace internal {
 template <typename _MatrixType>
 struct traits<CompleteOrthogonalDecomposition<_MatrixType> >
     : traits<_MatrixType> {
+  typedef MatrixXpr XprKind;
+  typedef SolverStorage StorageKind;
+  typedef int StorageIndex;
   enum { Flags = 0 };
 };
 
 }  // end namespace internal
 
 /** \ingroup QR_Module
   *
@@ -40,27 +43,29 @@
   * \b Q and \b Z are unitary matrices and \b T an upper triangular matrix of
   * size rank-by-rank. \b A may be rank deficient.
   *
   * This class supports the \link InplaceDecomposition inplace decomposition \endlink mechanism.
   * 
   * \sa MatrixBase::completeOrthogonalDecomposition()
   */
-template <typename _MatrixType>
-class CompleteOrthogonalDecomposition {
+template <typename _MatrixType> class CompleteOrthogonalDecomposition
+          : public SolverBase<CompleteOrthogonalDecomposition<_MatrixType> >
+{
  public:
   typedef _MatrixType MatrixType;
+  typedef SolverBase<CompleteOrthogonalDecomposition> Base;
+
+  template<typename Derived>
+  friend struct internal::solve_assertion;
+
+  EIGEN_GENERIC_PUBLIC_INTERFACE(CompleteOrthogonalDecomposition)
   enum {
-    RowsAtCompileTime = MatrixType::RowsAtCompileTime,
-    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
   };
-  typedef typename MatrixType::Scalar Scalar;
-  typedef typename MatrixType::RealScalar RealScalar;
-  typedef typename MatrixType::StorageIndex StorageIndex;
   typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;
   typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime>
       PermutationType;
   typedef typename internal::plain_row_type<MatrixType, Index>::type
       IntRowVectorType;
   typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;
   typedef typename internal::plain_row_type<MatrixType, RealScalar>::type
@@ -127,43 +132,40 @@
   template<typename InputType>
   explicit CompleteOrthogonalDecomposition(EigenBase<InputType>& matrix)
     : m_cpqr(matrix.derived()),
       m_zCoeffs((std::min)(matrix.rows(), matrix.cols())),
       m_temp(matrix.cols())
   {
     computeInPlace();
-  }
-
+  } 
 
+  #ifdef EIGEN_PARSED_BY_DOXYGEN
   /** This method computes the minimum-norm solution X to a least squares
    * problem \f[\mathrm{minimize} \|A X - B\|, \f] where \b A is the matrix of
    * which \c *this is the complete orthogonal decomposition.
    *
    * \param b the right-hand sides of the problem to solve.
    *
    * \returns a solution.
    *
    */
   template <typename Rhs>
   inline const Solve<CompleteOrthogonalDecomposition, Rhs> solve(
-      const MatrixBase<Rhs>& b) const {
-    eigen_assert(m_cpqr.m_isInitialized &&
-                 "CompleteOrthogonalDecomposition is not initialized.");
-    return Solve<CompleteOrthogonalDecomposition, Rhs>(*this, b.derived());
-  }
+      const MatrixBase<Rhs>& b) const;
+  #endif
 
   HouseholderSequenceType householderQ(void) const;
   HouseholderSequenceType matrixQ(void) const { return m_cpqr.householderQ(); }
 
   /** \returns the matrix \b Z.
    */
   MatrixType matrixZ() const {
     MatrixType Z = MatrixType::Identity(m_cpqr.cols(), m_cpqr.cols());
-    applyZAdjointOnTheLeftInPlace(Z);
-    return Z.adjoint();
+    applyZOnTheLeftInPlace<false>(Z);
+    return Z;
   }
 
   /** \returns a reference to the matrix where the complete orthogonal
    * decomposition is stored
    */
   const MatrixType& matrixQTZ() const { return m_cpqr.matrixQR(); }
 
@@ -271,14 +273,15 @@
   /** \returns the pseudo-inverse of the matrix of which *this is the complete
    * orthogonal decomposition.
    * \warning: Do not compute \c this->pseudoInverse()*rhs to solve a linear systems.
    * It is more efficient and numerically stable to call \c this->solve(rhs).
    */
   inline const Inverse<CompleteOrthogonalDecomposition> pseudoInverse() const
   {
+    eigen_assert(m_cpqr.m_isInitialized && "CompleteOrthogonalDecomposition is not initialized.");
     return Inverse<CompleteOrthogonalDecomposition>(*this);
   }
 
   inline Index rows() const { return m_cpqr.rows(); }
   inline Index cols() const { return m_cpqr.cols(); }
 
   /** \returns a const reference to the vector of Householder coefficients used
@@ -349,38 +352,55 @@
 
   /** \returns the absolute value of the biggest pivot, i.e. the biggest
    *          diagonal coefficient of R.
    */
   inline RealScalar maxPivot() const { return m_cpqr.maxPivot(); }
 
   /** \brief Reports whether the complete orthogonal decomposition was
-   * succesful.
+   * successful.
    *
    * \note This function always returns \c Success. It is provided for
    * compatibility
    * with other factorization routines.
    * \returns \c Success
    */
   ComputationInfo info() const {
     eigen_assert(m_cpqr.m_isInitialized && "Decomposition is not initialized.");
     return Success;
   }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
   template <typename RhsType, typename DstType>
-  EIGEN_DEVICE_FUNC void _solve_impl(const RhsType& rhs, DstType& dst) const;
+  void _solve_impl(const RhsType& rhs, DstType& dst) const;
+
+  template<bool Conjugate, typename RhsType, typename DstType>
+  void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;
 #endif
 
  protected:
   static void check_template_parameters() {
     EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar);
   }
 
+  template<bool Transpose_, typename Rhs>
+  void _check_solve_assertion(const Rhs& b) const {
+      EIGEN_ONLY_USED_FOR_DEBUG(b);
+      eigen_assert(m_cpqr.m_isInitialized && "CompleteOrthogonalDecomposition is not initialized.");
+      eigen_assert((Transpose_?derived().cols():derived().rows())==b.rows() && "CompleteOrthogonalDecomposition::solve(): invalid number of rows of the right hand side matrix b");
+  }
+
   void computeInPlace();
 
+  /** Overwrites \b rhs with \f$ \mathbf{Z} * \mathbf{rhs} \f$ or
+   *  \f$ \mathbf{\overline Z} * \mathbf{rhs} \f$ if \c Conjugate 
+   *  is set to \c true.
+   */
+  template <bool Conjugate, typename Rhs>
+  void applyZOnTheLeftInPlace(Rhs& rhs) const;
+
   /** Overwrites \b rhs with \f$ \mathbf{Z}^* * \mathbf{rhs} \f$.
    */
   template <typename Rhs>
   void applyZAdjointOnTheLeftInPlace(Rhs& rhs) const;
 
   ColPivHouseholderQR<MatrixType> m_cpqr;
   HCoeffsType m_zCoeffs;
@@ -448,34 +468,56 @@
           .tail(cols - rank + 1)
           .makeHouseholderInPlace(m_zCoeffs(k), beta);
       m_cpqr.m_qr(k, rank - 1) = beta;
       if (k > 0) {
         // Apply Z(k) to the first k rows of X_k
         m_cpqr.m_qr.topRightCorner(k, cols - rank + 1)
             .applyHouseholderOnTheRight(
-                m_cpqr.m_qr.row(k).tail(cols - rank).transpose(), m_zCoeffs(k),
+                m_cpqr.m_qr.row(k).tail(cols - rank).adjoint(), m_zCoeffs(k),
                 &m_temp(0));
       }
       if (k != rank - 1) {
         // Swap X(0:k,k) back to its proper location.
         m_cpqr.m_qr.col(k).head(k + 1).swap(
             m_cpqr.m_qr.col(rank - 1).head(k + 1));
       }
     }
   }
 }
 
 template <typename MatrixType>
+template <bool Conjugate, typename Rhs>
+void CompleteOrthogonalDecomposition<MatrixType>::applyZOnTheLeftInPlace(
+    Rhs& rhs) const {
+  const Index cols = this->cols();
+  const Index nrhs = rhs.cols();
+  const Index rank = this->rank();
+  Matrix<typename Rhs::Scalar, Dynamic, 1> temp((std::max)(cols, nrhs));
+  for (Index k = rank-1; k >= 0; --k) {
+    if (k != rank - 1) {
+      rhs.row(k).swap(rhs.row(rank - 1));
+    }
+    rhs.middleRows(rank - 1, cols - rank + 1)
+        .applyHouseholderOnTheLeft(
+            matrixQTZ().row(k).tail(cols - rank).transpose().template conjugateIf<!Conjugate>(), zCoeffs().template conjugateIf<Conjugate>()(k),
+            &temp(0));
+    if (k != rank - 1) {
+      rhs.row(k).swap(rhs.row(rank - 1));
+    }
+  }
+}
+
+template <typename MatrixType>
 template <typename Rhs>
 void CompleteOrthogonalDecomposition<MatrixType>::applyZAdjointOnTheLeftInPlace(
     Rhs& rhs) const {
   const Index cols = this->cols();
   const Index nrhs = rhs.cols();
   const Index rank = this->rank();
-  Matrix<typename MatrixType::Scalar, Dynamic, 1> temp((std::max)(cols, nrhs));
+  Matrix<typename Rhs::Scalar, Dynamic, 1> temp((std::max)(cols, nrhs));
   for (Index k = 0; k < rank; ++k) {
     if (k != rank - 1) {
       rhs.row(k).swap(rhs.row(rank - 1));
     }
     rhs.middleRows(rank - 1, cols - rank + 1)
         .applyHouseholderOnTheLeft(
             matrixQTZ().row(k).tail(cols - rank).adjoint(), zCoeffs()(k),
@@ -487,28 +529,23 @@
 }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template <typename _MatrixType>
 template <typename RhsType, typename DstType>
 void CompleteOrthogonalDecomposition<_MatrixType>::_solve_impl(
     const RhsType& rhs, DstType& dst) const {
-  eigen_assert(rhs.rows() == this->rows());
-
   const Index rank = this->rank();
   if (rank == 0) {
     dst.setZero();
     return;
   }
 
   // Compute c = Q^* * rhs
-  // Note that the matrix Q = H_0^* H_1^*... so its inverse is
-  // Q^* = (H_0 H_1 ...)^T
   typename RhsType::PlainObject c(rhs);
-  c.applyOnTheLeft(
-      householderSequence(matrixQTZ(), hCoeffs()).setLength(rank).transpose());
+  c.applyOnTheLeft(matrixQ().setLength(rank).adjoint());
 
   // Solve T z = c(1:rank, :)
   dst.topRows(rank) = matrixT()
                           .topLeftCorner(rank, rank)
                           .template triangularView<Upper>()
                           .solve(c.topRows(rank));
 
@@ -519,26 +556,62 @@
     dst.bottomRows(cols - rank).setZero();
     applyZAdjointOnTheLeftInPlace(dst);
   }
 
   // Undo permutation to get x = P^{-1} * y.
   dst = colsPermutation() * dst;
 }
+
+template<typename _MatrixType>
+template<bool Conjugate, typename RhsType, typename DstType>
+void CompleteOrthogonalDecomposition<_MatrixType>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const
+{
+  const Index rank = this->rank();
+
+  if (rank == 0) {
+    dst.setZero();
+    return;
+  }
+
+  typename RhsType::PlainObject c(colsPermutation().transpose()*rhs);
+
+  if (rank < cols()) {
+    applyZOnTheLeftInPlace<!Conjugate>(c);
+  }
+
+  matrixT().topLeftCorner(rank, rank)
+           .template triangularView<Upper>()
+           .transpose().template conjugateIf<Conjugate>()
+           .solveInPlace(c.topRows(rank));
+
+  dst.topRows(rank) = c.topRows(rank);
+  dst.bottomRows(rows()-rank).setZero();
+
+  dst.applyOnTheLeft(householderQ().setLength(rank).template conjugateIf<!Conjugate>() );
+}
 #endif
 
 namespace internal {
 
+template<typename MatrixType>
+struct traits<Inverse<CompleteOrthogonalDecomposition<MatrixType> > >
+  : traits<typename Transpose<typename MatrixType::PlainObject>::PlainObject>
+{
+  enum { Flags = 0 };
+};
+
 template<typename DstXprType, typename MatrixType>
 struct Assignment<DstXprType, Inverse<CompleteOrthogonalDecomposition<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename CompleteOrthogonalDecomposition<MatrixType>::Scalar>, Dense2Dense>
 {
   typedef CompleteOrthogonalDecomposition<MatrixType> CodType;
   typedef Inverse<CodType> SrcXprType;
   static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename CodType::Scalar> &)
   {
-    dst = src.nestedExpression().solve(MatrixType::Identity(src.rows(), src.rows()));
+    typedef Matrix<typename CodType::Scalar, CodType::RowsAtCompileTime, CodType::RowsAtCompileTime, 0, CodType::MaxRowsAtCompileTime, CodType::MaxRowsAtCompileTime> IdentityMatrixType;
+    dst = src.nestedExpression().solve(IdentityMatrixType::Identity(src.cols(), src.cols()));
   }
 };
 
 } // end namespace internal
 
 /** \returns the matrix Q as a sequence of householder transformations */
 template <typename MatrixType>
```

### Comparing `chronogram-0.1.7/include/Eigen/src/QR/FullPivHouseholderQR.h` & `chronogram-0.2.0/include/Eigen/src/QR/FullPivHouseholderQR.h`

 * *Files 3% similar despite different names*

```diff
@@ -14,14 +14,17 @@
 namespace Eigen { 
 
 namespace internal {
 
 template<typename _MatrixType> struct traits<FullPivHouseholderQR<_MatrixType> >
  : traits<_MatrixType>
 {
+  typedef MatrixXpr XprKind;
+  typedef SolverStorage StorageKind;
+  typedef int StorageIndex;
   enum { Flags = 0 };
 };
 
 template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType;
 
 template<typename MatrixType>
 struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >
@@ -51,28 +54,27 @@
   * numerical stability. The trade-off is that it is slower than HouseholderQR and ColPivHouseholderQR.
   *
   * This class supports the \link InplaceDecomposition inplace decomposition \endlink mechanism.
   * 
   * \sa MatrixBase::fullPivHouseholderQr()
   */
 template<typename _MatrixType> class FullPivHouseholderQR
+        : public SolverBase<FullPivHouseholderQR<_MatrixType> >
 {
   public:
 
     typedef _MatrixType MatrixType;
+    typedef SolverBase<FullPivHouseholderQR> Base;
+    friend class SolverBase<FullPivHouseholderQR>;
+
+    EIGEN_GENERIC_PUBLIC_INTERFACE(FullPivHouseholderQR)
     enum {
-      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
-      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
     };
-    typedef typename MatrixType::Scalar Scalar;
-    typedef typename MatrixType::RealScalar RealScalar;
-    // FIXME should be int
-    typedef typename MatrixType::StorageIndex StorageIndex;
     typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;
     typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;
     typedef Matrix<StorageIndex, 1,
                    EIGEN_SIZE_MIN_PREFER_DYNAMIC(ColsAtCompileTime,RowsAtCompileTime), RowMajor, 1,
                    EIGEN_SIZE_MIN_PREFER_FIXED(MaxColsAtCompileTime,MaxRowsAtCompileTime)> IntDiagSizeVectorType;
     typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;
     typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;
@@ -152,14 +154,15 @@
         m_temp(matrix.cols()),
         m_isInitialized(false),
         m_usePrescribedThreshold(false)
     {
       computeInPlace();
     }
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
     /** This method finds a solution x to the equation Ax=b, where A is the matrix of which
       * \c *this is the QR decomposition.
       *
       * \param b the right-hand-side of the equation to solve.
       *
       * \returns the exact or least-square solution if the rank is greater or equal to the number of columns of A,
       * and an arbitrary solution otherwise.
@@ -169,19 +172,16 @@
       * \note_about_arbitrary_choice_of_solution
       *
       * Example: \include FullPivHouseholderQR_solve.cpp
       * Output: \verbinclude FullPivHouseholderQR_solve.out
       */
     template<typename Rhs>
     inline const Solve<FullPivHouseholderQR, Rhs>
-    solve(const MatrixBase<Rhs>& b) const
-    {
-      eigen_assert(m_isInitialized && "FullPivHouseholderQR is not initialized.");
-      return Solve<FullPivHouseholderQR, Rhs>(*this, b.derived());
-    }
+    solve(const MatrixBase<Rhs>& b) const;
+    #endif
 
     /** \returns Expression object representing the matrix Q
       */
     MatrixQReturnType matrixQ(void) const;
 
     /** \returns a reference to the matrix where the Householder QR decomposition is stored
       */
@@ -388,30 +388,32 @@
       return m_nonzero_pivots;
     }
 
     /** \returns the absolute value of the biggest pivot, i.e. the biggest
       *          diagonal coefficient of U.
       */
     RealScalar maxPivot() const { return m_maxpivot; }
-    
+
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename RhsType, typename DstType>
-    EIGEN_DEVICE_FUNC
     void _solve_impl(const RhsType &rhs, DstType &dst) const;
+
+    template<bool Conjugate, typename RhsType, typename DstType>
+    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;
     #endif
 
   protected:
-    
+
     static void check_template_parameters()
     {
       EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar);
     }
-    
+
     void computeInPlace();
-    
+
     MatrixType m_qr;
     HCoeffsType m_hCoeffs;
     IntDiagSizeVectorType m_rows_transpositions;
     IntDiagSizeVectorType m_cols_transpositions;
     PermutationType m_cols_permutation;
     RowVectorType m_temp;
     bool m_isInitialized, m_usePrescribedThreshold;
@@ -495,23 +497,23 @@
 
     // if the corner is negligible, then we have less than full rank, and we can finish early
     if(internal::isMuchSmallerThan(biggest_in_corner, biggest, m_precision))
     {
       m_nonzero_pivots = k;
       for(Index i = k; i < size; i++)
       {
-        m_rows_transpositions.coeffRef(i) = i;
-        m_cols_transpositions.coeffRef(i) = i;
+        m_rows_transpositions.coeffRef(i) = internal::convert_index<StorageIndex>(i);
+        m_cols_transpositions.coeffRef(i) = internal::convert_index<StorageIndex>(i);
         m_hCoeffs.coeffRef(i) = Scalar(0);
       }
       break;
     }
 
-    m_rows_transpositions.coeffRef(k) = row_of_biggest_in_corner;
-    m_cols_transpositions.coeffRef(k) = col_of_biggest_in_corner;
+    m_rows_transpositions.coeffRef(k) = internal::convert_index<StorageIndex>(row_of_biggest_in_corner);
+    m_cols_transpositions.coeffRef(k) = internal::convert_index<StorageIndex>(col_of_biggest_in_corner);
     if(k != row_of_biggest_in_corner) {
       m_qr.row(k).tail(cols-k).swap(m_qr.row(row_of_biggest_in_corner).tail(cols-k));
       ++number_of_transpositions;
     }
     if(k != col_of_biggest_in_corner) {
       m_qr.col(k).swap(m_qr.col(col_of_biggest_in_corner));
       ++number_of_transpositions;
@@ -537,28 +539,27 @@
 }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template<typename _MatrixType>
 template<typename RhsType, typename DstType>
 void FullPivHouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const
 {
-  eigen_assert(rhs.rows() == rows());
   const Index l_rank = rank();
 
   // FIXME introduce nonzeroPivots() and use it here. and more generally,
   // make the same improvements in this dec as in FullPivLU.
   if(l_rank==0)
   {
     dst.setZero();
     return;
   }
 
   typename RhsType::PlainObject c(rhs);
 
-  Matrix<Scalar,1,RhsType::ColsAtCompileTime> temp(rhs.cols());
+  Matrix<typename RhsType::Scalar,1,RhsType::ColsAtCompileTime> temp(rhs.cols());
   for (Index k = 0; k < l_rank; ++k)
   {
     Index remainingSize = rows()-k;
     c.row(k).swap(c.row(m_rows_transpositions.coeff(k)));
     c.bottomRightCorner(remainingSize, rhs.cols())
       .applyHouseholderOnTheLeft(m_qr.col(k).tail(remainingSize-1),
                                m_hCoeffs.coeff(k), &temp.coeffRef(0));
@@ -567,14 +568,50 @@
   m_qr.topLeftCorner(l_rank, l_rank)
       .template triangularView<Upper>()
       .solveInPlace(c.topRows(l_rank));
 
   for(Index i = 0; i < l_rank; ++i) dst.row(m_cols_permutation.indices().coeff(i)) = c.row(i);
   for(Index i = l_rank; i < cols(); ++i) dst.row(m_cols_permutation.indices().coeff(i)).setZero();
 }
+
+template<typename _MatrixType>
+template<bool Conjugate, typename RhsType, typename DstType>
+void FullPivHouseholderQR<_MatrixType>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const
+{
+  const Index l_rank = rank();
+
+  if(l_rank == 0)
+  {
+    dst.setZero();
+    return;
+  }
+
+  typename RhsType::PlainObject c(m_cols_permutation.transpose()*rhs);
+
+  m_qr.topLeftCorner(l_rank, l_rank)
+         .template triangularView<Upper>()
+         .transpose().template conjugateIf<Conjugate>()
+         .solveInPlace(c.topRows(l_rank));
+
+  dst.topRows(l_rank) = c.topRows(l_rank);
+  dst.bottomRows(rows()-l_rank).setZero();
+
+  Matrix<Scalar, 1, DstType::ColsAtCompileTime> temp(dst.cols());
+  const Index size = (std::min)(rows(), cols());
+  for (Index k = size-1; k >= 0; --k)
+  {
+    Index remainingSize = rows()-k;
+
+    dst.bottomRightCorner(remainingSize, dst.cols())
+       .applyHouseholderOnTheLeft(m_qr.col(k).tail(remainingSize-1).template conjugateIf<!Conjugate>(),
+                                  m_hCoeffs.template conjugateIf<Conjugate>().coeff(k), &temp.coeffRef(0));
+
+    dst.row(k).swap(dst.row(m_rows_transpositions.coeff(k)));
+  }
+}
 #endif
 
 namespace internal {
   
 template<typename DstXprType, typename MatrixType>
 struct Assignment<DstXprType, Inverse<FullPivHouseholderQR<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename FullPivHouseholderQR<MatrixType>::Scalar>, Dense2Dense>
 {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/QR/HouseholderQR.h` & `chronogram-0.2.0/include/Eigen/src/QR/HouseholderQR.h`

 * *Files 4% similar despite different names*

```diff
@@ -10,14 +10,26 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_QR_H
 #define EIGEN_QR_H
 
 namespace Eigen { 
 
+namespace internal {
+template<typename _MatrixType> struct traits<HouseholderQR<_MatrixType> >
+ : traits<_MatrixType>
+{
+  typedef MatrixXpr XprKind;
+  typedef SolverStorage StorageKind;
+  typedef int StorageIndex;
+  enum { Flags = 0 };
+};
+
+} // end namespace internal
+
 /** \ingroup QR_Module
   *
   *
   * \class HouseholderQR
   *
   * \brief Householder QR decomposition of a matrix
   *
@@ -38,28 +50,27 @@
   * FullPivHouseholderQR or ColPivHouseholderQR.
   *
   * This class supports the \link InplaceDecomposition inplace decomposition \endlink mechanism.
   *
   * \sa MatrixBase::householderQr()
   */
 template<typename _MatrixType> class HouseholderQR
+        : public SolverBase<HouseholderQR<_MatrixType> >
 {
   public:
 
     typedef _MatrixType MatrixType;
+    typedef SolverBase<HouseholderQR> Base;
+    friend class SolverBase<HouseholderQR>;
+
+    EIGEN_GENERIC_PUBLIC_INTERFACE(HouseholderQR)
     enum {
-      RowsAtCompileTime = MatrixType::RowsAtCompileTime,
-      ColsAtCompileTime = MatrixType::ColsAtCompileTime,
       MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
     };
-    typedef typename MatrixType::Scalar Scalar;
-    typedef typename MatrixType::RealScalar RealScalar;
-    // FIXME should be int
-    typedef typename MatrixType::StorageIndex StorageIndex;
     typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;
     typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;
     typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;
     typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;
 
     /**
       * \brief Default Constructor.
@@ -117,14 +128,15 @@
         m_hCoeffs((std::min)(matrix.rows(),matrix.cols())),
         m_temp(matrix.cols()),
         m_isInitialized(false)
     {
       computeInPlace();
     }
 
+    #ifdef EIGEN_PARSED_BY_DOXYGEN
     /** This method finds a solution x to the equation Ax=b, where A is the matrix of which
       * *this is the QR decomposition, if any exists.
       *
       * \param b the right-hand-side of the equation to solve.
       *
       * \returns a solution.
       *
@@ -133,19 +145,16 @@
       * \note_about_arbitrary_choice_of_solution
       *
       * Example: \include HouseholderQR_solve.cpp
       * Output: \verbinclude HouseholderQR_solve.out
       */
     template<typename Rhs>
     inline const Solve<HouseholderQR, Rhs>
-    solve(const MatrixBase<Rhs>& b) const
-    {
-      eigen_assert(m_isInitialized && "HouseholderQR is not initialized.");
-      return Solve<HouseholderQR, Rhs>(*this, b.derived());
-    }
+    solve(const MatrixBase<Rhs>& b) const;
+    #endif
 
     /** This method returns an expression of the unitary matrix Q as a sequence of Householder transformations.
       *
       * The returned expression can directly be used to perform matrix products. It can also be assigned to a dense Matrix object.
       * Here is an example showing how to recover the full or thin matrix Q, as well as how to perform matrix products using operator*:
       *
       * Example: \include HouseholderQR_householderQ.cpp
@@ -200,36 +209,38 @@
       *
       * \sa absDeterminant(), MatrixBase::determinant()
       */
     typename MatrixType::RealScalar logAbsDeterminant() const;
 
     inline Index rows() const { return m_qr.rows(); }
     inline Index cols() const { return m_qr.cols(); }
-    
+
     /** \returns a const reference to the vector of Householder coefficients used to represent the factor \c Q.
       * 
       * For advanced uses only.
       */
     const HCoeffsType& hCoeffs() const { return m_hCoeffs; }
-    
+
     #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename RhsType, typename DstType>
-    EIGEN_DEVICE_FUNC
     void _solve_impl(const RhsType &rhs, DstType &dst) const;
+
+    template<bool Conjugate, typename RhsType, typename DstType>
+    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;
     #endif
 
   protected:
-    
+
     static void check_template_parameters()
     {
       EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar);
     }
 
     void computeInPlace();
-    
+
     MatrixType m_qr;
     HCoeffsType m_hCoeffs;
     RowVectorType m_temp;
     bool m_isInitialized;
 };
 
 template<typename MatrixType>
@@ -288,15 +299,15 @@
 
 /** \internal */
 template<typename MatrixQR, typename HCoeffs,
   typename MatrixQRScalar = typename MatrixQR::Scalar,
   bool InnerStrideIsOne = (MatrixQR::InnerStrideAtCompileTime == 1 && HCoeffs::InnerStrideAtCompileTime == 1)>
 struct householder_qr_inplace_blocked
 {
-  // This is specialized for MKL-supported Scalar types in HouseholderQR_MKL.h
+  // This is specialized for LAPACK-supported Scalar types in HouseholderQR_LAPACKE.h
   static void run(MatrixQR& mat, HCoeffs& hCoeffs, Index maxBlockSize=32,
       typename MatrixQR::Scalar* tempData = 0)
   {
     typedef typename MatrixQR::Scalar Scalar;
     typedef Block<MatrixQR,Dynamic,Dynamic> BlockType;
 
     Index rows = mat.rows();
@@ -346,31 +357,45 @@
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template<typename _MatrixType>
 template<typename RhsType, typename DstType>
 void HouseholderQR<_MatrixType>::_solve_impl(const RhsType &rhs, DstType &dst) const
 {
   const Index rank = (std::min)(rows(), cols());
-  eigen_assert(rhs.rows() == rows());
 
   typename RhsType::PlainObject c(rhs);
 
-  // Note that the matrix Q = H_0^* H_1^*... so its inverse is Q^* = (H_0 H_1 ...)^T
-  c.applyOnTheLeft(householderSequence(
-    m_qr.leftCols(rank),
-    m_hCoeffs.head(rank)).transpose()
-  );
+  c.applyOnTheLeft(householderQ().setLength(rank).adjoint() );
 
   m_qr.topLeftCorner(rank, rank)
       .template triangularView<Upper>()
       .solveInPlace(c.topRows(rank));
 
   dst.topRows(rank) = c.topRows(rank);
   dst.bottomRows(cols()-rank).setZero();
 }
+
+template<typename _MatrixType>
+template<bool Conjugate, typename RhsType, typename DstType>
+void HouseholderQR<_MatrixType>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const
+{
+  const Index rank = (std::min)(rows(), cols());
+
+  typename RhsType::PlainObject c(rhs);
+
+  m_qr.topLeftCorner(rank, rank)
+      .template triangularView<Upper>()
+      .transpose().template conjugateIf<Conjugate>()
+      .solveInPlace(c.topRows(rank));
+
+  dst.topRows(rank) = c.topRows(rank);
+  dst.bottomRows(rows()-rank).setZero();
+
+  dst.applyOnTheLeft(householderQ().setLength(rank).template conjugateIf<!Conjugate>() );
+}
 #endif
 
 /** Performs the QR factorization of the given matrix \a matrix. The result of
   * the factorization is stored into \c *this, and a reference to \c *this
   * is returned.
   *
   * \sa class HouseholderQR, HouseholderQR(const MatrixType&)
```

### Comparing `chronogram-0.1.7/include/Eigen/src/QR/HouseholderQR_LAPACKE.h` & `chronogram-0.2.0/include/Eigen/src/QR/HouseholderQR_LAPACKE.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h` & `chronogram-0.2.0/include/Eigen/src/SPQRSupport/SuiteSparseQRSupport.h`

 * *Files 8% similar despite different names*

```diff
@@ -70,21 +70,43 @@
     typedef Map<PermutationMatrix<Dynamic, Dynamic, StorageIndex> > PermutationType;
     enum {
       ColsAtCompileTime = Dynamic,
       MaxColsAtCompileTime = Dynamic
     };
   public:
     SPQR() 
-      : m_ordering(SPQR_ORDERING_DEFAULT), m_allow_tol(SPQR_DEFAULT_TOL), m_tolerance (NumTraits<Scalar>::epsilon()), m_useDefaultThreshold(true)
+      : m_analysisIsOk(false),
+        m_factorizationIsOk(false),
+        m_isRUpToDate(false),
+        m_ordering(SPQR_ORDERING_DEFAULT),
+        m_allow_tol(SPQR_DEFAULT_TOL),
+        m_tolerance (NumTraits<Scalar>::epsilon()),
+        m_cR(0),
+        m_E(0),
+        m_H(0),
+        m_HPinv(0),
+        m_HTau(0),
+        m_useDefaultThreshold(true)
     { 
       cholmod_l_start(&m_cc);
     }
     
     explicit SPQR(const _MatrixType& matrix)
-    : m_ordering(SPQR_ORDERING_DEFAULT), m_allow_tol(SPQR_DEFAULT_TOL), m_tolerance (NumTraits<Scalar>::epsilon()), m_useDefaultThreshold(true)
+      : m_analysisIsOk(false),
+        m_factorizationIsOk(false),
+        m_isRUpToDate(false),
+        m_ordering(SPQR_ORDERING_DEFAULT),
+        m_allow_tol(SPQR_DEFAULT_TOL),
+        m_tolerance (NumTraits<Scalar>::epsilon()),
+        m_cR(0),
+        m_E(0),
+        m_H(0),
+        m_HPinv(0),
+        m_HTau(0),
+        m_useDefaultThreshold(true)
     {
       cholmod_l_start(&m_cc);
       compute(matrix);
     }
     
     ~SPQR()
     {
@@ -216,15 +238,15 @@
     
     /** \returns a pointer to the SPQR workspace */
     cholmod_common *cholmodCommon() const { return &m_cc; }
     
     
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the sparse QR can not be computed
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "Decomposition is not initialized.");
       return m_info;
     }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SVD/BDCSVD.h` & `chronogram-0.2.0/include/Eigen/src/SVD/BDCSVD.h`

 * *Files 7% similar despite different names*

```diff
@@ -18,26 +18,32 @@
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_BDCSVD_H
 #define EIGEN_BDCSVD_H
 // #define EIGEN_BDCSVD_DEBUG_VERBOSE
 // #define EIGEN_BDCSVD_SANITY_CHECKS
 
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+#undef eigen_internal_assert
+#define eigen_internal_assert(X) assert(X);
+#endif
+
 namespace Eigen {
 
 #ifdef EIGEN_BDCSVD_DEBUG_VERBOSE
 IOFormat bdcsvdfmt(8, 0, ", ", "\n", "  [", "]");
 #endif
   
 template<typename _MatrixType> class BDCSVD;
 
 namespace internal {
 
 template<typename _MatrixType> 
 struct traits<BDCSVD<_MatrixType> >
+        : traits<_MatrixType>
 {
   typedef _MatrixType MatrixType;
 };  
 
 } // end namespace internal
   
   
@@ -53,15 +59,15 @@
  * This class first reduces the input matrix to bi-diagonal form using class UpperBidiagonalization,
  * and then performs a divide-and-conquer diagonalization. Small blocks are diagonalized using class JacobiSVD.
  * You can control the switching size with the setSwitchSize() method, default is 16.
  * For small matrice (<16), it is thus preferable to directly use JacobiSVD. For larger ones, BDCSVD is highly
  * recommended and can several order of magnitude faster.
  *
  * \warning this algorithm is unlikely to provide accurate result when compiled with unsafe math optimizations.
- * For instance, this concerns Intel's compiler (ICC), which perfroms such optimization by default unless
+ * For instance, this concerns Intel's compiler (ICC), which performs such optimization by default unless
  * you compile with the \c -fp-model \c precise option. Likewise, the \c -ffast-math option of GCC or clang will
  * significantly degrade the accuracy.
  *
  * \sa class JacobiSVD
  */
 template<typename _MatrixType> 
 class BDCSVD : public SVDBase<BDCSVD<_MatrixType> >
@@ -101,15 +107,15 @@
   typedef Ref<ArrayXi> IndicesRef;
 
   /** \brief Default Constructor.
    *
    * The default constructor is useful in cases in which the user intends to
    * perform decompositions via BDCSVD::compute(const MatrixType&).
    */
-  BDCSVD() : m_algoswap(16), m_numIters(0)
+  BDCSVD() : m_algoswap(16), m_isTranspose(false), m_compU(false), m_compV(false), m_numIters(0)
   {}
 
 
   /** \brief Default Constructor with memory preallocation
    *
    * Like the default constructor but with preallocation of the internal data
    * according to the specified problem size.
@@ -198,25 +204,26 @@
   using Base::m_diagSize;
   using Base::m_computeFullU;
   using Base::m_computeFullV;
   using Base::m_computeThinU;
   using Base::m_computeThinV;
   using Base::m_matrixU;
   using Base::m_matrixV;
+  using Base::m_info;
   using Base::m_isInitialized;
   using Base::m_nonzeroSingularValues;
 
 public:  
   int m_numIters;
 }; //end class BDCSVD
 
 
 // Method to allocate and initialize matrix and attributes
 template<typename MatrixType>
-void BDCSVD<MatrixType>::allocate(Index rows, Index cols, unsigned int computationOptions)
+void BDCSVD<MatrixType>::allocate(Eigen::Index rows, Eigen::Index cols, unsigned int computationOptions)
 {
   m_isTranspose = (cols > rows);
 
   if (Base::allocate(rows, cols, computationOptions))
     return;
   
   m_computed = MatrixXr::Zero(m_diagSize + 1, m_diagSize );
@@ -246,24 +253,33 @@
   const RealScalar considerZero = (std::numeric_limits<RealScalar>::min)();
   
   //**** step -1 - If the problem is too small, directly falls back to JacobiSVD and return
   if(matrix.cols() < m_algoswap)
   {
     // FIXME this line involves temporaries
     JacobiSVD<MatrixType> jsvd(matrix,computationOptions);
-    if(computeU()) m_matrixU = jsvd.matrixU();
-    if(computeV()) m_matrixV = jsvd.matrixV();
-    m_singularValues = jsvd.singularValues();
-    m_nonzeroSingularValues = jsvd.nonzeroSingularValues();
     m_isInitialized = true;
+    m_info = jsvd.info();
+    if (m_info == Success || m_info == NoConvergence) {
+      if(computeU()) m_matrixU = jsvd.matrixU();
+      if(computeV()) m_matrixV = jsvd.matrixV();
+      m_singularValues = jsvd.singularValues();
+      m_nonzeroSingularValues = jsvd.nonzeroSingularValues();
+    }
     return *this;
   }
   
   //**** step 0 - Copy the input matrix and apply scaling to reduce over/under-flows
-  RealScalar scale = matrix.cwiseAbs().maxCoeff();
+  RealScalar scale = matrix.cwiseAbs().template maxCoeff<PropagateNaN>();
+  if (!(numext::isfinite)(scale)) {
+    m_isInitialized = true;
+    m_info = InvalidInput;
+    return *this;
+  }
+
   if(scale==Literal(0)) scale = Literal(1);
   MatrixX copy;
   if (m_isTranspose) copy = matrix.adjoint()/scale;
   else               copy = matrix/scale;
   
   //**** step 1 - Bidiagonalization
   // FIXME this line involves temporaries
@@ -272,15 +288,19 @@
   //**** step 2 - Divide & Conquer
   m_naiveU.setZero();
   m_naiveV.setZero();
   // FIXME this line involves a temporary matrix
   m_computed.topRows(m_diagSize) = bid.bidiagonal().toDenseMatrix().transpose();
   m_computed.template bottomRows<1>().setZero();
   divide(0, m_diagSize - 1, 0, 0, 0);
-
+  if (m_info != Success && m_info != NoConvergence) {
+    m_isInitialized = true;
+    return *this;
+  }
+    
   //**** step 3 - Copy singular values and vectors
   for (int i=0; i<m_diagSize; i++)
   {
     RealScalar a = abs(m_computed.coeff(i, i));
     m_singularValues.coeffRef(i) = a * scale;
     if (a<considerZero)
     {
@@ -384,15 +404,15 @@
 //@param lastCol : The Index of the last column of the submatrix of m_computed and for m_naiveU; 
 // lastCol + 1 - firstCol is the size of the submatrix.
 //@param firstRowW : The Index of the first row of the matrix W that we are to change. (see the reference paper section 1 for more information on W)
 //@param firstRowW : Same as firstRowW with the column.
 //@param shift : Each time one takes the left submatrix, one must add 1 to the shift. Why? Because! We actually want the last column of the U submatrix 
 // to become the first column (*coeff) and to shift all the other columns to the right. There are more details on the reference paper.
 template<typename MatrixType>
-void BDCSVD<MatrixType>::divide (Index firstCol, Index lastCol, Index firstRowW, Index firstColW, Index shift)
+void BDCSVD<MatrixType>::divide(Eigen::Index firstCol, Eigen::Index lastCol, Eigen::Index firstRowW, Eigen::Index firstColW, Eigen::Index shift)
 {
   // requires rows = cols + 1;
   using std::pow;
   using std::sqrt;
   using std::abs;
   const Index n = lastCol - firstCol + 1;
   const Index k = n/2;
@@ -404,14 +424,16 @@
   VectorType l, f;
   // We use the other algorithm which is more efficient for small 
   // matrices.
   if (n < m_algoswap)
   {
     // FIXME this line involves temporaries
     JacobiSVD<MatrixXr> b(m_computed.block(firstCol, firstCol, n + 1, n), ComputeFullU | (m_compV ? ComputeFullV : 0));
+    m_info = b.info();
+    if (m_info != Success && m_info != NoConvergence) return;
     if (m_compU)
       m_naiveU.block(firstCol, firstCol, n + 1, n + 1).real() = b.matrixU();
     else 
     {
       m_naiveU.row(0).segment(firstCol, n + 1).real() = b.matrixU().row(0);
       m_naiveU.row(1).segment(firstCol, n + 1).real() = b.matrixU().row(n);
     }
@@ -423,15 +445,17 @@
   // We use the divide and conquer algorithm
   alphaK =  m_computed(firstCol + k, firstCol + k);
   betaK = m_computed(firstCol + k + 1, firstCol + k);
   // The divide must be done in that order in order to have good results. Divide change the data inside the submatrices
   // and the divide of the right submatrice reads one column of the left submatrice. That's why we need to treat the 
   // right submatrix before the left one. 
   divide(k + 1 + firstCol, lastCol, k + 1 + firstRowW, k + 1 + firstColW, shift);
+  if (m_info != Success && m_info != NoConvergence) return;
   divide(firstCol, k - 1 + firstCol, firstRowW, firstColW + 1, shift + 1);
+  if (m_info != Success && m_info != NoConvergence) return;
 
   if (m_compU)
   {
     lambda = m_naiveU(firstCol + k, firstCol + k);
     phi = m_naiveU(firstCol + k + 1, lastCol + 1);
   } 
   else 
@@ -564,15 +588,15 @@
 // order except for possibly the (0,0) entry. The computed SVD is stored U, singVals and V, except
 // that if m_compV is false, then V is not computed. Singular values are sorted in decreasing order.
 //
 // TODO Opportunities for optimization: better root finding algo, better stopping criterion, better
 // handling of round-off errors, be consistent in ordering
 // For instance, to solve the secular equation using FMM, see http://www.stat.uchicago.edu/~lekheng/courses/302/classics/greengard-rokhlin.pdf
 template <typename MatrixType>
-void BDCSVD<MatrixType>::computeSVDofM(Index firstCol, Index n, MatrixXr& U, VectorType& singVals, MatrixXr& V)
+void BDCSVD<MatrixType>::computeSVDofM(Eigen::Index firstCol, Eigen::Index n, MatrixXr& U, VectorType& singVals, MatrixXr& V)
 {
   const RealScalar considerZero = (std::numeric_limits<RealScalar>::min)();
   using std::abs;
   ArrayRef col0 = m_computed.col(firstCol).segment(firstCol, n);
   m_workspace.head(n) =  m_computed.block(firstCol, firstCol, n, n).diagonal();
   ArrayRef diag = m_workspace.head(n);
   diag(0) = Literal(0);
@@ -587,15 +611,15 @@
     std::cout << "\n\nHAS NAN\n\n";
 #endif
   
   // Many singular values might have been deflated, the zero ones have been moved to the end,
   // but others are interleaved and we must ignore them at this stage.
   // To this end, let's compute a permutation skipping them:
   Index actual_n = n;
-  while(actual_n>1 && diag(actual_n-1)==Literal(0)) --actual_n;
+  while(actual_n>1 && diag(actual_n-1)==Literal(0)) {--actual_n; eigen_internal_assert(col0(actual_n)==Literal(0)); }
   Index m = 0; // size of the deflated problem
   for(Index k=0;k<actual_n;++k)
     if(abs(col0(k))>considerZero)
       m_workspaceI(m++) = k;
   Map<ArrayXi> perm(m_workspaceI.data(),m);
   
   Map<ArrayXr> shifts(m_workspace.data()+1*n, n);
@@ -614,21 +638,19 @@
 #ifdef EIGEN_BDCSVD_DEBUG_VERBOSE
   std::cout << "  j:        " << (m_computed.block(firstCol, firstCol, n, n)).jacobiSvd().singularValues().transpose().reverse() << "\n\n";
   std::cout << "  sing-val: " << singVals.transpose() << "\n";
   std::cout << "  mu:       " << mus.transpose() << "\n";
   std::cout << "  shift:    " << shifts.transpose() << "\n";
   
   {
-    Index actual_n = n;
-    while(actual_n>1 && abs(col0(actual_n-1))<considerZero) --actual_n;
     std::cout << "\n\n    mus:    " << mus.head(actual_n).transpose() << "\n\n";
     std::cout << "    check1 (expect0) : " << ((singVals.array()-(shifts+mus)) / singVals.array()).head(actual_n).transpose() << "\n\n";
+    assert((((singVals.array()-(shifts+mus)) / singVals.array()).head(actual_n) >= 0).all());
     std::cout << "    check2 (>0)      : " << ((singVals.array()-diag) / singVals.array()).head(actual_n).transpose() << "\n\n";
-    std::cout << "    check3 (>0)      : " << ((diag.segment(1,actual_n-1)-singVals.head(actual_n-1).array()) / singVals.head(actual_n-1).array()).transpose() << "\n\n\n";
-    std::cout << "    check4 (>0)      : " << ((singVals.segment(1,actual_n-1)-singVals.head(actual_n-1))).transpose() << "\n\n\n";
+    assert((((singVals.array()-diag) / singVals.array()).head(actual_n) >= 0).all());
   }
 #endif
   
 #ifdef EIGEN_BDCSVD_SANITY_CHECKS
   assert(singVals.allFinite());
   assert(mus.allFinite());
   assert(shifts.allFinite());
@@ -648,35 +670,44 @@
   
 #ifdef  EIGEN_BDCSVD_DEBUG_VERBOSE
   std::cout << "U^T U: " << (U.transpose() * U - MatrixXr(MatrixXr::Identity(U.cols(),U.cols()))).norm() << "\n";
   std::cout << "V^T V: " << (V.transpose() * V - MatrixXr(MatrixXr::Identity(V.cols(),V.cols()))).norm() << "\n";
 #endif
   
 #ifdef EIGEN_BDCSVD_SANITY_CHECKS
-  assert(U.allFinite());
-  assert(V.allFinite());
-  assert((U.transpose() * U - MatrixXr(MatrixXr::Identity(U.cols(),U.cols()))).norm() < 1e-14 * n);
-  assert((V.transpose() * V - MatrixXr(MatrixXr::Identity(V.cols(),V.cols()))).norm() < 1e-14 * n);
   assert(m_naiveU.allFinite());
   assert(m_naiveV.allFinite());
   assert(m_computed.allFinite());
+  assert(U.allFinite());
+  assert(V.allFinite());
+//   assert((U.transpose() * U - MatrixXr(MatrixXr::Identity(U.cols(),U.cols()))).norm() < 100*NumTraits<RealScalar>::epsilon() * n);
+//   assert((V.transpose() * V - MatrixXr(MatrixXr::Identity(V.cols(),V.cols()))).norm() < 100*NumTraits<RealScalar>::epsilon() * n);
 #endif
   
   // Because of deflation, the singular values might not be completely sorted.
   // Fortunately, reordering them is a O(n) problem
   for(Index i=0; i<actual_n-1; ++i)
   {
     if(singVals(i)>singVals(i+1))
     {
       using std::swap;
       swap(singVals(i),singVals(i+1));
       U.col(i).swap(U.col(i+1));
       if(m_compV) V.col(i).swap(V.col(i+1));
     }
   }
+
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+  {
+    bool singular_values_sorted = (((singVals.segment(1,actual_n-1)-singVals.head(actual_n-1))).array() >= 0).all();
+    if(!singular_values_sorted)
+      std::cout << "Singular values are not sorted: " << singVals.segment(1,actual_n).transpose() << "\n";
+    assert(singular_values_sorted);
+  }
+#endif
   
   // Reverse order so that singular values in increased order
   // Because of deflation, the zeros singular-values are already at the end
   singVals.head(actual_n).reverseInPlace();
   U.leftCols(actual_n).rowwise().reverseInPlace();
   if (m_compV) V.leftCols(actual_n).rowwise().reverseInPlace();
   
@@ -745,33 +776,51 @@
       right = diag(l);
     }
 
     // first decide whether it's closer to the left end or the right end
     RealScalar mid = left + (right-left) / Literal(2);
     RealScalar fMid = secularEq(mid, col0, diag, perm, diag, Literal(0));
 #ifdef EIGEN_BDCSVD_DEBUG_VERBOSE
-    std::cout << right-left << "\n";
-    std::cout << "fMid = " << fMid << " " << secularEq(mid-left, col0, diag, perm, diag-left, left) << " " << secularEq(mid-right, col0, diag, perm, diag-right, right)   << "\n";
-    std::cout << "     = " << secularEq(0.1*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.2*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.3*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.4*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.49*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.5*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.51*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.6*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.7*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.8*(left+right), col0, diag, perm, diag, 0)
-              << " "       << secularEq(0.9*(left+right), col0, diag, perm, diag, 0) << "\n";
+    std::cout << "right-left = " << right-left << "\n";
+//     std::cout << "fMid = " << fMid << " " << secularEq(mid-left, col0, diag, perm, ArrayXr(diag-left), left)
+//                            << " " << secularEq(mid-right, col0, diag, perm, ArrayXr(diag-right), right)   << "\n";
+    std::cout << "     = " << secularEq(left+RealScalar(0.000001)*(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.1)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.2)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.3)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.4)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.49)    *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.5)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.51)    *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.6)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.7)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.8)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.9)     *(right-left), col0, diag, perm, diag, 0)
+              << " "       << secularEq(left+RealScalar(0.999999)*(right-left), col0, diag, perm, diag, 0) << "\n";
 #endif
     RealScalar shift = (k == actual_n-1 || fMid > Literal(0)) ? left : right;
     
     // measure everything relative to shift
     Map<ArrayXr> diagShifted(m_workspace.data()+4*n, n);
     diagShifted = diag - shift;
+
+    if(k!=actual_n-1)
+    {
+      // check that after the shift, f(mid) is still negative:
+      RealScalar midShifted = (right - left) / RealScalar(2);
+      if(shift==right)
+        midShifted = -midShifted;
+      RealScalar fMidShifted = secularEq(midShifted, col0, diag, perm, diagShifted, shift);
+      if(fMidShifted>0)
+      {
+        // fMid was erroneous, fix it:
+        shift =  fMidShifted > Literal(0) ? left : right;
+        diagShifted = diag - shift;
+      }
+    }
     
     // initial guess
     RealScalar muPrev, muCur;
     if (shift == left)
     {
       muPrev = (right - left) * RealScalar(0.1);
       if (k == actual_n-1) muCur = right - left;
@@ -800,21 +849,24 @@
 
       // Find a and b such that the function f(mu) = a / mu + b matches the current and previous samples.
       RealScalar a = (fCur - fPrev) / (Literal(1)/muCur - Literal(1)/muPrev);
       RealScalar b = fCur - a / muCur;
       // And find mu such that f(mu)==0:
       RealScalar muZero = -a/b;
       RealScalar fZero = secularEq(muZero, col0, diag, perm, diagShifted, shift);
+
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+      assert((numext::isfinite)(fZero));
+#endif
       
       muPrev = muCur;
       fPrev = fCur;
       muCur = muZero;
       fCur = fZero;
       
-      
       if (shift == left  && (muCur < Literal(0) || muCur > right - left)) useBisection = true;
       if (shift == right && (muCur < -(right - left) || muCur > Literal(0))) useBisection = true;
       if (abs(fCur)>abs(fPrev)) useBisection = true;
     }
 
     // fall back on bisection method if rational interpolation did not work
     if (useBisection)
@@ -839,52 +891,90 @@
       {
         leftShifted = -(right - left) * RealScalar(0.51);
         if(k+1<n)
           rightShifted = -numext::maxi<RealScalar>( (std::numeric_limits<RealScalar>::min)(), abs(col0(k+1)) / sqrt((std::numeric_limits<RealScalar>::max)()) );
         else
           rightShifted = -(std::numeric_limits<RealScalar>::min)();
       }
-      
+
       RealScalar fLeft = secularEq(leftShifted, col0, diag, perm, diagShifted, shift);
+      eigen_internal_assert(fLeft<Literal(0));
 
-#if defined EIGEN_INTERNAL_DEBUGGING || defined EIGEN_BDCSVD_DEBUG_VERBOSE
+#if defined EIGEN_INTERNAL_DEBUGGING || defined EIGEN_BDCSVD_SANITY_CHECKS
       RealScalar fRight = secularEq(rightShifted, col0, diag, perm, diagShifted, shift);
 #endif
 
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+      if(!(numext::isfinite)(fLeft))
+        std::cout << "f(" << leftShifted << ") =" << fLeft << " ; " << left << " " << shift << " " << right << "\n";
+      assert((numext::isfinite)(fLeft));
+
+      if(!(numext::isfinite)(fRight))
+        std::cout << "f(" << rightShifted << ") =" << fRight << " ; " << left << " " << shift << " " << right << "\n";
+      // assert((numext::isfinite)(fRight));
+#endif
+    
 #ifdef  EIGEN_BDCSVD_DEBUG_VERBOSE
       if(!(fLeft * fRight<0))
       {
-        std::cout << "fLeft: " << leftShifted << " - " << diagShifted.head(10).transpose()  << "\n ; " << bool(left==shift) << " " << (left-shift) << "\n";
-        std::cout << k << " : " <<  fLeft << " * " << fRight << " == " << fLeft * fRight << "  ;  " << left << " - " << right << " -> " <<  leftShifted << " " << rightShifted << "   shift=" << shift << "\n";
+        std::cout << "f(leftShifted) using  leftShifted=" << leftShifted << " ;  diagShifted(1:10):" << diagShifted.head(10).transpose()  << "\n ; "
+                  << "left==shift=" << bool(left==shift) << " ; left-shift = " << (left-shift) << "\n";
+        std::cout << "k=" << k << ", " <<  fLeft << " * " << fRight << " == " << fLeft * fRight << "  ;  "
+                  << "[" << left << " .. " << right << "] -> [" << leftShifted << " " << rightShifted << "], shift=" << shift
+                  << " ,  f(right)=" << secularEq(0,     col0, diag, perm, diagShifted, shift)
+                           << " == " << secularEq(right, col0, diag, perm, diag, 0) << " == " << fRight << "\n";
       }
 #endif
       eigen_internal_assert(fLeft * fRight < Literal(0));
-      
-      while (rightShifted - leftShifted > Literal(2) * NumTraits<RealScalar>::epsilon() * numext::maxi<RealScalar>(abs(leftShifted), abs(rightShifted)))
+
+      if(fLeft<Literal(0))
       {
-        RealScalar midShifted = (leftShifted + rightShifted) / Literal(2);
-        fMid = secularEq(midShifted, col0, diag, perm, diagShifted, shift);
-        if (fLeft * fMid < Literal(0))
+        while (rightShifted - leftShifted > Literal(2) * NumTraits<RealScalar>::epsilon() * numext::maxi<RealScalar>(abs(leftShifted), abs(rightShifted)))
         {
-          rightShifted = midShifted;
-        }
-        else
-        {
-          leftShifted = midShifted;
-          fLeft = fMid;
+          RealScalar midShifted = (leftShifted + rightShifted) / Literal(2);
+          fMid = secularEq(midShifted, col0, diag, perm, diagShifted, shift);
+          eigen_internal_assert((numext::isfinite)(fMid));
+
+          if (fLeft * fMid < Literal(0))
+          {
+            rightShifted = midShifted;
+          }
+          else
+          {
+            leftShifted = midShifted;
+            fLeft = fMid;
+          }
         }
+        muCur = (leftShifted + rightShifted) / Literal(2);
+      }
+      else 
+      {
+        // We have a problem as shifting on the left or right give either a positive or negative value
+        // at the middle of [left,right]...
+        // Instead fo abbording or entering an infinite loop,
+        // let's just use the middle as the estimated zero-crossing:
+        muCur = (right - left) * RealScalar(0.5);
+        if(shift == right)
+          muCur = -muCur;
       }
-
-      muCur = (leftShifted + rightShifted) / Literal(2);
     }
       
     singVals[k] = shift + muCur;
     shifts[k] = shift;
     mus[k] = muCur;
 
+#ifdef  EIGEN_BDCSVD_DEBUG_VERBOSE
+    if(k+1<n)
+      std::cout << "found " << singVals[k] << " == " << shift << " + " << muCur << " from " << diag(k) << " .. "  << diag(k+1) << "\n";
+#endif
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+    assert(k==0 || singVals[k]>=singVals[k-1]);
+    assert(singVals[k]>=diag(k));
+#endif
+
     // perturb singular value slightly if it equals diagonal entry to avoid division by zero later
     // (deflation is supposed to avoid this from happening)
     // - this does no seem to be necessary anymore -
 //     if (singVals[k] == left) singVals[k] *= 1 + NumTraits<RealScalar>::epsilon();
 //     if (singVals[k] == right) singVals[k] *= 1 - NumTraits<RealScalar>::epsilon();
   }
 }
@@ -900,45 +990,76 @@
   Index n = col0.size();
   Index m = perm.size();
   if(m==0)
   {
     zhat.setZero();
     return;
   }
-  Index last = perm(m-1);
+  Index lastIdx = perm(m-1);
   // The offset permits to skip deflated entries while computing zhat
   for (Index k = 0; k < n; ++k)
   {
     if (col0(k) == Literal(0)) // deflated
       zhat(k) = Literal(0);
     else
     {
       // see equation (3.6)
       RealScalar dk = diag(k);
-      RealScalar prod = (singVals(last) + dk) * (mus(last) + (shifts(last) - dk));
+      RealScalar prod = (singVals(lastIdx) + dk) * (mus(lastIdx) + (shifts(lastIdx) - dk));
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+      if(prod<0) {
+        std::cout << "k = " << k << " ;  z(k)=" << col0(k) << ", diag(k)=" << dk << "\n";
+        std::cout << "prod = " << "(" << singVals(lastIdx) << " + " << dk << ") * (" << mus(lastIdx) << " + (" << shifts(lastIdx) << " - " << dk << "))" << "\n";
+        std::cout << "     = " << singVals(lastIdx) + dk << " * " << mus(lastIdx) + (shifts(lastIdx) - dk) <<  "\n";
+      }
+      assert(prod>=0);
+#endif
 
       for(Index l = 0; l<m; ++l)
       {
         Index i = perm(l);
         if(i!=k)
         {
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+          if(i>=k && (l==0 || l-1>=m))
+          {
+            std::cout << "Error in perturbCol0\n";
+            std::cout << "  " << k << "/" << n << " "  << l << "/" << m << " " << i << "/" << n << " ; " << col0(k) << " " << diag(k) << " "  <<  "\n";
+            std::cout << "  " <<diag(i) << "\n";
+            Index j = (i<k /*|| l==0*/) ? i : perm(l-1);
+            std::cout << "  " << "j=" << j << "\n";
+          }
+#endif
           Index j = i<k ? i : perm(l-1);
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+          if(!(dk!=Literal(0) || diag(i)!=Literal(0)))
+          {
+            std::cout << "k=" << k << ", i=" << i << ", l=" << l << ", perm.size()=" << perm.size() << "\n";
+          }
+          assert(dk!=Literal(0) || diag(i)!=Literal(0));
+#endif
           prod *= ((singVals(j)+dk) / ((diag(i)+dk))) * ((mus(j)+(shifts(j)-dk)) / ((diag(i)-dk)));
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+          assert(prod>=0);
+#endif
 #ifdef EIGEN_BDCSVD_DEBUG_VERBOSE
-          if(i!=k && std::abs(((singVals(j)+dk)*(mus(j)+(shifts(j)-dk)))/((diag(i)+dk)*(diag(i)-dk)) - 1) > 0.9 )
+          if(i!=k && numext::abs(((singVals(j)+dk)*(mus(j)+(shifts(j)-dk)))/((diag(i)+dk)*(diag(i)-dk)) - 1) > 0.9 )
             std::cout << "     " << ((singVals(j)+dk)*(mus(j)+(shifts(j)-dk)))/((diag(i)+dk)*(diag(i)-dk)) << " == (" << (singVals(j)+dk) << " * " << (mus(j)+(shifts(j)-dk))
                        << ") / (" << (diag(i)+dk) << " * " << (diag(i)-dk) << ")\n";
 #endif
         }
       }
 #ifdef EIGEN_BDCSVD_DEBUG_VERBOSE
-      std::cout << "zhat(" << k << ") =  sqrt( " << prod << ")  ;  " << (singVals(last) + dk) << " * " << mus(last) + shifts(last) << " - " << dk << "\n";
+      std::cout << "zhat(" << k << ") =  sqrt( " << prod << ")  ;  " << (singVals(lastIdx) + dk) << " * " << mus(lastIdx) + shifts(lastIdx) << " - " << dk << "\n";
 #endif
       RealScalar tmp = sqrt(prod);
-      zhat(k) = col0(k) > Literal(0) ? tmp : -tmp;
+#ifdef EIGEN_BDCSVD_SANITY_CHECKS
+      assert((numext::isfinite)(tmp));
+#endif
+      zhat(k) = col0(k) > Literal(0) ? RealScalar(tmp) : RealScalar(-tmp);
     }
   }
 }
 
 // compute singular vectors
 template <typename MatrixType>
 void BDCSVD<MatrixType>::computeSingVecs
@@ -983,15 +1104,15 @@
 }
 
 
 // page 12_13
 // i >= 1, di almost null and zi non null.
 // We use a rotation to zero out zi applied to the left of M
 template <typename MatrixType>
-void BDCSVD<MatrixType>::deflation43(Index firstCol, Index shift, Index i, Index size)
+void BDCSVD<MatrixType>::deflation43(Eigen::Index firstCol, Eigen::Index shift, Eigen::Index i, Eigen::Index size)
 {
   using std::abs;
   using std::sqrt;
   using std::pow;
   Index start = firstCol + shift;
   RealScalar c = m_computed(start, start);
   RealScalar s = m_computed(start+i, start);
@@ -1012,15 +1133,15 @@
 
 
 // page 13
 // i,j >= 1, i!=j and |di - dj| < epsilon * norm2(M)
 // We apply two rotations to have zj = 0;
 // TODO deflation44 is still broken and not properly tested
 template <typename MatrixType>
-void BDCSVD<MatrixType>::deflation44(Index firstColu , Index firstColm, Index firstRowW, Index firstColW, Index i, Index j, Index size)
+void BDCSVD<MatrixType>::deflation44(Eigen::Index firstColu , Eigen::Index firstColm, Eigen::Index firstRowW, Eigen::Index firstColW, Eigen::Index i, Eigen::Index j, Eigen::Index size)
 {
   using std::abs;
   using std::sqrt;
   using std::conj;
   using std::pow;
   RealScalar c = m_computed(firstColm+i, firstColm);
   RealScalar s = m_computed(firstColm+j, firstColm);
@@ -1039,28 +1160,28 @@
   if (r==Literal(0))
   {
     m_computed(firstColm + i, firstColm + i) = m_computed(firstColm + j, firstColm + j);
     return;
   }
   c/=r;
   s/=r;
-  m_computed(firstColm + i, firstColm) = r;  
+  m_computed(firstColm + i, firstColm) = r;
   m_computed(firstColm + j, firstColm + j) = m_computed(firstColm + i, firstColm + i);
   m_computed(firstColm + j, firstColm) = Literal(0);
 
   JacobiRotation<RealScalar> J(c,-s);
   if (m_compU)  m_naiveU.middleRows(firstColu, size+1).applyOnTheRight(firstColu + i, firstColu + j, J);
   else          m_naiveU.applyOnTheRight(firstColu+i, firstColu+j, J);
   if (m_compV)  m_naiveV.middleRows(firstRowW, size).applyOnTheRight(firstColW + i, firstColW + j, J);
 }// end deflation 44
 
 
 // acts on block from (firstCol+shift, firstCol+shift) to (lastCol+shift, lastCol+shift) [inclusive]
 template <typename MatrixType>
-void BDCSVD<MatrixType>::deflation(Index firstCol, Index lastCol, Index k, Index firstRowW, Index firstColW, Index shift)
+void BDCSVD<MatrixType>::deflation(Eigen::Index firstCol, Eigen::Index lastCol, Eigen::Index k, Eigen::Index firstRowW, Eigen::Index firstColW, Eigen::Index shift)
 {
   using std::sqrt;
   using std::abs;
   const Index length = lastCol + 1 - firstCol;
   
   Block<MatrixXr,Dynamic,1> col0(m_computed, firstCol+shift, firstCol+shift, length, 1);
   Diagonal<MatrixXr> fulldiag(m_computed);
@@ -1113,14 +1234,15 @@
 #ifdef EIGEN_BDCSVD_SANITY_CHECKS
   assert(m_naiveU.allFinite());
   assert(m_naiveV.allFinite());
   assert(m_computed.allFinite());
 #endif
 #ifdef EIGEN_BDCSVD_DEBUG_VERBOSE
   std::cout << "to be sorted: " << diag.transpose() << "\n\n";
+  std::cout << "            : " << col0.transpose() << "\n\n";
 #endif
   {
     // Check for total deflation
     // If we have a total deflation, then we have to consider col0(0)==diag(0) as a singular value during sorting
     bool total_deflation = (col0.tail(length-1).array()<considerZero).all();
     
     // Sort the diagonal entries, since diag(1:k-1) and diag(k:length) are already sorted, let's do a sorted merge.
@@ -1203,15 +1325,15 @@
   {
     Index i = length-1;
     while(i>0 && (abs(diag(i))<considerZero || abs(col0(i))<considerZero)) --i;
     for(; i>1;--i)
        if( (diag(i) - diag(i-1)) < NumTraits<RealScalar>::epsilon()*maxDiag )
       {
 #ifdef EIGEN_BDCSVD_DEBUG_VERBOSE
-        std::cout << "deflation 4.4 with i = " << i << " because " << (diag(i) - diag(i-1)) << " < " << NumTraits<RealScalar>::epsilon()*diag(i) << "\n";
+        std::cout << "deflation 4.4 with i = " << i << " because " << diag(i) << " - " << diag(i-1) << " == " << (diag(i) - diag(i-1)) << " < " << NumTraits<RealScalar>::epsilon()*/*diag(i)*/maxDiag << "\n";
 #endif
         eigen_internal_assert(abs(diag(i) - diag(i-1))<epsilon_coarse && " diagonal entries are not properly sorted");
         deflation44(firstCol, firstCol + shift, firstRowW, firstColW, i-1, i, length);
       }
   }
   
 #ifdef EIGEN_BDCSVD_SANITY_CHECKS
@@ -1222,25 +1344,23 @@
 #ifdef EIGEN_BDCSVD_SANITY_CHECKS
   assert(m_naiveU.allFinite());
   assert(m_naiveV.allFinite());
   assert(m_computed.allFinite());
 #endif
 }//end deflation
 
-#ifndef __CUDACC__
 /** \svd_module
   *
   * \return the singular value decomposition of \c *this computed by Divide & Conquer algorithm
   *
   * \sa class BDCSVD
   */
 template<typename Derived>
 BDCSVD<typename MatrixBase<Derived>::PlainObject>
 MatrixBase<Derived>::bdcSvd(unsigned int computationOptions) const
 {
   return BDCSVD<PlainObject>(*this, computationOptions);
 }
-#endif
 
 } // end namespace Eigen
 
 #endif
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SVD/JacobiSVD.h` & `chronogram-0.2.0/include/Eigen/src/SVD/JacobiSVD.h`

 * *Files 2% similar despite different names*

```diff
@@ -108,20 +108,20 @@
   typedef typename MatrixType::Scalar Scalar;
   enum
   {
     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
     ColsAtCompileTime = MatrixType::ColsAtCompileTime,
     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
-    TrOptions = RowsAtCompileTime==1 ? (MatrixType::Options & ~(RowMajor))
-              : ColsAtCompileTime==1 ? (MatrixType::Options |   RowMajor)
-              : MatrixType::Options
+    Options = MatrixType::Options
   };
-  typedef Matrix<Scalar, ColsAtCompileTime, RowsAtCompileTime, TrOptions, MaxColsAtCompileTime, MaxRowsAtCompileTime>
-          TransposeTypeWithSameStorageOrder;
+
+  typedef typename internal::make_proper_matrix_type<
+    Scalar, ColsAtCompileTime, RowsAtCompileTime, Options, MaxColsAtCompileTime, MaxRowsAtCompileTime
+  >::type TransposeTypeWithSameStorageOrder;
 
   void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)
   {
     if (svd.cols() != m_qr.rows() || svd.rows() != m_qr.cols())
     {
       m_qr.~QRType();
       ::new (&m_qr) QRType(svd.cols(), svd.rows());
@@ -198,21 +198,20 @@
   typedef typename MatrixType::Scalar Scalar;
   enum
   {
     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
     ColsAtCompileTime = MatrixType::ColsAtCompileTime,
     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
-    TrOptions = RowsAtCompileTime==1 ? (MatrixType::Options & ~(RowMajor))
-              : ColsAtCompileTime==1 ? (MatrixType::Options |   RowMajor)
-              : MatrixType::Options
+    Options = MatrixType::Options
   };
 
-  typedef Matrix<Scalar, ColsAtCompileTime, RowsAtCompileTime, TrOptions, MaxColsAtCompileTime, MaxRowsAtCompileTime>
-          TransposeTypeWithSameStorageOrder;
+  typedef typename internal::make_proper_matrix_type<
+    Scalar, ColsAtCompileTime, RowsAtCompileTime, Options, MaxColsAtCompileTime, MaxRowsAtCompileTime
+  >::type TransposeTypeWithSameStorageOrder;
 
   void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)
   {
     if (svd.cols() != m_qr.rows() || svd.rows() != m_qr.cols())
     {
       m_qr.~QRType();
       ::new (&m_qr) QRType(svd.cols(), svd.rows());
@@ -299,16 +298,17 @@
     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
     ColsAtCompileTime = MatrixType::ColsAtCompileTime,
     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
     Options = MatrixType::Options
   };
 
-  typedef Matrix<Scalar, ColsAtCompileTime, RowsAtCompileTime, Options, MaxColsAtCompileTime, MaxRowsAtCompileTime>
-          TransposeTypeWithSameStorageOrder;
+  typedef typename internal::make_proper_matrix_type<
+    Scalar, ColsAtCompileTime, RowsAtCompileTime, Options, MaxColsAtCompileTime, MaxRowsAtCompileTime
+  >::type TransposeTypeWithSameStorageOrder;
 
   void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)
   {
     if (svd.cols() != m_qr.rows() || svd.rows() != m_qr.cols())
     {
       m_qr.~QRType();
       ::new (&m_qr) QRType(svd.cols(), svd.rows());
@@ -421,14 +421,15 @@
     RealScalar threshold = numext::maxi<RealScalar>(considerAsZero, precision * maxDiagEntry);
     return abs(work_matrix.coeff(p,q))>threshold || abs(work_matrix.coeff(q,p)) > threshold;
   }
 };
 
 template<typename _MatrixType, int QRPreconditioner> 
 struct traits<JacobiSVD<_MatrixType,QRPreconditioner> >
+        : traits<_MatrixType>
 {
   typedef _MatrixType MatrixType;
 };
 
 } // end namespace internal
 
 /** \ingroup SVD_Module
@@ -580,14 +581,15 @@
   private:
     void allocate(Index rows, Index cols, unsigned int computationOptions);
 
   protected:
     using Base::m_matrixU;
     using Base::m_matrixV;
     using Base::m_singularValues;
+    using Base::m_info;
     using Base::m_isInitialized;
     using Base::m_isAllocated;
     using Base::m_usePrescribedThreshold;
     using Base::m_computeFullU;
     using Base::m_computeThinU;
     using Base::m_computeFullV;
     using Base::m_computeThinV;
@@ -606,28 +608,29 @@
 
     internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;
     internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;
     MatrixType m_scaledMatrix;
 };
 
 template<typename MatrixType, int QRPreconditioner>
-void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)
+void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Eigen::Index rows, Eigen::Index cols, unsigned int computationOptions)
 {
   eigen_assert(rows >= 0 && cols >= 0);
 
   if (m_isAllocated &&
       rows == m_rows &&
       cols == m_cols &&
       computationOptions == m_computationOptions)
   {
     return;
   }
 
   m_rows = rows;
   m_cols = cols;
+  m_info = Success;
   m_isInitialized = false;
   m_isAllocated = true;
   m_computationOptions = computationOptions;
   m_computeFullU = (computationOptions & ComputeFullU) != 0;
   m_computeThinU = (computationOptions & ComputeThinU) != 0;
   m_computeFullV = (computationOptions & ComputeFullV) != 0;
   m_computeThinV = (computationOptions & ComputeThinV) != 0;
@@ -669,15 +672,20 @@
   // only worsening the precision of U and V as we accumulate more rotations
   const RealScalar precision = RealScalar(2) * NumTraits<Scalar>::epsilon();
 
   // limit for denormal numbers to be considered zero in order to avoid infinite loops (see bug 286)
   const RealScalar considerAsZero = (std::numeric_limits<RealScalar>::min)();
 
   // Scaling factor to reduce over/under-flows
-  RealScalar scale = matrix.cwiseAbs().maxCoeff();
+  RealScalar scale = matrix.cwiseAbs().template maxCoeff<PropagateNaN>();
+  if (!(numext::isfinite)(scale)) {
+    m_isInitialized = true;
+    m_info = InvalidInput;
+    return *this;
+  }
   if(scale==RealScalar(0)) scale = RealScalar(1);
   
   /*** step 1. The R-SVD step: we use a QR decomposition to reduce to the case of a square matrix */
 
   if(m_rows!=m_cols)
   {
     m_scaledMatrix = matrix / scale;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SVD/JacobiSVD_LAPACKE.h` & `chronogram-0.2.0/include/Eigen/src/SVD/JacobiSVD_LAPACKE.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SVD/SVDBase.h` & `chronogram-0.2.0/include/Eigen/src/SVD/SVDBase.h`

 * *Files 13% similar despite different names*

```diff
@@ -13,14 +13,26 @@
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_SVDBASE_H
 #define EIGEN_SVDBASE_H
 
 namespace Eigen {
+
+namespace internal {
+template<typename Derived> struct traits<SVDBase<Derived> >
+ : traits<Derived>
+{
+  typedef MatrixXpr XprKind;
+  typedef SolverStorage StorageKind;
+  typedef int StorageIndex;
+  enum { Flags = 0 };
+};
+}
+
 /** \ingroup SVD_Module
  *
  *
  * \class SVDBase
  *
  * \brief Base class of SVD algorithms
  *
@@ -35,28 +47,34 @@
  * Singular values are always sorted in decreasing order.
  *
  * 
  * You can ask for only \em thin \a U or \a V to be computed, meaning the following. In case of a rectangular n-by-p matrix, letting \a m be the
  * smaller value among \a n and \a p, there are only \a m singular vectors; the remaining columns of \a U and \a V do not correspond to actual
  * singular vectors. Asking for \em thin \a U or \a V means asking for only their \a m first columns to be formed. So \a U is then a n-by-m matrix,
  * and \a V is then a p-by-m matrix. Notice that thin \a U and \a V are all you need for (least squares) solving.
+ * 
+ * The status of the computation can be retrived using the \a info() method. Unless \a info() returns \a Success, the results should be not
+ * considered well defined.
  *  
- * If the input matrix has inf or nan coefficients, the result of the computation is undefined, but the computation is guaranteed to
+ * If the input matrix has inf or nan coefficients, the result of the computation is undefined, and \a info() will return \a InvalidInput, but the computation is guaranteed to
  * terminate in finite (and reasonable) time.
  * \sa class BDCSVD, class JacobiSVD
  */
-template<typename Derived>
-class SVDBase
+template<typename Derived> class SVDBase
+ : public SolverBase<SVDBase<Derived> >
 {
+public: 
+   
+  template<typename Derived_>
+  friend struct internal::solve_assertion;
 
-public:
   typedef typename internal::traits<Derived>::MatrixType MatrixType;
   typedef typename MatrixType::Scalar Scalar;
   typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;
-  typedef typename MatrixType::StorageIndex StorageIndex;
+  typedef typename Eigen::internal::traits<SVDBase>::StorageIndex StorageIndex;
   typedef Eigen::Index Index; ///< \deprecated since Eigen 3.3
   enum {
     RowsAtCompileTime = MatrixType::RowsAtCompileTime,
     ColsAtCompileTime = MatrixType::ColsAtCompileTime,
     DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),
     MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,
     MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,
@@ -78,15 +96,15 @@
    *
    * The \a m first columns of \a U are the left singular vectors of the matrix being decomposed.
    *
    * This method asserts that you asked for \a U to be computed.
    */
   const MatrixUType& matrixU() const
   {
-    eigen_assert(m_isInitialized && "SVD is not initialized.");
+    _check_compute_assertions();
     eigen_assert(computeU() && "This SVD decomposition didn't compute U. Did you ask for it?");
     return m_matrixU;
   }
 
   /** \returns the \a V matrix.
    *
    * For the SVD decomposition of a n-by-p matrix, letting \a m be the minimum of \a n and \a p,
@@ -94,47 +112,47 @@
    *
    * The \a m first columns of \a V are the right singular vectors of the matrix being decomposed.
    *
    * This method asserts that you asked for \a V to be computed.
    */
   const MatrixVType& matrixV() const
   {
-    eigen_assert(m_isInitialized && "SVD is not initialized.");
+    _check_compute_assertions();
     eigen_assert(computeV() && "This SVD decomposition didn't compute V. Did you ask for it?");
     return m_matrixV;
   }
 
   /** \returns the vector of singular values.
    *
    * For the SVD decomposition of a n-by-p matrix, letting \a m be the minimum of \a n and \a p, the
    * returned vector has size \a m.  Singular values are always sorted in decreasing order.
    */
   const SingularValuesType& singularValues() const
   {
-    eigen_assert(m_isInitialized && "SVD is not initialized.");
+    _check_compute_assertions();
     return m_singularValues;
   }
 
   /** \returns the number of singular values that are not exactly 0 */
   Index nonzeroSingularValues() const
   {
-    eigen_assert(m_isInitialized && "SVD is not initialized.");
+    _check_compute_assertions();
     return m_nonzeroSingularValues;
   }
   
   /** \returns the rank of the matrix of which \c *this is the SVD.
     *
     * \note This method has to determine which singular values should be considered nonzero.
     *       For that, it uses the threshold value that you can control by calling
     *       setThreshold(const RealScalar&).
     */
   inline Index rank() const
   {
     using std::abs;
-    eigen_assert(m_isInitialized && "JacobiSVD is not initialized.");
+    _check_compute_assertions();
     if(m_singularValues.size()==0) return 0;
     RealScalar premultiplied_threshold = numext::maxi<RealScalar>(m_singularValues.coeff(0) * threshold(), (std::numeric_limits<RealScalar>::min)());
     Index i = m_nonzeroSingularValues-1;
     while(i>=0 && m_singularValues.coeff(i) < premultiplied_threshold) --i;
     return i+1;
   }
   
@@ -179,102 +197,144 @@
     */
   RealScalar threshold() const
   {
     eigen_assert(m_isInitialized || m_usePrescribedThreshold);
     // this temporary is needed to workaround a MSVC issue
     Index diagSize = (std::max<Index>)(1,m_diagSize);
     return m_usePrescribedThreshold ? m_prescribedThreshold
-                                    : diagSize*NumTraits<Scalar>::epsilon();
+                                    : RealScalar(diagSize)*NumTraits<Scalar>::epsilon();
   }
 
   /** \returns true if \a U (full or thin) is asked for in this SVD decomposition */
   inline bool computeU() const { return m_computeFullU || m_computeThinU; }
   /** \returns true if \a V (full or thin) is asked for in this SVD decomposition */
   inline bool computeV() const { return m_computeFullV || m_computeThinV; }
 
   inline Index rows() const { return m_rows; }
   inline Index cols() const { return m_cols; }
   
+  #ifdef EIGEN_PARSED_BY_DOXYGEN
   /** \returns a (least squares) solution of \f$ A x = b \f$ using the current SVD decomposition of A.
     *
     * \param b the right-hand-side of the equation to solve.
     *
     * \note Solving requires both U and V to be computed. Thin U and V are enough, there is no need for full U or V.
     *
     * \note SVD solving is implicitly least-squares. Thus, this method serves both purposes of exact solving and least-squares solving.
     * In other words, the returned solution is guaranteed to minimize the Euclidean norm \f$ \Vert A x - b \Vert \f$.
     */
   template<typename Rhs>
   inline const Solve<Derived, Rhs>
-  solve(const MatrixBase<Rhs>& b) const
+  solve(const MatrixBase<Rhs>& b) const;
+  #endif
+
+
+  /** \brief Reports whether previous computation was successful.
+   *
+   * \returns \c Success if computation was successful.
+   */
+  EIGEN_DEVICE_FUNC
+  ComputationInfo info() const
   {
     eigen_assert(m_isInitialized && "SVD is not initialized.");
-    eigen_assert(computeU() && computeV() && "SVD::solve() requires both unitaries U and V to be computed (thin unitaries suffice).");
-    return Solve<Derived, Rhs>(derived(), b.derived());
+    return m_info;
   }
-  
+
   #ifndef EIGEN_PARSED_BY_DOXYGEN
   template<typename RhsType, typename DstType>
-  EIGEN_DEVICE_FUNC
   void _solve_impl(const RhsType &rhs, DstType &dst) const;
+
+  template<bool Conjugate, typename RhsType, typename DstType>
+  void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;
   #endif
 
 protected:
-  
+
   static void check_template_parameters()
   {
     EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar);
   }
-  
+
+  void _check_compute_assertions() const {
+    eigen_assert(m_isInitialized && "SVD is not initialized.");
+  }
+
+  template<bool Transpose_, typename Rhs>
+  void _check_solve_assertion(const Rhs& b) const {
+      EIGEN_ONLY_USED_FOR_DEBUG(b);
+      _check_compute_assertions();
+      eigen_assert(computeU() && computeV() && "SVDBase::solve(): Both unitaries U and V are required to be computed (thin unitaries suffice).");
+      eigen_assert((Transpose_?cols():rows())==b.rows() && "SVDBase::solve(): invalid number of rows of the right hand side matrix b");
+  }
+
   // return true if already allocated
   bool allocate(Index rows, Index cols, unsigned int computationOptions) ;
 
   MatrixUType m_matrixU;
   MatrixVType m_matrixV;
   SingularValuesType m_singularValues;
+  ComputationInfo m_info;
   bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;
   bool m_computeFullU, m_computeThinU;
   bool m_computeFullV, m_computeThinV;
   unsigned int m_computationOptions;
   Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;
   RealScalar m_prescribedThreshold;
 
   /** \brief Default Constructor.
    *
    * Default constructor of SVDBase
    */
   SVDBase()
-    : m_isInitialized(false),
+    : m_info(Success),
+      m_isInitialized(false),
       m_isAllocated(false),
       m_usePrescribedThreshold(false),
+      m_computeFullU(false),
+      m_computeThinU(false),
+      m_computeFullV(false),
+      m_computeThinV(false),
       m_computationOptions(0),
       m_rows(-1), m_cols(-1), m_diagSize(0)
   {
     check_template_parameters();
   }
 
 
 };
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template<typename Derived>
 template<typename RhsType, typename DstType>
 void SVDBase<Derived>::_solve_impl(const RhsType &rhs, DstType &dst) const
 {
-  eigen_assert(rhs.rows() == rows());
-
   // A = U S V^*
   // So A^{-1} = V S^{-1} U^*
 
-  Matrix<Scalar, Dynamic, RhsType::ColsAtCompileTime, 0, MatrixType::MaxRowsAtCompileTime, RhsType::MaxColsAtCompileTime> tmp;
+  Matrix<typename RhsType::Scalar, Dynamic, RhsType::ColsAtCompileTime, 0, MatrixType::MaxRowsAtCompileTime, RhsType::MaxColsAtCompileTime> tmp;
   Index l_rank = rank();
   tmp.noalias() =  m_matrixU.leftCols(l_rank).adjoint() * rhs;
   tmp = m_singularValues.head(l_rank).asDiagonal().inverse() * tmp;
   dst = m_matrixV.leftCols(l_rank) * tmp;
 }
+
+template<typename Derived>
+template<bool Conjugate, typename RhsType, typename DstType>
+void SVDBase<Derived>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const
+{
+  // A = U S V^*
+  // So  A^{-*} = U S^{-1} V^*
+  // And A^{-T} = U_conj S^{-1} V^T
+  Matrix<typename RhsType::Scalar, Dynamic, RhsType::ColsAtCompileTime, 0, MatrixType::MaxRowsAtCompileTime, RhsType::MaxColsAtCompileTime> tmp;
+  Index l_rank = rank();
+
+  tmp.noalias() =  m_matrixV.leftCols(l_rank).transpose().template conjugateIf<Conjugate>() * rhs;
+  tmp = m_singularValues.head(l_rank).asDiagonal().inverse() * tmp;
+  dst = m_matrixU.template conjugateIf<!Conjugate>().leftCols(l_rank) * tmp;
+}
 #endif
 
 template<typename MatrixType>
 bool SVDBase<MatrixType>::allocate(Index rows, Index cols, unsigned int computationOptions)
 {
   eigen_assert(rows >= 0 && cols >= 0);
 
@@ -284,14 +344,15 @@
       computationOptions == m_computationOptions)
   {
     return true;
   }
 
   m_rows = rows;
   m_cols = cols;
+  m_info = Success;
   m_isInitialized = false;
   m_isAllocated = true;
   m_computationOptions = computationOptions;
   m_computeFullU = (computationOptions & ComputeFullU) != 0;
   m_computeThinU = (computationOptions & ComputeThinU) != 0;
   m_computeFullV = (computationOptions & ComputeFullV) != 0;
   m_computeThinV = (computationOptions & ComputeThinV) != 0;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SVD/UpperBidiagonalization.h` & `chronogram-0.2.0/include/Eigen/src/SVD/UpperBidiagonalization.h`

 * *Files 0% similar despite different names*

```diff
@@ -123,15 +123,15 @@
     if(k == cols-1) break;
 
     // construct right householder transform in-place in mat
     mat.row(k).tail(remainingCols)
        .makeHouseholderInPlace(mat.coeffRef(k,k+1), upper_diagonal[k]);
     // apply householder transform to remaining part of mat on the left
     mat.bottomRightCorner(remainingRows-1, remainingCols)
-       .applyHouseholderOnTheRight(mat.row(k).tail(remainingCols-1).transpose(), mat.coeff(k,k+1), tempData);
+       .applyHouseholderOnTheRight(mat.row(k).tail(remainingCols-1).adjoint(), mat.coeff(k,k+1), tempData);
   }
 }
 
 /** \internal
   * Helper routine for the block reduction to upper bidiagonal form.
   *
   * Let's partition the matrix A:
@@ -198,15 +198,15 @@
       // A(k,k) will store tau_v later
       A(k,k) = Scalar(1);
 
       // 3 - Compute y_k^T = tau_v * ( A^T*v_k - Y_k-1*V_k-1^T*v_k - U_k-1*X_k-1^T*v_k )
       {
         SubColumnType y_k( Y.col(k).tail(remainingCols) );
         
-        // let's use the begining of column k of Y as a temporary vector
+        // let's use the beginning of column k of Y as a temporary vector
         SubColumnType tmp( Y.col(k).head(k) );
         y_k.noalias()  = A.block(k,k+1, remainingRows,remainingCols).adjoint() * v_k; // bottleneck
         tmp.noalias()  = V_k1.adjoint()  * v_k;
         y_k.noalias() -= Y_k.leftCols(k) * tmp;
         tmp.noalias()  = X_k1.adjoint()  * v_k;
         y_k.noalias() -= U_k1.adjoint()  * tmp;
         y_k *= numext::conj(tau_v);
@@ -227,15 +227,15 @@
       // A(k,k+1) will store tau_u later
       A(k,k+1) = Scalar(1);
 
       // 6 - Compute x_k = tau_u * ( A*u_k - X_k-1*U_k-1^T*u_k - V_k*Y_k^T*u_k )
       {
         SubColumnType x_k ( X.col(k).tail(remainingRows-1) );
         
-        // let's use the begining of column k of X as a temporary vectors
+        // let's use the beginning of column k of X as a temporary vectors
         // note that tmp0 and tmp1 overlaps
         SubColumnType tmp0 ( X.col(k).head(k) ),
                       tmp1 ( X.col(k).head(k+1) );
                     
         x_k.noalias()   = A.block(k+1,k+1, remainingRows-1,remainingCols) * u_k.transpose(); // bottleneck
         tmp0.noalias()  = U_k1 * u_k.transpose();
         x_k.noalias()  -= X_k1.bottomRows(remainingRows-1) * tmp0;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCholesky/SimplicialCholesky.h` & `chronogram-0.2.0/include/Eigen/src/SparseCholesky/SimplicialCholesky.h`

 * *Files 4% similar despite different names*

```diff
@@ -76,19 +76,27 @@
 
   public:
     
     using Base::derived;
 
     /** Default constructor */
     SimplicialCholeskyBase()
-      : m_info(Success), m_shiftOffset(0), m_shiftScale(1)
+      : m_info(Success),
+        m_factorizationIsOk(false),
+        m_analysisIsOk(false),
+        m_shiftOffset(0),
+        m_shiftScale(1)
     {}
 
     explicit SimplicialCholeskyBase(const MatrixType& matrix)
-      : m_info(Success), m_shiftOffset(0), m_shiftScale(1)
+      : m_info(Success),
+        m_factorizationIsOk(false),
+        m_analysisIsOk(false),
+        m_shiftOffset(0),
+        m_shiftScale(1)
     {
       derived().compute(matrix);
     }
 
     ~SimplicialCholeskyBase()
     {
     }
@@ -97,15 +105,15 @@
     const Derived& derived() const { return *static_cast<const Derived*>(this); }
     
     inline Index cols() const { return m_matrix.cols(); }
     inline Index rows() const { return m_matrix.rows(); }
     
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the matrix.appears to be negative.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "Decomposition is not initialized.");
       return m_info;
     }
@@ -206,15 +214,15 @@
     void factorize(const MatrixType& a)
     {
       eigen_assert(a.rows()==a.cols());
       Index size = a.cols();
       CholMatrixType tmp(size,size);
       ConstCholMatrixPtr pmat;
       
-      if(m_P.size()==0 && (UpLo&Upper)==Upper)
+      if(m_P.size() == 0 && (int(UpLo) & int(Upper)) == Upper)
       {
         // If there is no ordering, try to directly use the input matrix without any copy
         internal::simplicial_cholesky_grab_input<CholMatrixType,MatrixType>::run(a, pmat, tmp);
       }
       else
       {
         tmp.template selfadjointView<Upper>() = a.template selfadjointView<UpLo>().twistedBy(m_P);
@@ -275,30 +283,30 @@
   typedef _Ordering OrderingType;
   enum { UpLo = _UpLo };
   typedef typename MatrixType::Scalar                         Scalar;
   typedef typename MatrixType::StorageIndex                   StorageIndex;
   typedef SparseMatrix<Scalar, ColMajor, StorageIndex>        CholMatrixType;
   typedef TriangularView<const CholMatrixType, Eigen::Lower>  MatrixL;
   typedef TriangularView<const typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;
-  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }
-  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }
+  static inline MatrixL getL(const CholMatrixType& m) { return MatrixL(m); }
+  static inline MatrixU getU(const CholMatrixType& m) { return MatrixU(m.adjoint()); }
 };
 
 template<typename _MatrixType,int _UpLo, typename _Ordering> struct traits<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >
 {
   typedef _MatrixType MatrixType;
   typedef _Ordering OrderingType;
   enum { UpLo = _UpLo };
   typedef typename MatrixType::Scalar                             Scalar;
   typedef typename MatrixType::StorageIndex                       StorageIndex;
   typedef SparseMatrix<Scalar, ColMajor, StorageIndex>            CholMatrixType;
   typedef TriangularView<const CholMatrixType, Eigen::UnitLower>  MatrixL;
   typedef TriangularView<const typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;
-  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }
-  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }
+  static inline MatrixL getL(const CholMatrixType& m) { return MatrixL(m); }
+  static inline MatrixU getU(const CholMatrixType& m) { return MatrixU(m.adjoint()); }
 };
 
 template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >
 {
   typedef _MatrixType MatrixType;
   typedef _Ordering OrderingType;
   enum { UpLo = _UpLo };
@@ -604,15 +612,15 @@
         if(m_LDLT)
           LDLTTraits::getL(Base::m_matrix).solveInPlace(dest);
         else
           LLTTraits::getL(Base::m_matrix).solveInPlace(dest);
       }
 
       if(Base::m_diag.size()>0)
-        dest = Base::m_diag.asDiagonal().inverse() * dest;
+        dest = Base::m_diag.real().asDiagonal().inverse() * dest;
 
       if (Base::m_matrix.nonZeros()>0) // otherwise I==I
       {
         if(m_LDLT)
           LDLTTraits::getU(Base::m_matrix).solveInPlace(dest);
         else
           LLTTraits::getU(Base::m_matrix).solveInPlace(dest);
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCholesky/SimplicialCholesky_impl.h` & `chronogram-0.2.0/include/Eigen/src/SparseCholesky/SimplicialCholesky_impl.h`

 * *Files 21% similar despite different names*

```diff
@@ -1,51 +1,26 @@
 // This file is part of Eigen, a lightweight C++ template library
 // for linear algebra.
 //
 // Copyright (C) 2008-2012 Gael Guennebaud <gael.guennebaud@inria.fr>
+//
+// This Source Code Form is subject to the terms of the Mozilla
+// Public License v. 2.0. If a copy of the MPL was not distributed
+// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 /*
-
-NOTE: thes functions vave been adapted from the LDL library:
+NOTE: these functions have been adapted from the LDL library:
 
 LDL Copyright (c) 2005 by Timothy A. Davis.  All Rights Reserved.
 
-LDL License:
-
-    Your use or distribution of LDL or any modified version of
-    LDL implies that you agree to this License.
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
-    USA
-
-    Permission is hereby granted to use or copy this program under the
-    terms of the GNU LGPL, provided that the Copyright, this License,
-    and the Availability of the original version is retained on all copies.
-    User documentation of any code that uses this code or any modified
-    version of this code must cite the Copyright, this License, the
-    Availability note, and "Used by permission." Permission to modify
-    the code and to distribute modified code is granted, provided the
-    Copyright, this License, and the Availability note are retained,
-    and a notice that the code was modified is included.
+The author of LDL, Timothy A. Davis., has executed a license with Google LLC
+to permit distribution of this code and derivative works as part of Eigen under
+the Mozilla Public License v. 2.0, as stated at the top of this file.
  */
 
-#include "../Core/util/NonMPL2.h"
-
 #ifndef EIGEN_SIMPLICIAL_CHOLESKY_IMPL_H
 #define EIGEN_SIMPLICIAL_CHOLESKY_IMPL_H
 
 namespace Eigen {
 
 template<typename Derived>
 void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)
@@ -118,15 +93,15 @@
 
   bool ok = true;
   m_diag.resize(DoLDLT ? size : 0);
 
   for(StorageIndex k = 0; k < size; ++k)
   {
     // compute nonzero pattern of kth row of L, in topological order
-    y[k] = 0.0;                     // Y(0:k) is now all zero
+    y[k] = Scalar(0);                     // Y(0:k) is now all zero
     StorageIndex top = size;               // stack for pattern is empty
     tags[k] = k;                    // mark node k as visited
     m_nonZerosPerCol[k] = 0;        // count of nonzeros in column k of L
     for(typename CholMatrixType::InnerIterator it(ap,k); it; ++it)
     {
       StorageIndex i = it.index();
       if(i <= k)
@@ -142,25 +117,25 @@
           pattern[--top] = pattern[--len];
       }
     }
 
     /* compute numerical values kth row of L (a sparse triangular solve) */
 
     RealScalar d = numext::real(y[k]) * m_shiftScale + m_shiftOffset;    // get D(k,k), apply the shift function, and clear Y(k)
-    y[k] = 0.0;
+    y[k] = Scalar(0);
     for(; top < size; ++top)
     {
       Index i = pattern[top];       /* pattern[top:n-1] is pattern of L(:,k) */
       Scalar yi = y[i];             /* get and clear Y(i) */
-      y[i] = 0.0;
+      y[i] = Scalar(0);
 
       /* the nonzero entry L(k,i) */
       Scalar l_ki;
       if(DoLDLT)
-        l_ki = yi / m_diag[i];
+        l_ki = yi / numext::real(m_diag[i]);
       else
         yi = l_ki = yi / Lx[Lp[i]];
 
       Index p2 = Lp[i] + m_nonZerosPerCol[i];
       Index p;
       for(p = Lp[i] + (DoLDLT ? 0 : 1); p < p2; ++p)
         y[Li[p]] -= numext::conj(Lx[p]) * yi;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/AmbiVector.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/AmbiVector.h`

 * *Files 3% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 {
   public:
     typedef _Scalar Scalar;
     typedef _StorageIndex StorageIndex;
     typedef typename NumTraits<Scalar>::Real RealScalar;
 
     explicit AmbiVector(Index size)
-      : m_buffer(0), m_zero(0), m_size(0), m_allocatedSize(0), m_allocatedElements(0), m_mode(-1)
+      : m_buffer(0), m_zero(0), m_size(0), m_end(0), m_allocatedSize(0), m_allocatedElements(0), m_mode(-1)
     {
       resize(size);
     }
 
     void init(double estimatedDensity);
     void init(int mode);
 
@@ -143,15 +143,16 @@
     init(IsSparse);
 }
 
 template<typename _Scalar,typename _StorageIndex>
 void AmbiVector<_Scalar,_StorageIndex>::init(int mode)
 {
   m_mode = mode;
-  if (m_mode==IsSparse)
+  // This is only necessary in sparse mode, but we set these unconditionally to avoid some maybe-uninitialized warnings
+  // if (m_mode==IsSparse)
   {
     m_llSize = 0;
     m_llStart = -1;
   }
 }
 
 /** Must be called whenever we might perform a write access
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/CompressedStorage.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/CompressedStorage.h`

 * *Files 4% similar despite different names*

```diff
@@ -203,14 +203,30 @@
         m_size++;
         m_indices[id] = internal::convert_index<StorageIndex>(key);
         m_values[id] = defaultValue;
       }
       return m_values[id];
     }
 
+    void moveChunk(Index from, Index to, Index chunkSize)
+    {
+      eigen_internal_assert(to+chunkSize <= m_size);
+      if(to>from && from+chunkSize>to)
+      {
+        // move backward
+        internal::smart_memmove(m_values+from,  m_values+from+chunkSize,  m_values+to);
+        internal::smart_memmove(m_indices+from, m_indices+from+chunkSize, m_indices+to);
+      }
+      else
+      {
+        internal::smart_copy(m_values+from,  m_values+from+chunkSize,  m_values+to);
+        internal::smart_copy(m_indices+from, m_indices+from+chunkSize, m_indices+to);
+      }
+    }
+
     void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())
     {
       Index k = 0;
       Index n = size();
       for (Index i=0; i<n; ++i)
       {
         if (!internal::isMuchSmallerThan(value(i), reference, epsilon))
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/ConservativeSparseSparseProduct.h`

 * *Files 1% similar despite different names*

```diff
@@ -6,39 +6,39 @@
 // This Source Code Form is subject to the terms of the Mozilla
 // Public License v. 2.0. If a copy of the MPL was not distributed
 // with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 #ifndef EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H
 #define EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H
 
-namespace Eigen { 
+namespace Eigen {
 
 namespace internal {
 
 template<typename Lhs, typename Rhs, typename ResultType>
 static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, bool sortedInsertion = false)
 {
   typedef typename remove_all<Lhs>::type::Scalar LhsScalar;
   typedef typename remove_all<Rhs>::type::Scalar RhsScalar;
   typedef typename remove_all<ResultType>::type::Scalar ResScalar;
 
   // make sure to call innerSize/outerSize since we fake the storage order.
   Index rows = lhs.innerSize();
   Index cols = rhs.outerSize();
   eigen_assert(lhs.outerSize() == rhs.innerSize());
-  
+
   ei_declare_aligned_stack_constructed_variable(bool,   mask,     rows, 0);
   ei_declare_aligned_stack_constructed_variable(ResScalar, values,   rows, 0);
   ei_declare_aligned_stack_constructed_variable(Index,  indices,  rows, 0);
-  
+
   std::memset(mask,0,sizeof(bool)*rows);
 
   evaluator<Lhs> lhsEval(lhs);
   evaluator<Rhs> rhsEval(rhs);
-  
+
   // estimate the number of non zero entries
   // given a rhs column containing Y non zeros, we assume that the respective Y columns
   // of the lhs differs in average of one non zeros, thus the number of non zeros for
   // the product of a rhs column with the lhs is X+Y where X is the average number of non zero
   // per column of the lhs.
   // Therefore, we have nnz(lhs*rhs) = nnz(lhs) + nnz(rhs)
   Index estimated_nnz_prod = lhsEval.nonZerosEstimate() + rhsEval.nonZerosEstimate();
@@ -137,29 +137,29 @@
   typedef typename LhsCleaned::Scalar Scalar;
 
   static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)
   {
     typedef SparseMatrix<typename ResultType::Scalar,RowMajor,typename ResultType::StorageIndex> RowMajorMatrix;
     typedef SparseMatrix<typename ResultType::Scalar,ColMajor,typename ResultType::StorageIndex> ColMajorMatrixAux;
     typedef typename sparse_eval<ColMajorMatrixAux,ResultType::RowsAtCompileTime,ResultType::ColsAtCompileTime,ColMajorMatrixAux::Flags>::type ColMajorMatrix;
-    
+
     // If the result is tall and thin (in the extreme case a column vector)
     // then it is faster to sort the coefficients inplace instead of transposing twice.
     // FIXME, the following heuristic is probably not very good.
     if(lhs.rows()>rhs.cols())
     {
       ColMajorMatrix resCol(lhs.rows(),rhs.cols());
       // perform sorted insertion
       internal::conservative_sparse_sparse_product_impl<Lhs,Rhs,ColMajorMatrix>(lhs, rhs, resCol, true);
       res = resCol.markAsRValue();
     }
     else
     {
       ColMajorMatrixAux resCol(lhs.rows(),rhs.cols());
-      // ressort to transpose to sort the entries
+      // resort to transpose to sort the entries
       internal::conservative_sparse_sparse_product_impl<Lhs,Rhs,ColMajorMatrixAux>(lhs, rhs, resCol, false);
       RowMajorMatrix resRow(resCol);
       res = resRow.markAsRValue();
     }
   }
 };
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/MappedSparseMatrix.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/MappedSparseMatrix.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseAssign.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseAssign.h`

 * *Files 23% similar despite different names*

```diff
@@ -79,15 +79,15 @@
   const bool transpose = (DstEvaluatorType::Flags & RowMajorBit) != (SrcEvaluatorType::Flags & RowMajorBit);
   const Index outerEvaluationSize = (SrcEvaluatorType::Flags&RowMajorBit) ? src.rows() : src.cols();
   if ((!transpose) && src.isRValue())
   {
     // eval without temporary
     dst.resize(src.rows(), src.cols());
     dst.setZero();
-    dst.reserve((std::max)(src.rows(),src.cols())*2);
+    dst.reserve((std::min)(src.rows()*src.cols(), (std::max)(src.rows(),src.cols())*2));
     for (Index j=0; j<outerEvaluationSize; ++j)
     {
       dst.startVec(j);
       for (typename SrcEvaluatorType::InnerIterator it(srcEvaluator, j); it; ++it)
       {
         Scalar v = it.value();
         dst.insertBackByOuterInner(j,it.index()) = v;
@@ -103,15 +103,15 @@
               "the transpose operation is supposed to be handled in SparseMatrix::operator=");
 
     enum { Flip = (DstEvaluatorType::Flags & RowMajorBit) != (SrcEvaluatorType::Flags & RowMajorBit) };
 
     
     DstXprType temp(src.rows(), src.cols());
 
-    temp.reserve((std::max)(src.rows(),src.cols())*2);
+    temp.reserve((std::min)(src.rows()*src.cols(), (std::max)(src.rows(),src.cols())*2));
     for (Index j=0; j<outerEvaluationSize; ++j)
     {
       temp.startVec(j);
       for (typename SrcEvaluatorType::InnerIterator it(srcEvaluator, j); it; ++it)
       {
         Scalar v = it.value();
         temp.insertBackByOuterInner(Flip?it.index():j,Flip?j:it.index()) = v;
@@ -130,16 +130,16 @@
   static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)
   {
     assign_sparse_to_sparse(dst.derived(), src.derived());
   }
 };
 
 // Generic Sparse to Dense assignment
-template< typename DstXprType, typename SrcXprType, typename Functor>
-struct Assignment<DstXprType, SrcXprType, Functor, Sparse2Dense>
+template< typename DstXprType, typename SrcXprType, typename Functor, typename Weak>
+struct Assignment<DstXprType, SrcXprType, Functor, Sparse2Dense, Weak>
 {
   static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)
   {
     if(internal::is_same<Functor,internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> >::value)
       dst.setZero();
     
     internal::evaluator<SrcXprType> srcEval(src);
@@ -149,14 +149,81 @@
     const Index outerEvaluationSize = (internal::evaluator<SrcXprType>::Flags&RowMajorBit) ? src.rows() : src.cols();
     for (Index j=0; j<outerEvaluationSize; ++j)
       for (typename internal::evaluator<SrcXprType>::InnerIterator i(srcEval,j); i; ++i)
         func.assignCoeff(dstEval.coeffRef(i.row(),i.col()), i.value());
   }
 };
 
+// Specialization for dense ?= dense +/- sparse and dense ?= sparse +/- dense
+template<typename DstXprType, typename Func1, typename Func2>
+struct assignment_from_dense_op_sparse
+{
+  template<typename SrcXprType, typename InitialFunc>
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  void run(DstXprType &dst, const SrcXprType &src, const InitialFunc& /*func*/)
+  {
+    #ifdef EIGEN_SPARSE_ASSIGNMENT_FROM_DENSE_OP_SPARSE_PLUGIN
+    EIGEN_SPARSE_ASSIGNMENT_FROM_DENSE_OP_SPARSE_PLUGIN
+    #endif
+
+    call_assignment_no_alias(dst, src.lhs(), Func1());
+    call_assignment_no_alias(dst, src.rhs(), Func2());
+  }
+
+  // Specialization for dense1 = sparse + dense2; -> dense1 = dense2; dense1 += sparse;
+  template<typename Lhs, typename Rhs, typename Scalar>
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  typename internal::enable_if<internal::is_same<typename internal::evaluator_traits<Rhs>::Shape,DenseShape>::value>::type
+  run(DstXprType &dst, const CwiseBinaryOp<internal::scalar_sum_op<Scalar,Scalar>, const Lhs, const Rhs> &src,
+      const internal::assign_op<typename DstXprType::Scalar,Scalar>& /*func*/)
+  {
+    #ifdef EIGEN_SPARSE_ASSIGNMENT_FROM_SPARSE_ADD_DENSE_PLUGIN
+    EIGEN_SPARSE_ASSIGNMENT_FROM_SPARSE_ADD_DENSE_PLUGIN
+    #endif
+
+    // Apply the dense matrix first, then the sparse one.
+    call_assignment_no_alias(dst, src.rhs(), Func1());
+    call_assignment_no_alias(dst, src.lhs(), Func2());
+  }
+
+  // Specialization for dense1 = sparse - dense2; -> dense1 = -dense2; dense1 += sparse;
+  template<typename Lhs, typename Rhs, typename Scalar>
+  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE
+  typename internal::enable_if<internal::is_same<typename internal::evaluator_traits<Rhs>::Shape,DenseShape>::value>::type
+  run(DstXprType &dst, const CwiseBinaryOp<internal::scalar_difference_op<Scalar,Scalar>, const Lhs, const Rhs> &src,
+      const internal::assign_op<typename DstXprType::Scalar,Scalar>& /*func*/)
+  {
+    #ifdef EIGEN_SPARSE_ASSIGNMENT_FROM_SPARSE_SUB_DENSE_PLUGIN
+    EIGEN_SPARSE_ASSIGNMENT_FROM_SPARSE_SUB_DENSE_PLUGIN
+    #endif
+
+    // Apply the dense matrix first, then the sparse one.
+    call_assignment_no_alias(dst, -src.rhs(), Func1());
+    call_assignment_no_alias(dst,  src.lhs(), add_assign_op<typename DstXprType::Scalar,typename Lhs::Scalar>());
+  }
+};
+
+#define EIGEN_CATCH_ASSIGN_DENSE_OP_SPARSE(ASSIGN_OP,BINOP,ASSIGN_OP2) \
+  template< typename DstXprType, typename Lhs, typename Rhs, typename Scalar> \
+  struct Assignment<DstXprType, CwiseBinaryOp<internal::BINOP<Scalar,Scalar>, const Lhs, const Rhs>, internal::ASSIGN_OP<typename DstXprType::Scalar,Scalar>, \
+                    Sparse2Dense, \
+                    typename internal::enable_if<   internal::is_same<typename internal::evaluator_traits<Lhs>::Shape,DenseShape>::value \
+                                                 || internal::is_same<typename internal::evaluator_traits<Rhs>::Shape,DenseShape>::value>::type> \
+    : assignment_from_dense_op_sparse<DstXprType, internal::ASSIGN_OP<typename DstXprType::Scalar,typename Lhs::Scalar>, internal::ASSIGN_OP2<typename DstXprType::Scalar,typename Rhs::Scalar> > \
+  {}
+
+EIGEN_CATCH_ASSIGN_DENSE_OP_SPARSE(assign_op,    scalar_sum_op,add_assign_op);
+EIGEN_CATCH_ASSIGN_DENSE_OP_SPARSE(add_assign_op,scalar_sum_op,add_assign_op);
+EIGEN_CATCH_ASSIGN_DENSE_OP_SPARSE(sub_assign_op,scalar_sum_op,sub_assign_op);
+
+EIGEN_CATCH_ASSIGN_DENSE_OP_SPARSE(assign_op,    scalar_difference_op,sub_assign_op);
+EIGEN_CATCH_ASSIGN_DENSE_OP_SPARSE(add_assign_op,scalar_difference_op,sub_assign_op);
+EIGEN_CATCH_ASSIGN_DENSE_OP_SPARSE(sub_assign_op,scalar_difference_op,add_assign_op);
+
+
 // Specialization for "dst = dec.solve(rhs)"
 // NOTE we need to specialize it for Sparse2Sparse to avoid ambiguous specialization error
 template<typename DstXprType, typename DecType, typename RhsType, typename Scalar>
 struct Assignment<DstXprType, Solve<DecType,RhsType>, internal::assign_op<Scalar,Scalar>, Sparse2Sparse>
 {
   typedef Solve<DecType,RhsType> SrcXprType;
   static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)
@@ -175,42 +242,29 @@
 template<> struct AssignmentKind<SparseShape,DiagonalShape> { typedef Diagonal2Sparse Kind; };
 
 template< typename DstXprType, typename SrcXprType, typename Functor>
 struct Assignment<DstXprType, SrcXprType, Functor, Diagonal2Sparse>
 {
   typedef typename DstXprType::StorageIndex StorageIndex;
   typedef typename DstXprType::Scalar Scalar;
-  typedef Array<StorageIndex,Dynamic,1> ArrayXI;
-  typedef Array<Scalar,Dynamic,1> ArrayXS;
-  template<int Options>
-  static void run(SparseMatrix<Scalar,Options,StorageIndex> &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)
-  {
-    Index dstRows = src.rows();
-    Index dstCols = src.cols();
-    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))
-      dst.resize(dstRows, dstCols);
 
-    Index size = src.diagonal().size();
-    dst.makeCompressed();
-    dst.resizeNonZeros(size);
-    Map<ArrayXI>(dst.innerIndexPtr(), size).setLinSpaced(0,StorageIndex(size)-1);
-    Map<ArrayXI>(dst.outerIndexPtr(), size+1).setLinSpaced(0,StorageIndex(size));
-    Map<ArrayXS>(dst.valuePtr(), size) = src.diagonal();
-  }
+  template<int Options, typename AssignFunc>
+  static void run(SparseMatrix<Scalar,Options,StorageIndex> &dst, const SrcXprType &src, const AssignFunc &func)
+  { dst.assignDiagonal(src.diagonal(), func); }
   
   template<typename DstDerived>
   static void run(SparseMatrixBase<DstDerived> &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)
-  {
-    dst.diagonal() = src.diagonal();
-  }
+  { dst.derived().diagonal() = src.diagonal(); }
   
-  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)
-  { dst.diagonal() += src.diagonal(); }
+  template<typename DstDerived>
+  static void run(SparseMatrixBase<DstDerived> &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)
+  { dst.derived().diagonal() += src.diagonal(); }
   
-  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)
-  { dst.diagonal() -= src.diagonal(); }
+  template<typename DstDerived>
+  static void run(SparseMatrixBase<DstDerived> &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)
+  { dst.derived().diagonal() -= src.diagonal(); }
 };
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_SPARSEASSIGN_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseBlock.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseBlock.h`

 * *Files 9% similar despite different names*

```diff
@@ -160,15 +160,15 @@
 
         matrix.data().swap(newdata);
 
         update_trailing_pointers = true;
       }
       else
       {
-        if(m_matrix.isCompressed())
+        if(m_matrix.isCompressed() && nnz!=block_size)
         {
           // no need to realloc, simply copy the tail at its respective position and insert tmp
           matrix.data().resize(start + nnz + tail_size);
 
           internal::smart_memmove(matrix.valuePtr()+end,      matrix.valuePtr() + end+tail_size,      matrix.valuePtr() + start+nnz);
           internal::smart_memmove(matrix.innerIndexPtr()+end, matrix.innerIndexPtr() + end+tail_size, matrix.innerIndexPtr() + start+nnz);
 
@@ -322,54 +322,14 @@
 private:
   template<typename Derived> BlockImpl(const SparseMatrixBase<Derived>& xpr, Index i);
   template<typename Derived> BlockImpl(const SparseMatrixBase<Derived>& xpr);
 };
 
 //----------
 
-/** \returns the \a outer -th column (resp. row) of the matrix \c *this if \c *this
-  * is col-major (resp. row-major).
-  */
-template<typename Derived>
-typename SparseMatrixBase<Derived>::InnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer)
-{ return InnerVectorReturnType(derived(), outer); }
-
-/** \returns the \a outer -th column (resp. row) of the matrix \c *this if \c *this
-  * is col-major (resp. row-major). Read-only.
-  */
-template<typename Derived>
-const typename SparseMatrixBase<Derived>::ConstInnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer) const
-{ return ConstInnerVectorReturnType(derived(), outer); }
-
-/** \returns the \a outer -th column (resp. row) of the matrix \c *this if \c *this
-  * is col-major (resp. row-major).
-  */
-template<typename Derived>
-typename SparseMatrixBase<Derived>::InnerVectorsReturnType
-SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)
-{
-  return Block<Derived,Dynamic,Dynamic,true>(derived(),
-                                             IsRowMajor ? outerStart : 0, IsRowMajor ? 0 : outerStart,
-                                             IsRowMajor ? outerSize : rows(), IsRowMajor ? cols() : outerSize);
-
-}
-
-/** \returns the \a outer -th column (resp. row) of the matrix \c *this if \c *this
-  * is col-major (resp. row-major). Read-only.
-  */
-template<typename Derived>
-const typename SparseMatrixBase<Derived>::ConstInnerVectorsReturnType
-SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const
-{
-  return Block<const Derived,Dynamic,Dynamic,true>(derived(),
-                                                  IsRowMajor ? outerStart : 0, IsRowMajor ? 0 : outerStart,
-                                                  IsRowMajor ? outerSize : rows(), IsRowMajor ? cols() : outerSize);
-
-}
-
 /** Generic implementation of sparse Block expression.
   * Real-only.
   */
 template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>
 class BlockImpl<XprType,BlockRows,BlockCols,InnerPanel,Sparse>
   : public SparseMatrixBase<Block<XprType,BlockRows,BlockCols,InnerPanel> >, internal::no_assignment_operator
 {
@@ -482,83 +442,91 @@
     typedef typename internal::conditional<OuterVector,OuterVectorInnerIterator,InnerVectorInnerIterator>::type InnerIterator;
 
     explicit unary_evaluator(const XprType& op)
       : m_argImpl(op.nestedExpression()), m_block(op)
     {}
 
     inline Index nonZerosEstimate() const {
-      Index nnz = m_block.nonZeros();
-      if(nnz<0)
-        return m_argImpl.nonZerosEstimate() * m_block.size() / m_block.nestedExpression().size();
+      const Index nnz = m_block.nonZeros();
+      if(nnz < 0) {
+        // Scale the non-zero estimate for the underlying expression linearly with block size.
+        // Return zero if the underlying block is empty.
+        const Index nested_sz = m_block.nestedExpression().size();        
+        return nested_sz == 0 ? 0 : m_argImpl.nonZerosEstimate() * m_block.size() / nested_sz;
+      }
       return nnz;
     }
 
   protected:
     typedef typename evaluator<ArgType>::InnerIterator EvalIterator;
 
     evaluator<ArgType> m_argImpl;
     const XprType &m_block;
 };
 
 template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
 class unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased>::InnerVectorInnerIterator
  : public EvalIterator
 {
-  enum { IsRowMajor = unary_evaluator::IsRowMajor };
+  // NOTE MSVC fails to compile if we don't explicitely "import" IsRowMajor from unary_evaluator
+  //      because the base class EvalIterator has a private IsRowMajor enum too. (bug #1786)
+  // NOTE We cannot call it IsRowMajor because it would shadow unary_evaluator::IsRowMajor
+  enum { XprIsRowMajor = unary_evaluator::IsRowMajor };
   const XprType& m_block;
   Index m_end;
 public:
 
   EIGEN_STRONG_INLINE InnerVectorInnerIterator(const unary_evaluator& aEval, Index outer)
-    : EvalIterator(aEval.m_argImpl, outer + (IsRowMajor ? aEval.m_block.startRow() : aEval.m_block.startCol())),
+    : EvalIterator(aEval.m_argImpl, outer + (XprIsRowMajor ? aEval.m_block.startRow() : aEval.m_block.startCol())),
       m_block(aEval.m_block),
-      m_end(IsRowMajor ? aEval.m_block.startCol()+aEval.m_block.blockCols() : aEval.m_block.startRow()+aEval.m_block.blockRows())
+      m_end(XprIsRowMajor ? aEval.m_block.startCol()+aEval.m_block.blockCols() : aEval.m_block.startRow()+aEval.m_block.blockRows())
   {
-    while( (EvalIterator::operator bool()) && (EvalIterator::index() < (IsRowMajor ? m_block.startCol() : m_block.startRow())) )
+    while( (EvalIterator::operator bool()) && (EvalIterator::index() < (XprIsRowMajor ? m_block.startCol() : m_block.startRow())) )
       EvalIterator::operator++();
   }
 
-  inline StorageIndex index() const { return EvalIterator::index() - convert_index<StorageIndex>(IsRowMajor ? m_block.startCol() : m_block.startRow()); }
-  inline Index outer()  const { return EvalIterator::outer() - (IsRowMajor ? m_block.startRow() : m_block.startCol()); }
+  inline StorageIndex index() const { return EvalIterator::index() - convert_index<StorageIndex>(XprIsRowMajor ? m_block.startCol() : m_block.startRow()); }
+  inline Index outer()  const { return EvalIterator::outer() - (XprIsRowMajor ? m_block.startRow() : m_block.startCol()); }
   inline Index row()    const { return EvalIterator::row()   - m_block.startRow(); }
   inline Index col()    const { return EvalIterator::col()   - m_block.startCol(); }
 
   inline operator bool() const { return EvalIterator::operator bool() && EvalIterator::index() < m_end; }
 };
 
 template<typename ArgType, int BlockRows, int BlockCols, bool InnerPanel>
 class unary_evaluator<Block<ArgType,BlockRows,BlockCols,InnerPanel>, IteratorBased>::OuterVectorInnerIterator
 {
-  enum { IsRowMajor = unary_evaluator::IsRowMajor };
+  // NOTE see above
+  enum { XprIsRowMajor = unary_evaluator::IsRowMajor };
   const unary_evaluator& m_eval;
   Index m_outerPos;
   const Index m_innerIndex;
   Index m_end;
   EvalIterator m_it;
 public:
 
   EIGEN_STRONG_INLINE OuterVectorInnerIterator(const unary_evaluator& aEval, Index outer)
     : m_eval(aEval),
-      m_outerPos( (IsRowMajor ? aEval.m_block.startCol() : aEval.m_block.startRow()) ),
-      m_innerIndex(IsRowMajor ? aEval.m_block.startRow() : aEval.m_block.startCol()),
-      m_end(IsRowMajor ? aEval.m_block.startCol()+aEval.m_block.blockCols() : aEval.m_block.startRow()+aEval.m_block.blockRows()),
+      m_outerPos( (XprIsRowMajor ? aEval.m_block.startCol() : aEval.m_block.startRow()) ),
+      m_innerIndex(XprIsRowMajor ? aEval.m_block.startRow() : aEval.m_block.startCol()),
+      m_end(XprIsRowMajor ? aEval.m_block.startCol()+aEval.m_block.blockCols() : aEval.m_block.startRow()+aEval.m_block.blockRows()),
       m_it(m_eval.m_argImpl, m_outerPos)
   {
     EIGEN_UNUSED_VARIABLE(outer);
     eigen_assert(outer==0);
 
     while(m_it && m_it.index() < m_innerIndex) ++m_it;
     if((!m_it) || (m_it.index()!=m_innerIndex))
       ++(*this);
   }
 
-  inline StorageIndex index() const { return convert_index<StorageIndex>(m_outerPos - (IsRowMajor ? m_eval.m_block.startCol() : m_eval.m_block.startRow())); }
+  inline StorageIndex index() const { return convert_index<StorageIndex>(m_outerPos - (XprIsRowMajor ? m_eval.m_block.startCol() : m_eval.m_block.startRow())); }
   inline Index outer()  const { return 0; }
-  inline Index row()    const { return IsRowMajor ? 0 : index(); }
-  inline Index col()    const { return IsRowMajor ? index() : 0; }
+  inline Index row()    const { return XprIsRowMajor ? 0 : index(); }
+  inline Index col()    const { return XprIsRowMajor ? index() : 0; }
 
   inline Scalar value() const { return m_it.value(); }
   inline Scalar& valueRef() { return m_it.valueRef(); }
 
   inline OuterVectorInnerIterator& operator++()
   {
     // search next non-zero entry
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseColEtree.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseColEtree.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseCompressedBase.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseCompressedBase.h`

 * *Files 6% similar despite different names*

```diff
@@ -124,14 +124,36 @@
       *
       * \sa valuePtr(), isCompressed() */
     Map<Array<Scalar,Dynamic,1> > coeffs() { eigen_assert(isCompressed()); return Array<Scalar,Dynamic,1>::Map(valuePtr(),nonZeros()); }
 
   protected:
     /** Default constructor. Do nothing. */
     SparseCompressedBase() {}
+
+    /** \internal return the index of the coeff at (row,col) or just before if it does not exist.
+      * This is an analogue of std::lower_bound.
+      */
+    internal::LowerBoundIndex lower_bound(Index row, Index col) const
+    {
+      eigen_internal_assert(row>=0 && row<this->rows() && col>=0 && col<this->cols());
+
+      const Index outer = Derived::IsRowMajor ? row : col;
+      const Index inner = Derived::IsRowMajor ? col : row;
+
+      Index start = this->outerIndexPtr()[outer];
+      Index end = this->isCompressed() ? this->outerIndexPtr()[outer+1] : this->outerIndexPtr()[outer] + this->innerNonZeroPtr()[outer];
+      eigen_assert(end>=start && "you are using a non finalized sparse matrix or written coefficient does not exist");
+      internal::LowerBoundIndex p;
+      p.value = std::lower_bound(this->innerIndexPtr()+start, this->innerIndexPtr()+end,inner) - this->innerIndexPtr();
+      p.found = (p.value<end) && (this->innerIndexPtr()[p.value]==inner);
+      return p;
+    }
+
+    friend struct internal::evaluator<SparseCompressedBase<Derived> >;
+
   private:
     template<typename OtherDerived> explicit SparseCompressedBase(const SparseCompressedBase<OtherDerived>&);
 };
 
 template<typename Derived>
 class SparseCompressedBase<Derived>::InnerIterator
 {
@@ -181,14 +203,22 @@
     explicit InnerIterator(const internal::CompressedStorage<Scalar,StorageIndex>& data)
       : m_values(data.valuePtr()), m_indices(data.indexPtr()), m_outer(0), m_id(0), m_end(data.size())
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived);
     }
 
     inline InnerIterator& operator++() { m_id++; return *this; }
+    inline InnerIterator& operator+=(Index i) { m_id += i ; return *this; }
+
+    inline InnerIterator operator+(Index i) 
+    { 
+        InnerIterator result = *this;
+        result += i;
+        return result;
+    }
 
     inline const Scalar& value() const { return m_values[m_id]; }
     inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }
 
     inline StorageIndex index() const { return m_indices[m_id]; }
     inline Index outer() const { return m_outer.value(); }
     inline Index row() const { return IsRowMajor ? m_outer.value() : index(); }
@@ -241,14 +271,22 @@
     explicit ReverseInnerIterator(const internal::CompressedStorage<Scalar,StorageIndex>& data)
       : m_values(data.valuePtr()), m_indices(data.indexPtr()), m_outer(0), m_start(0), m_id(data.size())
     {
       EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived);
     }
 
     inline ReverseInnerIterator& operator--() { --m_id; return *this; }
+    inline ReverseInnerIterator& operator-=(Index i) { m_id -= i; return *this; }
+
+    inline ReverseInnerIterator operator-(Index i) 
+    {
+        ReverseInnerIterator result = *this;
+        result -= i;
+        return result;
+    }
 
     inline const Scalar& value() const { return m_values[m_id-1]; }
     inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }
 
     inline StorageIndex index() const { return m_indices[m_id-1]; }
     inline Index outer() const { return m_outer.value(); }
     inline Index row() const { return IsRowMajor ? m_outer.value() : index(); }
@@ -313,25 +351,16 @@
     return m_matrix->const_cast_derived().valuePtr()[p];
   }
 
 protected:
 
   Index find(Index row, Index col) const
   {
-    eigen_internal_assert(row>=0 && row<m_matrix->rows() && col>=0 && col<m_matrix->cols());
-
-    const Index outer = Derived::IsRowMajor ? row : col;
-    const Index inner = Derived::IsRowMajor ? col : row;
-
-    Index start = m_matrix->outerIndexPtr()[outer];
-    Index end = m_matrix->isCompressed() ? m_matrix->outerIndexPtr()[outer+1] : m_matrix->outerIndexPtr()[outer] + m_matrix->innerNonZeroPtr()[outer];
-    eigen_assert(end>=start && "you are using a non finalized sparse matrix or written coefficient does not exist");
-    const Index p = std::lower_bound(m_matrix->innerIndexPtr()+start, m_matrix->innerIndexPtr()+end,inner) - m_matrix->innerIndexPtr();
-
-    return ((p<end) && (m_matrix->innerIndexPtr()[p]==inner)) ? p : Dynamic;
+    internal::LowerBoundIndex p = m_matrix->lower_bound(row,col);
+    return p.found ? p.value : Dynamic;
   }
 
   const Derived *m_matrix;
   const Scalar m_zero;
 };
 
 }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseCwiseBinaryOp.h`

 * *Files 4% similar despite different names*

```diff
@@ -97,15 +97,15 @@
       {
         m_id = m_rhsIter.index();
         m_value = m_functor(Scalar(0), m_rhsIter.value());
         ++m_rhsIter;
       }
       else
       {
-        m_value = 0; // this is to avoid a compilation warning
+        m_value = Scalar(0); // this is to avoid a compilation warning
         m_id = -1;
       }
       return *this;
     }
 
     EIGEN_STRONG_INLINE Scalar value() const { return m_value; }
 
@@ -122,15 +122,15 @@
     const BinaryOp& m_functor;
     Scalar m_value;
     StorageIndex m_id;
   };
   
   
   enum {
-    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
+    CoeffReadCost = int(evaluator<Lhs>::CoeffReadCost) + int(evaluator<Rhs>::CoeffReadCost) + int(functor_traits<BinaryOp>::Cost),
     Flags = XprType::Flags
   };
   
   explicit binary_evaluator(const XprType& xpr)
     : m_functor(xpr.functor()),
       m_lhsImpl(xpr.lhs()), 
       m_rhsImpl(xpr.rhs())  
@@ -207,17 +207,16 @@
     Scalar m_value;
     StorageIndex m_id;
     StorageIndex m_innerSize;
   };
 
 
   enum {
-    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
-    // Expose storage order of the sparse expression
-    Flags = (XprType::Flags & ~RowMajorBit) | (int(Rhs::Flags)&RowMajorBit)
+    CoeffReadCost = int(evaluator<Lhs>::CoeffReadCost) + int(evaluator<Rhs>::CoeffReadCost) + int(functor_traits<BinaryOp>::Cost),
+    Flags = XprType::Flags
   };
 
   explicit binary_evaluator(const XprType& xpr)
     : m_functor(xpr.functor()),
       m_lhsImpl(xpr.lhs()),
       m_rhsImpl(xpr.rhs()),
       m_expr(xpr)
@@ -295,17 +294,16 @@
     Scalar m_value;
     StorageIndex m_id;
     StorageIndex m_innerSize;
   };
 
 
   enum {
-    CoeffReadCost = evaluator<Lhs>::CoeffReadCost + evaluator<Rhs>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
-    // Expose storage order of the sparse expression
-    Flags = (XprType::Flags & ~RowMajorBit) | (int(Lhs::Flags)&RowMajorBit)
+    CoeffReadCost = int(evaluator<Lhs>::CoeffReadCost) + int(evaluator<Rhs>::CoeffReadCost) + int(functor_traits<BinaryOp>::Cost),
+    Flags = XprType::Flags
   };
 
   explicit binary_evaluator(const XprType& xpr)
     : m_functor(xpr.functor()),
       m_lhsImpl(xpr.lhs()),
       m_rhsImpl(xpr.rhs()),
       m_expr(xpr)
@@ -455,15 +453,15 @@
     LhsIterator m_lhsIter;
     RhsIterator m_rhsIter;
     const BinaryOp& m_functor;
   };
   
   
   enum {
-    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
+    CoeffReadCost = int(evaluator<LhsArg>::CoeffReadCost) + int(evaluator<RhsArg>::CoeffReadCost) + int(functor_traits<BinaryOp>::Cost),
     Flags = XprType::Flags
   };
   
   explicit sparse_conjunction_evaluator(const XprType& xpr)
     : m_functor(xpr.functor()),
       m_lhsImpl(xpr.lhs()), 
       m_rhsImpl(xpr.rhs())  
@@ -528,17 +526,16 @@
     RhsIterator m_rhsIter;
     const BinaryOp& m_functor;
     const Index m_outer;
   };
   
   
   enum {
-    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
-    // Expose storage order of the sparse expression
-    Flags = (XprType::Flags & ~RowMajorBit) | (int(RhsArg::Flags)&RowMajorBit)
+    CoeffReadCost = int(evaluator<LhsArg>::CoeffReadCost) + int(evaluator<RhsArg>::CoeffReadCost) + int(functor_traits<BinaryOp>::Cost),
+    Flags = XprType::Flags
   };
   
   explicit sparse_conjunction_evaluator(const XprType& xpr)
     : m_functor(xpr.functor()),
       m_lhsImpl(xpr.lhs()), 
       m_rhsImpl(xpr.rhs())  
   {
@@ -603,17 +600,16 @@
     const evaluator<RhsArg> &m_rhsEval;
     const BinaryOp& m_functor;
     const Index m_outer;
   };
   
   
   enum {
-    CoeffReadCost = evaluator<LhsArg>::CoeffReadCost + evaluator<RhsArg>::CoeffReadCost + functor_traits<BinaryOp>::Cost,
-    // Expose storage order of the sparse expression
-    Flags = (XprType::Flags & ~RowMajorBit) | (int(LhsArg::Flags)&RowMajorBit)
+    CoeffReadCost = int(evaluator<LhsArg>::CoeffReadCost) + int(evaluator<RhsArg>::CoeffReadCost) + int(functor_traits<BinaryOp>::Cost),
+    Flags = XprType::Flags
   };
   
   explicit sparse_conjunction_evaluator(const XprType& xpr)
     : m_functor(xpr.functor()),
       m_lhsImpl(xpr.lhs()), 
       m_rhsImpl(xpr.rhs())  
   {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseCwiseUnaryOp.h`

 * *Files 5% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 {
   public:
     typedef CwiseUnaryOp<UnaryOp, ArgType> XprType;
 
     class InnerIterator;
     
     enum {
-      CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<UnaryOp>::Cost,
+      CoeffReadCost = int(evaluator<ArgType>::CoeffReadCost) + int(functor_traits<UnaryOp>::Cost),
       Flags = XprType::Flags
     };
     
     explicit unary_evaluator(const XprType& op) : m_functor(op.functor()), m_argImpl(op.nestedExpression())
     {
       EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<UnaryOp>::Cost);
       EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
@@ -45,14 +45,15 @@
     evaluator<ArgType> m_argImpl;
 };
 
 template<typename UnaryOp, typename ArgType>
 class unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>::InnerIterator
     : public unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>::EvalIterator
 {
+  protected:
     typedef typename XprType::Scalar Scalar;
     typedef typename unary_evaluator<CwiseUnaryOp<UnaryOp,ArgType>, IteratorBased>::EvalIterator Base;
   public:
 
     EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& unaryOp, Index outer)
       : Base(unaryOp.m_argImpl,outer), m_functor(unaryOp.m_functor)
     {}
@@ -74,15 +75,15 @@
 {
   public:
     typedef CwiseUnaryView<ViewOp, ArgType> XprType;
 
     class InnerIterator;
     
     enum {
-      CoeffReadCost = evaluator<ArgType>::CoeffReadCost + functor_traits<ViewOp>::Cost,
+      CoeffReadCost = int(evaluator<ArgType>::CoeffReadCost) + int(functor_traits<ViewOp>::Cost),
       Flags = XprType::Flags
     };
     
     explicit unary_evaluator(const XprType& op) : m_functor(op.functor()), m_argImpl(op.nestedExpression())
     {
       EIGEN_INTERNAL_CHECK_COST_VALUE(functor_traits<ViewOp>::Cost);
       EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);
@@ -95,14 +96,15 @@
     evaluator<ArgType> m_argImpl;
 };
 
 template<typename ViewOp, typename ArgType>
 class unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>::InnerIterator
     : public unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>::EvalIterator
 {
+  protected:
     typedef typename XprType::Scalar Scalar;
     typedef typename unary_evaluator<CwiseUnaryView<ViewOp,ArgType>, IteratorBased>::EvalIterator Base;
   public:
 
     EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& unaryOp, Index outer)
       : Base(unaryOp.m_argImpl,outer), m_functor(unaryOp.m_functor)
     {}
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseDenseProduct.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseDenseProduct.h`

 * *Files 4% similar despite different names*

```diff
@@ -84,18 +84,19 @@
 
 template<typename SparseLhsType, typename DenseRhsType, typename DenseResType, typename AlphaType>
 struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, AlphaType, ColMajor, true>
 {
   typedef typename internal::remove_all<SparseLhsType>::type Lhs;
   typedef typename internal::remove_all<DenseRhsType>::type Rhs;
   typedef typename internal::remove_all<DenseResType>::type Res;
-  typedef typename evaluator<Lhs>::InnerIterator LhsInnerIterator;
+  typedef evaluator<Lhs> LhsEval;
+  typedef typename LhsEval::InnerIterator LhsInnerIterator;
   static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)
   {
-    evaluator<Lhs> lhsEval(lhs);
+    LhsEval lhsEval(lhs);
     for(Index c=0; c<rhs.cols(); ++c)
     {
       for(Index j=0; j<lhs.outerSize(); ++j)
       {
 //        typename Res::Scalar rhs_j = alpha * rhs.coeff(j,c);
         typename ScalarBinaryOpTraits<AlphaType, typename Rhs::Scalar>::ReturnType rhs_j(alpha * rhs.coeff(j,c));
         for(LhsInnerIterator it(lhsEval,j); it ;++it)
@@ -107,25 +108,46 @@
 
 template<typename SparseLhsType, typename DenseRhsType, typename DenseResType>
 struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, RowMajor, false>
 {
   typedef typename internal::remove_all<SparseLhsType>::type Lhs;
   typedef typename internal::remove_all<DenseRhsType>::type Rhs;
   typedef typename internal::remove_all<DenseResType>::type Res;
-  typedef typename evaluator<Lhs>::InnerIterator LhsInnerIterator;
+  typedef evaluator<Lhs> LhsEval;
+  typedef typename LhsEval::InnerIterator LhsInnerIterator;
   static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha)
   {
-    evaluator<Lhs> lhsEval(lhs);
-    for(Index j=0; j<lhs.outerSize(); ++j)
+    Index n = lhs.rows();
+    LhsEval lhsEval(lhs);
+
+#ifdef EIGEN_HAS_OPENMP
+    Eigen::initParallel();
+    Index threads = Eigen::nbThreads();
+    // This 20000 threshold has been found experimentally on 2D and 3D Poisson problems.
+    // It basically represents the minimal amount of work to be done to be worth it.
+    if(threads>1 && lhsEval.nonZerosEstimate()*rhs.cols() > 20000)
+    {
+      #pragma omp parallel for schedule(dynamic,(n+threads*4-1)/(threads*4)) num_threads(threads)
+      for(Index i=0; i<n; ++i)
+        processRow(lhsEval,rhs,res,alpha,i);
+    }
+    else
+#endif
     {
-      typename Res::RowXpr res_j(res.row(j));
-      for(LhsInnerIterator it(lhsEval,j); it ;++it)
-        res_j += (alpha*it.value()) * rhs.row(it.index());
+      for(Index i=0; i<n; ++i)
+        processRow(lhsEval, rhs, res, alpha, i);
     }
   }
+
+  static void processRow(const LhsEval& lhsEval, const DenseRhsType& rhs, Res& res, const typename Res::Scalar& alpha, Index i)
+  {
+    typename Res::RowXpr res_i(res.row(i));
+    for(LhsInnerIterator it(lhsEval,i); it ;++it)
+      res_i += (alpha*it.value()) * rhs.row(it.index());
+  }
 };
 
 template<typename SparseLhsType, typename DenseRhsType, typename DenseResType>
 struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, typename DenseResType::Scalar, ColMajor, false>
 {
   typedef typename internal::remove_all<SparseLhsType>::type Lhs;
   typedef typename internal::remove_all<DenseRhsType>::type Rhs;
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseDiagonalProduct.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseDiagonalProduct.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseDot.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseDot.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseFuzzy.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseFuzzy.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseMap.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseMap.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseMatrix.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseMatrix.h`

 * *Files 6% similar despite different names*

```diff
@@ -17,15 +17,15 @@
   * \class SparseMatrix
   *
   * \brief A versatible sparse matrix representation
   *
   * This class implements a more versatile variants of the common \em compressed row/column storage format.
   * Each colmun's (resp. row) non zeros are stored as a pair of value with associated row (resp. colmiun) index.
   * All the non zeros are stored in a single large buffer. Unlike the \em compressed format, there might be extra
-  * space inbetween the nonzeros of two successive colmuns (resp. rows) such that insertion of new non-zero
+  * space in between the nonzeros of two successive colmuns (resp. rows) such that insertion of new non-zero
   * can be done with limited memory reallocation and copies.
   *
   * A call to the function makeCompressed() turns the matrix into the standard \em compressed format
   * compatible with many library.
   *
   * More details on this storage sceheme are given in the \ref TutorialSparse "manual pages".
   *
@@ -95,14 +95,16 @@
 template<typename _Scalar, int _Options, typename _StorageIndex>
 class SparseMatrix
   : public SparseCompressedBase<SparseMatrix<_Scalar, _Options, _StorageIndex> >
 {
     typedef SparseCompressedBase<SparseMatrix> Base;
     using Base::convert_index;
     friend class SparseVector<_Scalar,0,_StorageIndex>;
+    template<typename, typename, typename, typename, typename>
+    friend struct internal::Assignment;
   public:
     using Base::isCompressed;
     using Base::nonZeros;
     EIGEN_SPARSE_PUBLIC_INTERFACE(SparseMatrix)
     using Base::operator+=;
     using Base::operator-=;
 
@@ -323,15 +325,16 @@
             m_data.index(newOuterIndex[j]+i) = m_data.index(m_outerIndex[j]+i);
             m_data.value(newOuterIndex[j]+i) = m_data.value(m_outerIndex[j]+i);
           }
           previousOuterIndex = m_outerIndex[j];
           m_outerIndex[j] = newOuterIndex[j];
           m_innerNonZeros[j] = innerNNZ;
         }
-        m_outerIndex[m_outerSize] = m_outerIndex[m_outerSize-1] + m_innerNonZeros[m_outerSize-1] + reserveSizes[m_outerSize-1];
+        if(m_outerSize>0)
+          m_outerIndex[m_outerSize] = m_outerIndex[m_outerSize-1] + m_innerNonZeros[m_outerSize-1] + reserveSizes[m_outerSize-1];
         
         m_data.resize(m_outerIndex[m_outerSize]);
       }
       else
       {
         StorageIndex* newOuterIndex = static_cast<StorageIndex*>(std::malloc((m_outerSize+1)*sizeof(StorageIndex)));
         if (!newOuterIndex) internal::throw_std_bad_alloc();
@@ -498,16 +501,16 @@
         return; 
       m_innerNonZeros = static_cast<StorageIndex*>(std::malloc(m_outerSize * sizeof(StorageIndex)));
       for (Index i = 0; i < m_outerSize; i++)
       {
         m_innerNonZeros[i] = m_outerIndex[i+1] - m_outerIndex[i]; 
       }
     }
-    
-    /** Suppresses all nonzeros which are \b much \b smaller \b than \a reference under the tolerence \a epsilon */
+
+    /** Suppresses all nonzeros which are \b much \b smaller \b than \a reference under the tolerance \a epsilon */
     void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())
     {
       prune(default_prunning_func(reference,epsilon));
     }
     
     /** Turns the matrix into compressed format, and suppresses all nonzeros which do not satisfy the predicate \a keep.
       * The functor type \a KeepFunc must implement the following function:
@@ -572,18 +575,20 @@
         
         for(Index i=m_outerSize; i<m_outerSize+outerChange; i++)          
           m_innerNonZeros[i] = 0;
       } 
       else if (innerChange < 0) 
       {
         // Inner size decreased: allocate a new m_innerNonZeros
-        m_innerNonZeros = static_cast<StorageIndex*>(std::malloc((m_outerSize+outerChange+1) * sizeof(StorageIndex)));
+        m_innerNonZeros = static_cast<StorageIndex*>(std::malloc((m_outerSize + outerChange) * sizeof(StorageIndex)));
         if (!m_innerNonZeros) internal::throw_std_bad_alloc();
-        for(Index i = 0; i < m_outerSize; i++)
+        for(Index i = 0; i < m_outerSize + (std::min)(outerChange, Index(0)); i++)
           m_innerNonZeros[i] = m_outerIndex[i+1] - m_outerIndex[i];
+        for(Index i = m_outerSize; i < m_outerSize + outerChange; i++)
+          m_innerNonZeros[i] = 0;
       }
       
       // Change the m_innerNonZeros in case of a decrease of inner size
       if (m_innerNonZeros && innerChange < 0)
       {
         for(Index i = 0; i < m_outerSize + (std::min)(outerChange, Index(0)); i++)
         {
@@ -600,17 +605,17 @@
         return;
           
       StorageIndex *newOuterIndex = static_cast<StorageIndex*>(std::realloc(m_outerIndex, (m_outerSize + outerChange + 1) * sizeof(StorageIndex)));
       if (!newOuterIndex) internal::throw_std_bad_alloc();
       m_outerIndex = newOuterIndex;
       if (outerChange > 0)
       {
-        StorageIndex last = m_outerSize == 0 ? 0 : m_outerIndex[m_outerSize];
+        StorageIndex lastIdx = m_outerSize == 0 ? 0 : m_outerIndex[m_outerSize];
         for(Index i=m_outerSize; i<m_outerSize+outerChange+1; i++)          
-          m_outerIndex[i] = last; 
+          m_outerIndex[i] = lastIdx; 
       }
       m_outerSize += outerChange;
     }
     
     /** Resizes the matrix to a \a rows x \a cols matrix and initializes it to zero.
       * 
       * This function does not free the currently allocated memory. To release as much as memory as possible,
@@ -776,14 +781,17 @@
       return *this;
     }
 
 #ifndef EIGEN_PARSED_BY_DOXYGEN
     template<typename OtherDerived>
     inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)
     { return Base::operator=(other.derived()); }
+
+    template<typename Lhs, typename Rhs>
+    inline SparseMatrix& operator=(const Product<Lhs,Rhs,AliasFreeProduct>& other);
 #endif // EIGEN_PARSED_BY_DOXYGEN
 
     template<typename OtherDerived>
     EIGEN_DONT_INLINE SparseMatrix& operator=(const SparseMatrixBase<OtherDerived>& other);
 
     friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)
     {
@@ -891,14 +899,121 @@
       eigen_assert(!isCompressed());
       eigen_assert(m_innerNonZeros[outer]<=(m_outerIndex[outer+1] - m_outerIndex[outer]));
 
       Index p = m_outerIndex[outer] + m_innerNonZeros[outer]++;
       m_data.index(p) = convert_index(inner);
       return (m_data.value(p) = Scalar(0));
     }
+protected:
+    struct IndexPosPair {
+      IndexPosPair(Index a_i, Index a_p) : i(a_i), p(a_p) {}
+      Index i;
+      Index p;
+    };
+
+    /** \internal assign \a diagXpr to the diagonal of \c *this
+      * There are different strategies:
+      *   1 - if *this is overwritten (Func==assign_op) or *this is empty, then we can work treat *this as a dense vector expression.
+      *   2 - otherwise, for each diagonal coeff,
+      *     2.a - if it already exists, then we update it,
+      *     2.b - otherwise, if *this is uncompressed and that the current inner-vector has empty room for at least 1 element, then we perform an in-place insertion.
+      *     2.c - otherwise, we'll have to reallocate and copy everything, so instead of doing so for each new element, it is recorded in a std::vector.
+      *   3 - at the end, if some entries failed to be inserted in-place, then we alloc a new buffer, copy each chunk at the right position, and insert the new elements.
+      * 
+      * TODO: some piece of code could be isolated and reused for a general in-place update strategy.
+      * TODO: if we start to defer the insertion of some elements (i.e., case 2.c executed once),
+      *       then it *might* be better to disable case 2.b since they will have to be copied anyway.
+      */
+    template<typename DiagXpr, typename Func>
+    void assignDiagonal(const DiagXpr diagXpr, const Func& assignFunc)
+    {
+      Index n = diagXpr.size();
+
+      const bool overwrite = internal::is_same<Func, internal::assign_op<Scalar,Scalar> >::value;
+      if(overwrite)
+      {
+        if((this->rows()!=n) || (this->cols()!=n))
+          this->resize(n, n);
+      }
+
+      if(m_data.size()==0 || overwrite)
+      {
+        typedef Array<StorageIndex,Dynamic,1> ArrayXI;  
+        this->makeCompressed();
+        this->resizeNonZeros(n);
+        Eigen::Map<ArrayXI>(this->innerIndexPtr(), n).setLinSpaced(0,StorageIndex(n)-1);
+        Eigen::Map<ArrayXI>(this->outerIndexPtr(), n+1).setLinSpaced(0,StorageIndex(n));
+        Eigen::Map<Array<Scalar,Dynamic,1> > values = this->coeffs();
+        values.setZero();
+        internal::call_assignment_no_alias(values, diagXpr, assignFunc);
+      }
+      else
+      {
+        bool isComp = isCompressed();
+        internal::evaluator<DiagXpr> diaEval(diagXpr);
+        std::vector<IndexPosPair> newEntries;
+
+        // 1 - try in-place update and record insertion failures
+        for(Index i = 0; i<n; ++i)
+        {
+          internal::LowerBoundIndex lb = this->lower_bound(i,i);
+          Index p = lb.value;
+          if(lb.found)
+          {
+            // the coeff already exists
+            assignFunc.assignCoeff(m_data.value(p), diaEval.coeff(i));
+          }
+          else if((!isComp) && m_innerNonZeros[i] < (m_outerIndex[i+1]-m_outerIndex[i]))
+          {
+            // non compressed mode with local room for inserting one element
+            m_data.moveChunk(p, p+1, m_outerIndex[i]+m_innerNonZeros[i]-p);
+            m_innerNonZeros[i]++;
+            m_data.value(p) = Scalar(0);
+            m_data.index(p) = StorageIndex(i);
+            assignFunc.assignCoeff(m_data.value(p), diaEval.coeff(i));
+          }
+          else
+          {
+            // defer insertion
+            newEntries.push_back(IndexPosPair(i,p));
+          }
+        }
+        // 2 - insert deferred entries
+        Index n_entries = Index(newEntries.size());
+        if(n_entries>0)
+        {
+          Storage newData(m_data.size()+n_entries);
+          Index prev_p = 0;
+          Index prev_i = 0;
+          for(Index k=0; k<n_entries;++k)
+          {
+            Index i = newEntries[k].i;
+            Index p = newEntries[k].p;
+            internal::smart_copy(m_data.valuePtr()+prev_p, m_data.valuePtr()+p, newData.valuePtr()+prev_p+k);
+            internal::smart_copy(m_data.indexPtr()+prev_p, m_data.indexPtr()+p, newData.indexPtr()+prev_p+k);
+            for(Index j=prev_i;j<i;++j)
+              m_outerIndex[j+1] += k;
+            if(!isComp)
+              m_innerNonZeros[i]++;
+            prev_p = p;
+            prev_i = i;
+            newData.value(p+k) = Scalar(0);
+            newData.index(p+k) = StorageIndex(i);
+            assignFunc.assignCoeff(newData.value(p+k), diaEval.coeff(i));
+          }
+          {
+            internal::smart_copy(m_data.valuePtr()+prev_p, m_data.valuePtr()+m_data.size(), newData.valuePtr()+prev_p+n_entries);
+            internal::smart_copy(m_data.indexPtr()+prev_p, m_data.indexPtr()+m_data.size(), newData.indexPtr()+prev_p+n_entries);
+            for(Index j=prev_i+1;j<=m_outerSize;++j)
+              m_outerIndex[j] += n_entries;
+          }
+          m_data.swap(newData);
+        }
+      }
+    }
 
 private:
   static void check_template_parameters()
   {
     EIGEN_STATIC_ASSERT(NumTraits<StorageIndex>::IsSigned,THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE);
     EIGEN_STATIC_ASSERT((Options&(ColMajor|RowMajor))==Options,INVALID_MATRIX_TEMPLATE_PARAMETERS);
   }
@@ -969,28 +1084,28 @@
   * \endcode
   * See for instance the Eigen::Triplet template class.
   *
   * Here is a typical usage example:
   * \code
     typedef Triplet<double> T;
     std::vector<T> tripletList;
-    triplets.reserve(estimation_of_entries);
+    tripletList.reserve(estimation_of_entries);
     for(...)
     {
       // ...
       tripletList.push_back(T(i,j,v_ij));
     }
     SparseMatrixType m(rows,cols);
     m.setFromTriplets(tripletList.begin(), tripletList.end());
     // m is ready to go!
   * \endcode
   *
   * \warning The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define
   * an abstract iterator over a complex data-structure that would be expensive to evaluate. The triplets should rather
-  * be explicitely stored into a std::vector for instance.
+  * be explicitly stored into a std::vector for instance.
   */
 template<typename Scalar, int _Options, typename _StorageIndex>
 template<typename InputIterators>
 void SparseMatrix<Scalar,_Options,_StorageIndex>::setFromTriplets(const InputIterators& begin, const InputIterators& end)
 {
   internal::set_from_triplets<InputIterators, SparseMatrix<Scalar,_Options,_StorageIndex> >(begin, end, *this, internal::scalar_sum_op<Scalar,Scalar>());
 }
@@ -1228,15 +1343,15 @@
     {
       m_data.index(p) = m_data.index(p-1);
       m_data.value(p) = m_data.value(p-1);
       --p;
     }
     
     m_data.index(p) = convert_index(inner);
-    return (m_data.value(p) = 0);
+    return (m_data.value(p) = Scalar(0));
   }
   
   if(m_data.size() != m_data.allocatedSize())
   {
     // make sure the matrix is compatible to random un-compressed insertion:
     m_data.resize(m_data.allocatedSize());
     this->reserveInnerVectors(Array<StorageIndex,Dynamic,1>::Constant(m_outerSize, 2));
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseMatrixBase.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseMatrixBase.h`

 * *Files 4% similar despite different names*

```diff
@@ -83,14 +83,19 @@
 
       IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,
         /**< This is set to true if either the number of rows or the number of
           * columns is known at compile-time to be equal to 1. Indeed, in that case,
           * we are dealing with a column-vector (if there is only one column) or with
           * a row-vector (if there is only one row). */
 
+      NumDimensions = int(MaxSizeAtCompileTime) == 1 ? 0 : bool(IsVectorAtCompileTime) ? 1 : 2,
+        /**< This value is equal to Tensor::NumDimensions, i.e. 0 for scalars, 1 for vectors,
+         * and 2 for matrices.
+         */
+
       Flags = internal::traits<Derived>::Flags,
         /**< This stores expression \ref flags flags which may or may not be inherited by new expressions
           * constructed from this one. See the \ref flags "list of flags".
           */
 
       IsRowMajor = Flags&RowMajorBit ? 1 : 0,
       
@@ -346,26 +351,14 @@
     RealScalar norm()  const;
     RealScalar blueNorm() const;
 
     TransposeReturnType transpose() { return TransposeReturnType(derived()); }
     const ConstTransposeReturnType transpose() const { return ConstTransposeReturnType(derived()); }
     const AdjointReturnType adjoint() const { return AdjointReturnType(transpose()); }
 
-    // inner-vector
-    typedef Block<Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true>       InnerVectorReturnType;
-    typedef Block<const Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true> ConstInnerVectorReturnType;
-    InnerVectorReturnType innerVector(Index outer);
-    const ConstInnerVectorReturnType innerVector(Index outer) const;
-
-    // set of inner-vectors
-    typedef Block<Derived,Dynamic,Dynamic,true> InnerVectorsReturnType;
-    typedef Block<const Derived,Dynamic,Dynamic,true> ConstInnerVectorsReturnType;
-    InnerVectorsReturnType innerVectors(Index outerStart, Index outerSize);
-    const ConstInnerVectorsReturnType innerVectors(Index outerStart, Index outerSize) const;
-
     DenseMatrixType toDense() const
     {
       return DenseMatrixType(derived());
     }
 
     template<typename OtherDerived>
     bool isApprox(const SparseMatrixBase<OtherDerived>& other,
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparsePermutation.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparsePermutation.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseProduct.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseProduct.h`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 namespace Eigen { 
 
 /** \returns an expression of the product of two sparse matrices.
   * By default a conservative product preserving the symbolic non zeros is performed.
   * The automatic pruning of the small values can be achieved by calling the pruned() function
   * in which case a totally different product algorithm is employed:
   * \code
-  * C = (A*B).pruned();             // supress numerical zeros (exact)
+  * C = (A*B).pruned();             // suppress numerical zeros (exact)
   * C = (A*B).pruned(ref);
   * C = (A*B).pruned(ref,epsilon);
   * \endcode
   * where \c ref is a meaningful non zero reference value.
   * */
 template<typename Derived>
 template<typename OtherDerived>
@@ -160,10 +160,22 @@
 
 protected:
   PlainObject m_result;
 };
 
 } // end namespace internal
 
+// sparse matrix = sparse-product (can be sparse*sparse, sparse*perm, etc.)
+template<typename Scalar, int _Options, typename _StorageIndex>
+template<typename Lhs, typename Rhs>
+SparseMatrix<Scalar,_Options,_StorageIndex>& SparseMatrix<Scalar,_Options,_StorageIndex>::operator=(const Product<Lhs,Rhs,AliasFreeProduct>& src)
+{
+  // std::cout << "in Assignment : " << DstOptions << "\n";
+  SparseMatrix dst(src.rows(),src.cols());
+  internal::generic_product_impl<Lhs, Rhs>::evalTo(dst,src.lhs(),src.rhs());
+  this->swap(dst);
+  return *this;
+}
+
 } // end namespace Eigen
 
 #endif // EIGEN_SPARSEPRODUCT_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseRedux.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseRedux.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseRef.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseRef.h`

 * *Files 2% similar despite different names*

```diff
@@ -197,48 +197,48 @@
     template<typename OtherRef>
     inline Ref(const RefBase<OtherRef>& other) : m_hasCopy(false) {
       construct(other.derived(), typename Traits::template match<OtherRef>::type());
     }
 
     ~Ref() {
       if(m_hasCopy) {
-        TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(m_object_bytes);
+        TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(&m_storage);
         obj->~TPlainObjectType();
       }
     }
 
   protected:
 
     template<typename Expression>
     void construct(const Expression& expr,internal::true_type)
     {
       if((Options & int(StandardCompressedFormat)) && (!expr.isCompressed()))
       {
-        TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(m_object_bytes);
+        TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(&m_storage);
         ::new (obj) TPlainObjectType(expr);
         m_hasCopy = true;
         Base::construct(*obj);
       }
       else
       {
         Base::construct(expr);
       }
     }
 
     template<typename Expression>
     void construct(const Expression& expr, internal::false_type)
     {
-      TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(m_object_bytes);
+      TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(&m_storage);
       ::new (obj) TPlainObjectType(expr);
       m_hasCopy = true;
       Base::construct(*obj);
     }
 
   protected:
-    char m_object_bytes[sizeof(TPlainObjectType)];
+    typename internal::aligned_storage<sizeof(TPlainObjectType), EIGEN_ALIGNOF(TPlainObjectType)>::type m_storage;
     bool m_hasCopy;
 };
 
 
 
 /**
   * \ingroup SparseCore_Module
@@ -315,15 +315,15 @@
     template<typename OtherRef>
     inline Ref(const RefBase<OtherRef>& other) : m_hasCopy(false) {
       construct(other.derived(), typename Traits::template match<OtherRef>::type());
     }
 
     ~Ref() {
       if(m_hasCopy) {
-        TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(m_object_bytes);
+        TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(&m_storage);
         obj->~TPlainObjectType();
       }
     }
 
   protected:
 
     template<typename Expression>
@@ -331,22 +331,22 @@
     {
       Base::construct(expr);
     }
 
     template<typename Expression>
     void construct(const Expression& expr, internal::false_type)
     {
-      TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(m_object_bytes);
+      TPlainObjectType* obj = reinterpret_cast<TPlainObjectType*>(&m_storage);
       ::new (obj) TPlainObjectType(expr);
       m_hasCopy = true;
       Base::construct(*obj);
     }
 
   protected:
-    char m_object_bytes[sizeof(TPlainObjectType)];
+    typename internal::aligned_storage<sizeof(TPlainObjectType), EIGEN_ALIGNOF(TPlainObjectType)>::type m_storage;
     bool m_hasCopy;
 };
 
 namespace internal {
 
 // FIXME shall we introduce a general evaluatior_ref that we can specialize for any sparse object once, and thus remove this copy-pasta thing...
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseSelfAdjointView.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseSelfAdjointView.h`

 * *Files 1% similar despite different names*

```diff
@@ -138,14 +138,17 @@
 
     SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)
     {
       PermutationMatrix<Dynamic,Dynamic,StorageIndex> pnull;
       return *this = src.twistedBy(pnull);
     }
 
+    // Since we override the copy-assignment operator, we need to explicitly re-declare the copy-constructor
+    EIGEN_DEFAULT_COPY_CONSTRUCTOR(SparseSelfAdjointView)
+
     template<typename SrcMatrixType,unsigned int SrcMode>
     SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcMode>& src)
     {
       PermutationMatrix<Dynamic,Dynamic,StorageIndex> pnull;
       return *this = src.twistedBy(pnull);
     }
     
@@ -449,15 +452,15 @@
     Index jp = perm ? perm[j] : j;
     for(MatIterator it(matEval,j); it; ++it)
     {
       Index i = it.index();
       Index r = it.row();
       Index c = it.col();
       Index ip = perm ? perm[i] : i;
-      if(Mode==(Upper|Lower))
+      if(Mode==int(Upper|Lower))
         count[StorageOrderMatch ? jp : ip]++;
       else if(r==c)
         count[ip]++;
       else if(( Mode==Lower && r>c) || ( Mode==Upper && r<c))
       {
         count[ip]++;
         count[jp]++;
@@ -482,15 +485,15 @@
       StorageIndex i = internal::convert_index<StorageIndex>(it.index());
       Index r = it.row();
       Index c = it.col();
       
       StorageIndex jp = perm ? perm[j] : j;
       StorageIndex ip = perm ? perm[i] : i;
       
-      if(Mode==(Upper|Lower))
+      if(Mode==int(Upper|Lower))
       {
         Index k = count[StorageOrderMatch ? jp : ip]++;
         dest.innerIndexPtr()[k] = StorageOrderMatch ? ip : jp;
         dest.valuePtr()[k] = it.value();
       }
       else if(r==c)
       {
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseSolverBase.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseSolverBase.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseSparseProductWithPruning.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseTranspose.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseTranspose.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseTriangularView.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseTriangularView.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseUtil.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseUtil.h`

 * *Files 4% similar despite different names*

```diff
@@ -136,14 +136,22 @@
 
 struct SparseTriangularShape  { static std::string debugName() { return "SparseTriangularShape"; } };
 struct SparseSelfAdjointShape { static std::string debugName() { return "SparseSelfAdjointShape"; } };
 
 template<> struct glue_shapes<SparseShape,SelfAdjointShape> { typedef SparseSelfAdjointShape type;  };
 template<> struct glue_shapes<SparseShape,TriangularShape > { typedef SparseTriangularShape  type;  };
 
+// return type of SparseCompressedBase::lower_bound;
+struct LowerBoundIndex {
+  LowerBoundIndex() : value(-1), found(false) {}
+  LowerBoundIndex(Index val, bool ok) : value(val), found(ok) {}
+  Index value;
+  bool found;
+};
+
 } // end namespace internal
 
 /** \ingroup SparseCore_Module
   *
   * \class Triplet
   *
   * \brief A small structure to hold a non zero as a triplet (i,j,value).
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseVector.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseVector.h`

 * *Files 0% similar despite different names*

```diff
@@ -277,15 +277,15 @@
       : Base(other), m_size(0)
     {
       check_template_parameters();
       *this = other.derived();
     }
 
     /** Swaps the values of \c *this and \a other.
-      * Overloaded for performance: this version performs a \em shallow swap by swaping pointers and attributes only.
+      * Overloaded for performance: this version performs a \em shallow swap by swapping pointers and attributes only.
       * \sa SparseMatrixBase::swap()
       */
     inline void swap(SparseVector& other)
     {
       std::swap(m_size, other.m_size);
       m_data.swap(other.m_data);
     }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/SparseView.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/SparseView.h`

 * *Files 1% similar despite different names*

```diff
@@ -86,14 +86,15 @@
 {
     typedef typename evaluator<ArgType>::InnerIterator EvalIterator;
   public:
     typedef SparseView<ArgType> XprType;
     
     class InnerIterator : public EvalIterator
     {
+      protected:
         typedef typename XprType::Scalar Scalar;
       public:
 
         EIGEN_STRONG_INLINE InnerIterator(const unary_evaluator& sve, Index outer)
           : EvalIterator(sve.m_argImpl,outer), m_view(sve.m_view)
         {
           incrementToNonZero();
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseCore/TriangularSolver.h` & `chronogram-0.2.0/include/Eigen/src/SparseCore/TriangularSolver.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU.h`

 * *Files 10% similar despite different names*

```diff
@@ -14,23 +14,80 @@
 
 namespace Eigen {
 
 template <typename _MatrixType, typename _OrderingType = COLAMDOrdering<typename _MatrixType::StorageIndex> > class SparseLU;
 template <typename MappedSparseMatrixType> struct SparseLUMatrixLReturnType;
 template <typename MatrixLType, typename MatrixUType> struct SparseLUMatrixUReturnType;
 
+template <bool Conjugate,class SparseLUType>
+class SparseLUTransposeView : public SparseSolverBase<SparseLUTransposeView<Conjugate,SparseLUType> >
+{
+protected:
+  typedef SparseSolverBase<SparseLUTransposeView<Conjugate,SparseLUType> > APIBase;
+  using APIBase::m_isInitialized;
+public:
+  typedef typename SparseLUType::Scalar Scalar;
+  typedef typename SparseLUType::StorageIndex StorageIndex;
+  typedef typename SparseLUType::MatrixType MatrixType;
+  typedef typename SparseLUType::OrderingType OrderingType;
+
+  enum {
+    ColsAtCompileTime = MatrixType::ColsAtCompileTime,
+    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
+  };
+
+  SparseLUTransposeView() : m_sparseLU(NULL) {}
+  SparseLUTransposeView(const SparseLUTransposeView& view) {
+    this->m_sparseLU = view.m_sparseLU;
+  }
+  void setIsInitialized(const bool isInitialized) {this->m_isInitialized = isInitialized;}
+  void setSparseLU(SparseLUType* sparseLU) {m_sparseLU = sparseLU;}
+  using APIBase::_solve_impl;
+  template<typename Rhs, typename Dest>
+  bool _solve_impl(const MatrixBase<Rhs> &B, MatrixBase<Dest> &X_base) const
+  {
+    Dest& X(X_base.derived());
+    eigen_assert(m_sparseLU->info() == Success && "The matrix should be factorized first");
+    EIGEN_STATIC_ASSERT((Dest::Flags&RowMajorBit)==0,
+                        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES);
+
+
+    // this ugly const_cast_derived() helps to detect aliasing when applying the permutations
+    for(Index j = 0; j < B.cols(); ++j){
+      X.col(j) = m_sparseLU->colsPermutation() * B.const_cast_derived().col(j);
+    }
+    //Forward substitution with transposed or adjoint of U
+    m_sparseLU->matrixU().template solveTransposedInPlace<Conjugate>(X);
+
+    //Backward substitution with transposed or adjoint of L
+    m_sparseLU->matrixL().template solveTransposedInPlace<Conjugate>(X);
+
+    // Permute back the solution
+    for (Index j = 0; j < B.cols(); ++j)
+      X.col(j) = m_sparseLU->rowsPermutation().transpose() * X.col(j);
+    return true;
+  }
+  inline Index rows() const { return m_sparseLU->rows(); }
+  inline Index cols() const { return m_sparseLU->cols(); }
+
+private:
+  SparseLUType *m_sparseLU;
+  SparseLUTransposeView& operator=(const SparseLUTransposeView&);
+};
+
+
 /** \ingroup SparseLU_Module
   * \class SparseLU
   * 
   * \brief Sparse supernodal LU factorization for general matrices
   * 
   * This class implements the supernodal LU factorization for general matrices.
   * It uses the main techniques from the sequential SuperLU package 
   * (http://crd-legacy.lbl.gov/~xiaoye/SuperLU/). It handles transparently real 
-  * and complex arithmetics with single and double precision, depending on the 
+  * and complex arithmetic with single and double precision, depending on the 
   * scalar type of your input matrix. 
   * The code has been optimized to provide BLAS-3 operations during supernode-panel updates. 
   * It benefits directly from the built-in high-performant Eigen BLAS routines. 
   * Moreover, when the size of a supernode is very small, the BLAS calls are avoided to 
   * enable a better optimization from the compiler. For best performance, 
   * you should compile it with NDEBUG flag to avoid the numerous bounds checking on vectors. 
   * 
@@ -39,16 +96,16 @@
   * numerical factorization. The cheapest method available is COLAMD. 
   * See  \link OrderingMethods_Module the OrderingMethods module \endlink for the list of 
   * built-in and external ordering methods. 
   *
   * Simple example with key steps 
   * \code
   * VectorXd x(n), b(n);
-  * SparseMatrix<double, ColMajor> A;
-  * SparseLU<SparseMatrix<scalar, ColMajor>, COLAMDOrdering<Index> >   solver;
+  * SparseMatrix<double> A;
+  * SparseLU<SparseMatrix<double>, COLAMDOrdering<int> >   solver;
   * // fill A and b;
   * // Compute the ordering permutation vector from the structural pattern of A
   * solver.analyzePattern(A); 
   * // Compute the numerical factorization 
   * solver.factorize(A); 
   * //Use the factors to solve the linear system 
   * x = solver.solve(b); 
@@ -93,14 +150,15 @@
 
     enum {
       ColsAtCompileTime = MatrixType::ColsAtCompileTime,
       MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime
     };
     
   public:
+
     SparseLU():m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)
     {
       initperfvalues(); 
     }
     explicit SparseLU(const MatrixType& matrix)
       : m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)
     {
@@ -124,14 +182,53 @@
     void compute (const MatrixType& matrix)
     {
       // Analyze 
       analyzePattern(matrix); 
       //Factorize
       factorize(matrix);
     } 
+
+    /** \returns an expression of the transposed of the factored matrix.
+      *
+      * A typical usage is to solve for the transposed problem A^T x = b:
+      * \code
+      * solver.compute(A);
+      * x = solver.transpose().solve(b);
+      * \endcode
+      *
+      * \sa adjoint(), solve()
+      */
+    const SparseLUTransposeView<false,SparseLU<_MatrixType,_OrderingType> > transpose()
+    {
+      SparseLUTransposeView<false,  SparseLU<_MatrixType,_OrderingType> > transposeView;
+      transposeView.setSparseLU(this);
+      transposeView.setIsInitialized(this->m_isInitialized);
+      return transposeView;
+    }
+
+
+    /** \returns an expression of the adjoint of the factored matrix
+      *
+      * A typical usage is to solve for the adjoint problem A' x = b:
+      * \code
+      * solver.compute(A);
+      * x = solver.adjoint().solve(b);
+      * \endcode
+      *
+      * For real scalar types, this function is equivalent to transpose().
+      *
+      * \sa transpose(), solve()
+      */
+    const SparseLUTransposeView<true, SparseLU<_MatrixType,_OrderingType> > adjoint()
+    {
+      SparseLUTransposeView<true,  SparseLU<_MatrixType,_OrderingType> > adjointView;
+      adjointView.setSparseLU(this);
+      adjointView.setIsInitialized(this->m_isInitialized);
+      return adjointView;
+    }
     
     inline Index rows() const { return m_mat.rows(); }
     inline Index cols() const { return m_mat.cols(); }
     /** Indicate that the pattern of the input matrix is symmetric */
     void isSymmetric(bool sym)
     {
       m_symmetricmode = sym;
@@ -189,15 +286,15 @@
       */
     template<typename Rhs>
     inline const Solve<SparseLU, Rhs> solve(const MatrixBase<Rhs>& B) const;
 #endif // EIGEN_PARSED_BY_DOXYGEN
     
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the LU factorization reports a problem, zero diagonal for instance
       *          \c InvalidInput if the input matrix is invalid
       *
       * \sa iparm()          
       */
     ComputationInfo info() const
     {
@@ -351,14 +448,17 @@
             break;
           }
         }
       }
       return (m_detPermR * m_detPermC) > 0 ? det : -det;
     }
 
+    Index nnzL() const { return m_nnzL; };
+    Index nnzU() const { return m_nnzU; };
+
   protected:
     // Functions 
     void initperfvalues()
     {
       m_perfv.panel_size = 16;
       m_perfv.relax = 1; 
       m_perfv.maxsuper = 128; 
@@ -387,15 +487,14 @@
     internal::perfvalues m_perfv;
     RealScalar m_diagpivotthresh; // Specifies the threshold used for a diagonal entry to be an acceptable pivot
     Index m_nnzL, m_nnzU; // Nonzeros in L and U factors
     Index m_detPermR, m_detPermC; // Determinants of the permutation matrices
   private:
     // Disable copy constructor 
     SparseLU (const SparseLU& );
-  
 }; // End class SparseLU
 
 
 
 // Functions needed by the anaysis phase
 /** 
   * Compute the column permutation to minimize the fill-in
@@ -497,15 +596,14 @@
 {
   using internal::emptyIdxLU;
   eigen_assert(m_analysisIsOk && "analyzePattern() should be called first"); 
   eigen_assert((matrix.rows() == matrix.cols()) && "Only for squared matrices");
   
   m_isInitialized = true;
   
-  
   // Apply the column permutation computed in analyzepattern()
   //   m_mat = matrix * m_perm_c.inverse(); 
   m_mat = matrix;
   if (m_perm_c.size()) 
   {
     m_mat.uncompress(); //NOTE: The effect of this command is only to create the InnerNonzeros pointers.
     //Then, permute only the column pointers
@@ -581,15 +679,14 @@
   m_glu.supno(0) = emptyIdxLU; m_glu.xsup.setConstant(0);
   m_glu.xsup(0) = m_glu.xlsub(0) = m_glu.xusub(0) = m_glu.xlusup(0) = Index(0);
   
   // Work on one 'panel' at a time. A panel is one of the following :
   //  (a) a relaxed supernode at the bottom of the etree, or
   //  (b) panel_size contiguous columns, <panel_size> defined by the user
   Index jcol; 
-  IndexVector panel_histo(n);
   Index pivrow; // Pivotal row number in the original row matrix
   Index nseg1; // Number of segments in U-column above panel row jcol
   Index nseg; // Number of segments in each U-column 
   Index irep; 
   Index i, k, jj; 
   for (jcol = 0; jcol < n; )
   {
@@ -700,33 +797,39 @@
 
 template<typename MappedSupernodalType>
 struct SparseLUMatrixLReturnType : internal::no_assignment_operator
 {
   typedef typename MappedSupernodalType::Scalar Scalar;
   explicit SparseLUMatrixLReturnType(const MappedSupernodalType& mapL) : m_mapL(mapL)
   { }
-  Index rows() { return m_mapL.rows(); }
-  Index cols() { return m_mapL.cols(); }
+  Index rows() const { return m_mapL.rows(); }
+  Index cols() const { return m_mapL.cols(); }
   template<typename Dest>
   void solveInPlace( MatrixBase<Dest> &X) const
   {
     m_mapL.solveInPlace(X);
   }
+  template<bool Conjugate, typename Dest>
+  void solveTransposedInPlace( MatrixBase<Dest> &X) const
+  {
+    m_mapL.template solveTransposedInPlace<Conjugate>(X);
+  }
+
   const MappedSupernodalType& m_mapL;
 };
 
 template<typename MatrixLType, typename MatrixUType>
 struct SparseLUMatrixUReturnType : internal::no_assignment_operator
 {
   typedef typename MatrixLType::Scalar Scalar;
   SparseLUMatrixUReturnType(const MatrixLType& mapL, const MatrixUType& mapU)
   : m_mapL(mapL),m_mapU(mapU)
   { }
-  Index rows() { return m_mapL.rows(); }
-  Index cols() { return m_mapL.cols(); }
+  Index rows() const { return m_mapL.rows(); }
+  Index cols() const { return m_mapL.cols(); }
 
   template<typename Dest>   void solveInPlace(MatrixBase<Dest> &X) const
   {
     Index nrhs = X.cols();
     Index n    = X.rows();
     // Backward solve with U
     for (Index k = m_mapL.nsuper(); k >= 0; k--)
@@ -741,16 +844,17 @@
         for (Index j = 0; j < nrhs; j++)
         {
           X(fsupc, j) /= m_mapL.valuePtr()[luptr];
         }
       }
       else
       {
+        // FIXME: the following lines should use Block expressions and not Map!
         Map<const Matrix<Scalar,Dynamic,Dynamic, ColMajor>, 0, OuterStride<> > A( &(m_mapL.valuePtr()[luptr]), nsupc, nsupc, OuterStride<>(lda) );
-        Map< Matrix<Scalar,Dynamic,Dest::ColsAtCompileTime, ColMajor>, 0, OuterStride<> > U (&(X(fsupc,0)), nsupc, nrhs, OuterStride<>(n) );
+        Map< Matrix<Scalar,Dynamic,Dest::ColsAtCompileTime, ColMajor>, 0, OuterStride<> > U (&(X.coeffRef(fsupc,0)), nsupc, nrhs, OuterStride<>(n) );
         U = A.template triangularView<Upper>().solve(U);
       }
 
       for (Index j = 0; j < nrhs; ++j)
       {
         for (Index jcol = fsupc; jcol < fsupc + nsupc; jcol++)
         {
@@ -760,14 +864,60 @@
             Index irow = it.index();
             X(irow, j) -= X(jcol, j) * it.value();
           }
         }
       }
     } // End For U-solve
   }
+
+  template<bool Conjugate, typename Dest>   void solveTransposedInPlace(MatrixBase<Dest> &X) const
+  {
+    using numext::conj;
+    Index nrhs = X.cols();
+    Index n    = X.rows();
+    // Forward solve with U
+    for (Index k = 0; k <=  m_mapL.nsuper(); k++)
+    {
+      Index fsupc = m_mapL.supToCol()[k];
+      Index lda = m_mapL.colIndexPtr()[fsupc+1] - m_mapL.colIndexPtr()[fsupc]; // leading dimension
+      Index nsupc = m_mapL.supToCol()[k+1] - fsupc;
+      Index luptr = m_mapL.colIndexPtr()[fsupc];
+
+      for (Index j = 0; j < nrhs; ++j)
+      {
+        for (Index jcol = fsupc; jcol < fsupc + nsupc; jcol++)
+        {
+          typename MatrixUType::InnerIterator it(m_mapU, jcol);
+          for ( ; it; ++it)
+          {
+            Index irow = it.index();
+            X(jcol, j) -= X(irow, j) * (Conjugate? conj(it.value()): it.value());
+          }
+        }
+      }
+      if (nsupc == 1)
+      {
+        for (Index j = 0; j < nrhs; j++)
+        {
+          X(fsupc, j) /= (Conjugate? conj(m_mapL.valuePtr()[luptr]) : m_mapL.valuePtr()[luptr]);
+        }
+      }
+      else
+      {
+        Map<const Matrix<Scalar,Dynamic,Dynamic, ColMajor>, 0, OuterStride<> > A( &(m_mapL.valuePtr()[luptr]), nsupc, nsupc, OuterStride<>(lda) );
+        Map< Matrix<Scalar,Dynamic,Dest::ColsAtCompileTime, ColMajor>, 0, OuterStride<> > U (&(X(fsupc,0)), nsupc, nrhs, OuterStride<>(n) );
+        if(Conjugate)
+          U = A.adjoint().template triangularView<Lower>().solve(U);
+        else
+          U = A.transpose().template triangularView<Lower>().solve(U);
+      }
+    }// End For U-solve
+  }
+
+
   const MatrixLType& m_mapL;
   const MatrixUType& m_mapU;
 };
 
 } // End namespace Eigen 
 
 #endif
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLUImpl.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLUImpl.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_Memory.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_Memory.h`

 * *Files 0% similar despite different names*

```diff
@@ -47,15 +47,15 @@
   return (2*w + 4 + LUNoMarker) * m * sizeof(Index) + (w + 1) * m * sizeof(Scalar);
 }
 
 
 
 
 /** 
-  * Expand the existing storage to accomodate more fill-ins
+  * Expand the existing storage to accommodate more fill-ins
   * \param vec Valid pointer to the vector to allocate or expand
   * \param[in,out] length  At input, contain the current length of the vector that is to be increased. At output, length of the newly allocated vector
   * \param[in] nbElts Current number of elements in the factors
   * \param keep_prev  1: use length  and do not expand the vector; 0: compute new_len and expand
   * \param[in,out] num_expansions Number of times the memory has been expanded
   */
 template <typename Scalar, typename StorageIndex>
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_Structs.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_Structs.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h`

 * *Files 19% similar despite different names*

```diff
@@ -71,20 +71,20 @@
       m_col_to_sup = col_to_sup.data(); 
       m_sup_to_col = sup_to_col.data(); 
     }
     
     /**
      * Number of rows
      */
-    Index rows() { return m_row; }
+    Index rows() const { return m_row; }
     
     /**
      * Number of columns
      */
-    Index cols() { return m_col; }
+    Index cols() const { return m_col; }
     
     /**
      * Return the array of nonzero values packed by column
      * 
      * The size is nnz
      */
     Scalar* valuePtr() {  return m_nzval; }
@@ -152,14 +152,17 @@
     {
       return m_nsuper; 
     }
     
     class InnerIterator; 
     template<typename Dest>
     void solveInPlace( MatrixBase<Dest>&X) const;
+    template<bool Conjugate, typename Dest>
+    void solveTransposedInPlace( MatrixBase<Dest>&X) const;
+
     
       
       
     
   protected:
     Index m_row; // Number of rows
     Index m_col; // Number of columns
@@ -290,12 +293,83 @@
             iptr++;
           }
         }
       }
     } 
 }
 
+template<typename Scalar, typename Index_>
+template<bool Conjugate, typename Dest>
+void MappedSuperNodalMatrix<Scalar,Index_>::solveTransposedInPlace( MatrixBase<Dest>&X) const
+{
+    using numext::conj;
+  Index n    = int(X.rows());
+  Index nrhs = Index(X.cols());
+  const Scalar * Lval = valuePtr();                 // Nonzero values
+  Matrix<Scalar,Dynamic,Dest::ColsAtCompileTime, ColMajor> work(n, nrhs);     // working vector
+  work.setZero();
+  for (Index k = nsuper(); k >= 0; k--)
+  {
+    Index fsupc = supToCol()[k];                    // First column of the current supernode
+    Index istart = rowIndexPtr()[fsupc];            // Pointer index to the subscript of the current column
+    Index nsupr = rowIndexPtr()[fsupc+1] - istart;  // Number of rows in the current supernode
+    Index nsupc = supToCol()[k+1] - fsupc;          // Number of columns in the current supernode
+    Index nrow = nsupr - nsupc;                     // Number of rows in the non-diagonal part of the supernode
+    Index irow;                                     //Current index row
+
+    if (nsupc == 1 )
+    {
+      for (Index j = 0; j < nrhs; j++)
+      {
+        InnerIterator it(*this, fsupc);
+        ++it; // Skip the diagonal element
+        for (; it; ++it)
+        {
+          irow = it.row();
+          X(fsupc,j) -= X(irow, j) * (Conjugate?conj(it.value()):it.value());
+        }
+      }
+    }
+    else
+    {
+      // The supernode has more than one column
+      Index luptr = colIndexPtr()[fsupc];
+      Index lda = colIndexPtr()[fsupc+1] - luptr;
+
+      //Begin Gather
+      for (Index j = 0; j < nrhs; j++)
+      {
+        Index iptr = istart + nsupc;
+        for (Index i = 0; i < nrow; i++)
+        {
+          irow = rowIndex()[iptr];
+          work.topRows(nrow)(i,j)= X(irow,j); // Gather operation
+          iptr++;
+        }
+      }
+
+      // Matrix-vector product with transposed submatrix
+      Map<const Matrix<Scalar,Dynamic,Dynamic, ColMajor>, 0, OuterStride<> > A( &(Lval[luptr+nsupc]), nrow, nsupc, OuterStride<>(lda) );
+      Map< Matrix<Scalar,Dynamic,Dest::ColsAtCompileTime, ColMajor>, 0, OuterStride<> > U (&(X(fsupc,0)), nsupc, nrhs, OuterStride<>(n) );
+      if(Conjugate)
+        U = U - A.adjoint() * work.topRows(nrow);
+      else
+        U = U - A.transpose() * work.topRows(nrow);
+
+      // Triangular solve (of transposed diagonal block)
+      new (&A) Map<const Matrix<Scalar,Dynamic,Dynamic, ColMajor>, 0, OuterStride<> > ( &(Lval[luptr]), nsupc, nsupc, OuterStride<>(lda) );
+      if(Conjugate)
+        U = A.adjoint().template triangularView<UnitUpper>().solve(U);
+      else
+        U = A.transpose().template triangularView<UnitUpper>().solve(U);
+
+    }
+
+  }
+}
+
+
 } // end namespace internal
 
 } // end namespace Eigen
 
 #endif // EIGEN_SPARSELU_MATRIX_H
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_Utils.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_Utils.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_column_bmod.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_column_bmod.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_column_dfs.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_column_dfs.h`

 * *Files 1% similar despite different names*

```diff
@@ -147,30 +147,30 @@
     if (jsuper == emptyIdxLU)
     { // starts a new supernode 
       if ( (fsupc < jcolm1-1) ) 
       { // >= 3 columns in nsuper
         StorageIndex ito = glu.xlsub(fsupc+1);
         glu.xlsub(jcolm1) = ito; 
         StorageIndex istop = ito + jptr - jm1ptr; 
-        xprune(jcolm1) = istop; // intialize xprune(jcol-1)
+        xprune(jcolm1) = istop; // initialize xprune(jcol-1)
         glu.xlsub(jcol) = istop; 
         
         for (StorageIndex ifrom = jm1ptr; ifrom < nextl; ++ifrom, ++ito)
           glu.lsub(ito) = glu.lsub(ifrom); 
         nextl = ito;  // = istop + length(jcol)
       }
       nsuper++; 
       glu.supno(jcol) = nsuper; 
     } // if a new supernode 
   } // end else:  jcol > 0
   
   // Tidy up the pointers before exit
   glu.xsup(nsuper+1) = jcolp1; 
   glu.supno(jcolp1) = nsuper; 
-  xprune(jcol) = StorageIndex(nextl);  // Intialize upper bound for pruning
+  xprune(jcol) = StorageIndex(nextl);  // Initialize upper bound for pruning
   glu.xlsub(jcolp1) = StorageIndex(nextl); 
   
   return 0; 
 }
 
 } // end namespace internal
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_copy_to_ucol.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_gemm_kernel.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_gemm_kernel.h`

 * *Files 1% similar despite different names*

```diff
@@ -211,15 +211,15 @@
                    a1 = pload<Packet>(A1+i+(I+1)*PacketSize);   \
         if(RK==4){ KMADD(c0, a2, b20, t0)                      }\
         if(RK==4){ a2 = pload<Packet>(A2+i+(I+1)*PacketSize);  }\
         if(RK==4){ KMADD(c0, a3, b30, t0)                      }\
         if(RK==4){ a3 = pload<Packet>(A3+i+(I+1)*PacketSize);  }\
                    pstore(C0+i+(I)*PacketSize, c0);
         
-        // agressive vectorization and peeling
+        // aggressive vectorization and peeling
         for(Index i=0; i<actual_b_end1; i+=PacketSize*8)
         {
           EIGEN_ASM_COMMENT("SPARSELU_GEMML_KERNEL2");
           WORK(0);
           WORK(1);
           WORK(2);
           WORK(3);
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_heap_relax_snode.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_heap_relax_snode.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_kernel_bmod.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_kernel_bmod.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_panel_bmod.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_panel_bmod.h`

 * *Files 0% similar despite different names*

```diff
@@ -34,15 +34,15 @@
 namespace Eigen {
 namespace internal {
 
 /**
  * \brief Performs numeric block updates (sup-panel) in topological order.
  * 
  * Before entering this routine, the original nonzeros in the panel
- * were already copied i nto the spa[m,w]
+ * were already copied into the spa[m,w]
  * 
  * \param m number of rows in the matrix
  * \param w Panel size
  * \param jcol Starting  column of the panel
  * \param nseg Number of segments in the U part
  * \param dense Store the full representation of the panel 
  * \param tempv working array
```

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_panel_dfs.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_panel_dfs.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_pivotL.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_pivotL.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_pruneL.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_pruneL.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseLU/SparseLU_relax_snode.h` & `chronogram-0.2.0/include/Eigen/src/SparseLU/SparseLU_relax_snode.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SparseQR/SparseQR.h` & `chronogram-0.2.0/include/Eigen/src/SparseQR/SparseQR.h`

 * *Files 3% similar despite different names*

```diff
@@ -37,37 +37,49 @@
     typedef typename Derived::PlainObject ReturnType;
   };
 } // End namespace internal
 
 /**
   * \ingroup SparseQR_Module
   * \class SparseQR
-  * \brief Sparse left-looking rank-revealing QR factorization
+  * \brief Sparse left-looking QR factorization with numerical column pivoting
   * 
-  * This class implements a left-looking rank-revealing QR decomposition 
-  * of sparse matrices. When a column has a norm less than a given tolerance
+  * This class implements a left-looking QR decomposition of sparse matrices
+  * with numerical column pivoting.
+  * When a column has a norm less than a given tolerance
   * it is implicitly permuted to the end. The QR factorization thus obtained is 
   * given by A*P = Q*R where R is upper triangular or trapezoidal. 
   * 
   * P is the column permutation which is the product of the fill-reducing and the
-  * rank-revealing permutations. Use colsPermutation() to get it.
+  * numerical permutations. Use colsPermutation() to get it.
   * 
   * Q is the orthogonal matrix represented as products of Householder reflectors. 
   * Use matrixQ() to get an expression and matrixQ().adjoint() to get the adjoint.
   * You can then apply it to a vector.
   * 
   * R is the sparse triangular or trapezoidal matrix. The later occurs when A is rank-deficient.
   * matrixR().topLeftCorner(rank(), rank()) always returns a triangular factor of full rank.
   * 
   * \tparam _MatrixType The type of the sparse matrix A, must be a column-major SparseMatrix<>
   * \tparam _OrderingType The fill-reducing ordering method. See the \link OrderingMethods_Module 
   *  OrderingMethods \endlink module for the list of built-in and external ordering methods.
   * 
   * \implsparsesolverconcept
   *
+  * The numerical pivoting strategy and default threshold are the same as in SuiteSparse QR, and
+  * detailed in the following paper:
+  * <i>
+  * Tim Davis, "Algorithm 915, SuiteSparseQR: Multifrontal Multithreaded Rank-Revealing
+  * Sparse QR Factorization, ACM Trans. on Math. Soft. 38(1), 2011.
+  * </i>
+  * Even though it is qualified as "rank-revealing", this strategy might fail for some 
+  * rank deficient problems. When this class is used to solve linear or least-square problems
+  * it is thus strongly recommended to check the accuracy of the computed solution. If it
+  * failed, it usually helps to increase the threshold with setPivotThreshold.
+  * 
   * \warning The input sparse matrix A must be in compressed mode (see SparseMatrix::makeCompressed()).
   * \warning For complex matrices matrixQ().transpose() will actually return the adjoint matrix.
   * 
   */
 template<typename _MatrixType, typename _OrderingType>
 class SparseQR : public SparseSolverBase<SparseQR<_MatrixType,_OrderingType> >
 {
@@ -327,15 +339,15 @@
   m_outputPerm_c = m_perm_c.inverse();
   internal::coletree(matCpy, m_etree, m_firstRowElt, m_outputPerm_c.indices().data());
   m_isEtreeOk = true;
   
   m_R.resize(m, n);
   m_Q.resize(m, diagSize);
   
-  // Allocate space for nonzero elements : rough estimation
+  // Allocate space for nonzero elements: rough estimation
   m_R.reserve(2*mat.nonZeros()); //FIXME Get a more accurate estimation through symbolic factorization with the etree
   m_Q.reserve(2*mat.nonZeros());
   m_hcoeffs.resize(diagSize);
   m_analysisIsok = true;
 }
 
 /** \brief Performs the numerical QR factorization of the input matrix
@@ -636,15 +648,16 @@
       eigen_assert(m_qr.matrixQ().cols() == m_other.rows() && "Non conforming object sizes");
 
       res.conservativeResize(rows(), cols());
 
       // Compute res = Q * other column by column
       for(Index j = 0; j < res.cols(); j++)
       {
-        for (Index k = diagSize-1; k >=0; k--)
+        Index start_k = internal::is_identity<Derived>::value ? numext::mini(j,diagSize-1) : diagSize-1;
+        for (Index k = start_k; k >=0; k--)
         {
           Scalar tau = Scalar(0);
           tau = m_qr.m_Q.col(k).dot(res.col(j));
           if(tau==Scalar(0)) continue;
           tau = tau * numext::conj(m_qr.m_hcoeffs(k));
           res.col(j) -= tau * m_qr.m_Q.col(k);
         }
```

### Comparing `chronogram-0.1.7/include/Eigen/src/StlSupport/StdDeque.h` & `chronogram-0.2.0/include/Eigen/src/StlSupport/StdDeque.h`

 * *Files 8% similar despite different names*

```diff
@@ -32,15 +32,15 @@
     typedef deque_base::size_type size_type;  \
     typedef deque_base::iterator iterator;  \
     explicit deque(const allocator_type& a = allocator_type()) : deque_base(a) {}  \
     template<typename InputIterator> \
     deque(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) : deque_base(first, last, a) {} \
     deque(const deque& c) : deque_base(c) {}  \
     explicit deque(size_type num, const value_type& val = value_type()) : deque_base(num, val) {} \
-    deque(iterator start, iterator end) : deque_base(start, end) {}  \
+    deque(iterator start_, iterator end_) : deque_base(start_, end_) {}  \
     deque& operator=(const deque& x) {  \
       deque_base::operator=(x);  \
       return *this;  \
     } \
   }; \
 }
 
@@ -58,15 +58,15 @@
     typedef typename deque_base::const_iterator const_iterator;  \
     explicit deque(const allocator_type& a = allocator_type()) : deque_base(a) {}  \
     template<typename InputIterator> \
     deque(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) \
     : deque_base(first, last, a) {} \
     deque(const deque& c) : deque_base(c) {}  \
     explicit deque(size_type num, const value_type& val = value_type()) : deque_base(num, val) {} \
-    deque(iterator start, iterator end) : deque_base(start, end) {}  \
+    deque(iterator start_, iterator end_) : deque_base(start_, end_) {}  \
     deque& operator=(const deque& x) {  \
       deque_base::operator=(x);  \
       return *this;  \
     }
 
   template<typename T>
   class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >
@@ -94,25 +94,15 @@
   void push_front(const value_type& x)
   { deque_base::push_front(x); }
   using deque_base::insert;  
   iterator insert(const_iterator position, const value_type& x)
   { return deque_base::insert(position,x); }
   void insert(const_iterator position, size_type new_size, const value_type& x)
   { deque_base::insert(position, new_size, x); }
-#elif defined(_GLIBCXX_DEQUE) && EIGEN_GNUC_AT_LEAST(4,2)
-  // workaround GCC std::deque implementation
-  void resize(size_type new_size, const value_type& x)
-  {
-    if (new_size < deque_base::size())
-      deque_base::_M_erase_at_end(this->_M_impl._M_start + new_size);
-    else
-      deque_base::insert(deque_base::end(), new_size - deque_base::size(), x);
-  }
 #else
-  // either GCC 4.1 or non-GCC
   // default implementation which should always work.
   void resize(size_type new_size, const value_type& x)
   {
     if (new_size < deque_base::size())
       deque_base::erase(deque_base::begin() + new_size, deque_base::end());
     else if (new_size > deque_base::size())
       deque_base::insert(deque_base::end(), new_size - deque_base::size(), x);
```

### Comparing `chronogram-0.1.7/include/Eigen/src/StlSupport/StdList.h` & `chronogram-0.2.0/include/Eigen/src/StlSupport/StdList.h`

 * *Files 4% similar despite different names*

```diff
@@ -31,15 +31,15 @@
     typedef list_base::size_type size_type;  \
     typedef list_base::iterator iterator;  \
     explicit list(const allocator_type& a = allocator_type()) : list_base(a) {}  \
     template<typename InputIterator> \
     list(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) : list_base(first, last, a) {} \
     list(const list& c) : list_base(c) {}  \
     explicit list(size_type num, const value_type& val = value_type()) : list_base(num, val) {} \
-    list(iterator start, iterator end) : list_base(start, end) {}  \
+    list(iterator start_, iterator end_) : list_base(start_, end_) {}  \
     list& operator=(const list& x) {  \
       list_base::operator=(x);  \
       return *this;  \
     } \
   }; \
 }
 
@@ -58,15 +58,15 @@
     typedef typename list_base::const_iterator const_iterator;  \
     explicit list(const allocator_type& a = allocator_type()) : list_base(a) {}  \
     template<typename InputIterator> \
     list(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) \
     : list_base(first, last, a) {} \
     list(const list& c) : list_base(c) {}  \
     explicit list(size_type num, const value_type& val = value_type()) : list_base(num, val) {} \
-    list(iterator start, iterator end) : list_base(start, end) {}  \
+    list(iterator start_, iterator end_) : list_base(start_, end_) {}  \
     list& operator=(const list& x) {  \
     list_base::operator=(x);  \
     return *this; \
   }
 
   template<typename T>
   class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >
```

### Comparing `chronogram-0.1.7/include/Eigen/src/StlSupport/StdVector.h` & `chronogram-0.2.0/include/Eigen/src/StlSupport/StdVector.h`

 * *Files 2% similar despite different names*

```diff
@@ -32,15 +32,15 @@
     typedef vector_base::size_type size_type;  \
     typedef vector_base::iterator iterator;  \
     explicit vector(const allocator_type& a = allocator_type()) : vector_base(a) {}  \
     template<typename InputIterator> \
     vector(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) : vector_base(first, last, a) {} \
     vector(const vector& c) : vector_base(c) {}  \
     explicit vector(size_type num, const value_type& val = value_type()) : vector_base(num, val) {} \
-    vector(iterator start, iterator end) : vector_base(start, end) {}  \
+    vector(iterator start_, iterator end_) : vector_base(start_, end_) {}  \
     vector& operator=(const vector& x) {  \
       vector_base::operator=(x);  \
       return *this;  \
     } \
   }; \
 }
 
@@ -58,15 +58,15 @@
     typedef typename vector_base::const_iterator const_iterator;  \
     explicit vector(const allocator_type& a = allocator_type()) : vector_base(a) {}  \
     template<typename InputIterator> \
     vector(InputIterator first, InputIterator last, const allocator_type& a = allocator_type()) \
     : vector_base(first, last, a) {} \
     vector(const vector& c) : vector_base(c) {}  \
     explicit vector(size_type num, const value_type& val = value_type()) : vector_base(num, val) {} \
-    vector(iterator start, iterator end) : vector_base(start, end) {}  \
+    vector(iterator start_, iterator end_) : vector_base(start_, end_) {}  \
     vector& operator=(const vector& x) {  \
       vector_base::operator=(x);  \
       return *this;  \
     }
 
   template<typename T>
   class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >
```

### Comparing `chronogram-0.1.7/include/Eigen/src/StlSupport/details.h` & `chronogram-0.2.0/include/Eigen/src/StlSupport/details.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/SuperLUSupport/SuperLUSupport.h` & `chronogram-0.2.0/include/Eigen/src/SuperLUSupport/SuperLUSupport.h`

 * *Files 1% similar despite different names*

```diff
@@ -213,20 +213,20 @@
     res.storage.values    = mat.valuePtr();
     res.storage.innerInd  = mat.innerIndexPtr();
     res.storage.outerInd  = mat.outerIndexPtr();
 
     res.setScalarType<typename MatrixType::Scalar>();
 
     // FIXME the following is not very accurate
-    if (MatrixType::Flags & Upper)
+    if (int(MatrixType::Flags) & int(Upper))
       res.Mtype = SLU_TRU;
-    if (MatrixType::Flags & Lower)
+    if (int(MatrixType::Flags) & int(Lower))
       res.Mtype = SLU_TRL;
 
-    eigen_assert(((MatrixType::Flags & SelfAdjoint)==0) && "SelfAdjoint matrix shape not supported by SuperLU");
+    eigen_assert(((int(MatrixType::Flags) & int(SelfAdjoint))==0) && "SelfAdjoint matrix shape not supported by SuperLU");
 
     return res;
   }
 };
 
 template<typename Scalar, int Rows, int Cols, int Options, int MRows, int MCols>
 struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >
@@ -348,15 +348,15 @@
     inline Index cols() const { return m_matrix.cols(); }
     
     /** \returns a reference to the Super LU option object to configure the  Super LU algorithms. */
     inline superlu_options_t& options() { return m_sluOptions; }
     
     /** \brief Reports whether previous computation was successful.
       *
-      * \returns \c Success if computation was succesful,
+      * \returns \c Success if computation was successful,
       *          \c NumericalIssue if the matrix.appears to be negative.
       */
     ComputationInfo info() const
     {
       eigen_assert(m_isInitialized && "Decomposition is not initialized.");
       return m_info;
     }
@@ -646,17 +646,16 @@
 
 template<typename MatrixType>
 template<typename Rhs,typename Dest>
 void SuperLU<MatrixType>::_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
 {
   eigen_assert(m_factorizationIsOk && "The decomposition is not in a valid state for solving, you must first call either compute() or analyzePattern()/factorize()");
 
-  const Index size = m_matrix.rows();
   const Index rhsCols = b.cols();
-  eigen_assert(size==b.rows());
+  eigen_assert(m_matrix.rows()==b.rows());
 
   m_sluOptions.Trans = NOTRANS;
   m_sluOptions.Fact = FACTORED;
   m_sluOptions.IterRefine = NOREFINE;
   
 
   m_sluFerr.resize(rhsCols);
@@ -970,17 +969,16 @@
 #ifndef EIGEN_PARSED_BY_DOXYGEN
 template<typename MatrixType>
 template<typename Rhs,typename Dest>
 void SuperILU<MatrixType>::_solve_impl(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const
 {
   eigen_assert(m_factorizationIsOk && "The decomposition is not in a valid state for solving, you must first call either compute() or analyzePattern()/factorize()");
 
-  const int size = m_matrix.rows();
   const int rhsCols = b.cols();
-  eigen_assert(size==b.rows());
+  eigen_assert(m_matrix.rows()==b.rows());
 
   m_sluOptions.Trans = NOTRANS;
   m_sluOptions.Fact = FACTORED;
   m_sluOptions.IterRefine = NOREFINE;
 
   m_sluFerr.resize(rhsCols);
   m_sluBerr.resize(rhsCols);
```

### Comparing `chronogram-0.1.7/include/Eigen/src/misc/Image.h` & `chronogram-0.2.0/include/Eigen/src/misc/Image.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/misc/Kernel.h` & `chronogram-0.2.0/include/Eigen/src/misc/Kernel.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/misc/RealSvd2x2.h` & `chronogram-0.2.0/include/Eigen/src/misc/RealSvd2x2.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/misc/blas.h` & `chronogram-0.2.0/include/Eigen/src/misc/blas.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/misc/lapack.h` & `chronogram-0.2.0/include/Eigen/src/misc/lapack.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/misc/lapacke.h` & `chronogram-0.2.0/include/Eigen/src/misc/lapacke.h`

 * *Files 0% similar despite different names*

```diff
@@ -39,18 +39,14 @@
 /*
 *  Turn on HAVE_LAPACK_CONFIG_H to redefine C-LAPACK datatypes
 */
 #ifdef HAVE_LAPACK_CONFIG_H
 #include "lapacke_config.h"
 #endif
 
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
 #include <stdlib.h>
 
 #ifndef lapack_int
 #define lapack_int     int
 #endif
 
 #ifndef lapack_logical
@@ -104,14 +100,19 @@
 #define lapack_complex_double_imag(z)       (cimag(z))
 #endif
 
 lapack_complex_double lapack_make_complex_double( double re, double im );
 
 #endif
 
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
 #ifndef LAPACKE_malloc
 #define LAPACKE_malloc( size ) malloc( size )
 #endif
 #ifndef LAPACKE_free
 #define LAPACKE_free( p )      free( p )
 #endif
```

### Comparing `chronogram-0.1.7/include/Eigen/src/plugins/ArrayCwiseBinaryOps.h` & `chronogram-0.2.0/include/Eigen/src/plugins/ArrayCwiseBinaryOps.h`

 * *Files 6% similar despite different names*

```diff
@@ -71,14 +71,40 @@
 (max)
 #endif
 (const Scalar &other) const
 {
   return (max)(Derived::PlainObject::Constant(rows(), cols(), other));
 }
 
+/** \returns an expression of the coefficient-wise absdiff of \c *this and \a other
+  *
+  * Example: \include Cwise_absolute_difference.cpp
+  * Output: \verbinclude Cwise_absolute_difference.out
+  *
+  * \sa absolute_difference()
+  */
+EIGEN_MAKE_CWISE_BINARY_OP(absolute_difference,absolute_difference)
+
+/** \returns an expression of the coefficient-wise absolute_difference of \c *this and scalar \a other
+  *
+  * \sa absolute_difference()
+  */
+EIGEN_DEVICE_FUNC
+EIGEN_STRONG_INLINE const CwiseBinaryOp<internal::scalar_absolute_difference_op<Scalar,Scalar>, const Derived,
+                                        const CwiseNullaryOp<internal::scalar_constant_op<Scalar>, PlainObject> >
+#ifdef EIGEN_PARSED_BY_DOXYGEN
+absolute_difference
+#else
+(absolute_difference)
+#endif
+(const Scalar &other) const
+{
+  return (absolute_difference)(Derived::PlainObject::Constant(rows(), cols(), other));
+}
+
 /** \returns an expression of the coefficient-wise power of \c *this to the given array of \a exponents.
   *
   * This function computes the coefficient-wise power.
   *
   * Example: \include Cwise_array_power_array.cpp
   * Output: \verbinclude Cwise_array_power_array.out
   */
@@ -115,15 +141,15 @@
 typedef CwiseBinaryOp<internal::scalar_cmp_op<Scalar,Scalar, internal::cmp_ ## COMPARATOR>, const Derived, const CwiseNullaryOp<internal::scalar_constant_op<Scalar>, PlainObject> > Cmp ## COMPARATOR ## ReturnType; \
 typedef CwiseBinaryOp<internal::scalar_cmp_op<Scalar,Scalar, internal::cmp_ ## COMPARATOR>, const CwiseNullaryOp<internal::scalar_constant_op<Scalar>, PlainObject>, const Derived > RCmp ## COMPARATOR ## ReturnType; \
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Cmp ## COMPARATOR ## ReturnType \
 OP(const Scalar& s) const { \
   return this->OP(Derived::PlainObject::Constant(rows(), cols(), s)); \
 } \
 EIGEN_DEVICE_FUNC friend EIGEN_STRONG_INLINE const RCmp ## COMPARATOR ## ReturnType \
-OP(const Scalar& s, const Derived& d) { \
+OP(const Scalar& s, const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& d) { \
   return Derived::PlainObject::Constant(d.rows(), d.cols(), s).OP(d); \
 }
 
 #define EIGEN_MAKE_CWISE_COMP_R_OP(OP, R_OP, RCOMPARATOR) \
 template<typename OtherDerived> \
 EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CwiseBinaryOp<internal::scalar_cmp_op<typename OtherDerived::Scalar, Scalar, internal::cmp_##RCOMPARATOR>, const OtherDerived, const Derived> \
 OP(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const \
@@ -310,17 +336,17 @@
 
 /** \returns an expression of the coefficient-wise zeta function.
   *
   * \specialfunctions_module
   *
   * It returns the Riemann zeta function of two arguments \c *this and \a q:
   *
-  * \param *this is the exposent, it must be > 1
   * \param q is the shift, it must be > 0
   *
+  * \note *this is the exponent, it must be > 1.
   * \note This function supports only float and double scalar types. To support other scalar types, the user has
   * to provide implementations of zeta(T,T) for any scalar type T to be supported.
   *
   * This method is an alias for zeta(*this,q);
   *
   * \sa Eigen::zeta()
   */
```

### Comparing `chronogram-0.1.7/include/Eigen/src/plugins/ArrayCwiseUnaryOps.h` & `chronogram-0.2.0/include/Eigen/src/plugins/ArrayCwiseUnaryOps.h`

 * *Files 15% similar despite different names*

```diff
@@ -6,29 +6,38 @@
 typedef CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived> SqrtReturnType;
 typedef CwiseUnaryOp<internal::scalar_rsqrt_op<Scalar>, const Derived> RsqrtReturnType;
 typedef CwiseUnaryOp<internal::scalar_sign_op<Scalar>, const Derived> SignReturnType;
 typedef CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived> InverseReturnType;
 typedef CwiseUnaryOp<internal::scalar_boolean_not_op<Scalar>, const Derived> BooleanNotReturnType;
 
 typedef CwiseUnaryOp<internal::scalar_exp_op<Scalar>, const Derived> ExpReturnType;
+typedef CwiseUnaryOp<internal::scalar_expm1_op<Scalar>, const Derived> Expm1ReturnType;
 typedef CwiseUnaryOp<internal::scalar_log_op<Scalar>, const Derived> LogReturnType;
 typedef CwiseUnaryOp<internal::scalar_log1p_op<Scalar>, const Derived> Log1pReturnType;
 typedef CwiseUnaryOp<internal::scalar_log10_op<Scalar>, const Derived> Log10ReturnType;
+typedef CwiseUnaryOp<internal::scalar_log2_op<Scalar>, const Derived> Log2ReturnType;
 typedef CwiseUnaryOp<internal::scalar_cos_op<Scalar>, const Derived> CosReturnType;
 typedef CwiseUnaryOp<internal::scalar_sin_op<Scalar>, const Derived> SinReturnType;
 typedef CwiseUnaryOp<internal::scalar_tan_op<Scalar>, const Derived> TanReturnType;
 typedef CwiseUnaryOp<internal::scalar_acos_op<Scalar>, const Derived> AcosReturnType;
 typedef CwiseUnaryOp<internal::scalar_asin_op<Scalar>, const Derived> AsinReturnType;
 typedef CwiseUnaryOp<internal::scalar_atan_op<Scalar>, const Derived> AtanReturnType;
 typedef CwiseUnaryOp<internal::scalar_tanh_op<Scalar>, const Derived> TanhReturnType;
+typedef CwiseUnaryOp<internal::scalar_logistic_op<Scalar>, const Derived> LogisticReturnType;
 typedef CwiseUnaryOp<internal::scalar_sinh_op<Scalar>, const Derived> SinhReturnType;
+#if EIGEN_HAS_CXX11_MATH
+typedef CwiseUnaryOp<internal::scalar_atanh_op<Scalar>, const Derived> AtanhReturnType;
+typedef CwiseUnaryOp<internal::scalar_asinh_op<Scalar>, const Derived> AsinhReturnType;
+typedef CwiseUnaryOp<internal::scalar_acosh_op<Scalar>, const Derived> AcoshReturnType;
+#endif
 typedef CwiseUnaryOp<internal::scalar_cosh_op<Scalar>, const Derived> CoshReturnType;
 typedef CwiseUnaryOp<internal::scalar_square_op<Scalar>, const Derived> SquareReturnType;
 typedef CwiseUnaryOp<internal::scalar_cube_op<Scalar>, const Derived> CubeReturnType;
 typedef CwiseUnaryOp<internal::scalar_round_op<Scalar>, const Derived> RoundReturnType;
+typedef CwiseUnaryOp<internal::scalar_rint_op<Scalar>, const Derived> RintReturnType;
 typedef CwiseUnaryOp<internal::scalar_floor_op<Scalar>, const Derived> FloorReturnType;
 typedef CwiseUnaryOp<internal::scalar_ceil_op<Scalar>, const Derived> CeilReturnType;
 typedef CwiseUnaryOp<internal::scalar_isnan_op<Scalar>, const Derived> IsNaNReturnType;
 typedef CwiseUnaryOp<internal::scalar_isinf_op<Scalar>, const Derived> IsInfReturnType;
 typedef CwiseUnaryOp<internal::scalar_isfinite_op<Scalar>, const Derived> IsFiniteReturnType;
 
 /** \returns an expression of the coefficient-wise absolute value of \c *this
@@ -86,23 +95,37 @@
 EIGEN_DEVICE_FUNC
 inline const ExpReturnType
 exp() const
 {
   return ExpReturnType(derived());
 }
 
+/** \returns an expression of the coefficient-wise exponential of *this minus 1.
+  *
+  * In exact arithmetic, \c x.expm1() is equivalent to \c x.exp() - 1,
+  * however, with finite precision, this function is much more accurate when \c x is close to zero.
+  *
+  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_expm1">Math functions</a>, exp()
+  */
+EIGEN_DEVICE_FUNC
+inline const Expm1ReturnType
+expm1() const
+{
+  return Expm1ReturnType(derived());
+}
+
 /** \returns an expression of the coefficient-wise logarithm of *this.
   *
   * This function computes the coefficient-wise logarithm. The function MatrixBase::log() in the
   * unsupported module MatrixFunctions computes the matrix logarithm.
   *
   * Example: \include Cwise_log.cpp
   * Output: \verbinclude Cwise_log.out
   *
-  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_log">Math functions</a>, exp()
+  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_log">Math functions</a>, log()
   */
 EIGEN_DEVICE_FUNC
 inline const LogReturnType
 log() const
 {
   return LogReturnType(derived());
 }
@@ -133,14 +156,26 @@
 EIGEN_DEVICE_FUNC
 inline const Log10ReturnType
 log10() const
 {
   return Log10ReturnType(derived());
 }
 
+/** \returns an expression of the coefficient-wise base-2 logarithm of *this.
+  *
+  * This function computes the coefficient-wise base-2 logarithm.
+  *
+  */
+EIGEN_DEVICE_FUNC
+inline const Log2ReturnType
+log2() const
+{
+  return Log2ReturnType(derived());
+}
+
 /** \returns an expression of the coefficient-wise square root of *this.
   *
   * This function computes the coefficient-wise square root. The function MatrixBase::sqrt() in the
   * unsupported module MatrixFunctions computes the matrix square root.
   *
   * Example: \include Cwise_sqrt.cpp
   * Output: \verbinclude Cwise_sqrt.out
@@ -307,23 +342,67 @@
 }
 
 /** \returns an expression of the coefficient-wise hyperbolic cos of *this.
   *
   * Example: \include Cwise_cosh.cpp
   * Output: \verbinclude Cwise_cosh.out
   *
-  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_cosh">Math functions</a>, tan(), sinh(), cosh()
+  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_cosh">Math functions</a>, tanh(), sinh(), cosh()
   */
 EIGEN_DEVICE_FUNC
 inline const CoshReturnType
 cosh() const
 {
   return CoshReturnType(derived());
 }
 
+#if EIGEN_HAS_CXX11_MATH
+/** \returns an expression of the coefficient-wise inverse hyperbolic tan of *this.
+  *
+  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_atanh">Math functions</a>, atanh(), asinh(), acosh()
+  */
+EIGEN_DEVICE_FUNC
+inline const AtanhReturnType
+atanh() const
+{
+  return AtanhReturnType(derived());
+}
+
+/** \returns an expression of the coefficient-wise inverse hyperbolic sin of *this.
+  *
+  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_asinh">Math functions</a>, atanh(), asinh(), acosh()
+  */
+EIGEN_DEVICE_FUNC
+inline const AsinhReturnType
+asinh() const
+{
+  return AsinhReturnType(derived());
+}
+
+/** \returns an expression of the coefficient-wise inverse hyperbolic cos of *this.
+  *
+  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_acosh">Math functions</a>, atanh(), asinh(), acosh()
+  */
+EIGEN_DEVICE_FUNC
+inline const AcoshReturnType
+acosh() const
+{
+  return AcoshReturnType(derived());
+}
+#endif
+
+/** \returns an expression of the coefficient-wise logistic of *this.
+  */
+EIGEN_DEVICE_FUNC
+inline const LogisticReturnType
+logistic() const
+{
+  return LogisticReturnType(derived());
+}
+
 /** \returns an expression of the coefficient-wise inverse of *this.
   *
   * Example: \include Cwise_inverse.cpp
   * Output: \verbinclude Cwise_inverse.out
   *
   * \sa operator/(), operator*()
   */
@@ -358,14 +437,28 @@
 EIGEN_DEVICE_FUNC
 inline const CubeReturnType
 cube() const
 {
   return CubeReturnType(derived());
 }
 
+/** \returns an expression of the coefficient-wise rint of *this.
+  *
+  * Example: \include Cwise_rint.cpp
+  * Output: \verbinclude Cwise_rint.out
+  *
+  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_rint">Math functions</a>, ceil(), floor()
+  */
+EIGEN_DEVICE_FUNC
+inline const RintReturnType
+rint() const
+{
+  return RintReturnType(derived());
+}
+
 /** \returns an expression of the coefficient-wise round of *this.
   *
   * Example: \include Cwise_round.cpp
   * Output: \verbinclude Cwise_round.out
   *
   * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_round">Math functions</a>, ceil(), floor()
   */
@@ -400,14 +493,53 @@
 EIGEN_DEVICE_FUNC
 inline const CeilReturnType
 ceil() const
 {
   return CeilReturnType(derived());
 }
 
+template<int N> struct ShiftRightXpr {
+  typedef CwiseUnaryOp<internal::scalar_shift_right_op<Scalar, N>, const Derived> Type;
+};
+
+/** \returns an expression of \c *this with the \a Scalar type arithmetically
+  * shifted right by \a N bit positions.
+  *
+  * The template parameter \a N specifies the number of bit positions to shift.
+  * 
+  * \sa shiftLeft()
+  */
+template<int N>
+EIGEN_DEVICE_FUNC
+typename ShiftRightXpr<N>::Type
+shiftRight() const
+{
+  return typename ShiftRightXpr<N>::Type(derived());
+}
+
+
+template<int N> struct ShiftLeftXpr {
+  typedef CwiseUnaryOp<internal::scalar_shift_left_op<Scalar, N>, const Derived> Type;
+};
+
+/** \returns an expression of \c *this with the \a Scalar type logically
+  * shifted left by \a N bit positions.
+  *
+  * The template parameter \a N specifies the number of bit positions to shift.
+  *
+  * \sa shiftRight()
+  */
+template<int N>
+EIGEN_DEVICE_FUNC
+typename ShiftLeftXpr<N>::Type
+shiftLeft() const
+{
+  return typename ShiftLeftXpr<N>::Type(derived());
+}
+
 /** \returns an expression of the coefficient-wise isnan of *this.
   *
   * Example: \include Cwise_isNaN.cpp
   * Output: \verbinclude Cwise_isNaN.out
   *
   * \sa isfinite(), isinf()
   */
@@ -467,22 +599,20 @@
 
 // --- SpecialFunctions module ---
 
 typedef CwiseUnaryOp<internal::scalar_lgamma_op<Scalar>, const Derived> LgammaReturnType;
 typedef CwiseUnaryOp<internal::scalar_digamma_op<Scalar>, const Derived> DigammaReturnType;
 typedef CwiseUnaryOp<internal::scalar_erf_op<Scalar>, const Derived> ErfReturnType;
 typedef CwiseUnaryOp<internal::scalar_erfc_op<Scalar>, const Derived> ErfcReturnType;
+typedef CwiseUnaryOp<internal::scalar_ndtri_op<Scalar>, const Derived> NdtriReturnType;
 
 /** \cpp11 \returns an expression of the coefficient-wise ln(|gamma(*this)|).
   *
   * \specialfunctions_module
   *
-  * Example: \include Cwise_lgamma.cpp
-  * Output: \verbinclude Cwise_lgamma.out
-  *
   * \note This function supports only float and double scalar types in c++11 mode. To support other scalar types,
   * or float/double in non c++11 mode, the user has to provide implementations of lgamma(T) for any scalar
   * type T to be supported.
   *
   * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_lgamma">Math functions</a>, digamma()
   */
 EIGEN_DEVICE_FUNC
@@ -510,17 +640,14 @@
 }
 
 /** \cpp11 \returns an expression of the coefficient-wise Gauss error
   * function of *this.
   *
   * \specialfunctions_module
   *
-  * Example: \include Cwise_erf.cpp
-  * Output: \verbinclude Cwise_erf.out
-  *
   * \note This function supports only float and double scalar types in c++11 mode. To support other scalar types,
   * or float/double in non c++11 mode, the user has to provide implementations of erf(T) for any scalar
   * type T to be supported.
   *
   * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_erf">Math functions</a>, erfc()
   */
 EIGEN_DEVICE_FUNC
@@ -531,22 +658,39 @@
 }
 
 /** \cpp11 \returns an expression of the coefficient-wise Complementary error
   * function of *this.
   *
   * \specialfunctions_module
   *
-  * Example: \include Cwise_erfc.cpp
-  * Output: \verbinclude Cwise_erfc.out
-  *
   * \note This function supports only float and double scalar types in c++11 mode. To support other scalar types,
   * or float/double in non c++11 mode, the user has to provide implementations of erfc(T) for any scalar
   * type T to be supported.
   *
   * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_erfc">Math functions</a>, erf()
   */
 EIGEN_DEVICE_FUNC
 inline const ErfcReturnType
 erfc() const
 {
   return ErfcReturnType(derived());
 }
+
+/** \returns an expression of the coefficient-wise inverse of the CDF of the Normal distribution function
+  * function of *this.
+  *
+  * \specialfunctions_module
+  * 
+  * In other words, considering `x = ndtri(y)`, it returns the argument, x, for which the area under the
+  * Gaussian probability density function (integrated from minus infinity to x) is equal to y.
+  *
+  * \note This function supports only float and double scalar types. To support other scalar types,
+  * the user has to provide implementations of ndtri(T) for any scalar type T to be supported.
+  *
+  * \sa <a href="group__CoeffwiseMathFunctions.html#cwisetable_ndtri">Math functions</a>
+  */
+EIGEN_DEVICE_FUNC
+inline const NdtriReturnType
+ndtri() const
+{
+  return NdtriReturnType(derived());
+}
```

#### html2text {}

```diff
@@ -4,29 +4,37 @@
 Scalar>, const Derived> Abs2ReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> SqrtReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> RsqrtReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> SignReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> InverseReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> BooleanNotReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> ExpReturnType; typedef CwiseUnaryOp
+Scalar>, const Derived> Expm1ReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> LogReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> Log1pReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> Log10ReturnType; typedef CwiseUnaryOp
+Scalar>, const Derived> Log2ReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> CosReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> SinReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> TanReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> AcosReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> AsinReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> AtanReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> TanhReturnType; typedef CwiseUnaryOp
-Scalar>, const Derived> SinhReturnType; typedef CwiseUnaryOp
+Scalar>, const Derived> LogisticReturnType; typedef CwiseUnaryOp
+Scalar>, const Derived> SinhReturnType; #if EIGEN_HAS_CXX11_MATH typedef
+CwiseUnaryOp
+Scalar>, const Derived> AtanhReturnType; typedef CwiseUnaryOp
+Scalar>, const Derived> AsinhReturnType; typedef CwiseUnaryOp
+Scalar>, const Derived> AcoshReturnType; #endif typedef CwiseUnaryOp
 Scalar>, const Derived> CoshReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> SquareReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> CubeReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> RoundReturnType; typedef CwiseUnaryOp
+Scalar>, const Derived> RintReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> FloorReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> CeilReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> IsNaNReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> IsInfReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> IsFiniteReturnType; /** \returns an expression of the
 coefficient-wise absolute value of \c *this * * Example: \include Cwise_abs.cpp
 * Output: \verbinclude Cwise_abs.out * * \sa Math_functions, abs2() */
@@ -42,66 +50,74 @@
 { return Abs2ReturnType(derived()); } /** \returns an expression of the
 coefficient-wise exponential of *this. * * This function computes the
 coefficient-wise exponential. The function MatrixBase::exp() in the *
 unsupported module MatrixFunctions computes the matrix exponential. * *
 Example: \include Cwise_exp.cpp * Output: \verbinclude Cwise_exp.out * * \sa
 Math_functions, pow(), log(), sin(), cos() */ EIGEN_DEVICE_FUNC inline const
 ExpReturnType exp() const { return ExpReturnType(derived()); } /** \returns an
-expression of the coefficient-wise logarithm of *this. * * This function
-computes the coefficient-wise logarithm. The function MatrixBase::log() in the
-* unsupported module MatrixFunctions computes the matrix logarithm. * *
-Example: \include Cwise_log.cpp * Output: \verbinclude Cwise_log.out * * \sa
-Math_functions, exp() */ EIGEN_DEVICE_FUNC inline const LogReturnType log()
+expression of the coefficient-wise exponential of *this minus 1. * * In exact
+arithmetic, \c x.expm1() is equivalent to \c x.exp() - 1, * however, with
+finite precision, this function is much more accurate when \c x is close to
+zero. * * \sa Math_functions, exp() */ EIGEN_DEVICE_FUNC inline const
+Expm1ReturnType expm1() const { return Expm1ReturnType(derived()); } /**
+\returns an expression of the coefficient-wise logarithm of *this. * * This
+function computes the coefficient-wise logarithm. The function MatrixBase::log
+() in the * unsupported module MatrixFunctions computes the matrix logarithm. *
+* Example: \include Cwise_log.cpp * Output: \verbinclude Cwise_log.out * * \sa
+Math_functions, log() */ EIGEN_DEVICE_FUNC inline const LogReturnType log()
 const { return LogReturnType(derived()); } /** \returns an expression of the
 coefficient-wise logarithm of 1 plus \c *this. * * In exact arithmetic, \c
 x.log() is equivalent to \c (x+1).log(), * however, with finite precision, this
 function is much more accurate when \c x is close to zero. * * \sa Math
 functions, log() */ EIGEN_DEVICE_FUNC inline const Log1pReturnType log1p()
 const { return Log1pReturnType(derived()); } /** \returns an expression of the
 coefficient-wise base-10 logarithm of *this. * * This function computes the
 coefficient-wise base-10 logarithm. * * Example: \include Cwise_log10.cpp *
 Output: \verbinclude Cwise_log10.out * * \sa Math_functions, log() */
 EIGEN_DEVICE_FUNC inline const Log10ReturnType log10() const { return
 Log10ReturnType(derived()); } /** \returns an expression of the coefficient-
-wise square root of *this. * * This function computes the coefficient-wise
-square root. The function MatrixBase::sqrt() in the * unsupported module
-MatrixFunctions computes the matrix square root. * * Example: \include
-Cwise_sqrt.cpp * Output: \verbinclude Cwise_sqrt.out * * \sa Math_functions,
-pow(), square() */ EIGEN_DEVICE_FUNC inline const SqrtReturnType sqrt() const
-{ return SqrtReturnType(derived()); } /** \returns an expression of the
-coefficient-wise inverse square root of *this. * * This function computes the
-coefficient-wise inverse square root. * * Example: \include Cwise_sqrt.cpp *
-Output: \verbinclude Cwise_sqrt.out * * \sa pow(), square() */
-EIGEN_DEVICE_FUNC inline const RsqrtReturnType rsqrt() const { return
-RsqrtReturnType(derived()); } /** \returns an expression of the coefficient-
-wise signum of *this. * * This function computes the coefficient-wise signum. *
-* Example: \include Cwise_sign.cpp * Output: \verbinclude Cwise_sign.out * *
-\sa pow(), square() */ EIGEN_DEVICE_FUNC inline const SignReturnType sign()
-const { return SignReturnType(derived()); } /** \returns an expression of the
-coefficient-wise cosine of *this. * * This function computes the coefficient-
-wise cosine. The function MatrixBase::cos() in the * unsupported module
-MatrixFunctions computes the matrix cosine. * * Example: \include Cwise_cos.cpp
-* Output: \verbinclude Cwise_cos.out * * \sa Math_functions, sin(), acos() */
-EIGEN_DEVICE_FUNC inline const CosReturnType cos() const { return CosReturnType
-(derived()); } /** \returns an expression of the coefficient-wise sine of
-*this. * * This function computes the coefficient-wise sine. The function
-MatrixBase::sin() in the * unsupported module MatrixFunctions computes the
-matrix sine. * * Example: \include Cwise_sin.cpp * Output: \verbinclude
-Cwise_sin.out * * \sa Math_functions, cos(), asin() */ EIGEN_DEVICE_FUNC inline
-const SinReturnType sin() const { return SinReturnType(derived()); } /**
-\returns an expression of the coefficient-wise tan of *this. * * Example:
-\include Cwise_tan.cpp * Output: \verbinclude Cwise_tan.out * * \sa Math
-functions, cos(), sin() */ EIGEN_DEVICE_FUNC inline const TanReturnType tan()
-const { return TanReturnType(derived()); } /** \returns an expression of the
-coefficient-wise arc tan of *this. * * Example: \include Cwise_atan.cpp *
-Output: \verbinclude Cwise_atan.out * * \sa Math_functions, tan(), asin(), acos
-() */ EIGEN_DEVICE_FUNC inline const AtanReturnType atan() const { return
-AtanReturnType(derived()); } /** \returns an expression of the coefficient-wise
-arc cosine of *this. * * Example: \include Cwise_acos.cpp * Output:
-\verbinclude Cwise_acos.out * * \sa Math_functions, cos(), asin() */
+wise base-2 logarithm of *this. * * This function computes the coefficient-wise
+base-2 logarithm. * */ EIGEN_DEVICE_FUNC inline const Log2ReturnType log2()
+const { return Log2ReturnType(derived()); } /** \returns an expression of the
+coefficient-wise square root of *this. * * This function computes the
+coefficient-wise square root. The function MatrixBase::sqrt() in the *
+unsupported module MatrixFunctions computes the matrix square root. * *
+Example: \include Cwise_sqrt.cpp * Output: \verbinclude Cwise_sqrt.out * * \sa
+Math_functions, pow(), square() */ EIGEN_DEVICE_FUNC inline const
+SqrtReturnType sqrt() const { return SqrtReturnType(derived()); } /** \returns
+an expression of the coefficient-wise inverse square root of *this. * * This
+function computes the coefficient-wise inverse square root. * * Example:
+\include Cwise_sqrt.cpp * Output: \verbinclude Cwise_sqrt.out * * \sa pow(),
+square() */ EIGEN_DEVICE_FUNC inline const RsqrtReturnType rsqrt() const
+{ return RsqrtReturnType(derived()); } /** \returns an expression of the
+coefficient-wise signum of *this. * * This function computes the coefficient-
+wise signum. * * Example: \include Cwise_sign.cpp * Output: \verbinclude
+Cwise_sign.out * * \sa pow(), square() */ EIGEN_DEVICE_FUNC inline const
+SignReturnType sign() const { return SignReturnType(derived()); } /** \returns
+an expression of the coefficient-wise cosine of *this. * * This function
+computes the coefficient-wise cosine. The function MatrixBase::cos() in the *
+unsupported module MatrixFunctions computes the matrix cosine. * * Example:
+\include Cwise_cos.cpp * Output: \verbinclude Cwise_cos.out * * \sa Math
+functions, sin(), acos() */ EIGEN_DEVICE_FUNC inline const CosReturnType cos()
+const { return CosReturnType(derived()); } /** \returns an expression of the
+coefficient-wise sine of *this. * * This function computes the coefficient-wise
+sine. The function MatrixBase::sin() in the * unsupported module
+MatrixFunctions computes the matrix sine. * * Example: \include Cwise_sin.cpp *
+Output: \verbinclude Cwise_sin.out * * \sa Math_functions, cos(), asin() */
+EIGEN_DEVICE_FUNC inline const SinReturnType sin() const { return SinReturnType
+(derived()); } /** \returns an expression of the coefficient-wise tan of *this.
+* * Example: \include Cwise_tan.cpp * Output: \verbinclude Cwise_tan.out * *
+\sa Math_functions, cos(), sin() */ EIGEN_DEVICE_FUNC inline const
+TanReturnType tan() const { return TanReturnType(derived()); } /** \returns an
+expression of the coefficient-wise arc tan of *this. * * Example: \include
+Cwise_atan.cpp * Output: \verbinclude Cwise_atan.out * * \sa Math_functions,
+tan(), asin(), acos() */ EIGEN_DEVICE_FUNC inline const AtanReturnType atan()
+const { return AtanReturnType(derived()); } /** \returns an expression of the
+coefficient-wise arc cosine of *this. * * Example: \include Cwise_acos.cpp *
+Output: \verbinclude Cwise_acos.out * * \sa Math_functions, cos(), asin() */
 EIGEN_DEVICE_FUNC inline const AcosReturnType acos() const { return
 AcosReturnType(derived()); } /** \returns an expression of the coefficient-wise
 arc sine of *this. * * Example: \include Cwise_asin.cpp * Output: \verbinclude
 Cwise_asin.out * * \sa Math_functions, sin(), acos() */ EIGEN_DEVICE_FUNC
 inline const AsinReturnType asin() const { return AsinReturnType(derived()); }
 /** \returns an expression of the coefficient-wise hyperbolic tan of *this. * *
 Example: \include Cwise_tanh.cpp * Output: \verbinclude Cwise_tanh.out * * \sa
@@ -109,84 +125,119 @@
 TanhReturnType tanh() const { return TanhReturnType(derived()); } /** \returns
 an expression of the coefficient-wise hyperbolic sin of *this. * * Example:
 \include Cwise_sinh.cpp * Output: \verbinclude Cwise_sinh.out * * \sa Math
 functions, sin(), tanh(), cosh() */ EIGEN_DEVICE_FUNC inline const
 SinhReturnType sinh() const { return SinhReturnType(derived()); } /** \returns
 an expression of the coefficient-wise hyperbolic cos of *this. * * Example:
 \include Cwise_cosh.cpp * Output: \verbinclude Cwise_cosh.out * * \sa Math
-functions, tan(), sinh(), cosh() */ EIGEN_DEVICE_FUNC inline const
-CoshReturnType cosh() const { return CoshReturnType(derived()); } /** \returns
-an expression of the coefficient-wise inverse of *this. * * Example: \include
-Cwise_inverse.cpp * Output: \verbinclude Cwise_inverse.out * * \sa operator/(),
-operator*() */ EIGEN_DEVICE_FUNC inline const InverseReturnType inverse() const
-{ return InverseReturnType(derived()); } /** \returns an expression of the
-coefficient-wise square of *this. * * Example: \include Cwise_square.cpp *
-Output: \verbinclude Cwise_square.out * * \sa Math_functions, abs2(), cube(),
-pow() */ EIGEN_DEVICE_FUNC inline const SquareReturnType square() const
-{ return SquareReturnType(derived()); } /** \returns an expression of the
-coefficient-wise cube of *this. * * Example: \include Cwise_cube.cpp * Output:
-\verbinclude Cwise_cube.out * * \sa Math_functions, square(), pow() */
-EIGEN_DEVICE_FUNC inline const CubeReturnType cube() const { return
-CubeReturnType(derived()); } /** \returns an expression of the coefficient-wise
+functions, tanh(), sinh(), cosh() */ EIGEN_DEVICE_FUNC inline const
+CoshReturnType cosh() const { return CoshReturnType(derived()); } #if
+EIGEN_HAS_CXX11_MATH /** \returns an expression of the coefficient-wise inverse
+hyperbolic tan of *this. * * \sa Math_functions, atanh(), asinh(), acosh() */
+EIGEN_DEVICE_FUNC inline const AtanhReturnType atanh() const { return
+AtanhReturnType(derived()); } /** \returns an expression of the coefficient-
+wise inverse hyperbolic sin of *this. * * \sa Math_functions, atanh(), asinh(),
+acosh() */ EIGEN_DEVICE_FUNC inline const AsinhReturnType asinh() const
+{ return AsinhReturnType(derived()); } /** \returns an expression of the
+coefficient-wise inverse hyperbolic cos of *this. * * \sa Math_functions, atanh
+(), asinh(), acosh() */ EIGEN_DEVICE_FUNC inline const AcoshReturnType acosh()
+const { return AcoshReturnType(derived()); } #endif /** \returns an expression
+of the coefficient-wise logistic of *this. */ EIGEN_DEVICE_FUNC inline const
+LogisticReturnType logistic() const { return LogisticReturnType(derived()); } /
+** \returns an expression of the coefficient-wise inverse of *this. * *
+Example: \include Cwise_inverse.cpp * Output: \verbinclude Cwise_inverse.out *
+* \sa operator/(), operator*() */ EIGEN_DEVICE_FUNC inline const
+InverseReturnType inverse() const { return InverseReturnType(derived()); } /**
+\returns an expression of the coefficient-wise square of *this. * * Example:
+\include Cwise_square.cpp * Output: \verbinclude Cwise_square.out * * \sa Math
+functions, abs2(), cube(), pow() */ EIGEN_DEVICE_FUNC inline const
+SquareReturnType square() const { return SquareReturnType(derived()); } /**
+\returns an expression of the coefficient-wise cube of *this. * * Example:
+\include Cwise_cube.cpp * Output: \verbinclude Cwise_cube.out * * \sa Math
+functions, square(), pow() */ EIGEN_DEVICE_FUNC inline const CubeReturnType
+cube() const { return CubeReturnType(derived()); } /** \returns an expression
+of the coefficient-wise rint of *this. * * Example: \include Cwise_rint.cpp *
+Output: \verbinclude Cwise_rint.out * * \sa Math_functions, ceil(), floor() */
+EIGEN_DEVICE_FUNC inline const RintReturnType rint() const { return
+RintReturnType(derived()); } /** \returns an expression of the coefficient-wise
 round of *this. * * Example: \include Cwise_round.cpp * Output: \verbinclude
 Cwise_round.out * * \sa Math_functions, ceil(), floor() */ EIGEN_DEVICE_FUNC
 inline const RoundReturnType round() const { return RoundReturnType(derived());
 } /** \returns an expression of the coefficient-wise floor of *this. * *
 Example: \include Cwise_floor.cpp * Output: \verbinclude Cwise_floor.out * *
 \sa Math_functions, ceil(), round() */ EIGEN_DEVICE_FUNC inline const
 FloorReturnType floor() const { return FloorReturnType(derived()); } /**
 \returns an expression of the coefficient-wise ceil of *this. * * Example:
 \include Cwise_ceil.cpp * Output: \verbinclude Cwise_ceil.out * * \sa Math
 functions, floor(), round() */ EIGEN_DEVICE_FUNC inline const CeilReturnType
-ceil() const { return CeilReturnType(derived()); } /** \returns an expression
-of the coefficient-wise isnan of *this. * * Example: \include Cwise_isNaN.cpp *
-Output: \verbinclude Cwise_isNaN.out * * \sa isfinite(), isinf() */
-EIGEN_DEVICE_FUNC inline const IsNaNReturnType isNaN() const { return
-IsNaNReturnType(derived()); } /** \returns an expression of the coefficient-
-wise isinf of *this. * * Example: \include Cwise_isInf.cpp * Output:
-\verbinclude Cwise_isInf.out * * \sa isnan(), isfinite() */ EIGEN_DEVICE_FUNC
-inline const IsInfReturnType isInf() const { return IsInfReturnType(derived());
-} /** \returns an expression of the coefficient-wise isfinite of *this. * *
-Example: \include Cwise_isFinite.cpp * Output: \verbinclude Cwise_isFinite.out
-* * \sa isnan(), isinf() */ EIGEN_DEVICE_FUNC inline const IsFiniteReturnType
-isFinite() const { return IsFiniteReturnType(derived()); } /** \returns an
-expression of the coefficient-wise ! operator of *this * * \warning this
-operator is for expression of bool only. * * Example: \include
-Cwise_boolean_not.cpp * Output: \verbinclude Cwise_boolean_not.out * * \sa
-operator!=() */ EIGEN_DEVICE_FUNC inline const BooleanNotReturnType operator!()
-const { EIGEN_STATIC_ASSERT((internal::is_same
+ceil() const { return CeilReturnType(derived()); } template struct
+ShiftRightXpr { typedef CwiseUnaryOp
+Scalar, N>, const Derived> Type; }; /** \returns an expression of \c *this with
+the \a Scalar type arithmetically * shifted right by \a N bit positions. * *
+The template parameter \a N specifies the number of bit positions to shift. * *
+\sa shiftLeft() */ template EIGEN_DEVICE_FUNC typename ShiftRightXpr::Type
+shiftRight() const { return typename ShiftRightXpr::Type(derived()); } template
+struct ShiftLeftXpr { typedef CwiseUnaryOp
+Scalar, N>, const Derived> Type; }; /** \returns an expression of \c *this with
+the \a Scalar type logically * shifted left by \a N bit positions. * * The
+template parameter \a N specifies the number of bit positions to shift. * * \sa
+shiftRight() */ template EIGEN_DEVICE_FUNC typename ShiftLeftXpr::Type
+shiftLeft() const { return typename ShiftLeftXpr::Type(derived()); } /**
+\returns an expression of the coefficient-wise isnan of *this. * * Example:
+\include Cwise_isNaN.cpp * Output: \verbinclude Cwise_isNaN.out * * \sa
+isfinite(), isinf() */ EIGEN_DEVICE_FUNC inline const IsNaNReturnType isNaN()
+const { return IsNaNReturnType(derived()); } /** \returns an expression of the
+coefficient-wise isinf of *this. * * Example: \include Cwise_isInf.cpp *
+Output: \verbinclude Cwise_isInf.out * * \sa isnan(), isfinite() */
+EIGEN_DEVICE_FUNC inline const IsInfReturnType isInf() const { return
+IsInfReturnType(derived()); } /** \returns an expression of the coefficient-
+wise isfinite of *this. * * Example: \include Cwise_isFinite.cpp * Output:
+\verbinclude Cwise_isFinite.out * * \sa isnan(), isinf() */ EIGEN_DEVICE_FUNC
+inline const IsFiniteReturnType isFinite() const { return IsFiniteReturnType
+(derived()); } /** \returns an expression of the coefficient-wise ! operator of
+*this * * \warning this operator is for expression of bool only. * * Example:
+\include Cwise_boolean_not.cpp * Output: \verbinclude Cwise_boolean_not.out * *
+\sa operator!=() */ EIGEN_DEVICE_FUNC inline const BooleanNotReturnType
+operator!() const { EIGEN_STATIC_ASSERT((internal::is_same
 Scalar>::value), THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL); return
 BooleanNotReturnType(derived()); } // --- SpecialFunctions module --- typedef
 CwiseUnaryOp
 Scalar>, const Derived> LgammaReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> DigammaReturnType; typedef CwiseUnaryOp
 Scalar>, const Derived> ErfReturnType; typedef CwiseUnaryOp
-Scalar>, const Derived> ErfcReturnType; /** \cpp11 \returns an expression of
-the coefficient-wise ln(|gamma(*this)|). * * \specialfunctions_module * *
-Example: \include Cwise_lgamma.cpp * Output: \verbinclude Cwise_lgamma.out * *
-\note This function supports only float and double scalar types in c++11 mode.
-To support other scalar types, * or float/double in non c++11 mode, the user
-has to provide implementations of lgamma(T) for any scalar * type T to be
+Scalar>, const Derived> ErfcReturnType; typedef CwiseUnaryOp
+Scalar>, const Derived> NdtriReturnType; /** \cpp11 \returns an expression of
+the coefficient-wise ln(|gamma(*this)|). * * \specialfunctions_module * * \note
+This function supports only float and double scalar types in c++11 mode. To
+support other scalar types, * or float/double in non c++11 mode, the user has
+to provide implementations of lgamma(T) for any scalar * type T to be
 supported. * * \sa Math_functions, digamma() */ EIGEN_DEVICE_FUNC inline const
 LgammaReturnType lgamma() const { return LgammaReturnType(derived()); } /**
 \returns an expression of the coefficient-wise digamma (psi, derivative of
 lgamma). * * \specialfunctions_module * * \note This function supports only
 float and double scalar types. To support other scalar types, * the user has to
 provide implementations of digamma(T) for any scalar * type T to be supported.
 * * \sa Math_functions, Eigen::digamma(), Eigen::polygamma(), lgamma() */
 EIGEN_DEVICE_FUNC inline const DigammaReturnType digamma() const { return
 DigammaReturnType(derived()); } /** \cpp11 \returns an expression of the
 coefficient-wise Gauss error * function of *this. * * \specialfunctions_module
-* * Example: \include Cwise_erf.cpp * Output: \verbinclude Cwise_erf.out * *
-\note This function supports only float and double scalar types in c++11 mode.
-To support other scalar types, * or float/double in non c++11 mode, the user
-has to provide implementations of erf(T) for any scalar * type T to be
+* * \note This function supports only float and double scalar types in c++11
+mode. To support other scalar types, * or float/double in non c++11 mode, the
+user has to provide implementations of erf(T) for any scalar * type T to be
 supported. * * \sa Math_functions, erfc() */ EIGEN_DEVICE_FUNC inline const
 ErfReturnType erf() const { return ErfReturnType(derived()); } /** \cpp11
 \returns an expression of the coefficient-wise Complementary error * function
-of *this. * * \specialfunctions_module * * Example: \include Cwise_erfc.cpp *
-Output: \verbinclude Cwise_erfc.out * * \note This function supports only float
-and double scalar types in c++11 mode. To support other scalar types, * or
-float/double in non c++11 mode, the user has to provide implementations of erfc
-(T) for any scalar * type T to be supported. * * \sa Math_functions, erf() */
-EIGEN_DEVICE_FUNC inline const ErfcReturnType erfc() const { return
-ErfcReturnType(derived()); }
+of *this. * * \specialfunctions_module * * \note This function supports only
+float and double scalar types in c++11 mode. To support other scalar types, *
+or float/double in non c++11 mode, the user has to provide implementations of
+erfc(T) for any scalar * type T to be supported. * * \sa Math_functions, erf()
+*/ EIGEN_DEVICE_FUNC inline const ErfcReturnType erfc() const { return
+ErfcReturnType(derived()); } /** \returns an expression of the coefficient-wise
+inverse of the CDF of the Normal distribution function * function of *this. * *
+\specialfunctions_module * * In other words, considering `x = ndtri(y)`, it
+returns the argument, x, for which the area under the * Gaussian probability
+density function (integrated from minus infinity to x) is equal to y. * * \note
+This function supports only float and double scalar types. To support other
+scalar types, * the user has to provide implementations of ndtri(T) for any
+scalar type T to be supported. * * \sa Math_functions */ EIGEN_DEVICE_FUNC
+inline const NdtriReturnType ndtri() const { return NdtriReturnType(derived());
+}
```

### Comparing `chronogram-0.1.7/include/Eigen/src/plugins/CommonCwiseBinaryOps.h` & `chronogram-0.2.0/include/Eigen/src/plugins/CommonCwiseBinaryOps.h`

 * *Files identical despite different names*

### Comparing `chronogram-0.1.7/include/Eigen/src/plugins/CommonCwiseUnaryOps.h` & `chronogram-0.2.0/include/Eigen/src/plugins/CommonCwiseUnaryOps.h`

 * *Files 8% similar despite different names*

```diff
@@ -72,14 +72,28 @@
 EIGEN_DEVICE_FUNC
 inline ConjugateReturnType
 conjugate() const
 {
   return ConjugateReturnType(derived());
 }
 
+/// \returns an expression of the complex conjugate of \c *this if Cond==true, returns derived() otherwise.
+///
+EIGEN_DOC_UNARY_ADDONS(conjugate,complex conjugate)
+///
+/// \sa conjugate()
+template<bool Cond>
+EIGEN_DEVICE_FUNC
+inline typename internal::conditional<Cond,ConjugateReturnType,const Derived&>::type
+conjugateIf() const
+{
+  typedef typename internal::conditional<Cond,ConjugateReturnType,const Derived&>::type ReturnType;
+  return ReturnType(derived());
+}
+
 /// \returns a read-only expression of the real part of \c *this.
 ///
 EIGEN_DOC_UNARY_ADDONS(real,real part function)
 ///
 /// \sa imag()
 EIGEN_DEVICE_FUNC
 inline RealReturnType
```

### Comparing `chronogram-0.1.7/include/Eigen/src/plugins/MatrixCwiseBinaryOps.h` & `chronogram-0.2.0/include/Eigen/src/plugins/MatrixCwiseBinaryOps.h`

 * *Files 2% similar despite different names*

```diff
@@ -35,18 +35,18 @@
   * Example: \include MatrixBase_cwiseEqual.cpp
   * Output: \verbinclude MatrixBase_cwiseEqual.out
   *
   * \sa cwiseNotEqual(), isApprox(), isMuchSmallerThan()
   */
 template<typename OtherDerived>
 EIGEN_DEVICE_FUNC
-inline const CwiseBinaryOp<std::equal_to<Scalar>, const Derived, const OtherDerived>
+inline const CwiseBinaryOp<numext::equal_to<Scalar>, const Derived, const OtherDerived>
 cwiseEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
 {
-  return CwiseBinaryOp<std::equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
+  return CwiseBinaryOp<numext::equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
 }
 
 /** \returns an expression of the coefficient-wise != operator of *this and \a other
   *
   * \warning this performs an exact comparison, which is generally a bad idea with floating-point types.
   * In order to check for equality between two vectors or matrices with floating-point coefficients, it is
   * generally a far better idea to use a fuzzy comparison as provided by isApprox() and
@@ -55,18 +55,18 @@
   * Example: \include MatrixBase_cwiseNotEqual.cpp
   * Output: \verbinclude MatrixBase_cwiseNotEqual.out
   *
   * \sa cwiseEqual(), isApprox(), isMuchSmallerThan()
   */
 template<typename OtherDerived>
 EIGEN_DEVICE_FUNC
-inline const CwiseBinaryOp<std::not_equal_to<Scalar>, const Derived, const OtherDerived>
+inline const CwiseBinaryOp<numext::not_equal_to<Scalar>, const Derived, const OtherDerived>
 cwiseNotEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const
 {
-  return CwiseBinaryOp<std::not_equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
+  return CwiseBinaryOp<numext::not_equal_to<Scalar>, const Derived, const OtherDerived>(derived(), other.derived());
 }
 
 /** \returns an expression of the coefficient-wise min of *this and \a other
   *
   * Example: \include MatrixBase_cwiseMin.cpp
   * Output: \verbinclude MatrixBase_cwiseMin.out
   *
```

### Comparing `chronogram-0.1.7/include/Eigen/src/plugins/MatrixCwiseUnaryOps.h` & `chronogram-0.2.0/include/Eigen/src/plugins/MatrixCwiseUnaryOps.h`

 * *Files 7% similar despite different names*

```diff
@@ -10,14 +10,15 @@
 
 // This file is included into the body of the base classes supporting matrix specific coefficient-wise functions.
 // This include MatrixBase and SparseMatrixBase.
 
 
 typedef CwiseUnaryOp<internal::scalar_abs_op<Scalar>, const Derived> CwiseAbsReturnType;
 typedef CwiseUnaryOp<internal::scalar_abs2_op<Scalar>, const Derived> CwiseAbs2ReturnType;
+typedef CwiseUnaryOp<internal::scalar_arg_op<Scalar>, const Derived> CwiseArgReturnType;
 typedef CwiseUnaryOp<internal::scalar_sqrt_op<Scalar>, const Derived> CwiseSqrtReturnType;
 typedef CwiseUnaryOp<internal::scalar_sign_op<Scalar>, const Derived> CwiseSignReturnType;
 typedef CwiseUnaryOp<internal::scalar_inverse_op<Scalar>, const Derived> CwiseInverseReturnType;
 
 /// \returns an expression of the coefficient-wise absolute value of \c *this
 ///
 /// Example: \include MatrixBase_cwiseAbs.cpp
@@ -78,8 +79,17 @@
 ///
 /// \sa cwiseProduct()
 ///
 EIGEN_DEVICE_FUNC
 inline const CwiseInverseReturnType
 cwiseInverse() const { return CwiseInverseReturnType(derived()); }
 
+/// \returns an expression of the coefficient-wise phase angle of \c *this
+///
+/// Example: \include MatrixBase_cwiseArg.cpp
+/// Output: \verbinclude MatrixBase_cwiseArg.out
+///
+EIGEN_DOC_UNARY_ADDONS(cwiseArg,arg)
 
+EIGEN_DEVICE_FUNC
+inline const CwiseArgReturnType
+cwiseArg() const { return CwiseArgReturnType(derived()); }
```

### Comparing `chronogram-0.1.7/setup.py` & `chronogram-0.2.0/setup.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,83 +1,89 @@
-from setuptools import setup, Extension
-from codecs import open
-import os, os.path, struct, platform
-from setuptools.command.install import install
-
-here = os.path.abspath(os.path.dirname(__file__))
-
-with open(os.path.join(here, 'README.rst'), encoding='utf-8') as f:
-    long_description = f.read()
-
-sources = []
-for f in os.listdir(os.path.join(here, 'src')):
-    if f.endswith('.cpp') and not f.endswith('main.cpp'): sources.append('src/' + f)
-
-if platform.system() == 'Windows': 
-    cargs = ['/O2', '/MT', '/Gy']
-    arch_levels = {'':'', 'sse2':'/arch:SSE2', 'avx':'/arch:AVX', 'avx2':'/arch:AVX2'}
-elif platform.system() == 'Darwin': 
-    cargs = ['-std=c++1y', '-O3', '-fpermissive', '-stdlib=libc++']
-    arch_levels = {'':'-march=native'}
-elif 'manylinux' in os.environ.get('AUDITWHEEL_PLAT', ''):
-    cargs = ['-std=c++1y', '-O3', '-fpermissive']
-    arch_levels = {'':'', 'sse2':'-msse2', 'avx':'-mavx', 'avx2':'-mavx2'}
-else:
-    cargs = ['-std=c++1y', '-O3', '-fpermissive']
-    arch_levels = {'':'-march=native'}
-
-if struct.calcsize('P') < 8: arch_levels = {k:v for k, v in arch_levels.items() if k in ('', 'sse2')}
-else: arch_levels = {k:v for k, v in arch_levels.items() if k not in ('sse2',)}
-
-modules = []
-for arch, aopt in arch_levels.items():
-    module_name = '_chronogram' + ('_' + arch if arch else '')
-    modules.append(Extension(module_name,
-                    libraries = [],
-                    include_dirs=['include'],
-                    sources = sources,
-                    define_macros=[('MODULE_NAME', 'PyInit_' + module_name)],
-                    extra_compile_args=cargs + ([aopt] if aopt else [])))
-
-
-setup(
-    name='chronogram',
-
-    version='0.1.7',
-
-    description='Chrono-gram, the diachronic word embedding model based on Word2vec Skip-gram with Chebyshev approximation',
-    long_description=long_description,
-
-    url='https://github.com/bab2min/chronogram',
-
-    author='bab2min',
-    author_email='bab2min@gmail.com',
-
-    license='MIT License',
-
-    classifiers=[
-        'Development Status :: 3 - Alpha',
-
-        "Intended Audience :: Information Technology",
-        "Intended Audience :: Science/Research",
-        "Topic :: Software Development :: Libraries",
-        "Topic :: Text Processing :: Linguistic",
-		"Topic :: Scientific/Engineering :: Information Analysis",
-
-        "License :: OSI Approved :: MIT License",
-
-        'Programming Language :: Python :: 3',
-        'Programming Language :: C++',
-		"Operating System :: Microsoft :: Windows :: Windows Vista",
-		"Operating System :: Microsoft :: Windows :: Windows 7",
-		"Operating System :: Microsoft :: Windows :: Windows 8",
-		"Operating System :: Microsoft :: Windows :: Windows 8.1",
-		"Operating System :: Microsoft :: Windows :: Windows 10",
-		"Operating System :: POSIX"
-    ],
-    install_requires=['py-cpuinfo'],
-    keywords='NLP,Word2vec,Word Embedding',
-
-    packages = ['chronogram'],
-    include_package_data=True,
-    ext_modules = modules
-)
+from setuptools import setup, Extension
+from codecs import open
+import os, os.path, struct, platform
+from setuptools.command.install import install
+import numpy
+
+here = os.path.abspath(os.path.dirname(__file__))
+
+if os.environ.get('CG_CPU_ARCH'):
+    from sysconfig import get_platform
+    fd = get_platform().split('-')
+    if fd[0] == 'macosx':
+        os.environ['_PYTHON_HOST_PLATFORM'] = '-'.join(fd[:-1] + [os.environ['CG_CPU_ARCH']])
+
+with open(os.path.join(here, 'README.rst'), encoding='utf-8') as f:
+    long_description = f.read()
+
+sources = []
+for f in os.listdir(os.path.join(here, 'src')):
+    if f.endswith('.cpp') and not f.endswith('main.cpp'): sources.append('src/' + f)
+
+if platform.system() == 'Windows': 
+    cargs = ['/O2', '/MT', '/Gy']
+    arch_levels = {'':'', 'sse2':'/arch:SSE2', 'avx':'/arch:AVX', 'avx2':'/arch:AVX2'}
+elif platform.system() == 'Darwin': 
+    cargs = ['-std=c++1y', '-O3', '-fpermissive', '-stdlib=libc++']
+    arch_levels = {'':'', 'sse2':'-msse2'}
+elif 'manylinux' in os.environ.get('AUDITWHEEL_PLAT', ''):
+    cargs = ['-std=c++1y', '-O3', '-fpermissive']
+    arch_levels = {'':'', 'sse2':'-msse2', 'avx':'-mavx', 'avx2':'-mavx2'}
+else:
+    cargs = ['-std=c++1y', '-O3', '-fpermissive']
+    arch_levels = {'':'-march=native'}
+
+if struct.calcsize('P') < 8: arch_levels = {k:v for k, v in arch_levels.items() if k in ('', 'sse2')}
+else: arch_levels = {k:v for k, v in arch_levels.items() if k not in ('sse2',)}
+
+modules = []
+for arch, aopt in arch_levels.items():
+    module_name = '_chronogram' + ('_' + arch if arch else '')
+    modules.append(Extension(module_name,
+                    libraries = [],
+                    include_dirs=['include', numpy.get_include()],
+                    sources = sources,
+                    define_macros=[('MODULE_NAME', 'PyInit_' + module_name)],
+                    extra_compile_args=cargs + ([aopt] if aopt else [])))
+
+setup(
+    name='chronogram',
+
+    version='0.2.0',
+
+    description='Chrono-gram, the diachronic word embedding model based on Word2vec Skip-gram with Chebyshev approximation',
+    long_description='',
+
+    url='https://github.com/bab2min/chronogram',
+
+    author='bab2min',
+    author_email='bab2min@gmail.com',
+
+    license='MIT License',
+
+    classifiers=[
+        'Development Status :: 3 - Alpha',
+
+        "Intended Audience :: Information Technology",
+        "Intended Audience :: Science/Research",
+        "Topic :: Software Development :: Libraries",
+        "Topic :: Text Processing :: Linguistic",
+		"Topic :: Scientific/Engineering :: Information Analysis",
+
+        "License :: OSI Approved :: MIT License",
+
+        'Programming Language :: Python :: 3',
+        'Programming Language :: C++',
+		"Operating System :: Microsoft :: Windows :: Windows Vista",
+		"Operating System :: Microsoft :: Windows :: Windows 7",
+		"Operating System :: Microsoft :: Windows :: Windows 8",
+		"Operating System :: Microsoft :: Windows :: Windows 8.1",
+		"Operating System :: Microsoft :: Windows :: Windows 10",
+		"Operating System :: POSIX"
+    ],
+    install_requires=['py-cpuinfo'],
+    keywords='NLP,Word2vec,Word Embedding',
+
+    packages = ['chronogram'],
+    include_package_data=True,
+    ext_modules = modules
+)
```

### Comparing `chronogram-0.1.7/src/DataReader.h` & `chronogram-0.2.0/src/DataReader.h`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-#pragma once
-#include <fstream>
-#include <memory>
-#include "ChronoGramModel.h"
-
-class MultipleReader
-{
-	std::vector<std::string> files;
-	size_t currentId = 0;
-	std::unique_ptr<std::ifstream> ifs;
-public:
-	MultipleReader(const std::vector<std::string>& _files) : files(_files), ifs(new std::ifstream{_files[0]})
-	{
-	}
-
-	ChronoGramModel::ReadResult operator()();
-	static std::function<ChronoGramModel::ResultReader()> factory(const std::vector<std::string>& _files);
-};
-
-class GNgramBinaryReader
-{
-	std::ifstream ifs;
-public:
-	GNgramBinaryReader(const std::string& filename) : ifs(filename, std::ios_base::binary)
-	{
-	}
-
-	ChronoGramModel::GNgramReadResult operator()();
-	static std::function<ChronoGramModel::GNgramResultReader()> factory(const std::string& _file);
-};
+#pragma once
+#include <fstream>
+#include <memory>
+#include "ChronoGramModel.h"
+
+class MultipleReader
+{
+	std::vector<std::string> files;
+	size_t currentId = 0;
+	std::unique_ptr<std::ifstream> ifs;
+public:
+	MultipleReader(const std::vector<std::string>& _files) : files(_files), ifs(new std::ifstream{_files[0]})
+	{
+	}
+
+	ChronoGramModel::ReadResult operator()();
+	static std::function<ChronoGramModel::ResultReader()> factory(const std::vector<std::string>& _files);
+};
+
+class GNgramBinaryReader
+{
+	std::ifstream ifs;
+public:
+	GNgramBinaryReader(const std::string& filename) : ifs(filename, std::ios_base::binary)
+	{
+	}
+
+	ChronoGramModel::GNgramReadResult operator()();
+	static std::function<ChronoGramModel::GNgramResultReader()> factory(const std::string& _file);
+};
```

### Comparing `chronogram-0.1.7/src/IOUtils.h` & `chronogram-0.2.0/src/IOUtils.h`

 * *Files 25% similar despite different names*

```diff
@@ -1,217 +1,222 @@
-#pragma once
-
-#include <iostream>
-#include <vector>
-#include <map>
-
-class imstream
-{
-private:
-	const char* ptr, *begin, *end;
-public:
-	imstream(const char* _ptr, size_t len) : ptr(_ptr), begin(_ptr), end(_ptr + len)
-	{
-	}
-
-	template<class _Ty>
-	const _Ty& read()
-	{
-		if (end - ptr < sizeof(_Ty)) throw std::ios_base::failure(std::string{ "reading type '" } +typeid(_Ty).name() + "' failed");
-		auto p = (_Ty*)ptr;
-		ptr += sizeof(_Ty);
-		return *p;
-	}
-
-	bool read(void* dest, size_t size)
-	{
-		if (end - ptr < size) return false;
-		std::memcpy(dest, ptr, size);
-		ptr += size;
-		return true;
-	}
-
-	void exceptions(int)
-	{
-		// dummy functions
-	}
-
-	const char* get() const
-	{
-		return ptr;
-	}
-
-	size_t tellg() const
-	{
-		return ptr - begin;
-	}
-
-	bool seekg(std::streamoff distance, std::ios_base::seek_dir dir = std::ios_base::beg)
-	{
-		if (dir == std::ios_base::beg)
-		{
-			if (distance < 0 || distance > end - begin) return false;
-			ptr = begin + distance;
-		}
-		else if (dir == std::ios_base::cur)
-		{
-			if (ptr + distance < begin || ptr + distance > end) return false;
-			ptr += distance;
-		}
-		else if (dir == std::ios_base::end)
-		{
-			if (distance > 0 || end + distance < begin) return false;
-			ptr = end + distance;
-		}
-		else return false;
-		return true;
-	}
-};
-
-template<class _Ty> inline void writeToBinStream(std::ostream& os, const _Ty& v);
-template<class _Ty, class _Istream> inline _Ty readFromBinStream(_Istream& is);
-template<class _Ty, class _Istream> inline void readFromBinStream(_Istream& is, _Ty& v);
-
-template<class _Ty>
-inline typename std::enable_if<std::is_fundamental<_Ty>::value || std::is_enum<_Ty>::value>::type writeToBinStreamImpl(std::ostream& os, const _Ty& v)
-{
-	if (!os.write((const char*)&v, sizeof(_Ty))) throw std::ios_base::failure(std::string{ "writing type '" } +typeid(_Ty).name() + "' failed");
-}
-
-template<class _Ty, class _Istream>
-inline typename std::enable_if<std::is_fundamental<_Ty>::value || std::is_enum<_Ty>::value>::type readFromBinStreamImpl(_Istream& is, _Ty& v)
-{
-	if (!is.read((char*)&v, sizeof(_Ty))) throw std::ios_base::failure(std::string{ "reading type '" } +typeid(_Ty).name() + "' failed");
-}
-
-template<typename _Elem>
-inline void writeToBinStreamImpl(std::ostream& os, const std::basic_string<_Elem>& v)
-{
-	writeToBinStream<uint32_t>(os, v.size());
-	if (!os.write((const char*)&v[0], v.size() * sizeof(_Elem))) throw std::ios_base::failure(std::string{ "writing type '" } +typeid(std::basic_string<_Elem>).name() + "' failed");
-}
-
-template<typename _Elem, class _Istream>
-inline void readFromBinStreamImpl(_Istream& is, std::basic_string<_Elem>& v)
-{
-	v.resize(readFromBinStream<uint32_t>(is));
-	if (!is.read((char*)&v[0], v.size() * sizeof(_Elem))) throw std::ios_base::failure(std::string{ "reading type '" } +typeid(std::basic_string<_Elem>).name() + "' failed");
-}
-
-template<class _Ty1, class _Ty2>
-inline void writeToBinStreamImpl(std::ostream& os, const typename std::pair<_Ty1, _Ty2>& v)
-{
-	writeToBinStream(os, v.first);
-	writeToBinStream(os, v.second);
-}
-
-template<class _Ty1, class _Ty2, class _Istream>
-inline void readFromBinStreamImpl(_Istream& is, typename std::pair<_Ty1, _Ty2>& v)
-{
-	v.first = readFromBinStream<_Ty1>(is);
-	v.second = readFromBinStream<_Ty2>(is);
-}
-
-
-template<class _Ty1, class _Ty2>
-inline void writeToBinStreamImpl(std::ostream& os, const typename std::map<_Ty1, _Ty2>& v)
-{
-	writeToBinStream<uint32_t>(os, v.size());
-	for (auto& p : v)
-	{
-		writeToBinStream(os, p);
-	}
-}
-
-template<class _Ty1, class _Ty2, class _Istream>
-inline void readFromBinStreamImpl(_Istream& is, typename std::map<_Ty1, _Ty2>& v)
-{
-	size_t len = readFromBinStream<uint32_t>(is);
-	v.clear();
-	for (size_t i = 0; i < len; ++i)
-	{
-		v.emplace(readFromBinStream<std::pair<_Ty1, _Ty2>>(is));
-	}
-}
-
-
-template<class _Ty1>
-inline void writeToBinStreamImpl(std::ostream& os, const typename std::vector<_Ty1>& v)
-{
-	writeToBinStream<uint32_t>(os, v.size());
-	for (auto& p : v)
-	{
-		writeToBinStream(os, p);
-	}
-}
-
-template<class _Ty1, class _Istream>
-inline void readFromBinStreamImpl(_Istream& is, typename std::vector<_Ty1>& v)
-{
-	size_t len = readFromBinStream<uint32_t>(is);
-	v.clear();
-	for (size_t i = 0; i < len; ++i)
-	{
-		v.emplace_back(readFromBinStream<_Ty1>(is));
-	}
-}
-
-template<typename _Ty1, int _Rows, int _Cols>
-inline void writeToBinStreamImpl(std::ostream& os, const typename Eigen::Matrix<_Ty1, _Rows, _Cols>& v)
-{
-	for (size_t i = 0; i < v.size(); ++i)
-	{
-		writeToBinStream(os, v.data()[i]);
-	}
-}
-
-template<typename _Ty1, int _Rows, int _Cols, class _Istream>
-inline void readFromBinStreamImpl(_Istream& is, typename Eigen::Matrix<_Ty1, _Rows, _Cols>& v)
-{
-	for (size_t i = 0; i < v.size(); ++i)
-	{
-		readFromBinStream(is, v.data()[i]);
-	}
-}
-
-void writeFloatVL(std::ostream& os, float f);
-float readFloatVL(std::istream& is);
-float readFloatVL(imstream& is);
-
-template<typename _Ty1, int _Rows, int _Cols>
-inline void writeToBinStreamCompressed(std::ostream& os, const typename Eigen::Matrix<_Ty1, _Rows, _Cols>& v)
-{
-	for (size_t i = 0; i < v.size(); ++i)
-	{
-		writeFloatVL(os, v.data()[i]);
-	}
-}
-
-template<typename _Ty1, int _Rows, int _Cols, class _Istream>
-inline void readFromBinStreamCompressed(_Istream& is, typename Eigen::Matrix<_Ty1, _Rows, _Cols>& v)
-{
-	for (size_t i = 0; i < v.size(); ++i)
-	{
-		v.data()[i] = readFloatVL(is);
-	}
-}
-
-template<class _Ty>
-inline void writeToBinStream(std::ostream& os, const _Ty& v)
-{
-	writeToBinStreamImpl(os, v);
-}
-
-
-template<class _Ty, class _Istream>
-inline _Ty readFromBinStream(_Istream& is)
-{
-	_Ty v;
-	readFromBinStreamImpl(is, v);
-	return v;
-}
-
-template<class _Ty, class _Istream>
-inline void readFromBinStream(_Istream& is, _Ty& v)
-{
-	readFromBinStreamImpl(is, v);
-}
+#pragma once
+
+#include <iostream>
+#include <vector>
+#include <map>
+
+class imstream
+{
+private:
+	const char* ptr, *begin, *end;
+public:
+	imstream(const char* _ptr, size_t len) : ptr(_ptr), begin(_ptr), end(_ptr + len)
+	{
+	}
+
+	template<class _Ty>
+	const _Ty& read()
+	{
+		if (end - ptr < sizeof(_Ty)) throw std::ios_base::failure(std::string{ "reading type '" } +typeid(_Ty).name() + "' failed");
+		auto p = (_Ty*)ptr;
+		ptr += sizeof(_Ty);
+		return *p;
+	}
+
+	bool read(void* dest, size_t size)
+	{
+		if (end - ptr < size) return false;
+		std::memcpy(dest, ptr, size);
+		ptr += size;
+		return true;
+	}
+
+	void exceptions(int)
+	{
+		// dummy functions
+	}
+
+	const char* get() const
+	{
+		return ptr;
+	}
+
+	size_t tellg() const
+	{
+		return ptr - begin;
+	}
+
+	bool seekg(std::streamoff distance, std::ios_base::seek_dir dir = std::ios_base::beg)
+	{
+		if (dir == std::ios_base::beg)
+		{
+			if (distance < 0 || distance > end - begin) return false;
+			ptr = begin + distance;
+		}
+		else if (dir == std::ios_base::cur)
+		{
+			if (ptr + distance < begin || ptr + distance > end) return false;
+			ptr += distance;
+		}
+		else if (dir == std::ios_base::end)
+		{
+			if (distance > 0 || end + distance < begin) return false;
+			ptr = end + distance;
+		}
+		else return false;
+		return true;
+	}
+};
+
+template<class _Ty> inline void writeToBinStream(std::ostream& os, const _Ty& v);
+template<class _Ty, class _Istream> inline _Ty readFromBinStream(_Istream& is);
+template<class _Ty, class _Istream> inline void readFromBinStream(_Istream& is, _Ty& v);
+
+template<typename _Ty, typename = void>
+struct Serializer;
+
+template<typename _Ty>
+struct Serializer<_Ty,
+	typename std::enable_if<std::is_fundamental<_Ty>::value || std::is_enum<_Ty>::value>::type>
+{
+	template<typename _Os>
+	void write(_Os&& os, const _Ty& v)
+	{
+		if (!os.write((const char*)&v, sizeof(_Ty))) throw std::ios_base::failure(std::string{ "writing type '" } + typeid(_Ty).name() + "' failed");
+	}
+
+	template<typename _Is>
+	void read(_Is&& is, _Ty& v)
+	{
+		if (!is.read((char*)&v, sizeof(_Ty))) throw std::ios_base::failure(std::string{ "reading type '" } + typeid(_Ty).name() + "' failed");
+	}
+};
+
+template<typename _Ty>
+struct Serializer<std::basic_string<_Ty>>
+{
+	template<typename _Os>
+	void write(_Os&& os, const std::basic_string<_Ty>& v)
+	{
+		writeToBinStream<uint32_t>(os, v.size());
+		if (!os.write((const char*)&v[0], v.size() * sizeof(_Ty))) throw std::ios_base::failure(std::string{ "writing type '" } + typeid(std::basic_string<_Ty>).name() + "' failed");
+	}
+
+	template<typename _Is>
+	void read(_Is&& is, std::basic_string<_Ty>& v)
+	{
+		v.resize(readFromBinStream<uint32_t>(is));
+		if (!is.read((char*)&v[0], v.size() * sizeof(_Ty))) throw std::ios_base::failure(std::string{ "reading type '" } + typeid(std::basic_string<_Ty>).name() + "' failed");
+	}
+};
+
+
+template<typename _Ty>
+struct Serializer<std::vector<_Ty>>
+{
+	template<typename _Os>
+	void write(_Os&& os, const std::vector<_Ty>& v)
+	{
+		writeToBinStream<uint32_t>(os, v.size());
+		for (auto& p : v)
+		{
+			writeToBinStream(os, p);
+		}
+	}
+
+	template<typename _Is>
+	void read(_Is&& is, std::vector<_Ty>& v)
+	{
+		size_t len = readFromBinStream<uint32_t>(is);
+		v.clear();
+		for (size_t i = 0; i < len; ++i)
+		{
+			v.emplace_back(readFromBinStream<_Ty>(is));
+		}
+	}
+};
+
+template<typename _Ty1, typename _Ty2>
+struct Serializer<std::pair<_Ty1, _Ty2>>
+{
+	template<typename _Os>
+	void write(_Os&& os, const std::pair<_Ty1, _Ty2>& v)
+	{
+		writeToBinStream(os, v.first);
+		writeToBinStream(os, v.second);
+	}
+
+	template<typename _Is>
+	void read(_Is&& is, std::pair<_Ty1, _Ty2>& v)
+	{
+		readFromBinStream(is, v.first);
+		readFromBinStream(is, v.second);
+	}
+};
+
+template<typename _Ty1, typename _Ty2>
+struct Serializer<std::map<_Ty1, _Ty2>>
+{
+	template<typename _Os>
+	void write(_Os&& os, const std::map<_Ty1, _Ty2>& v)
+	{
+		writeToBinStream<uint32_t>(os, v.size());
+		for (auto& p : v)
+		{
+			writeToBinStream(os, p);
+		}
+	}
+
+	template<typename _Is>
+	void read(_Is&& is, std::map<_Ty1, _Ty2>& v)
+	{
+		size_t len = readFromBinStream<uint32_t>(is);
+		v.clear();
+		for (size_t i = 0; i < len; ++i)
+		{
+			v.emplace(readFromBinStream<std::pair<_Ty1, _Ty2>>(is));
+		}
+	}
+};
+
+void writeFloatVL(std::ostream& os, float f);
+float readFloatVL(std::istream& is);
+float readFloatVL(imstream& is);
+
+template<typename _Ty1, int _Rows, int _Cols>
+inline void writeToBinStreamCompressed(std::ostream& os, const typename Eigen::Matrix<_Ty1, _Rows, _Cols>& v)
+{
+	for (size_t i = 0; i < v.size(); ++i)
+	{
+		writeFloatVL(os, v.data()[i]);
+	}
+}
+
+template<typename _Ty1, int _Rows, int _Cols, class _Istream>
+inline void readFromBinStreamCompressed(_Istream& is, typename Eigen::Matrix<_Ty1, _Rows, _Cols>& v)
+{
+	for (size_t i = 0; i < v.size(); ++i)
+	{
+		v.data()[i] = readFloatVL(is);
+	}
+}
+
+template<class _Ty>
+inline void writeToBinStream(std::ostream& os, const _Ty& v)
+{
+	Serializer<typename std::remove_reference<_Ty>::type>().write(os, v);
+}
+
+
+template<class _Ty, class _Istream>
+inline _Ty readFromBinStream(_Istream& is)
+{
+	_Ty v;
+	Serializer<typename std::remove_reference<_Ty>::type>().read(is, v);
+	return v;
+}
+
+template<class _Ty, class _Istream>
+inline void readFromBinStream(_Istream& is, _Ty& v)
+{
+	Serializer<typename std::remove_reference<_Ty>::type>().read(is, v);
+}
```

### Comparing `chronogram-0.1.7/src/LUT.hpp` & `chronogram-0.2.0/src/LUT.hpp`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,77 +1,77 @@
-#pragma once
-
-template<class MathFunction, class Precision, size_t N, size_t S, size_t M, size_t T, size_t L, size_t U>
-class LUT3
-{
-protected:
-	Precision* points;
-	const Precision P = 1.0 / S;
-	const Precision Q = 1.0 / T;
-	const Precision R = 1.0 / U;
-	LUT3()
-	{
-		MathFunction fun;
-		points = new Precision[N + M + L];
-		for (size_t i = 0; i < N; i++)
-		{
-			points[i] = fun(i ? i*P : 0.0001);
-		}
-		for (size_t i = 0; i < M; i++)
-		{
-			points[i + N] = fun(i*Q + N*P);
-		}
-		for (size_t i = 0; i < L; i++)
-		{
-			points[i + N + M] = fun(i*R + N*P + M*Q);
-		}
-	}
-	~LUT3()
-	{
-		delete[] points;
-	}
-
-	Precision _get(Precision x) const
-	{
-		if (x < 0) return NAN;
-		if (x < MathFunction::smallThreshold) return MathFunction{}.forSmall(x);
-		if (x >= N / S + M / T + L / U) return MathFunction{}.forLarge(x);
-		size_t idx;
-		Precision a;
-		Precision nx = x;
-		if (x < N*P)
-		{
-			idx = (size_t)(nx / P);
-			a = (nx - idx*P) / P;
-		}
-		else
-		{
-			nx -= N*P;
-			if (nx < M*Q)
-			{
-				idx = (size_t)(nx / Q);
-				a = (nx - idx*Q) / Q;
-				idx += N;
-			}
-			else
-			{
-				nx -= M*Q;
-				idx = (size_t)(nx / R);
-				a = (nx - idx*R) / R;
-				idx += N + M;
-			}
-		}
-		return points[idx] + a * (points[idx + 1] - points[idx]);
-	}
-public:
-	static const LUT3& getInst()
-	{
-		static LUT3 lg;
-		return lg;
-	}
-
-	static Precision get(Precision x)
-	{
-		return getInst()._get(x);
-	}
-};
-
+#pragma once
+
+template<class MathFunction, class Precision, size_t N, size_t S, size_t M, size_t T, size_t L, size_t U>
+class LUT3
+{
+protected:
+	Precision* points;
+	const Precision P = 1.0 / S;
+	const Precision Q = 1.0 / T;
+	const Precision R = 1.0 / U;
+	LUT3()
+	{
+		MathFunction fun;
+		points = new Precision[N + M + L];
+		for (size_t i = 0; i < N; i++)
+		{
+			points[i] = fun(i ? i*P : 0.0001);
+		}
+		for (size_t i = 0; i < M; i++)
+		{
+			points[i + N] = fun(i*Q + N*P);
+		}
+		for (size_t i = 0; i < L; i++)
+		{
+			points[i + N + M] = fun(i*R + N*P + M*Q);
+		}
+	}
+	~LUT3()
+	{
+		delete[] points;
+	}
+
+	Precision _get(Precision x) const
+	{
+		if (x < 0) return NAN;
+		if (x < MathFunction::smallThreshold) return MathFunction{}.forSmall(x);
+		if (x >= N / S + M / T + L / U) return MathFunction{}.forLarge(x);
+		size_t idx;
+		Precision a;
+		Precision nx = x;
+		if (x < N*P)
+		{
+			idx = (size_t)(nx / P);
+			a = (nx - idx*P) / P;
+		}
+		else
+		{
+			nx -= N*P;
+			if (nx < M*Q)
+			{
+				idx = (size_t)(nx / Q);
+				a = (nx - idx*Q) / Q;
+				idx += N;
+			}
+			else
+			{
+				nx -= M*Q;
+				idx = (size_t)(nx / R);
+				a = (nx - idx*R) / R;
+				idx += N + M;
+			}
+		}
+		return points[idx] + a * (points[idx + 1] - points[idx]);
+	}
+public:
+	static const LUT3& getInst()
+	{
+		static LUT3 lg;
+		return lg;
+	}
+
+	static Precision get(Precision x)
+	{
+		return getInst()._get(x);
+	}
+};
+
```

### Comparing `chronogram-0.1.7/src/ThreadPool.h` & `chronogram-0.2.0/src/ThreadPool.h`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,102 +1,102 @@
-#pragma once
-
-/*
-A simple C++11 Thread Pool implementation(https://github.com/progschj/ThreadPool)
-modified by bab2min to have additional parameter threadId
-*/
-
-#include <vector>
-#include <queue>
-#include <memory>
-#include <thread>
-#include <mutex>
-#include <condition_variable>
-#include <future>
-#include <functional>
-#include <stdexcept>
-
-class ThreadPool {
-public:
-	ThreadPool(size_t, size_t maxQueued = 0);
-	template<class F, class... Args>
-	auto enqueue(F&& f, Args&&... args)
-		->std::future<typename std::result_of<F(size_t, Args...)>::type>;
-	~ThreadPool();
-	size_t getNumWorkers() const { return workers.size(); }
-	size_t getNumEnqued() const { return tasks.size(); }
-private:
-	// need to keep track of threads so we can join them
-	std::vector< std::thread > workers;
-	// the task queue
-	std::queue< std::function<void(size_t)> > tasks;
-
-	// synchronization
-	std::mutex queue_mutex;
-	std::condition_variable condition, inputCnd;
-	size_t maxQueued;
-	bool stop;
-};
-
-// the constructor just launches some amount of workers
-inline ThreadPool::ThreadPool(size_t threads, size_t _maxQueued)
-	: stop(false), maxQueued(_maxQueued)
-{
-	for (size_t i = 0; i < threads; ++i)
-		workers.emplace_back([this, i]
-	{
-		for (;;)
-		{
-			std::function<void(size_t)> task;
-			{
-				std::unique_lock<std::mutex> lock(this->queue_mutex);
-				this->condition.wait(lock,
-					[this] { return this->stop || !this->tasks.empty(); });
-				if (this->stop && this->tasks.empty()) return;
-				task = std::move(this->tasks.front());
-				this->tasks.pop();
-				if (this->maxQueued) this->inputCnd.notify_all();
-			}
-			//std::cout << "Start #" << i << std::endl;
-			task(i);
-			//std::cout << "End #" << i << std::endl;
-		}
-	});
-}
-
-// add new work item to the pool
-template<class F, class... Args>
-auto ThreadPool::enqueue(F&& f, Args&&... args)
--> std::future<typename std::result_of<F(size_t, Args...)>::type>
-{
-	using return_type = typename std::result_of<F(size_t, Args...)>::type;
-
-	auto task = std::make_shared< std::packaged_task<return_type(size_t)> >(
-		std::bind(std::forward<F>(f), std::placeholders::_1, std::forward<Args>(args)...));
-
-	std::future<return_type> res = task->get_future();
-	{
-		std::unique_lock<std::mutex> lock(queue_mutex);
-
-		// don't allow enqueueing after stopping the pool
-		if (stop) throw std::runtime_error("enqueue on stopped ThreadPool");
-		if (maxQueued && tasks.size() >= maxQueued)
-		{
-			inputCnd.wait(lock, [&]() { return tasks.size() < maxQueued; });
-		}
-		tasks.emplace([task](size_t id) { (*task)(id); });
-	}
-	condition.notify_one();
-	return res;
-}
-
-// the destructor joins all threads
-inline ThreadPool::~ThreadPool()
-{
-	{
-		std::unique_lock<std::mutex> lock(queue_mutex);
-		stop = true;
-	}
-	condition.notify_all();
-	for (std::thread &worker : workers)
-		worker.join();
-}
+#pragma once
+
+/*
+A simple C++11 Thread Pool implementation(https://github.com/progschj/ThreadPool)
+modified by bab2min to have additional parameter threadId
+*/
+
+#include <vector>
+#include <queue>
+#include <memory>
+#include <thread>
+#include <mutex>
+#include <condition_variable>
+#include <future>
+#include <functional>
+#include <stdexcept>
+
+class ThreadPool {
+public:
+	ThreadPool(size_t, size_t maxQueued = 0);
+	template<class F, class... Args>
+	auto enqueue(F&& f, Args&&... args)
+		->std::future<typename std::result_of<F(size_t, Args...)>::type>;
+	~ThreadPool();
+	size_t getNumWorkers() const { return workers.size(); }
+	size_t getNumEnqued() const { return tasks.size(); }
+private:
+	// need to keep track of threads so we can join them
+	std::vector< std::thread > workers;
+	// the task queue
+	std::queue< std::function<void(size_t)> > tasks;
+
+	// synchronization
+	std::mutex queue_mutex;
+	std::condition_variable condition, inputCnd;
+	size_t maxQueued;
+	bool stop;
+};
+
+// the constructor just launches some amount of workers
+inline ThreadPool::ThreadPool(size_t threads, size_t _maxQueued)
+	: stop(false), maxQueued(_maxQueued)
+{
+	for (size_t i = 0; i < threads; ++i)
+		workers.emplace_back([this, i]
+	{
+		for (;;)
+		{
+			std::function<void(size_t)> task;
+			{
+				std::unique_lock<std::mutex> lock(this->queue_mutex);
+				this->condition.wait(lock,
+					[this] { return this->stop || !this->tasks.empty(); });
+				if (this->stop && this->tasks.empty()) return;
+				task = std::move(this->tasks.front());
+				this->tasks.pop();
+				if (this->maxQueued) this->inputCnd.notify_all();
+			}
+			//std::cout << "Start #" << i << std::endl;
+			task(i);
+			//std::cout << "End #" << i << std::endl;
+		}
+	});
+}
+
+// add new work item to the pool
+template<class F, class... Args>
+auto ThreadPool::enqueue(F&& f, Args&&... args)
+-> std::future<typename std::result_of<F(size_t, Args...)>::type>
+{
+	using return_type = typename std::result_of<F(size_t, Args...)>::type;
+
+	auto task = std::make_shared< std::packaged_task<return_type(size_t)> >(
+		std::bind(std::forward<F>(f), std::placeholders::_1, std::forward<Args>(args)...));
+
+	std::future<return_type> res = task->get_future();
+	{
+		std::unique_lock<std::mutex> lock(queue_mutex);
+
+		// don't allow enqueueing after stopping the pool
+		if (stop) throw std::runtime_error("enqueue on stopped ThreadPool");
+		if (maxQueued && tasks.size() >= maxQueued)
+		{
+			inputCnd.wait(lock, [&]() { return tasks.size() < maxQueued; });
+		}
+		tasks.emplace([task](size_t id) { (*task)(id); });
+	}
+	condition.notify_one();
+	return res;
+}
+
+// the destructor joins all threads
+inline ThreadPool::~ThreadPool()
+{
+	{
+		std::unique_lock<std::mutex> lock(queue_mutex);
+		stop = true;
+	}
+	condition.notify_all();
+	for (std::thread &worker : workers)
+		worker.join();
+}
```

### Comparing `chronogram-0.1.7/src/cxxopts.hpp` & `chronogram-0.2.0/src/cxxopts.hpp`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,2077 +1,2077 @@
-/*
-Copyright (c) 2014, 2015, 2016, 2017 Jarryd Beck
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-*/
-
-#ifndef CXXOPTS_HPP_INCLUDED
-#define CXXOPTS_HPP_INCLUDED
-
-#include <cstring>
-#include <cctype>
-#include <exception>
-#include <iostream>
-#include <map>
-#include <memory>
-#include <regex>
-#include <sstream>
-#include <string>
-#include <unordered_map>
-#include <unordered_set>
-#include <vector>
-
-#ifdef __cpp_lib_optional
-#include <optional>
-#define CXXOPTS_HAS_OPTIONAL
-#endif
-
-#define CXXOPTS__VERSION_MAJOR 2
-#define CXXOPTS__VERSION_MINOR 2
-#define CXXOPTS__VERSION_PATCH 0
-
-namespace cxxopts
-{
-	static constexpr struct {
-		uint8_t major, minor, patch;
-	} version = {
-	  CXXOPTS__VERSION_MAJOR,
-	  CXXOPTS__VERSION_MINOR,
-	  CXXOPTS__VERSION_PATCH
-	};
-}
-
-//when we ask cxxopts to use Unicode, help strings are processed using ICU,
-//which results in the correct lengths being computed for strings when they
-//are formatted for the help output
-//it is necessary to make sure that <unicode/unistr.h> can be found by the
-//compiler, and that icu-uc is linked in to the binary.
-
-#ifdef CXXOPTS_USE_UNICODE
-#include <unicode/unistr.h>
-
-namespace cxxopts
-{
-	typedef icu::UnicodeString String;
-
-	inline
-		String
-		toLocalString(std::string s)
-	{
-		return icu::UnicodeString::fromUTF8(std::move(s));
-	}
-
-	class UnicodeStringIterator : public
-		std::iterator<std::forward_iterator_tag, int32_t>
-	{
-	public:
-
-		UnicodeStringIterator(const icu::UnicodeString* string, int32_t pos)
-			: s(string)
-			, i(pos)
-		{
-		}
-
-		value_type
-			operator*() const
-		{
-			return s->char32At(i);
-		}
-
-		bool
-			operator==(const UnicodeStringIterator& rhs) const
-		{
-			return s == rhs.s && i == rhs.i;
-		}
-
-		bool
-			operator!=(const UnicodeStringIterator& rhs) const
-		{
-			return !(*this == rhs);
-		}
-
-		UnicodeStringIterator&
-			operator++()
-		{
-			++i;
-			return *this;
-		}
-
-		UnicodeStringIterator
-			operator+(int32_t v)
-		{
-			return UnicodeStringIterator(s, i + v);
-		}
-
-	private:
-		const icu::UnicodeString* s;
-		int32_t i;
-	};
-
-	inline
-		String&
-		stringAppend(String&s, String a)
-	{
-		return s.append(std::move(a));
-	}
-
-	inline
-		String&
-		stringAppend(String& s, int n, UChar32 c)
-	{
-		for (int i = 0; i != n; ++i)
-		{
-			s.append(c);
-		}
-
-		return s;
-	}
-
-	template <typename Iterator>
-	String&
-		stringAppend(String& s, Iterator begin, Iterator end)
-	{
-		while (begin != end)
-		{
-			s.append(*begin);
-			++begin;
-		}
-
-		return s;
-	}
-
-	inline
-		size_t
-		stringLength(const String& s)
-	{
-		return s.length();
-	}
-
-	inline
-		std::string
-		toUTF8String(const String& s)
-	{
-		std::string result;
-		s.toUTF8String(result);
-
-		return result;
-	}
-
-	inline
-		bool
-		empty(const String& s)
-	{
-		return s.isEmpty();
-	}
-}
-
-namespace std
-{
-	inline
-		cxxopts::UnicodeStringIterator
-		begin(const icu::UnicodeString& s)
-	{
-		return cxxopts::UnicodeStringIterator(&s, 0);
-	}
-
-	inline
-		cxxopts::UnicodeStringIterator
-		end(const icu::UnicodeString& s)
-	{
-		return cxxopts::UnicodeStringIterator(&s, s.length());
-	}
-}
-
-//ifdef CXXOPTS_USE_UNICODE
-#else
-
-namespace cxxopts
-{
-	typedef std::string String;
-
-	template <typename T>
-	T
-		toLocalString(T&& t)
-	{
-		return std::forward<T>(t);
-	}
-
-	inline
-		size_t
-		stringLength(const String& s)
-	{
-		return s.length();
-	}
-
-	inline
-		String&
-		stringAppend(String&s, String a)
-	{
-		return s.append(std::move(a));
-	}
-
-	inline
-		String&
-		stringAppend(String& s, size_t n, char c)
-	{
-		return s.append(n, c);
-	}
-
-	template <typename Iterator>
-	String&
-		stringAppend(String& s, Iterator begin, Iterator end)
-	{
-		return s.append(begin, end);
-	}
-
-	template <typename T>
-	std::string
-		toUTF8String(T&& t)
-	{
-		return std::forward<T>(t);
-	}
-
-	inline
-		bool
-		empty(const std::string& s)
-	{
-		return s.empty();
-	}
-}
-
-//ifdef CXXOPTS_USE_UNICODE
-#endif
-
-namespace cxxopts
-{
-	namespace
-	{
-#ifdef _WIN32
-		const std::string LQUOTE("\'");
-		const std::string RQUOTE("\'");
-#else
-		const std::string LQUOTE("");
-		const std::string RQUOTE("");
-#endif
-	}
-
-	class Value : public std::enable_shared_from_this<Value>
-	{
-	public:
-
-		virtual ~Value() = default;
-
-		virtual
-			std::shared_ptr<Value>
-			clone() const = 0;
-
-		virtual void
-			parse(const std::string& text) const = 0;
-
-		virtual void
-			parse() const = 0;
-
-		virtual bool
-			has_default() const = 0;
-
-		virtual bool
-			is_container() const = 0;
-
-		virtual bool
-			has_implicit() const = 0;
-
-		virtual std::string
-			get_default_value() const = 0;
-
-		virtual std::string
-			get_implicit_value() const = 0;
-
-		virtual std::shared_ptr<Value>
-			default_value(const std::string& value) = 0;
-
-		virtual std::shared_ptr<Value>
-			implicit_value(const std::string& value) = 0;
-
-		virtual bool
-			is_boolean() const = 0;
-	};
-
-	class OptionException : public std::exception
-	{
-	public:
-		OptionException(const std::string& message)
-			: m_message(message)
-		{
-		}
-
-		virtual const char*
-			what() const noexcept
-		{
-			return m_message.c_str();
-		}
-
-	private:
-		std::string m_message;
-	};
-
-	class OptionSpecException : public OptionException
-	{
-	public:
-
-		OptionSpecException(const std::string& message)
-			: OptionException(message)
-		{
-		}
-	};
-
-	class OptionParseException : public OptionException
-	{
-	public:
-		OptionParseException(const std::string& message)
-			: OptionException(message)
-		{
-		}
-	};
-
-	class option_exists_error : public OptionSpecException
-	{
-	public:
-		option_exists_error(const std::string& option)
-			: OptionSpecException(u8"Option " + LQUOTE + option + RQUOTE + u8" already exists")
-		{
-		}
-	};
-
-	class invalid_option_format_error : public OptionSpecException
-	{
-	public:
-		invalid_option_format_error(const std::string& format)
-			: OptionSpecException(u8"Invalid option format " + LQUOTE + format + RQUOTE)
-		{
-		}
-	};
-
-	class option_syntax_exception : public OptionParseException {
-	public:
-		option_syntax_exception(const std::string& text)
-			: OptionParseException(u8"Argument " + LQUOTE + text + RQUOTE +
-				u8" starts with a - but has incorrect syntax")
-		{
-		}
-	};
-
-	class option_not_exists_exception : public OptionParseException
-	{
-	public:
-		option_not_exists_exception(const std::string& option)
-			: OptionParseException(u8"Option " + LQUOTE + option + RQUOTE + u8" does not exist")
-		{
-		}
-	};
-
-	class missing_argument_exception : public OptionParseException
-	{
-	public:
-		missing_argument_exception(const std::string& option)
-			: OptionParseException(
-				u8"Option " + LQUOTE + option + RQUOTE + u8" is missing an argument"
-			)
-		{
-		}
-	};
-
-	class option_requires_argument_exception : public OptionParseException
-	{
-	public:
-		option_requires_argument_exception(const std::string& option)
-			: OptionParseException(
-				u8"Option " + LQUOTE + option + RQUOTE + u8" requires an argument"
-			)
-		{
-		}
-	};
-
-	class option_not_has_argument_exception : public OptionParseException
-	{
-	public:
-		option_not_has_argument_exception
-		(
-			const std::string& option,
-			const std::string& arg
-		)
-			: OptionParseException(
-				u8"Option " + LQUOTE + option + RQUOTE +
-				u8" does not take an argument, but argument " +
-				LQUOTE + arg + RQUOTE + " given"
-			)
-		{
-		}
-	};
-
-	class option_not_present_exception : public OptionParseException
-	{
-	public:
-		option_not_present_exception(const std::string& option)
-			: OptionParseException(u8"Option " + LQUOTE + option + RQUOTE + u8" not present")
-		{
-		}
-	};
-
-	class argument_incorrect_type : public OptionParseException
-	{
-	public:
-		argument_incorrect_type
-		(
-			const std::string& arg
-		)
-			: OptionParseException(
-				u8"Argument " + LQUOTE + arg + RQUOTE + u8" failed to parse"
-			)
-		{
-		}
-	};
-
-	class option_required_exception : public OptionParseException
-	{
-	public:
-		option_required_exception(const std::string& option)
-			: OptionParseException(
-				u8"Option " + LQUOTE + option + RQUOTE + u8" is required but not present"
-			)
-		{
-		}
-	};
-
-	namespace values
-	{
-		namespace
-		{
-			std::basic_regex<char> integer_pattern
-			("(-)?(0x)?([0-9a-zA-Z]+)|((0x)?0)");
-			std::basic_regex<char> truthy_pattern
-			("(t|T)(rue)?");
-			std::basic_regex<char> falsy_pattern
-			("((f|F)(alse)?)?");
-		}
-
-		namespace detail
-		{
-			template <typename T, bool B>
-			struct SignedCheck;
-
-			template <typename T>
-			struct SignedCheck<T, true>
-			{
-				template <typename U>
-				void
-					operator()(bool negative, U u, const std::string& text)
-				{
-					if (negative)
-					{
-						if (u > static_cast<U>(-(std::numeric_limits<T>::min)()))
-						{
-							throw argument_incorrect_type(text);
-						}
-					}
-					else
-					{
-						if (u > static_cast<U>((std::numeric_limits<T>::max)()))
-						{
-							throw argument_incorrect_type(text);
-						}
-					}
-				}
-			};
-
-			template <typename T>
-			struct SignedCheck<T, false>
-			{
-				template <typename U>
-				void
-					operator()(bool, U, const std::string&) {}
-			};
-
-			template <typename T, typename U>
-			void
-				check_signed_range(bool negative, U value, const std::string& text)
-			{
-				SignedCheck<T, std::numeric_limits<T>::is_signed>()(negative, value, text);
-			}
-		}
-
-		template <typename R, typename T>
-		R
-			checked_negate(T&& t, const std::string&, std::true_type)
-		{
-			// if we got to here, then `t` is a positive number that fits into
-			// `R`. So to avoid MSVC C4146, we first cast it to `R`.
-			// See https://github.com/jarro2783/cxxopts/issues/62 for more details.
-			return -static_cast<R>(t);
-		}
-
-		template <typename R, typename T>
-		T
-			checked_negate(T&&, const std::string& text, std::false_type)
-		{
-			throw argument_incorrect_type(text);
-		}
-
-		template <typename T>
-		void
-			integer_parser(const std::string& text, T& value)
-		{
-			std::smatch match;
-			std::regex_match(text, match, integer_pattern);
-
-			if (match.length() == 0)
-			{
-				throw argument_incorrect_type(text);
-			}
-
-			if (match.length(4) > 0)
-			{
-				value = 0;
-				return;
-			}
-
-			using US = typename std::make_unsigned<T>::type;
-
-			constexpr auto umax = (std::numeric_limits<US>::max)();
-			constexpr bool is_signed = std::numeric_limits<T>::is_signed;
-			const bool negative = match.length(1) > 0;
-			const uint8_t base = match.length(2) > 0 ? 16 : 10;
-
-			auto value_match = match[3];
-
-			US result = 0;
-
-			for (auto iter = value_match.first; iter != value_match.second; ++iter)
-			{
-				US digit = 0;
-
-				if (*iter >= '0' && *iter <= '9')
-				{
-					digit = *iter - '0';
-				}
-				else if (base == 16 && *iter >= 'a' && *iter <= 'f')
-				{
-					digit = *iter - 'a' + 10;
-				}
-				else if (base == 16 && *iter >= 'A' && *iter <= 'F')
-				{
-					digit = *iter - 'A' + 10;
-				}
-				else
-				{
-					throw argument_incorrect_type(text);
-				}
-
-				if (umax - digit < result * base)
-				{
-					throw argument_incorrect_type(text);
-				}
-
-				result = result * base + digit;
-			}
-
-			detail::check_signed_range<T>(negative, result, text);
-
-			if (negative)
-			{
-				value = checked_negate<T>(result,
-					text,
-					std::integral_constant<bool, is_signed>());
-			}
-			else
-			{
-				value = result;
-			}
-		}
-
-		template <typename T>
-		void stringstream_parser(const std::string& text, T& value)
-		{
-			std::stringstream in(text);
-			in >> value;
-			if (!in) {
-				throw argument_incorrect_type(text);
-			}
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, uint8_t& value)
-		{
-			integer_parser(text, value);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, int8_t& value)
-		{
-			integer_parser(text, value);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, uint16_t& value)
-		{
-			integer_parser(text, value);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, int16_t& value)
-		{
-			integer_parser(text, value);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, uint32_t& value)
-		{
-			integer_parser(text, value);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, int32_t& value)
-		{
-			integer_parser(text, value);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, uint64_t& value)
-		{
-			integer_parser(text, value);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, int64_t& value)
-		{
-			integer_parser(text, value);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, bool& value)
-		{
-			std::smatch result;
-			std::regex_match(text, result, truthy_pattern);
-
-			if (!result.empty())
-			{
-				value = true;
-				return;
-			}
-
-			std::regex_match(text, result, falsy_pattern);
-			if (!result.empty())
-			{
-				value = false;
-				return;
-			}
-
-			throw argument_incorrect_type(text);
-		}
-
-		inline
-			void
-			parse_value(const std::string& text, std::string& value)
-		{
-			value = text;
-		}
-
-		// The fallback parser. It uses the stringstream parser to parse all types
-		// that have not been overloaded explicitly.  It has to be placed in the
-		// source code before all other more specialized templates.
-		template <typename T>
-		void
-			parse_value(const std::string& text, T& value) {
-			stringstream_parser(text, value);
-		}
-
-		template <typename T>
-		void
-			parse_value(const std::string& text, std::vector<T>& value)
-		{
-			T v;
-			parse_value(text, v);
-			value.push_back(v);
-		}
-
-#ifdef CXXOPTS_HAS_OPTIONAL
-		template <typename T>
-		void
-			parse_value(const std::string& text, std::optional<T>& value)
-		{
-			T result;
-			parse_value(text, result);
-			value = std::move(result);
-		}
-#endif
-
-		template <typename T>
-		struct type_is_container
-		{
-			static constexpr bool value = false;
-		};
-
-		template <typename T>
-		struct type_is_container<std::vector<T>>
-		{
-			static constexpr bool value = true;
-		};
-
-		template <typename T>
-		class abstract_value : public Value
-		{
-			using Self = abstract_value<T>;
-
-		public:
-			abstract_value()
-				: m_result(std::make_shared<T>())
-				, m_store(m_result.get())
-			{
-			}
-
-			abstract_value(T* t)
-				: m_store(t)
-			{
-			}
-
-			virtual ~abstract_value() = default;
-
-			abstract_value(const abstract_value& rhs)
-			{
-				if (rhs.m_result)
-				{
-					m_result = std::make_shared<T>();
-					m_store = m_result.get();
-				}
-				else
-				{
-					m_store = rhs.m_store;
-				}
-
-				m_default = rhs.m_default;
-				m_implicit = rhs.m_implicit;
-				m_default_value = rhs.m_default_value;
-				m_implicit_value = rhs.m_implicit_value;
-			}
-
-			void
-				parse(const std::string& text) const
-			{
-				parse_value(text, *m_store);
-			}
-
-			bool
-				is_container() const
-			{
-				return type_is_container<T>::value;
-			}
-
-			void
-				parse() const
-			{
-				parse_value(m_default_value, *m_store);
-			}
-
-			bool
-				has_default() const
-			{
-				return m_default;
-			}
-
-			bool
-				has_implicit() const
-			{
-				return m_implicit;
-			}
-
-			std::shared_ptr<Value>
-				default_value(const std::string& value)
-			{
-				m_default = true;
-				m_default_value = value;
-				return shared_from_this();
-			}
-
-			std::shared_ptr<Value>
-				implicit_value(const std::string& value)
-			{
-				m_implicit = true;
-				m_implicit_value = value;
-				return shared_from_this();
-			}
-
-			std::string
-				get_default_value() const
-			{
-				return m_default_value;
-			}
-
-			std::string
-				get_implicit_value() const
-			{
-				return m_implicit_value;
-			}
-
-			bool
-				is_boolean() const
-			{
-				return std::is_same<T, bool>::value;
-			}
-
-			const T&
-				get() const
-			{
-				if (m_store == nullptr)
-				{
-					return *m_result;
-				}
-				else
-				{
-					return *m_store;
-				}
-			}
-
-		protected:
-			std::shared_ptr<T> m_result;
-			T* m_store;
-
-			bool m_default = false;
-			bool m_implicit = false;
-
-			std::string m_default_value;
-			std::string m_implicit_value;
-		};
-
-		template <typename T>
-		class standard_value : public abstract_value<T>
-		{
-		public:
-			using abstract_value<T>::abstract_value;
-
-			std::shared_ptr<Value>
-				clone() const
-			{
-				return std::make_shared<standard_value<T>>(*this);
-			}
-		};
-
-		template <>
-		class standard_value<bool> : public abstract_value<bool>
-		{
-		public:
-			~standard_value() = default;
-
-			standard_value()
-			{
-				set_default_and_implicit();
-			}
-
-			standard_value(bool* b)
-				: abstract_value(b)
-			{
-				set_default_and_implicit();
-			}
-
-			std::shared_ptr<Value>
-				clone() const
-			{
-				return std::make_shared<standard_value<bool>>(*this);
-			}
-
-		private:
-
-			void
-				set_default_and_implicit()
-			{
-				m_default = true;
-				m_default_value = "false";
-				m_implicit = true;
-				m_implicit_value = "true";
-			}
-		};
-	}
-
-	template <typename T>
-	std::shared_ptr<Value>
-		value()
-	{
-		return std::make_shared<values::standard_value<T>>();
-	}
-
-	template <typename T>
-	std::shared_ptr<Value>
-		value(T& t)
-	{
-		return std::make_shared<values::standard_value<T>>(&t);
-	}
-
-	class OptionAdder;
-
-	class OptionDetails
-	{
-	public:
-		OptionDetails
-		(
-			const std::string& short_,
-			const std::string& long_,
-			const String& desc,
-			std::shared_ptr<const Value> val
-		)
-			: m_short(short_)
-			, m_long(long_)
-			, m_desc(desc)
-			, m_value(val)
-			, m_count(0)
-		{
-		}
-
-		OptionDetails(const OptionDetails& rhs)
-			: m_desc(rhs.m_desc)
-			, m_count(rhs.m_count)
-		{
-			m_value = rhs.m_value->clone();
-		}
-
-		OptionDetails(OptionDetails&& rhs) = default;
-
-		const String&
-			description() const
-		{
-			return m_desc;
-		}
-
-		const Value& value() const {
-			return *m_value;
-		}
-
-		std::shared_ptr<Value>
-			make_storage() const
-		{
-			return m_value->clone();
-		}
-
-		const std::string&
-			short_name() const
-		{
-			return m_short;
-		}
-
-		const std::string&
-			long_name() const
-		{
-			return m_long;
-		}
-
-	private:
-		std::string m_short;
-		std::string m_long;
-		String m_desc;
-		std::shared_ptr<const Value> m_value;
-		int m_count;
-	};
-
-	struct HelpOptionDetails
-	{
-		std::string s;
-		std::string l;
-		String desc;
-		bool has_default;
-		std::string default_value;
-		bool has_implicit;
-		std::string implicit_value;
-		std::string arg_help;
-		bool is_container;
-		bool is_boolean;
-	};
-
-	struct HelpGroupDetails
-	{
-		std::string name;
-		std::string description;
-		std::vector<HelpOptionDetails> options;
-	};
-
-	class OptionValue
-	{
-	public:
-		void
-			parse
-			(
-				std::shared_ptr<const OptionDetails> details,
-				const std::string& text
-			)
-		{
-			ensure_value(details);
-			++m_count;
-			m_value->parse(text);
-		}
-
-		void
-			parse_default(std::shared_ptr<const OptionDetails> details)
-		{
-			ensure_value(details);
-			m_value->parse();
-		}
-
-		size_t
-			count() const
-		{
-			return m_count;
-		}
-
-		template <typename T>
-		const T&
-			as() const
-		{
-			if (m_value == nullptr) {
-				throw std::domain_error("No value");
-			}
-
-#ifdef CXXOPTS_NO_RTTI
-			return static_cast<const values::standard_value<T>&>(*m_value).get();
-#else
-			return dynamic_cast<const values::standard_value<T>&>(*m_value).get();
-#endif
-		}
-
-	private:
-		void
-			ensure_value(std::shared_ptr<const OptionDetails> details)
-		{
-			if (m_value == nullptr)
-			{
-				m_value = details->make_storage();
-			}
-		}
-
-		std::shared_ptr<Value> m_value;
-		size_t m_count = 0;
-	};
-
-	class KeyValue
-	{
-	public:
-		KeyValue(std::string key_, std::string value_)
-			: m_key(std::move(key_))
-			, m_value(std::move(value_))
-		{
-		}
-
-		const
-			std::string&
-			key() const
-		{
-			return m_key;
-		}
-
-		const std::string
-			value() const
-		{
-			return m_value;
-		}
-
-		template <typename T>
-		T
-			as() const
-		{
-			T result;
-			values::parse_value(m_value, result);
-			return result;
-		}
-
-	private:
-		std::string m_key;
-		std::string m_value;
-	};
-
-	class ParseResult
-	{
-	public:
-
-		ParseResult(
-			const std::shared_ptr<
-			std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
-			>,
-			std::vector<std::string>,
-			bool allow_unrecognised,
-			int&, char**&);
-
-		size_t
-			count(const std::string& o) const
-		{
-			auto iter = m_options->find(o);
-			if (iter == m_options->end())
-			{
-				return 0;
-			}
-
-			auto riter = m_results.find(iter->second);
-
-			return riter->second.count();
-		}
-
-		const OptionValue&
-			operator[](const std::string& option) const
-		{
-			auto iter = m_options->find(option);
-
-			if (iter == m_options->end())
-			{
-				throw option_not_present_exception(option);
-			}
-
-			auto riter = m_results.find(iter->second);
-
-			return riter->second;
-		}
-
-		const std::vector<KeyValue>&
-			arguments() const
-		{
-			return m_sequential;
-		}
-
-	private:
-
-		void
-			parse(int& argc, char**& argv);
-
-		void
-			add_to_option(const std::string& option, const std::string& arg);
-
-		bool
-			consume_positional(std::string a);
-
-		void
-			parse_option
-			(
-				std::shared_ptr<OptionDetails> value,
-				const std::string& name,
-				const std::string& arg = ""
-			);
-
-		void
-			parse_default(std::shared_ptr<OptionDetails> details);
-
-		void
-			checked_parse_arg
-			(
-				int argc,
-				char* argv[],
-				int& current,
-				std::shared_ptr<OptionDetails> value,
-				const std::string& name
-			);
-
-		const std::shared_ptr<
-			std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
-		> m_options;
-		std::vector<std::string> m_positional;
-		std::vector<std::string>::iterator m_next_positional;
-		std::unordered_set<std::string> m_positional_set;
-		std::unordered_map<std::shared_ptr<OptionDetails>, OptionValue> m_results;
-
-		bool m_allow_unrecognised;
-
-		std::vector<KeyValue> m_sequential;
-	};
-
-	class Options
-	{
-		typedef std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
-			OptionMap;
-	public:
-
-		Options(std::string program, std::string help_string = "")
-			: m_program(std::move(program))
-			, m_help_string(toLocalString(std::move(help_string)))
-			, m_custom_help("[OPTION...]")
-			, m_positional_help("positional parameters")
-			, m_show_positional(false)
-			, m_allow_unrecognised(false)
-			, m_options(std::make_shared<OptionMap>())
-			, m_next_positional(m_positional.end())
-		{
-		}
-
-		Options&
-			positional_help(std::string help_text)
-		{
-			m_positional_help = std::move(help_text);
-			return *this;
-		}
-
-		Options&
-			custom_help(std::string help_text)
-		{
-			m_custom_help = std::move(help_text);
-			return *this;
-		}
-
-		Options&
-			show_positional_help()
-		{
-			m_show_positional = true;
-			return *this;
-		}
-
-		Options&
-			allow_unrecognised_options()
-		{
-			m_allow_unrecognised = true;
-			return *this;
-		}
-
-		ParseResult
-			parse(int& argc, char**& argv);
-
-		OptionAdder
-			add_options(std::string group = "");
-
-		void
-			add_option
-			(
-				const std::string& group,
-				const std::string& s,
-				const std::string& l,
-				std::string desc,
-				std::shared_ptr<const Value> value,
-				std::string arg_help
-			);
-
-		//parse positional arguments into the given option
-		void
-			parse_positional(std::string option);
-
-		void
-			parse_positional(std::vector<std::string> options);
-
-		void
-			parse_positional(std::initializer_list<std::string> options);
-
-		template <typename Iterator>
-		void
-			parse_positional(Iterator begin, Iterator end) {
-			parse_positional(std::vector<std::string>{begin, end});
-		}
-
-		std::string
-			help(const std::vector<std::string>& groups = { "" }) const;
-
-		const std::vector<std::string>
-			groups() const;
-
-		const HelpGroupDetails&
-			group_help(const std::string& group) const;
-
-	private:
-
-		void
-			add_one_option
-			(
-				const std::string& option,
-				std::shared_ptr<OptionDetails> details
-			);
-
-		String
-			help_one_group(const std::string& group) const;
-
-		void
-			generate_group_help
-			(
-				String& result,
-				const std::vector<std::string>& groups
-			) const;
-
-		void
-			generate_all_groups_help(String& result) const;
-
-		std::string m_program;
-		String m_help_string;
-		std::string m_custom_help;
-		std::string m_positional_help;
-		bool m_show_positional;
-		bool m_allow_unrecognised;
-
-		std::shared_ptr<OptionMap> m_options;
-		std::vector<std::string> m_positional;
-		std::vector<std::string>::iterator m_next_positional;
-		std::unordered_set<std::string> m_positional_set;
-
-		//mapping from groups to help options
-		std::map<std::string, HelpGroupDetails> m_help;
-	};
-
-	class OptionAdder
-	{
-	public:
-
-		OptionAdder(Options& options, std::string group)
-			: m_options(options), m_group(std::move(group))
-		{
-		}
-
-		OptionAdder&
-			operator()
-			(
-				const std::string& opts,
-				const std::string& desc,
-				std::shared_ptr<const Value> value
-				= ::cxxopts::value<bool>(),
-				std::string arg_help = ""
-				);
-
-	private:
-		Options& m_options;
-		std::string m_group;
-	};
-
-	namespace
-	{
-		constexpr int OPTION_LONGEST = 30;
-		constexpr int OPTION_DESC_GAP = 2;
-
-		std::basic_regex<char> option_matcher
-		("--([[:alnum:]][-_[:alnum:]]+)(=(.*))?|-([[:alnum:]]+)");
-
-		std::basic_regex<char> option_specifier
-		("(([[:alnum:]]),)?[ ]*([[:alnum:]][-_[:alnum:]]*)?");
-
-		String
-			format_option
-			(
-				const HelpOptionDetails& o
-			)
-		{
-			auto& s = o.s;
-			auto& l = o.l;
-
-			String result = "  ";
-
-			if (s.size() > 0)
-			{
-				result += "-" + toLocalString(s) + ",";
-			}
-			else
-			{
-				result += "   ";
-			}
-
-			if (l.size() > 0)
-			{
-				result += " --" + toLocalString(l);
-			}
-
-			auto arg = o.arg_help.size() > 0 ? toLocalString(o.arg_help) : "arg";
-
-			if (!o.is_boolean)
-			{
-				if (o.has_implicit)
-				{
-					result += " [=" + arg + "(=" + toLocalString(o.implicit_value) + ")]";
-				}
-				else
-				{
-					result += " " + arg;
-				}
-			}
-
-			return result;
-		}
-
-		String
-			format_description
-			(
-				const HelpOptionDetails& o,
-				size_t start,
-				size_t width
-			)
-		{
-			auto desc = o.desc;
-
-			if (o.has_default && (!o.is_boolean || o.default_value != "false"))
-			{
-				desc += toLocalString(" (default: " + o.default_value + ")");
-			}
-
-			String result;
-
-			auto current = std::begin(desc);
-			auto startLine = current;
-			auto lastSpace = current;
-
-			auto size = size_t{};
-
-			while (current != std::end(desc))
-			{
-				if (*current == ' ')
-				{
-					lastSpace = current;
-				}
-
-				if (*current == '\n')
-				{
-					startLine = current + 1;
-					lastSpace = startLine;
-				}
-				else if (size > width)
-				{
-					if (lastSpace == startLine)
-					{
-						stringAppend(result, startLine, current + 1);
-						stringAppend(result, "\n");
-						stringAppend(result, start, ' ');
-						startLine = current + 1;
-						lastSpace = startLine;
-					}
-					else
-					{
-						stringAppend(result, startLine, lastSpace);
-						stringAppend(result, "\n");
-						stringAppend(result, start, ' ');
-						startLine = lastSpace + 1;
-					}
-					size = 0;
-				}
-				else
-				{
-					++size;
-				}
-
-				++current;
-			}
-
-			//append whatever is left
-			stringAppend(result, startLine, current);
-
-			return result;
-		}
-	}
-
-	inline
-		ParseResult::ParseResult
-		(
-			const std::shared_ptr<
-			std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
-			> options,
-			std::vector<std::string> positional,
-			bool allow_unrecognised,
-			int& argc, char**& argv
-		)
-		: m_options(options)
-		, m_positional(std::move(positional))
-		, m_next_positional(m_positional.begin())
-		, m_allow_unrecognised(allow_unrecognised)
-	{
-		parse(argc, argv);
-	}
-
-	inline
-		OptionAdder
-		Options::add_options(std::string group)
-	{
-		return OptionAdder(*this, std::move(group));
-	}
-
-	inline
-		OptionAdder&
-		OptionAdder::operator()
-		(
-			const std::string& opts,
-			const std::string& desc,
-			std::shared_ptr<const Value> value,
-			std::string arg_help
-			)
-	{
-		std::match_results<const char*> result;
-		std::regex_match(opts.c_str(), result, option_specifier);
-
-		if (result.empty())
-		{
-			throw invalid_option_format_error(opts);
-		}
-
-		const auto& short_match = result[2];
-		const auto& long_match = result[3];
-
-		if (!short_match.length() && !long_match.length())
-		{
-			throw invalid_option_format_error(opts);
-		}
-		else if (long_match.length() == 1 && short_match.length())
-		{
-			throw invalid_option_format_error(opts);
-		}
-
-		auto option_names = []
-		(
-			const std::sub_match<const char*>& short_,
-			const std::sub_match<const char*>& long_
-			)
-		{
-			if (long_.length() == 1)
-			{
-				return std::make_tuple(long_.str(), short_.str());
-			}
-			else
-			{
-				return std::make_tuple(short_.str(), long_.str());
-			}
-		}(short_match, long_match);
-
-		m_options.add_option
-		(
-			m_group,
-			std::get<0>(option_names),
-			std::get<1>(option_names),
-			desc,
-			value,
-			std::move(arg_help)
-		);
-
-		return *this;
-	}
-
-	inline
-		void
-		ParseResult::parse_default(std::shared_ptr<OptionDetails> details)
-	{
-		m_results[details].parse_default(details);
-	}
-
-	inline
-		void
-		ParseResult::parse_option
-		(
-			std::shared_ptr<OptionDetails> value,
-			const std::string& /*name*/,
-			const std::string& arg
-		)
-	{
-		auto& result = m_results[value];
-		result.parse(value, arg);
-
-		m_sequential.emplace_back(value->long_name(), arg);
-	}
-
-	inline
-		void
-		ParseResult::checked_parse_arg
-		(
-			int argc,
-			char* argv[],
-			int& current,
-			std::shared_ptr<OptionDetails> value,
-			const std::string& name
-		)
-	{
-		if (current + 1 >= argc)
-		{
-			if (value->value().has_implicit())
-			{
-				parse_option(value, name, value->value().get_implicit_value());
-			}
-			else
-			{
-				throw missing_argument_exception(name);
-			}
-		}
-		else
-		{
-			if (value->value().has_implicit())
-			{
-				parse_option(value, name, value->value().get_implicit_value());
-			}
-			else
-			{
-				parse_option(value, name, argv[current + 1]);
-				++current;
-			}
-		}
-	}
-
-	inline
-		void
-		ParseResult::add_to_option(const std::string& option, const std::string& arg)
-	{
-		auto iter = m_options->find(option);
-
-		if (iter == m_options->end())
-		{
-			throw option_not_exists_exception(option);
-		}
-
-		parse_option(iter->second, option, arg);
-	}
-
-	inline
-		bool
-		ParseResult::consume_positional(std::string a)
-	{
-		while (m_next_positional != m_positional.end())
-		{
-			auto iter = m_options->find(*m_next_positional);
-			if (iter != m_options->end())
-			{
-				auto& result = m_results[iter->second];
-				if (!iter->second->value().is_container())
-				{
-					if (result.count() == 0)
-					{
-						add_to_option(*m_next_positional, a);
-						++m_next_positional;
-						return true;
-					}
-					else
-					{
-						++m_next_positional;
-						continue;
-					}
-				}
-				else
-				{
-					add_to_option(*m_next_positional, a);
-					return true;
-				}
-			}
-			++m_next_positional;
-		}
-
-		return false;
-	}
-
-	inline
-		void
-		Options::parse_positional(std::string option)
-	{
-		parse_positional(std::vector<std::string>{std::move(option)});
-	}
-
-	inline
-		void
-		Options::parse_positional(std::vector<std::string> options)
-	{
-		m_positional = std::move(options);
-		m_next_positional = m_positional.begin();
-
-		m_positional_set.insert(m_positional.begin(), m_positional.end());
-	}
-
-	inline
-		void
-		Options::parse_positional(std::initializer_list<std::string> options)
-	{
-		parse_positional(std::vector<std::string>(std::move(options)));
-	}
-
-	inline
-		ParseResult
-		Options::parse(int& argc, char**& argv)
-	{
-		ParseResult result(m_options, m_positional, m_allow_unrecognised, argc, argv);
-		return result;
-	}
-
-	inline
-		void
-		ParseResult::parse(int& argc, char**& argv)
-	{
-		int current = 1;
-
-		int nextKeep = 1;
-
-		bool consume_remaining = false;
-
-		while (current != argc)
-		{
-			if (strcmp(argv[current], "--") == 0)
-			{
-				consume_remaining = true;
-				++current;
-				break;
-			}
-
-			std::match_results<const char*> result;
-			std::regex_match(argv[current], result, option_matcher);
-
-			if (result.empty())
-			{
-				//not a flag
-
-				// but if it starts with a `-`, then it's an error
-				if (argv[current][0] == '-' && argv[current][1] != '\0') {
-					throw option_syntax_exception(argv[current]);
-				}
-
-				//if true is returned here then it was consumed, otherwise it is
-				//ignored
-				if (consume_positional(argv[current]))
-				{
-				}
-				else
-				{
-					argv[nextKeep] = argv[current];
-					++nextKeep;
-				}
-				//if we return from here then it was parsed successfully, so continue
-			}
-			else
-			{
-				//short or long option?
-				if (result[4].length() != 0)
-				{
-					const std::string& s = result[4];
-
-					for (std::size_t i = 0; i != s.size(); ++i)
-					{
-						std::string name(1, s[i]);
-						auto iter = m_options->find(name);
-
-						if (iter == m_options->end())
-						{
-							if (m_allow_unrecognised)
-							{
-								continue;
-							}
-							else
-							{
-								//error
-								throw option_not_exists_exception(name);
-							}
-						}
-
-						auto value = iter->second;
-
-						if (i + 1 == s.size())
-						{
-							//it must be the last argument
-							checked_parse_arg(argc, argv, current, value, name);
-						}
-						else if (value->value().has_implicit())
-						{
-							parse_option(value, name, value->value().get_implicit_value());
-						}
-						else
-						{
-							//error
-							throw option_requires_argument_exception(name);
-						}
-					}
-				}
-				else if (result[1].length() != 0)
-				{
-					const std::string& name = result[1];
-
-					auto iter = m_options->find(name);
-
-					if (iter == m_options->end())
-					{
-						if (m_allow_unrecognised)
-						{
-							// keep unrecognised options in argument list, skip to next argument
-							argv[nextKeep] = argv[current];
-							++nextKeep;
-							++current;
-							continue;
-						}
-						else
-						{
-							//error
-							throw option_not_exists_exception(name);
-						}
-					}
-
-					auto opt = iter->second;
-
-					//equals provided for long option?
-					if (result[2].length() != 0)
-					{
-						//parse the option given
-
-						parse_option(opt, name, result[3]);
-					}
-					else
-					{
-						//parse the next argument
-						checked_parse_arg(argc, argv, current, opt, name);
-					}
-				}
-
-			}
-
-			++current;
-		}
-
-		for (auto& opt : *m_options)
-		{
-			auto& detail = opt.second;
-			auto& value = detail->value();
-
-			auto& store = m_results[detail];
-
-			if (!store.count() && value.has_default()) {
-				parse_default(detail);
-			}
-		}
-
-		if (consume_remaining)
-		{
-			while (current < argc)
-			{
-				if (!consume_positional(argv[current])) {
-					break;
-				}
-				++current;
-			}
-
-			//adjust argv for any that couldn't be swallowed
-			while (current != argc) {
-				argv[nextKeep] = argv[current];
-				++nextKeep;
-				++current;
-			}
-		}
-
-		argc = nextKeep;
-
-	}
-
-	inline
-		void
-		Options::add_option
-		(
-			const std::string& group,
-			const std::string& s,
-			const std::string& l,
-			std::string desc,
-			std::shared_ptr<const Value> value,
-			std::string arg_help
-		)
-	{
-		auto stringDesc = toLocalString(std::move(desc));
-		auto option = std::make_shared<OptionDetails>(s, l, stringDesc, value);
-
-		if (s.size() > 0)
-		{
-			add_one_option(s, option);
-		}
-
-		if (l.size() > 0)
-		{
-			add_one_option(l, option);
-		}
-
-		//add the help details
-		auto& options = m_help[group];
-
-		options.options.emplace_back(HelpOptionDetails{ s, l, stringDesc,
-			value->has_default(), value->get_default_value(),
-			value->has_implicit(), value->get_implicit_value(),
-			std::move(arg_help),
-			value->is_container(),
-			value->is_boolean() });
-	}
-
-	inline
-		void
-		Options::add_one_option
-		(
-			const std::string& option,
-			std::shared_ptr<OptionDetails> details
-		)
-	{
-		auto in = m_options->emplace(option, details);
-
-		if (!in.second)
-		{
-			throw option_exists_error(option);
-		}
-	}
-
-	inline
-		String
-		Options::help_one_group(const std::string& g) const
-	{
-		typedef std::vector<std::pair<String, String>> OptionHelp;
-
-		auto group = m_help.find(g);
-		if (group == m_help.end())
-		{
-			return "";
-		}
-
-		OptionHelp format;
-
-		size_t longest = 0;
-
-		String result;
-
-		if (!g.empty())
-		{
-			result += toLocalString(" " + g + " options:\n");
-		}
-
-		for (const auto& o : group->second.options)
-		{
-			if (o.is_container &&
-				m_positional_set.find(o.l) != m_positional_set.end() &&
-				!m_show_positional)
-			{
-				continue;
-			}
-
-			auto s = format_option(o);
-			longest = (std::max)(longest, stringLength(s));
-			format.push_back(std::make_pair(s, String()));
-		}
-
-		longest = (std::min)(longest, static_cast<size_t>(OPTION_LONGEST));
-
-		//widest allowed description
-		auto allowed = size_t{ 76 } -longest - OPTION_DESC_GAP;
-
-		auto fiter = format.begin();
-		for (const auto& o : group->second.options)
-		{
-			if (o.is_container &&
-				m_positional_set.find(o.l) != m_positional_set.end() &&
-				!m_show_positional)
-			{
-				continue;
-			}
-
-			auto d = format_description(o, longest + OPTION_DESC_GAP, allowed);
-
-			result += fiter->first;
-			if (stringLength(fiter->first) > longest)
-			{
-				result += '\n';
-				result += toLocalString(std::string(longest + OPTION_DESC_GAP, ' '));
-			}
-			else
-			{
-				result += toLocalString(std::string(longest + OPTION_DESC_GAP -
-					stringLength(fiter->first),
-					' '));
-			}
-			result += d;
-			result += '\n';
-
-			++fiter;
-		}
-
-		return result;
-	}
-
-	inline
-		void
-		Options::generate_group_help
-		(
-			String& result,
-			const std::vector<std::string>& print_groups
-		) const
-	{
-		for (size_t i = 0; i != print_groups.size(); ++i)
-		{
-			const String& group_help_text = help_one_group(print_groups[i]);
-			if (empty(group_help_text))
-			{
-				continue;
-			}
-			result += group_help_text;
-			if (i < print_groups.size() - 1)
-			{
-				result += '\n';
-			}
-		}
-	}
-
-	inline
-		void
-		Options::generate_all_groups_help(String& result) const
-	{
-		std::vector<std::string> all_groups;
-		all_groups.reserve(m_help.size());
-
-		for (auto& group : m_help)
-		{
-			all_groups.push_back(group.first);
-		}
-
-		generate_group_help(result, all_groups);
-	}
-
-	inline
-		std::string
-		Options::help(const std::vector<std::string>& help_groups) const
-	{
-		String result = m_help_string + "\nUsage:\n  " +
-			toLocalString(m_program) + " " + toLocalString(m_custom_help);
-
-		if (m_positional.size() > 0 && m_positional_help.size() > 0) {
-			result += " " + toLocalString(m_positional_help);
-		}
-
-		result += "\n\n";
-
-		if (help_groups.size() == 0)
-		{
-			generate_all_groups_help(result);
-		}
-		else
-		{
-			generate_group_help(result, help_groups);
-		}
-
-		return toUTF8String(result);
-	}
-
-	inline
-		const std::vector<std::string>
-		Options::groups() const
-	{
-		std::vector<std::string> g;
-
-		std::transform(
-			m_help.begin(),
-			m_help.end(),
-			std::back_inserter(g),
-			[](const std::map<std::string, HelpGroupDetails>::value_type& pair)
-		{
-			return pair.first;
-		}
-		);
-
-		return g;
-	}
-
-	inline
-		const HelpGroupDetails&
-		Options::group_help(const std::string& group) const
-	{
-		return m_help.at(group);
-	}
-
-}
-
+/*
+Copyright (c) 2014, 2015, 2016, 2017 Jarryd Beck
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+*/
+
+#ifndef CXXOPTS_HPP_INCLUDED
+#define CXXOPTS_HPP_INCLUDED
+
+#include <cstring>
+#include <cctype>
+#include <exception>
+#include <iostream>
+#include <map>
+#include <memory>
+#include <regex>
+#include <sstream>
+#include <string>
+#include <unordered_map>
+#include <unordered_set>
+#include <vector>
+
+#ifdef __cpp_lib_optional
+#include <optional>
+#define CXXOPTS_HAS_OPTIONAL
+#endif
+
+#define CXXOPTS__VERSION_MAJOR 2
+#define CXXOPTS__VERSION_MINOR 2
+#define CXXOPTS__VERSION_PATCH 0
+
+namespace cxxopts
+{
+	static constexpr struct {
+		uint8_t major, minor, patch;
+	} version = {
+	  CXXOPTS__VERSION_MAJOR,
+	  CXXOPTS__VERSION_MINOR,
+	  CXXOPTS__VERSION_PATCH
+	};
+}
+
+//when we ask cxxopts to use Unicode, help strings are processed using ICU,
+//which results in the correct lengths being computed for strings when they
+//are formatted for the help output
+//it is necessary to make sure that <unicode/unistr.h> can be found by the
+//compiler, and that icu-uc is linked in to the binary.
+
+#ifdef CXXOPTS_USE_UNICODE
+#include <unicode/unistr.h>
+
+namespace cxxopts
+{
+	typedef icu::UnicodeString String;
+
+	inline
+		String
+		toLocalString(std::string s)
+	{
+		return icu::UnicodeString::fromUTF8(std::move(s));
+	}
+
+	class UnicodeStringIterator : public
+		std::iterator<std::forward_iterator_tag, int32_t>
+	{
+	public:
+
+		UnicodeStringIterator(const icu::UnicodeString* string, int32_t pos)
+			: s(string)
+			, i(pos)
+		{
+		}
+
+		value_type
+			operator*() const
+		{
+			return s->char32At(i);
+		}
+
+		bool
+			operator==(const UnicodeStringIterator& rhs) const
+		{
+			return s == rhs.s && i == rhs.i;
+		}
+
+		bool
+			operator!=(const UnicodeStringIterator& rhs) const
+		{
+			return !(*this == rhs);
+		}
+
+		UnicodeStringIterator&
+			operator++()
+		{
+			++i;
+			return *this;
+		}
+
+		UnicodeStringIterator
+			operator+(int32_t v)
+		{
+			return UnicodeStringIterator(s, i + v);
+		}
+
+	private:
+		const icu::UnicodeString* s;
+		int32_t i;
+	};
+
+	inline
+		String&
+		stringAppend(String&s, String a)
+	{
+		return s.append(std::move(a));
+	}
+
+	inline
+		String&
+		stringAppend(String& s, int n, UChar32 c)
+	{
+		for (int i = 0; i != n; ++i)
+		{
+			s.append(c);
+		}
+
+		return s;
+	}
+
+	template <typename Iterator>
+	String&
+		stringAppend(String& s, Iterator begin, Iterator end)
+	{
+		while (begin != end)
+		{
+			s.append(*begin);
+			++begin;
+		}
+
+		return s;
+	}
+
+	inline
+		size_t
+		stringLength(const String& s)
+	{
+		return s.length();
+	}
+
+	inline
+		std::string
+		toUTF8String(const String& s)
+	{
+		std::string result;
+		s.toUTF8String(result);
+
+		return result;
+	}
+
+	inline
+		bool
+		empty(const String& s)
+	{
+		return s.isEmpty();
+	}
+}
+
+namespace std
+{
+	inline
+		cxxopts::UnicodeStringIterator
+		begin(const icu::UnicodeString& s)
+	{
+		return cxxopts::UnicodeStringIterator(&s, 0);
+	}
+
+	inline
+		cxxopts::UnicodeStringIterator
+		end(const icu::UnicodeString& s)
+	{
+		return cxxopts::UnicodeStringIterator(&s, s.length());
+	}
+}
+
+//ifdef CXXOPTS_USE_UNICODE
+#else
+
+namespace cxxopts
+{
+	typedef std::string String;
+
+	template <typename T>
+	T
+		toLocalString(T&& t)
+	{
+		return std::forward<T>(t);
+	}
+
+	inline
+		size_t
+		stringLength(const String& s)
+	{
+		return s.length();
+	}
+
+	inline
+		String&
+		stringAppend(String&s, String a)
+	{
+		return s.append(std::move(a));
+	}
+
+	inline
+		String&
+		stringAppend(String& s, size_t n, char c)
+	{
+		return s.append(n, c);
+	}
+
+	template <typename Iterator>
+	String&
+		stringAppend(String& s, Iterator begin, Iterator end)
+	{
+		return s.append(begin, end);
+	}
+
+	template <typename T>
+	std::string
+		toUTF8String(T&& t)
+	{
+		return std::forward<T>(t);
+	}
+
+	inline
+		bool
+		empty(const std::string& s)
+	{
+		return s.empty();
+	}
+}
+
+//ifdef CXXOPTS_USE_UNICODE
+#endif
+
+namespace cxxopts
+{
+	namespace
+	{
+#ifdef _WIN32
+		const std::string LQUOTE("\'");
+		const std::string RQUOTE("\'");
+#else
+		const std::string LQUOTE("");
+		const std::string RQUOTE("");
+#endif
+	}
+
+	class Value : public std::enable_shared_from_this<Value>
+	{
+	public:
+
+		virtual ~Value() = default;
+
+		virtual
+			std::shared_ptr<Value>
+			clone() const = 0;
+
+		virtual void
+			parse(const std::string& text) const = 0;
+
+		virtual void
+			parse() const = 0;
+
+		virtual bool
+			has_default() const = 0;
+
+		virtual bool
+			is_container() const = 0;
+
+		virtual bool
+			has_implicit() const = 0;
+
+		virtual std::string
+			get_default_value() const = 0;
+
+		virtual std::string
+			get_implicit_value() const = 0;
+
+		virtual std::shared_ptr<Value>
+			default_value(const std::string& value) = 0;
+
+		virtual std::shared_ptr<Value>
+			implicit_value(const std::string& value) = 0;
+
+		virtual bool
+			is_boolean() const = 0;
+	};
+
+	class OptionException : public std::exception
+	{
+	public:
+		OptionException(const std::string& message)
+			: m_message(message)
+		{
+		}
+
+		virtual const char*
+			what() const noexcept
+		{
+			return m_message.c_str();
+		}
+
+	private:
+		std::string m_message;
+	};
+
+	class OptionSpecException : public OptionException
+	{
+	public:
+
+		OptionSpecException(const std::string& message)
+			: OptionException(message)
+		{
+		}
+	};
+
+	class OptionParseException : public OptionException
+	{
+	public:
+		OptionParseException(const std::string& message)
+			: OptionException(message)
+		{
+		}
+	};
+
+	class option_exists_error : public OptionSpecException
+	{
+	public:
+		option_exists_error(const std::string& option)
+			: OptionSpecException(u8"Option " + LQUOTE + option + RQUOTE + u8" already exists")
+		{
+		}
+	};
+
+	class invalid_option_format_error : public OptionSpecException
+	{
+	public:
+		invalid_option_format_error(const std::string& format)
+			: OptionSpecException(u8"Invalid option format " + LQUOTE + format + RQUOTE)
+		{
+		}
+	};
+
+	class option_syntax_exception : public OptionParseException {
+	public:
+		option_syntax_exception(const std::string& text)
+			: OptionParseException(u8"Argument " + LQUOTE + text + RQUOTE +
+				u8" starts with a - but has incorrect syntax")
+		{
+		}
+	};
+
+	class option_not_exists_exception : public OptionParseException
+	{
+	public:
+		option_not_exists_exception(const std::string& option)
+			: OptionParseException(u8"Option " + LQUOTE + option + RQUOTE + u8" does not exist")
+		{
+		}
+	};
+
+	class missing_argument_exception : public OptionParseException
+	{
+	public:
+		missing_argument_exception(const std::string& option)
+			: OptionParseException(
+				u8"Option " + LQUOTE + option + RQUOTE + u8" is missing an argument"
+			)
+		{
+		}
+	};
+
+	class option_requires_argument_exception : public OptionParseException
+	{
+	public:
+		option_requires_argument_exception(const std::string& option)
+			: OptionParseException(
+				u8"Option " + LQUOTE + option + RQUOTE + u8" requires an argument"
+			)
+		{
+		}
+	};
+
+	class option_not_has_argument_exception : public OptionParseException
+	{
+	public:
+		option_not_has_argument_exception
+		(
+			const std::string& option,
+			const std::string& arg
+		)
+			: OptionParseException(
+				u8"Option " + LQUOTE + option + RQUOTE +
+				u8" does not take an argument, but argument " +
+				LQUOTE + arg + RQUOTE + " given"
+			)
+		{
+		}
+	};
+
+	class option_not_present_exception : public OptionParseException
+	{
+	public:
+		option_not_present_exception(const std::string& option)
+			: OptionParseException(u8"Option " + LQUOTE + option + RQUOTE + u8" not present")
+		{
+		}
+	};
+
+	class argument_incorrect_type : public OptionParseException
+	{
+	public:
+		argument_incorrect_type
+		(
+			const std::string& arg
+		)
+			: OptionParseException(
+				u8"Argument " + LQUOTE + arg + RQUOTE + u8" failed to parse"
+			)
+		{
+		}
+	};
+
+	class option_required_exception : public OptionParseException
+	{
+	public:
+		option_required_exception(const std::string& option)
+			: OptionParseException(
+				u8"Option " + LQUOTE + option + RQUOTE + u8" is required but not present"
+			)
+		{
+		}
+	};
+
+	namespace values
+	{
+		namespace
+		{
+			std::basic_regex<char> integer_pattern
+			("(-)?(0x)?([0-9a-zA-Z]+)|((0x)?0)");
+			std::basic_regex<char> truthy_pattern
+			("(t|T)(rue)?");
+			std::basic_regex<char> falsy_pattern
+			("((f|F)(alse)?)?");
+		}
+
+		namespace detail
+		{
+			template <typename T, bool B>
+			struct SignedCheck;
+
+			template <typename T>
+			struct SignedCheck<T, true>
+			{
+				template <typename U>
+				void
+					operator()(bool negative, U u, const std::string& text)
+				{
+					if (negative)
+					{
+						if (u > static_cast<U>(-(std::numeric_limits<T>::min)()))
+						{
+							throw argument_incorrect_type(text);
+						}
+					}
+					else
+					{
+						if (u > static_cast<U>((std::numeric_limits<T>::max)()))
+						{
+							throw argument_incorrect_type(text);
+						}
+					}
+				}
+			};
+
+			template <typename T>
+			struct SignedCheck<T, false>
+			{
+				template <typename U>
+				void
+					operator()(bool, U, const std::string&) {}
+			};
+
+			template <typename T, typename U>
+			void
+				check_signed_range(bool negative, U value, const std::string& text)
+			{
+				SignedCheck<T, std::numeric_limits<T>::is_signed>()(negative, value, text);
+			}
+		}
+
+		template <typename R, typename T>
+		R
+			checked_negate(T&& t, const std::string&, std::true_type)
+		{
+			// if we got to here, then `t` is a positive number that fits into
+			// `R`. So to avoid MSVC C4146, we first cast it to `R`.
+			// See https://github.com/jarro2783/cxxopts/issues/62 for more details.
+			return -static_cast<R>(t);
+		}
+
+		template <typename R, typename T>
+		T
+			checked_negate(T&&, const std::string& text, std::false_type)
+		{
+			throw argument_incorrect_type(text);
+		}
+
+		template <typename T>
+		void
+			integer_parser(const std::string& text, T& value)
+		{
+			std::smatch match;
+			std::regex_match(text, match, integer_pattern);
+
+			if (match.length() == 0)
+			{
+				throw argument_incorrect_type(text);
+			}
+
+			if (match.length(4) > 0)
+			{
+				value = 0;
+				return;
+			}
+
+			using US = typename std::make_unsigned<T>::type;
+
+			constexpr auto umax = (std::numeric_limits<US>::max)();
+			constexpr bool is_signed = std::numeric_limits<T>::is_signed;
+			const bool negative = match.length(1) > 0;
+			const uint8_t base = match.length(2) > 0 ? 16 : 10;
+
+			auto value_match = match[3];
+
+			US result = 0;
+
+			for (auto iter = value_match.first; iter != value_match.second; ++iter)
+			{
+				US digit = 0;
+
+				if (*iter >= '0' && *iter <= '9')
+				{
+					digit = *iter - '0';
+				}
+				else if (base == 16 && *iter >= 'a' && *iter <= 'f')
+				{
+					digit = *iter - 'a' + 10;
+				}
+				else if (base == 16 && *iter >= 'A' && *iter <= 'F')
+				{
+					digit = *iter - 'A' + 10;
+				}
+				else
+				{
+					throw argument_incorrect_type(text);
+				}
+
+				if (umax - digit < result * base)
+				{
+					throw argument_incorrect_type(text);
+				}
+
+				result = result * base + digit;
+			}
+
+			detail::check_signed_range<T>(negative, result, text);
+
+			if (negative)
+			{
+				value = checked_negate<T>(result,
+					text,
+					std::integral_constant<bool, is_signed>());
+			}
+			else
+			{
+				value = result;
+			}
+		}
+
+		template <typename T>
+		void stringstream_parser(const std::string& text, T& value)
+		{
+			std::stringstream in(text);
+			in >> value;
+			if (!in) {
+				throw argument_incorrect_type(text);
+			}
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, uint8_t& value)
+		{
+			integer_parser(text, value);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, int8_t& value)
+		{
+			integer_parser(text, value);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, uint16_t& value)
+		{
+			integer_parser(text, value);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, int16_t& value)
+		{
+			integer_parser(text, value);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, uint32_t& value)
+		{
+			integer_parser(text, value);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, int32_t& value)
+		{
+			integer_parser(text, value);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, uint64_t& value)
+		{
+			integer_parser(text, value);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, int64_t& value)
+		{
+			integer_parser(text, value);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, bool& value)
+		{
+			std::smatch result;
+			std::regex_match(text, result, truthy_pattern);
+
+			if (!result.empty())
+			{
+				value = true;
+				return;
+			}
+
+			std::regex_match(text, result, falsy_pattern);
+			if (!result.empty())
+			{
+				value = false;
+				return;
+			}
+
+			throw argument_incorrect_type(text);
+		}
+
+		inline
+			void
+			parse_value(const std::string& text, std::string& value)
+		{
+			value = text;
+		}
+
+		// The fallback parser. It uses the stringstream parser to parse all types
+		// that have not been overloaded explicitly.  It has to be placed in the
+		// source code before all other more specialized templates.
+		template <typename T>
+		void
+			parse_value(const std::string& text, T& value) {
+			stringstream_parser(text, value);
+		}
+
+		template <typename T>
+		void
+			parse_value(const std::string& text, std::vector<T>& value)
+		{
+			T v;
+			parse_value(text, v);
+			value.push_back(v);
+		}
+
+#ifdef CXXOPTS_HAS_OPTIONAL
+		template <typename T>
+		void
+			parse_value(const std::string& text, std::optional<T>& value)
+		{
+			T result;
+			parse_value(text, result);
+			value = std::move(result);
+		}
+#endif
+
+		template <typename T>
+		struct type_is_container
+		{
+			static constexpr bool value = false;
+		};
+
+		template <typename T>
+		struct type_is_container<std::vector<T>>
+		{
+			static constexpr bool value = true;
+		};
+
+		template <typename T>
+		class abstract_value : public Value
+		{
+			using Self = abstract_value<T>;
+
+		public:
+			abstract_value()
+				: m_result(std::make_shared<T>())
+				, m_store(m_result.get())
+			{
+			}
+
+			abstract_value(T* t)
+				: m_store(t)
+			{
+			}
+
+			virtual ~abstract_value() = default;
+
+			abstract_value(const abstract_value& rhs)
+			{
+				if (rhs.m_result)
+				{
+					m_result = std::make_shared<T>();
+					m_store = m_result.get();
+				}
+				else
+				{
+					m_store = rhs.m_store;
+				}
+
+				m_default = rhs.m_default;
+				m_implicit = rhs.m_implicit;
+				m_default_value = rhs.m_default_value;
+				m_implicit_value = rhs.m_implicit_value;
+			}
+
+			void
+				parse(const std::string& text) const
+			{
+				parse_value(text, *m_store);
+			}
+
+			bool
+				is_container() const
+			{
+				return type_is_container<T>::value;
+			}
+
+			void
+				parse() const
+			{
+				parse_value(m_default_value, *m_store);
+			}
+
+			bool
+				has_default() const
+			{
+				return m_default;
+			}
+
+			bool
+				has_implicit() const
+			{
+				return m_implicit;
+			}
+
+			std::shared_ptr<Value>
+				default_value(const std::string& value)
+			{
+				m_default = true;
+				m_default_value = value;
+				return shared_from_this();
+			}
+
+			std::shared_ptr<Value>
+				implicit_value(const std::string& value)
+			{
+				m_implicit = true;
+				m_implicit_value = value;
+				return shared_from_this();
+			}
+
+			std::string
+				get_default_value() const
+			{
+				return m_default_value;
+			}
+
+			std::string
+				get_implicit_value() const
+			{
+				return m_implicit_value;
+			}
+
+			bool
+				is_boolean() const
+			{
+				return std::is_same<T, bool>::value;
+			}
+
+			const T&
+				get() const
+			{
+				if (m_store == nullptr)
+				{
+					return *m_result;
+				}
+				else
+				{
+					return *m_store;
+				}
+			}
+
+		protected:
+			std::shared_ptr<T> m_result;
+			T* m_store;
+
+			bool m_default = false;
+			bool m_implicit = false;
+
+			std::string m_default_value;
+			std::string m_implicit_value;
+		};
+
+		template <typename T>
+		class standard_value : public abstract_value<T>
+		{
+		public:
+			using abstract_value<T>::abstract_value;
+
+			std::shared_ptr<Value>
+				clone() const
+			{
+				return std::make_shared<standard_value<T>>(*this);
+			}
+		};
+
+		template <>
+		class standard_value<bool> : public abstract_value<bool>
+		{
+		public:
+			~standard_value() = default;
+
+			standard_value()
+			{
+				set_default_and_implicit();
+			}
+
+			standard_value(bool* b)
+				: abstract_value(b)
+			{
+				set_default_and_implicit();
+			}
+
+			std::shared_ptr<Value>
+				clone() const
+			{
+				return std::make_shared<standard_value<bool>>(*this);
+			}
+
+		private:
+
+			void
+				set_default_and_implicit()
+			{
+				m_default = true;
+				m_default_value = "false";
+				m_implicit = true;
+				m_implicit_value = "true";
+			}
+		};
+	}
+
+	template <typename T>
+	std::shared_ptr<Value>
+		value()
+	{
+		return std::make_shared<values::standard_value<T>>();
+	}
+
+	template <typename T>
+	std::shared_ptr<Value>
+		value(T& t)
+	{
+		return std::make_shared<values::standard_value<T>>(&t);
+	}
+
+	class OptionAdder;
+
+	class OptionDetails
+	{
+	public:
+		OptionDetails
+		(
+			const std::string& short_,
+			const std::string& long_,
+			const String& desc,
+			std::shared_ptr<const Value> val
+		)
+			: m_short(short_)
+			, m_long(long_)
+			, m_desc(desc)
+			, m_value(val)
+			, m_count(0)
+		{
+		}
+
+		OptionDetails(const OptionDetails& rhs)
+			: m_desc(rhs.m_desc)
+			, m_count(rhs.m_count)
+		{
+			m_value = rhs.m_value->clone();
+		}
+
+		OptionDetails(OptionDetails&& rhs) = default;
+
+		const String&
+			description() const
+		{
+			return m_desc;
+		}
+
+		const Value& value() const {
+			return *m_value;
+		}
+
+		std::shared_ptr<Value>
+			make_storage() const
+		{
+			return m_value->clone();
+		}
+
+		const std::string&
+			short_name() const
+		{
+			return m_short;
+		}
+
+		const std::string&
+			long_name() const
+		{
+			return m_long;
+		}
+
+	private:
+		std::string m_short;
+		std::string m_long;
+		String m_desc;
+		std::shared_ptr<const Value> m_value;
+		int m_count;
+	};
+
+	struct HelpOptionDetails
+	{
+		std::string s;
+		std::string l;
+		String desc;
+		bool has_default;
+		std::string default_value;
+		bool has_implicit;
+		std::string implicit_value;
+		std::string arg_help;
+		bool is_container;
+		bool is_boolean;
+	};
+
+	struct HelpGroupDetails
+	{
+		std::string name;
+		std::string description;
+		std::vector<HelpOptionDetails> options;
+	};
+
+	class OptionValue
+	{
+	public:
+		void
+			parse
+			(
+				std::shared_ptr<const OptionDetails> details,
+				const std::string& text
+			)
+		{
+			ensure_value(details);
+			++m_count;
+			m_value->parse(text);
+		}
+
+		void
+			parse_default(std::shared_ptr<const OptionDetails> details)
+		{
+			ensure_value(details);
+			m_value->parse();
+		}
+
+		size_t
+			count() const
+		{
+			return m_count;
+		}
+
+		template <typename T>
+		const T&
+			as() const
+		{
+			if (m_value == nullptr) {
+				throw std::domain_error("No value");
+			}
+
+#ifdef CXXOPTS_NO_RTTI
+			return static_cast<const values::standard_value<T>&>(*m_value).get();
+#else
+			return dynamic_cast<const values::standard_value<T>&>(*m_value).get();
+#endif
+		}
+
+	private:
+		void
+			ensure_value(std::shared_ptr<const OptionDetails> details)
+		{
+			if (m_value == nullptr)
+			{
+				m_value = details->make_storage();
+			}
+		}
+
+		std::shared_ptr<Value> m_value;
+		size_t m_count = 0;
+	};
+
+	class KeyValue
+	{
+	public:
+		KeyValue(std::string key_, std::string value_)
+			: m_key(std::move(key_))
+			, m_value(std::move(value_))
+		{
+		}
+
+		const
+			std::string&
+			key() const
+		{
+			return m_key;
+		}
+
+		const std::string
+			value() const
+		{
+			return m_value;
+		}
+
+		template <typename T>
+		T
+			as() const
+		{
+			T result;
+			values::parse_value(m_value, result);
+			return result;
+		}
+
+	private:
+		std::string m_key;
+		std::string m_value;
+	};
+
+	class ParseResult
+	{
+	public:
+
+		ParseResult(
+			const std::shared_ptr<
+			std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
+			>,
+			std::vector<std::string>,
+			bool allow_unrecognised,
+			int&, char**&);
+
+		size_t
+			count(const std::string& o) const
+		{
+			auto iter = m_options->find(o);
+			if (iter == m_options->end())
+			{
+				return 0;
+			}
+
+			auto riter = m_results.find(iter->second);
+
+			return riter->second.count();
+		}
+
+		const OptionValue&
+			operator[](const std::string& option) const
+		{
+			auto iter = m_options->find(option);
+
+			if (iter == m_options->end())
+			{
+				throw option_not_present_exception(option);
+			}
+
+			auto riter = m_results.find(iter->second);
+
+			return riter->second;
+		}
+
+		const std::vector<KeyValue>&
+			arguments() const
+		{
+			return m_sequential;
+		}
+
+	private:
+
+		void
+			parse(int& argc, char**& argv);
+
+		void
+			add_to_option(const std::string& option, const std::string& arg);
+
+		bool
+			consume_positional(std::string a);
+
+		void
+			parse_option
+			(
+				std::shared_ptr<OptionDetails> value,
+				const std::string& name,
+				const std::string& arg = ""
+			);
+
+		void
+			parse_default(std::shared_ptr<OptionDetails> details);
+
+		void
+			checked_parse_arg
+			(
+				int argc,
+				char* argv[],
+				int& current,
+				std::shared_ptr<OptionDetails> value,
+				const std::string& name
+			);
+
+		const std::shared_ptr<
+			std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
+		> m_options;
+		std::vector<std::string> m_positional;
+		std::vector<std::string>::iterator m_next_positional;
+		std::unordered_set<std::string> m_positional_set;
+		std::unordered_map<std::shared_ptr<OptionDetails>, OptionValue> m_results;
+
+		bool m_allow_unrecognised;
+
+		std::vector<KeyValue> m_sequential;
+	};
+
+	class Options
+	{
+		typedef std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
+			OptionMap;
+	public:
+
+		Options(std::string program, std::string help_string = "")
+			: m_program(std::move(program))
+			, m_help_string(toLocalString(std::move(help_string)))
+			, m_custom_help("[OPTION...]")
+			, m_positional_help("positional parameters")
+			, m_show_positional(false)
+			, m_allow_unrecognised(false)
+			, m_options(std::make_shared<OptionMap>())
+			, m_next_positional(m_positional.end())
+		{
+		}
+
+		Options&
+			positional_help(std::string help_text)
+		{
+			m_positional_help = std::move(help_text);
+			return *this;
+		}
+
+		Options&
+			custom_help(std::string help_text)
+		{
+			m_custom_help = std::move(help_text);
+			return *this;
+		}
+
+		Options&
+			show_positional_help()
+		{
+			m_show_positional = true;
+			return *this;
+		}
+
+		Options&
+			allow_unrecognised_options()
+		{
+			m_allow_unrecognised = true;
+			return *this;
+		}
+
+		ParseResult
+			parse(int& argc, char**& argv);
+
+		OptionAdder
+			add_options(std::string group = "");
+
+		void
+			add_option
+			(
+				const std::string& group,
+				const std::string& s,
+				const std::string& l,
+				std::string desc,
+				std::shared_ptr<const Value> value,
+				std::string arg_help
+			);
+
+		//parse positional arguments into the given option
+		void
+			parse_positional(std::string option);
+
+		void
+			parse_positional(std::vector<std::string> options);
+
+		void
+			parse_positional(std::initializer_list<std::string> options);
+
+		template <typename Iterator>
+		void
+			parse_positional(Iterator begin, Iterator end) {
+			parse_positional(std::vector<std::string>{begin, end});
+		}
+
+		std::string
+			help(const std::vector<std::string>& groups = { "" }) const;
+
+		const std::vector<std::string>
+			groups() const;
+
+		const HelpGroupDetails&
+			group_help(const std::string& group) const;
+
+	private:
+
+		void
+			add_one_option
+			(
+				const std::string& option,
+				std::shared_ptr<OptionDetails> details
+			);
+
+		String
+			help_one_group(const std::string& group) const;
+
+		void
+			generate_group_help
+			(
+				String& result,
+				const std::vector<std::string>& groups
+			) const;
+
+		void
+			generate_all_groups_help(String& result) const;
+
+		std::string m_program;
+		String m_help_string;
+		std::string m_custom_help;
+		std::string m_positional_help;
+		bool m_show_positional;
+		bool m_allow_unrecognised;
+
+		std::shared_ptr<OptionMap> m_options;
+		std::vector<std::string> m_positional;
+		std::vector<std::string>::iterator m_next_positional;
+		std::unordered_set<std::string> m_positional_set;
+
+		//mapping from groups to help options
+		std::map<std::string, HelpGroupDetails> m_help;
+	};
+
+	class OptionAdder
+	{
+	public:
+
+		OptionAdder(Options& options, std::string group)
+			: m_options(options), m_group(std::move(group))
+		{
+		}
+
+		OptionAdder&
+			operator()
+			(
+				const std::string& opts,
+				const std::string& desc,
+				std::shared_ptr<const Value> value
+				= ::cxxopts::value<bool>(),
+				std::string arg_help = ""
+				);
+
+	private:
+		Options& m_options;
+		std::string m_group;
+	};
+
+	namespace
+	{
+		constexpr int OPTION_LONGEST = 30;
+		constexpr int OPTION_DESC_GAP = 2;
+
+		std::basic_regex<char> option_matcher
+		("--([[:alnum:]][-_[:alnum:]]+)(=(.*))?|-([[:alnum:]]+)");
+
+		std::basic_regex<char> option_specifier
+		("(([[:alnum:]]),)?[ ]*([[:alnum:]][-_[:alnum:]]*)?");
+
+		String
+			format_option
+			(
+				const HelpOptionDetails& o
+			)
+		{
+			auto& s = o.s;
+			auto& l = o.l;
+
+			String result = "  ";
+
+			if (s.size() > 0)
+			{
+				result += "-" + toLocalString(s) + ",";
+			}
+			else
+			{
+				result += "   ";
+			}
+
+			if (l.size() > 0)
+			{
+				result += " --" + toLocalString(l);
+			}
+
+			auto arg = o.arg_help.size() > 0 ? toLocalString(o.arg_help) : "arg";
+
+			if (!o.is_boolean)
+			{
+				if (o.has_implicit)
+				{
+					result += " [=" + arg + "(=" + toLocalString(o.implicit_value) + ")]";
+				}
+				else
+				{
+					result += " " + arg;
+				}
+			}
+
+			return result;
+		}
+
+		String
+			format_description
+			(
+				const HelpOptionDetails& o,
+				size_t start,
+				size_t width
+			)
+		{
+			auto desc = o.desc;
+
+			if (o.has_default && (!o.is_boolean || o.default_value != "false"))
+			{
+				desc += toLocalString(" (default: " + o.default_value + ")");
+			}
+
+			String result;
+
+			auto current = std::begin(desc);
+			auto startLine = current;
+			auto lastSpace = current;
+
+			auto size = size_t{};
+
+			while (current != std::end(desc))
+			{
+				if (*current == ' ')
+				{
+					lastSpace = current;
+				}
+
+				if (*current == '\n')
+				{
+					startLine = current + 1;
+					lastSpace = startLine;
+				}
+				else if (size > width)
+				{
+					if (lastSpace == startLine)
+					{
+						stringAppend(result, startLine, current + 1);
+						stringAppend(result, "\n");
+						stringAppend(result, start, ' ');
+						startLine = current + 1;
+						lastSpace = startLine;
+					}
+					else
+					{
+						stringAppend(result, startLine, lastSpace);
+						stringAppend(result, "\n");
+						stringAppend(result, start, ' ');
+						startLine = lastSpace + 1;
+					}
+					size = 0;
+				}
+				else
+				{
+					++size;
+				}
+
+				++current;
+			}
+
+			//append whatever is left
+			stringAppend(result, startLine, current);
+
+			return result;
+		}
+	}
+
+	inline
+		ParseResult::ParseResult
+		(
+			const std::shared_ptr<
+			std::unordered_map<std::string, std::shared_ptr<OptionDetails>>
+			> options,
+			std::vector<std::string> positional,
+			bool allow_unrecognised,
+			int& argc, char**& argv
+		)
+		: m_options(options)
+		, m_positional(std::move(positional))
+		, m_next_positional(m_positional.begin())
+		, m_allow_unrecognised(allow_unrecognised)
+	{
+		parse(argc, argv);
+	}
+
+	inline
+		OptionAdder
+		Options::add_options(std::string group)
+	{
+		return OptionAdder(*this, std::move(group));
+	}
+
+	inline
+		OptionAdder&
+		OptionAdder::operator()
+		(
+			const std::string& opts,
+			const std::string& desc,
+			std::shared_ptr<const Value> value,
+			std::string arg_help
+			)
+	{
+		std::match_results<const char*> result;
+		std::regex_match(opts.c_str(), result, option_specifier);
+
+		if (result.empty())
+		{
+			throw invalid_option_format_error(opts);
+		}
+
+		const auto& short_match = result[2];
+		const auto& long_match = result[3];
+
+		if (!short_match.length() && !long_match.length())
+		{
+			throw invalid_option_format_error(opts);
+		}
+		else if (long_match.length() == 1 && short_match.length())
+		{
+			throw invalid_option_format_error(opts);
+		}
+
+		auto option_names = []
+		(
+			const std::sub_match<const char*>& short_,
+			const std::sub_match<const char*>& long_
+			)
+		{
+			if (long_.length() == 1)
+			{
+				return std::make_tuple(long_.str(), short_.str());
+			}
+			else
+			{
+				return std::make_tuple(short_.str(), long_.str());
+			}
+		}(short_match, long_match);
+
+		m_options.add_option
+		(
+			m_group,
+			std::get<0>(option_names),
+			std::get<1>(option_names),
+			desc,
+			value,
+			std::move(arg_help)
+		);
+
+		return *this;
+	}
+
+	inline
+		void
+		ParseResult::parse_default(std::shared_ptr<OptionDetails> details)
+	{
+		m_results[details].parse_default(details);
+	}
+
+	inline
+		void
+		ParseResult::parse_option
+		(
+			std::shared_ptr<OptionDetails> value,
+			const std::string& /*name*/,
+			const std::string& arg
+		)
+	{
+		auto& result = m_results[value];
+		result.parse(value, arg);
+
+		m_sequential.emplace_back(value->long_name(), arg);
+	}
+
+	inline
+		void
+		ParseResult::checked_parse_arg
+		(
+			int argc,
+			char* argv[],
+			int& current,
+			std::shared_ptr<OptionDetails> value,
+			const std::string& name
+		)
+	{
+		if (current + 1 >= argc)
+		{
+			if (value->value().has_implicit())
+			{
+				parse_option(value, name, value->value().get_implicit_value());
+			}
+			else
+			{
+				throw missing_argument_exception(name);
+			}
+		}
+		else
+		{
+			if (value->value().has_implicit())
+			{
+				parse_option(value, name, value->value().get_implicit_value());
+			}
+			else
+			{
+				parse_option(value, name, argv[current + 1]);
+				++current;
+			}
+		}
+	}
+
+	inline
+		void
+		ParseResult::add_to_option(const std::string& option, const std::string& arg)
+	{
+		auto iter = m_options->find(option);
+
+		if (iter == m_options->end())
+		{
+			throw option_not_exists_exception(option);
+		}
+
+		parse_option(iter->second, option, arg);
+	}
+
+	inline
+		bool
+		ParseResult::consume_positional(std::string a)
+	{
+		while (m_next_positional != m_positional.end())
+		{
+			auto iter = m_options->find(*m_next_positional);
+			if (iter != m_options->end())
+			{
+				auto& result = m_results[iter->second];
+				if (!iter->second->value().is_container())
+				{
+					if (result.count() == 0)
+					{
+						add_to_option(*m_next_positional, a);
+						++m_next_positional;
+						return true;
+					}
+					else
+					{
+						++m_next_positional;
+						continue;
+					}
+				}
+				else
+				{
+					add_to_option(*m_next_positional, a);
+					return true;
+				}
+			}
+			++m_next_positional;
+		}
+
+		return false;
+	}
+
+	inline
+		void
+		Options::parse_positional(std::string option)
+	{
+		parse_positional(std::vector<std::string>{std::move(option)});
+	}
+
+	inline
+		void
+		Options::parse_positional(std::vector<std::string> options)
+	{
+		m_positional = std::move(options);
+		m_next_positional = m_positional.begin();
+
+		m_positional_set.insert(m_positional.begin(), m_positional.end());
+	}
+
+	inline
+		void
+		Options::parse_positional(std::initializer_list<std::string> options)
+	{
+		parse_positional(std::vector<std::string>(std::move(options)));
+	}
+
+	inline
+		ParseResult
+		Options::parse(int& argc, char**& argv)
+	{
+		ParseResult result(m_options, m_positional, m_allow_unrecognised, argc, argv);
+		return result;
+	}
+
+	inline
+		void
+		ParseResult::parse(int& argc, char**& argv)
+	{
+		int current = 1;
+
+		int nextKeep = 1;
+
+		bool consume_remaining = false;
+
+		while (current != argc)
+		{
+			if (strcmp(argv[current], "--") == 0)
+			{
+				consume_remaining = true;
+				++current;
+				break;
+			}
+
+			std::match_results<const char*> result;
+			std::regex_match(argv[current], result, option_matcher);
+
+			if (result.empty())
+			{
+				//not a flag
+
+				// but if it starts with a `-`, then it's an error
+				if (argv[current][0] == '-' && argv[current][1] != '\0') {
+					throw option_syntax_exception(argv[current]);
+				}
+
+				//if true is returned here then it was consumed, otherwise it is
+				//ignored
+				if (consume_positional(argv[current]))
+				{
+				}
+				else
+				{
+					argv[nextKeep] = argv[current];
+					++nextKeep;
+				}
+				//if we return from here then it was parsed successfully, so continue
+			}
+			else
+			{
+				//short or long option?
+				if (result[4].length() != 0)
+				{
+					const std::string& s = result[4];
+
+					for (std::size_t i = 0; i != s.size(); ++i)
+					{
+						std::string name(1, s[i]);
+						auto iter = m_options->find(name);
+
+						if (iter == m_options->end())
+						{
+							if (m_allow_unrecognised)
+							{
+								continue;
+							}
+							else
+							{
+								//error
+								throw option_not_exists_exception(name);
+							}
+						}
+
+						auto value = iter->second;
+
+						if (i + 1 == s.size())
+						{
+							//it must be the last argument
+							checked_parse_arg(argc, argv, current, value, name);
+						}
+						else if (value->value().has_implicit())
+						{
+							parse_option(value, name, value->value().get_implicit_value());
+						}
+						else
+						{
+							//error
+							throw option_requires_argument_exception(name);
+						}
+					}
+				}
+				else if (result[1].length() != 0)
+				{
+					const std::string& name = result[1];
+
+					auto iter = m_options->find(name);
+
+					if (iter == m_options->end())
+					{
+						if (m_allow_unrecognised)
+						{
+							// keep unrecognised options in argument list, skip to next argument
+							argv[nextKeep] = argv[current];
+							++nextKeep;
+							++current;
+							continue;
+						}
+						else
+						{
+							//error
+							throw option_not_exists_exception(name);
+						}
+					}
+
+					auto opt = iter->second;
+
+					//equals provided for long option?
+					if (result[2].length() != 0)
+					{
+						//parse the option given
+
+						parse_option(opt, name, result[3]);
+					}
+					else
+					{
+						//parse the next argument
+						checked_parse_arg(argc, argv, current, opt, name);
+					}
+				}
+
+			}
+
+			++current;
+		}
+
+		for (auto& opt : *m_options)
+		{
+			auto& detail = opt.second;
+			auto& value = detail->value();
+
+			auto& store = m_results[detail];
+
+			if (!store.count() && value.has_default()) {
+				parse_default(detail);
+			}
+		}
+
+		if (consume_remaining)
+		{
+			while (current < argc)
+			{
+				if (!consume_positional(argv[current])) {
+					break;
+				}
+				++current;
+			}
+
+			//adjust argv for any that couldn't be swallowed
+			while (current != argc) {
+				argv[nextKeep] = argv[current];
+				++nextKeep;
+				++current;
+			}
+		}
+
+		argc = nextKeep;
+
+	}
+
+	inline
+		void
+		Options::add_option
+		(
+			const std::string& group,
+			const std::string& s,
+			const std::string& l,
+			std::string desc,
+			std::shared_ptr<const Value> value,
+			std::string arg_help
+		)
+	{
+		auto stringDesc = toLocalString(std::move(desc));
+		auto option = std::make_shared<OptionDetails>(s, l, stringDesc, value);
+
+		if (s.size() > 0)
+		{
+			add_one_option(s, option);
+		}
+
+		if (l.size() > 0)
+		{
+			add_one_option(l, option);
+		}
+
+		//add the help details
+		auto& options = m_help[group];
+
+		options.options.emplace_back(HelpOptionDetails{ s, l, stringDesc,
+			value->has_default(), value->get_default_value(),
+			value->has_implicit(), value->get_implicit_value(),
+			std::move(arg_help),
+			value->is_container(),
+			value->is_boolean() });
+	}
+
+	inline
+		void
+		Options::add_one_option
+		(
+			const std::string& option,
+			std::shared_ptr<OptionDetails> details
+		)
+	{
+		auto in = m_options->emplace(option, details);
+
+		if (!in.second)
+		{
+			throw option_exists_error(option);
+		}
+	}
+
+	inline
+		String
+		Options::help_one_group(const std::string& g) const
+	{
+		typedef std::vector<std::pair<String, String>> OptionHelp;
+
+		auto group = m_help.find(g);
+		if (group == m_help.end())
+		{
+			return "";
+		}
+
+		OptionHelp format;
+
+		size_t longest = 0;
+
+		String result;
+
+		if (!g.empty())
+		{
+			result += toLocalString(" " + g + " options:\n");
+		}
+
+		for (const auto& o : group->second.options)
+		{
+			if (o.is_container &&
+				m_positional_set.find(o.l) != m_positional_set.end() &&
+				!m_show_positional)
+			{
+				continue;
+			}
+
+			auto s = format_option(o);
+			longest = (std::max)(longest, stringLength(s));
+			format.push_back(std::make_pair(s, String()));
+		}
+
+		longest = (std::min)(longest, static_cast<size_t>(OPTION_LONGEST));
+
+		//widest allowed description
+		auto allowed = size_t{ 76 } -longest - OPTION_DESC_GAP;
+
+		auto fiter = format.begin();
+		for (const auto& o : group->second.options)
+		{
+			if (o.is_container &&
+				m_positional_set.find(o.l) != m_positional_set.end() &&
+				!m_show_positional)
+			{
+				continue;
+			}
+
+			auto d = format_description(o, longest + OPTION_DESC_GAP, allowed);
+
+			result += fiter->first;
+			if (stringLength(fiter->first) > longest)
+			{
+				result += '\n';
+				result += toLocalString(std::string(longest + OPTION_DESC_GAP, ' '));
+			}
+			else
+			{
+				result += toLocalString(std::string(longest + OPTION_DESC_GAP -
+					stringLength(fiter->first),
+					' '));
+			}
+			result += d;
+			result += '\n';
+
+			++fiter;
+		}
+
+		return result;
+	}
+
+	inline
+		void
+		Options::generate_group_help
+		(
+			String& result,
+			const std::vector<std::string>& print_groups
+		) const
+	{
+		for (size_t i = 0; i != print_groups.size(); ++i)
+		{
+			const String& group_help_text = help_one_group(print_groups[i]);
+			if (empty(group_help_text))
+			{
+				continue;
+			}
+			result += group_help_text;
+			if (i < print_groups.size() - 1)
+			{
+				result += '\n';
+			}
+		}
+	}
+
+	inline
+		void
+		Options::generate_all_groups_help(String& result) const
+	{
+		std::vector<std::string> all_groups;
+		all_groups.reserve(m_help.size());
+
+		for (auto& group : m_help)
+		{
+			all_groups.push_back(group.first);
+		}
+
+		generate_group_help(result, all_groups);
+	}
+
+	inline
+		std::string
+		Options::help(const std::vector<std::string>& help_groups) const
+	{
+		String result = m_help_string + "\nUsage:\n  " +
+			toLocalString(m_program) + " " + toLocalString(m_custom_help);
+
+		if (m_positional.size() > 0 && m_positional_help.size() > 0) {
+			result += " " + toLocalString(m_positional_help);
+		}
+
+		result += "\n\n";
+
+		if (help_groups.size() == 0)
+		{
+			generate_all_groups_help(result);
+		}
+		else
+		{
+			generate_group_help(result, help_groups);
+		}
+
+		return toUTF8String(result);
+	}
+
+	inline
+		const std::vector<std::string>
+		Options::groups() const
+	{
+		std::vector<std::string> g;
+
+		std::transform(
+			m_help.begin(),
+			m_help.end(),
+			std::back_inserter(g),
+			[](const std::map<std::string, HelpGroupDetails>::value_type& pair)
+		{
+			return pair.first;
+		}
+		);
+
+		return g;
+	}
+
+	inline
+		const HelpGroupDetails&
+		Options::group_help(const std::string& group) const
+	{
+		return m_help.at(group);
+	}
+
+}
+
 #endif //CXXOPTS_HPP_INCLUDED
```

### Comparing `chronogram-0.1.7/src/gamma.h` & `chronogram-0.2.0/src/gamma.h`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-#pragma once
-
-#include <cmath>
-#include "LUT.hpp"
-
-#define M_PIf 3.14159265f
-#define M_GAMMAf 0.577215664f
-#define M_LN2f 0.693147180f
-
-inline float digammaf(float x)
-{
-	if (x < 0.0f)
-		return digammaf(1.0f - x) + M_PIf / tanl(M_PIf*(1.0f - x));
-	else if (x < 1.0f)
-		return digammaf(1.0f + x) - 1.0f / x;
-	else if (x == 1.0f)
-		return -M_GAMMAf;
-	else if (x == 2.0f)
-		return 1.0L - M_GAMMAf;
-	else if (x == 3.0f)
-		return 1.5L - M_GAMMAf;
-	else if (x > 3.0f)
-		return 0.5f*(digammaf(x / 2.0f) + digammaf((x + 1.0f) / 2.0f)) + M_LN2f;
-	else
-	{
-		static float Kncoe[] = { .304591985f,
-			.720379774f, -.124549592f,
-			.277694573e-1f, -.677623714e-2f,
-			.172387551e-2f, -.448176990e-3f,
-			.117936600e-3f, -.312538942e-4f,
-			.831739970e-5f, -.221914276e-5f,
-			.593022667e-6f, -.158630511e-6f,
-			.424592039e-7f, -.113691296e-7f,
-			.304502217e-8f, -.815684550e-9f };
-
-		float Tn_1 = 1.0L;
-		float Tn = x - 2.0L;
-		float resul = Kncoe[0] + Kncoe[1] * Tn;
-
-		x -= 2.0L;
-
-		for (int n = 2; n < sizeof(Kncoe) / sizeof(float); n++)
-		{
-			const float Tn1 = 2.0L * x * Tn - Tn_1;
-			resul += Kncoe[n] * Tn1;
-			Tn_1 = Tn;
-			Tn = Tn1;
-		}
-		return resul;
-	}
-}
-
-
-struct F_digamma
-{
-	float operator()(float x)
-	{
-		return digammaf(x);
-	}
-	static constexpr float smallThreshold = 0.1;
-	float forSmall(float x) { return log(x + 2) - 0.5 / (x + 2) - 1 / 12.0 / pow(x + 2, 2) - 1 / (x + 1) - 1 / x; }
-	float forLarge(float x) { return log(x) - 0.5/x - 1 / 12.0 / pow(x, 2); }
-};
-
-typedef LUT3<F_digamma, float, 1 * 1024, 1024, 100 * 64, 64, 1000 * 4, 4> LUT_digamma;
-
-#define DIGAMMA(x) LUT_digamma::get(x)
+#pragma once
+
+#include <cmath>
+#include "LUT.hpp"
+
+#define M_PIf 3.14159265f
+#define M_GAMMAf 0.577215664f
+#define M_LN2f 0.693147180f
+
+inline float digammaf(float x)
+{
+	if (x < 0.0f)
+		return digammaf(1.0f - x) + M_PIf / tanl(M_PIf*(1.0f - x));
+	else if (x < 1.0f)
+		return digammaf(1.0f + x) - 1.0f / x;
+	else if (x == 1.0f)
+		return -M_GAMMAf;
+	else if (x == 2.0f)
+		return 1.0L - M_GAMMAf;
+	else if (x == 3.0f)
+		return 1.5L - M_GAMMAf;
+	else if (x > 3.0f)
+		return 0.5f*(digammaf(x / 2.0f) + digammaf((x + 1.0f) / 2.0f)) + M_LN2f;
+	else
+	{
+		static float Kncoe[] = { .304591985f,
+			.720379774f, -.124549592f,
+			.277694573e-1f, -.677623714e-2f,
+			.172387551e-2f, -.448176990e-3f,
+			.117936600e-3f, -.312538942e-4f,
+			.831739970e-5f, -.221914276e-5f,
+			.593022667e-6f, -.158630511e-6f,
+			.424592039e-7f, -.113691296e-7f,
+			.304502217e-8f, -.815684550e-9f };
+
+		float Tn_1 = 1.0L;
+		float Tn = x - 2.0L;
+		float resul = Kncoe[0] + Kncoe[1] * Tn;
+
+		x -= 2.0L;
+
+		for (int n = 2; n < sizeof(Kncoe) / sizeof(float); n++)
+		{
+			const float Tn1 = 2.0L * x * Tn - Tn_1;
+			resul += Kncoe[n] * Tn1;
+			Tn_1 = Tn;
+			Tn = Tn1;
+		}
+		return resul;
+	}
+}
+
+
+struct F_digamma
+{
+	float operator()(float x)
+	{
+		return digammaf(x);
+	}
+	static constexpr float smallThreshold = 0.1;
+	float forSmall(float x) { return log(x + 2) - 0.5 / (x + 2) - 1 / 12.0 / pow(x + 2, 2) - 1 / (x + 1) - 1 / x; }
+	float forLarge(float x) { return log(x) - 0.5/x - 1 / 12.0 / pow(x, 2); }
+};
+
+typedef LUT3<F_digamma, float, 1 * 1024, 1024, 100 * 64, 64, 1000 * 4, 4> LUT_digamma;
+
+#define DIGAMMA(x) LUT_digamma::get(x)
```

### Comparing `chronogram-0.1.7/src/main.cpp` & `chronogram-0.2.0/src/main.cpp`

 * *Files 21% similar despite different names*

```diff
@@ -1,927 +1,977 @@
-#include <vector>
-#include <array>
-#include <map>
-#include <algorithm>
-#include <unordered_map>
-#include <numeric>
-#include <string>
-#include <iostream>
-#include <iomanip>
-#include <sstream>
-#include <iterator>
-#include <fstream>
-#include <random>
-#include <thread>
-
-#include "cxxopts.hpp"
-#include "ChronoGramModel.h"
-#include "DataReader.h"
-#include "MMap.h"
-#include "IOUtils.h"
-
-using namespace std;
-
-struct Args
-{
-	string load, save, eval, result, llSave, fixed, loadPrior;
-	string vocab, ngram;
-	size_t maxItem = -1;
-	float minT = INFINITY, maxT = -INFINITY;
-	vector<string> input;
-	int worker = 0, window = 4, dimension = 100;
-	int order = 5, negative = 5, temporalSample = 5;
-	int batch = 10000, minCnt = 10;
-	int report = 100000;
-	int nsQ = 8, initStep = 8;
-	float eta = 1.f, zeta = .1f, lambda = .1f, padding = -1;
-	float initEpochs = 0, epoch = 1, threshold = 0.0025f;
-	float timePrior = 0;
-	float subsampling = 1e-4f;
-	bool compressed = true;
-	bool recountVocabs = false;
-	bool semEval = false;
-
-	string evalShift, shiftMetric;
-	float mixed = 0, timeA = INFINITY, timeB = INFINITY;
-
-	string evalCTA;
-};
-
-
-int main(int argc, char* argv[])
-{
-	Args args;
-	try
-	{
-		cxxopts::Options options("chronogram", "Diachronic Word Embeddings");
-
-		options.add_options()
-			("i,input", "Input File", cxxopts::value<string>(), "Input file path that contains documents per line")
-			("l,load", "Load Model File", cxxopts::value<string>(), "Model file path to be loaded")
-			("v,save", "Save Model File", cxxopts::value<string>(), "Model file path to be saved")
-			("f,fixed", "Fixed Word List File", cxxopts::value<string>())
-			("h,help", "Help")
-			("version", "Version")
-			("w,worker", "Number of Workes", cxxopts::value<int>(), "The number of workers(thread) for inferencing model, default value is 0 which means the number of cores in system")
-			("W,window", "Size of Window", cxxopts::value<int>())
-			("d,dimension", "Embedding Dimension", cxxopts::value<int>())
-			("r,order", "Order of Chebyshev Polynomial", cxxopts::value<int>())
-			("e,epoch", "Number of Epoch", cxxopts::value<float>())
-			("n,negative", "Negative Sampling Size", cxxopts::value<int>())
-			("T,ts", "Time Negative Weight", cxxopts::value<int>())
-			("F,initEpochs", "Weight-Initializing Epochs", cxxopts::value<float>())
-			("b,batch", "Batch Docs Size", cxxopts::value<int>())
-			("t,minCnt", "Min Count Threshold of Word", cxxopts::value<int>())
-			("report", "", cxxopts::value<int>())
-			("eta", "", cxxopts::value<float>())
-			("z,zeta", "", cxxopts::value<float>())
-			("lambda", "", cxxopts::value<float>())
-			("p,padding", "", cxxopts::value<float>())
-			("ss", "Sub-Samping", cxxopts::value<float>())
-			("rv", "recount vocabs", cxxopts::value<int>()->implicit_value("1"))
-
-			("compressed", "Save as compressed", cxxopts::value<int>(), "default = 1")
-			("semEval", "Print SemEval2015 Task7 Result", cxxopts::value<int>()->implicit_value("1"))
-			;
-
-		options.add_options("Google Ngram")
-			("vocab", "Vocab file", cxxopts::value<string>())
-			("ngram", "Ngram file", cxxopts::value<string>())
-			("maxItem", "max item to be loaded", cxxopts::value<size_t>())
-			("minT", "Minimum time point", cxxopts::value<float>())
-			("maxT", "Maximum time point", cxxopts::value<float>())
-			;
-
-		options.add_options("Text Dating")
-			("eval", "Evaluation set File", cxxopts::value<string>(), "Evaluation set file path")
-			("result", "Evaluation Result File", cxxopts::value<string>(), "Evaluation result file path")
-			("llSave", "Save log likelihoods of evaluation", cxxopts::value<string>())
-			("nsQ", "", cxxopts::value<int>())
-			("initStep", "", cxxopts::value<int>())
-			("threshold", "", cxxopts::value<float>())
-			("timePrior", "", cxxopts::value<float>())
-			("loadPrior", "", cxxopts::value<string>())
-			;
-
-		options.add_options("Semantic Shift")
-			("evalShift", "File to be evaluate semantic shift", cxxopts::value<string>())
-			("mixed", "mixing factor of U and V", cxxopts::value<float>())
-			("timeA", "", cxxopts::value<float>())
-			("timeB", "", cxxopts::value<float>())
-			("shiftMetric", "", cxxopts::value<string>())
-			;
-
-		options.add_options("Cross Temporal Analogy")
-			("evalCTA", "File to be evaluate cross temporal analogy", cxxopts::value<string>())
-			;
-
-		try
-		{
-			auto result = options.parse(argc, argv);
-
-			if (result.count("version"))
-			{
-				cout << "v0.1" << endl;
-				return 0;
-			}
-			if (result.count("help"))
-			{
-				cout << options.help({ "", "Text Dating", "Semantic Shift", "Google Ngram", "Cross Temporal Analogy" }) << endl;
-				return 0;
-			}
-
-
-#define READ_OPT(P, TYPE) if (result.count(#P)) args.P = result[#P].as<TYPE>()
-#define READ_OPT2(P, Q, TYPE) if (result.count(#P)) args.Q = result[#P].as<TYPE>()
-
-
-			READ_OPT(load, string);
-			READ_OPT(save, string);
-			READ_OPT(eval, string);
-			READ_OPT(result, string);
-			READ_OPT(fixed, string);
-			READ_OPT(loadPrior, string);
-			READ_OPT(llSave, string);
-
-			READ_OPT(vocab, string);
-			READ_OPT(ngram, string);
-			READ_OPT(minT, float);
-			READ_OPT(maxT, float);
-			READ_OPT2(ss, subsampling, float);
-			READ_OPT2(rv, recountVocabs, int);
-
-			READ_OPT(maxItem, size_t);
-
-			if (result.count("input")) args.input.emplace_back(result["input"].as<string>());
-			for (size_t i = 1; i < argc; ++i)
-			{
-				args.input.emplace_back(argv[i]);
-			}
-
-			READ_OPT(worker, int);
-			READ_OPT(window, int);
-			READ_OPT(dimension, int);
-			READ_OPT(order, int);
-			READ_OPT(epoch, float);
-			READ_OPT(negative, int);
-			READ_OPT(batch, int);
-			READ_OPT(minCnt, int);
-			READ_OPT(nsQ, int);
-			READ_OPT(initStep, int);
-			READ_OPT(report, int);
-			
-			READ_OPT(compressed, int);
-			READ_OPT(semEval, int);
-
-			READ_OPT(eta, float);
-			READ_OPT(zeta, float);
-			READ_OPT(lambda, float);
-			READ_OPT(padding, float);
-			READ_OPT2(ts, temporalSample, int);
-			READ_OPT(initEpochs, float);
-			READ_OPT(threshold, float);
-			READ_OPT(timePrior, float);
-
-			READ_OPT(evalShift, string);
-			READ_OPT(timeA, float);
-			READ_OPT(timeB, float);
-			READ_OPT(mixed, float);
-			READ_OPT(shiftMetric, string);
-
-			READ_OPT(evalCTA, string);
-			
-			if (args.load.empty() && args.input.empty() && args.ngram.empty())
-			{
-				throw cxxopts::OptionException("'input', 'load' or 'ngram' should be specified.");
-			}
-		}
-		catch (const cxxopts::OptionException& e)
-		{
-			cout << "error parsing options: " << e.what() << endl;
-			cout << options.help({ "", "Text Dating", "Semantic Shift", "Google Ngram" }) << endl;
-			return -1;
-		}
-
-	}
-	catch (const cxxopts::OptionException& e)
-	{
-		cout << "error parsing options: " << e.what() << endl;
-		return -1;
-	}
-
-	ChronoGramModel tgm{ (size_t)args.dimension, (size_t)args.order, 1e-4, (size_t)args.negative,
-		(size_t)args.temporalSample, args.eta, args.zeta, args.lambda };
-	if (args.padding >= 0)
-	{
-		tgm.setPadding(args.padding);
-	}
-
-	if (!args.load.empty())
-	{
-		cout << "Loading Model: " << args.load << endl;
-		//ifstream ifs{ args.load, ios_base::binary };
-		MMap mm{ args.load };
-		imstream ifs{ mm.get(), mm.size() };
-		tgm = ChronoGramModel::loadModel(ifs);
-		cout << "Dimension: " << tgm.getD() << "\tOrder: " << tgm.getR() << endl;
-		cout << "Workers: " << (args.worker ? args.worker : thread::hardware_concurrency()) << endl;
-		cout << "Zeta: " << tgm.getZeta() << "\tLambda: " << tgm.getLambda() << endl;
-		cout << "Padding: " << tgm.getPadding() << endl;
-	}
-	else if (!args.input.empty() || !args.ngram.empty())
-	{
-		cout << "Dimension: " << args.dimension << "\tOrder: " << args.order << "\tNegative Sampling: " << args.negative << endl;
-		cout << "Workers: " << (args.worker ? args.worker : thread::hardware_concurrency()) << "\tBatch: " << args.batch << "\tEpochs: " << args.epoch << endl;
-		cout << "Eta: " << args.eta << "\tZeta: " << args.zeta << "\tLambda: " << args.lambda << endl;
-		cout << "Padding: " << tgm.getPadding() << "\tTemporal Negative Sampling: " << args.temporalSample << "\tWeight-Initializing Epochs: " << args.initEpochs << endl;
-
-		if (args.ngram.empty())
-		{
-			cout << "Training Input: ";
-			for (auto& s : args.input)
-			{
-				cout << s << "  ";
-			}
-			cout << endl;
-		}
-		else
-		{
-			cout << "Training Ngram Corpus Input: " << args.ngram << endl;
-		}
-
-		Timer timer;
-		if (!args.ngram.empty())
-		{
-			if (args.maxItem == (size_t)-1)
-			{
-				GNgramBinaryReader reader{ args.ngram };
-				args.maxItem = 0;
-				if (!isfinite(args.minT))
-				{
-					while (1)
-					{
-						auto p = reader().yearCnt;
-						args.maxItem++;
-						if (p.empty()) break;
-						args.minT = min(min_element(p.begin(), p.end())->first, args.minT);
-						args.maxT = max(max_element(p.begin(), p.end())->first, args.maxT);
-					}
-					cout << "Time point: [" << args.minT << ", " << args.maxT << "]" << endl;
-				}
-				else
-				{
-					while (args.maxItem++,!reader().yearCnt.empty());
-				}
-				cout << "Total items in training data: " << args.maxItem << endl;
-			}
-		}
-
-		if (args.vocab.empty())
-		{
-			tgm.buildVocab(MultipleReader::factory(args.input), args.minCnt, args.worker);
-			cout << "MinCnt: " << args.minCnt << "\tVocab Size: " << tgm.getVocabs().size()
-				<< "\tTotal Words: " << tgm.getTotalWords() << endl;
-		}
-		else
-		{
-			ifstream vocab{ args.vocab };
-			tgm.buildVocabFromDict([&vocab]()
-			{
-				string line;
-				getline(vocab, line);
-				istringstream iss{ line };
-				string w;
-				getline(iss, w, '\t');
-				uint64_t cnt = 0;
-				iss >> cnt;
-				return make_pair(w, cnt);
-			}, args.minT, args.maxT);
-
-			cout << "Vocab Size: " << tgm.getVocabs().size() << endl;
-			if (args.recountVocabs)
-			{
-				cout << "Recounting vocabs in time range [" << args.minT << ", " << args.maxT << "]" << endl;
-				GNgramBinaryReader reader{ args.ngram };
-				cout << "Recounted Vocab Size: " <<
-					tgm.recountVocab(GNgramBinaryReader::factory(args.ngram), args.minT, args.maxT, 0) << endl;
-			}
-		}
-
-		if(!args.fixed.empty())
-		{
-			ifstream ifs{ args.fixed };
-			string line;
-			size_t numFixedWords = 0;
-			while (getline(ifs, line))
-			{
-				while (!line.empty() && isspace(line.back())) line.pop_back();
-				if (tgm.addFixedWord(line)) numFixedWords++;
-			}
-			cout << numFixedWords << " fixed words are loaded." << endl;
-		}
-
-		if (args.ngram.empty())
-		{
-			if (args.initEpochs)
-			{
-				cout << "Initializing weights ... " << endl;
-				tgm.template train<true>(MultipleReader::factory(args.input),
-					args.worker, args.window, .025f, .00025f, args.batch, args.initEpochs, args.report);
-			}
-			cout << "Training ... " << endl;
-			tgm.train(MultipleReader::factory(args.input),
-				args.worker, args.window, .025f, .00025f, args.batch, args.epoch, args.report);
-		}
-		else
-		{
-			if (args.initEpochs)
-			{
-				cout << "Initializing weights ... " << endl;
-				tgm.template trainFromGNgram<true>(GNgramBinaryReader::factory(args.ngram),
-					args.maxItem, args.worker, .025f, .00025f, args.batch, args.initEpochs, args.report);
-			}
-			cout << "Training ... " << endl;
-			tgm.trainFromGNgram(GNgramBinaryReader::factory(args.ngram),
-				args.maxItem, args.worker, .025f, .00025f, args.batch, args.epoch, args.report);
-		}
-
-		cout << "Finished in " << timer.getElapsed() << " sec" << endl;
-		if (!args.save.empty())
-		{
-			cout << "Saving Model: " << args.save << endl;
-			ofstream ofs{ args.save, ios_base::binary };
-			tgm.saveModel(ofs, args.compressed);
-		}
-	}
-
-	if (!args.evalShift.empty())
-	{
-		if (!isfinite(args.timeA)) args.timeA = tgm.getMinPoint();
-		if (!isfinite(args.timeB)) args.timeB = tgm.getMaxPoint();
-
-		ifstream ifs{ args.evalShift };
-		string line;
-		cout << "== Evaluating semantic shift : " << args.evalShift 
-			<< " between " << args.timeA << " and " << args.timeB << " ==" << endl;
-		vector<float> refScores, sysScores;
-		while (getline(ifs, line))
-		{
-			istringstream iss{ line };
-			string word;
-			float score = INFINITY, s;
-			getline(iss, word, '\t');
-			iss >> score;
-			if (word.empty()) continue;
-
-			auto v = tgm.getEmbedding(word);
-			auto u1 = tgm.getEmbedding(word, args.timeA), u2 = tgm.getEmbedding(word, args.timeB);
-			if (args.shiftMetric == "l2")
-			{
-				s = (u1 - u2).norm();
-			}
-			else
-			{
-				s = (v * args.mixed + u1 * (1 - args.mixed)).normalized().dot(
-					(v * args.mixed + u2 * (1 - args.mixed)).normalized());
-			}
-			cout << word << '\t' << s << endl;
-			if (isfinite(score))
-			{
-				refScores.emplace_back(score);
-				sysScores.emplace_back(s);
-			}
-		}
-		cout << endl;
-		if (!refScores.empty())
-		{
-			cout << "Pearson Correl: " << correlPearson<float>(refScores.begin(), refScores.end(), sysScores.begin()) << endl;
-			cout << "Spearman Correl: " << correlSpearman<float>(refScores.begin(), refScores.end(), sysScores.begin()) << endl;
-		}
-	}
-
-	if (!args.evalCTA.empty())
-	{
-		ifstream ifs{ args.evalCTA };
-		string line;
-		cout << "== Evaluating cross temporal analogy : " << args.evalCTA << endl;
-		array<size_t, 5> at = { 0, 1, 3, 5, 10 };
-		array<float, 5> scores = { 0, };
-		size_t totSet = 0;
-		
-		while (getline(ifs, line))
-		{
-			if (isspace(line.back())) line.pop_back();
-			istringstream iss{ line };
-			string left, right;
-			if (!getline(iss, left, ',')) continue;
-			if (!getline(iss, right, ',')) continue;
-			
-			if (left.find('-') == string::npos || right.find('-') == string::npos)
-			{
-				cerr << "wrong input: " << line << endl;
-				continue;
-			}
-
-			float lYear = stof(left.substr(left.find('-') + 1));
-			float rYear = stof(right.substr(right.find('-') + 1));
-
-			left = left.substr(0, left.find('-'));
-			right = right.substr(0, right.find('-'));
-			auto res = tgm.nearestNeighbors(left, lYear, rYear, args.mixed, 10);
-			size_t rank = 0;
-			for (; rank < res.size(); ++rank)
-			{
-				if (get<0>(res[rank]) == right) break;
-			}
-
-			if (rank < 10 && rank < res.size())
-			{
-				for (size_t i = 0; i < at.size(); ++i)
-				{
-					if (at[i] == 0) scores[i] += 1.f / (rank + 1);
-					else if (rank < at[i]) scores[i] += 1;
-				}
-			}
-			totSet++;
-		}
-
-		for (auto& s : scores) s /= totSet;
-		for (size_t i = 0; i < at.size(); ++i)
-		{
-			if (at[i]) cout << "MP@" << at[i];
-			else cout << "MPR";
-			cout << "\t" << scores[i] << endl;
-		}
-	}
-
-	map<float, float> priorMap;
-	function<float(float)> priorFunc = [&priorMap](float x)->float
-	{
-		auto it = priorMap.lower_bound(x);
-		if (it == priorMap.end()) return -INFINITY;
-		if (it->first == x) return it->second;
-		if (it == priorMap.begin()) return -INFINITY;
-		float nx = it->first, ny = it->second;
-		--it;
-		float px = it->first, py = it->second;
-		return py + (x - px) * (ny - py) / (nx - px);
-	};
-
-	if (!args.loadPrior.empty())
-	{
-		ifstream lpf{ args.loadPrior };
-		string line;
-		while (getline(lpf, line))
-		{
-			istringstream iss{ line };
-			float x = INFINITY, y = INFINITY;
-			iss >> x >> y;
-			if (!isfinite(x) || !isfinite(y)) continue;
-			priorMap.emplace(x, y);
-		}
-	}
-	if (priorMap.empty()) priorFunc = function<float(float)>{};
-
-	if (!args.eval.empty())
-	{
-		cout << "Evaluating Time Prediction: " << args.eval << endl;
-		cout << "TimePriorWeight: " << args.timePrior << endl;
-		Timer timer;
-		ifstream ifs{ args.eval };
-		if (args.result.empty()) args.result = args.eval + ".result";
-		ofstream ofs{ args.result };
-		ofstream ollfs;
-		if (!args.llSave.empty())
-		{
-			ollfs = ofstream{ args.llSave };
-			for (size_t i = 0; i <= args.initStep; ++i)
-			{
-				if (i) ollfs << '\t';
-				ollfs << tgm.getMinPoint() + (tgm.getMaxPoint() - tgm.getMinPoint()) * i / args.initStep;
-			}
-			ollfs << endl;
-		}
-
-		float avgErr = 0, meanErr = 0;
-		double score[3] = { 0, };
-		size_t correct[3] = { 0, };
-		size_t n = 0;
-		MultipleReader reader{ {args.eval} };
-		tgm.evaluate(bind(&MultipleReader::operator(), &reader), 
-			[&](ChronoGramModel::EvalResult r)
-		{
-			ofs << r.trueTime << "\t" << r.estimatedTime << "\t" << r.ll
-				<< "\t" << r.llPerWord << "\t" << r.normalizedErr << endl;
-			avgErr += pow(r.normalizedErr, 2);
-			meanErr += abs(r.normalizedErr);
-			if (abs(r.normalizedErr) >= 0.5)
-			{
-				cout << r.trueTime << "\t" << r.estimatedTime << "\t" << r.normalizedErr << "\t";
-				for (auto& w : r.words) cout << w << ' ';
-				cout << endl;
-			}
-
-			if (ollfs)
-			{
-				size_t n = 0;
-				for (auto ll : r.lls)
-				{
-					if (n++) ollfs << '\t';
-					ollfs << ll;
-				}
-				ollfs << endl;
-			}
-
-			if (args.semEval)
-			{
-				static size_t span[3] = { 6, 12, 20 };
-				static double offsetScore[] = { 1, 0.9, 0.85, 0.8, 0.6, 0.5, 0.4, 0.2, 0.1, 0.01 };
-				float err = r.trueTime - r.estimatedTime;
-				for (size_t i = 0; i < 3; ++i)
-				{
-					auto s = span[i];
-					size_t offset = 0;
-					if (abs(err) <= s / 2)
-					{
-						++correct[i];
-					}
-					else
-					{
-						offset = (abs(err) - s / 2 - 1) / (s + 1) + 1;
-					}
-					score[i] += offsetScore[min(offset, (size_t)9)];
-				}
-			}
-			n++;
-		}, args.worker, args.window, args.nsQ, priorFunc, args.timePrior, args.initStep, args.threshold);
-		
-		avgErr /= n;
-		meanErr /= n;
-
-		const auto printResult = [&](auto& os)
-		{
-			os << "Running Time: " << timer.getElapsed() << "s" << endl;
-			os << "Total Docs: " << n << endl;
-			os << "Avg Squared Error: " << avgErr << endl;
-			os << "Avg Error: " << sqrt(avgErr) << endl;
-			os << "MAE: " << meanErr << endl;
-
-			if (args.semEval)
-			{
-				os << "Correct (F, M, C): " << correct[0] << ", " << correct[1] << ", " << correct[2] << endl;
-				os << "Precision (F, M, C): " << correct[0] / (double)n << ", " << correct[1] / (double)n << ", " << correct[2] / (double)n << endl;
-				os << "Avg Score (F, M, C): " << score[0] / n << ", " << score[1] / n << ", " << score[2] / n << endl;
-			}
-		};
-
-		cout << "== Evaluating Result ==" << endl;
-		printResult(cout);
-		printResult(ofs);
-	}
-
-	string line;
-	while (cout << ">> ", getline(cin, line))
-	{
-		if (line[0] == '~') // calculate arc length
-		{
-			if (line.size() == 1) // find shortest arc length
-			{
-				cout << "==== Shortest Arc Length ====" << endl;
-				vector<pair<string, float>> lens;
-				for (auto& w : tgm.getVocabs())
-				{
-					lens.emplace_back(w, tgm.arcLengthOfWord(w));
-				}
-				sort(lens.begin(), lens.end(), [](auto a, auto b)
-				{
-					return a.second < b.second;
-				});
-				size_t i = 0;
-				for (auto& p : lens)
-				{
-					cout << p.first << "\t" << p.second << endl;
-					if (++i >= 20) break;
-				}
-				cout << "==== Longest Arc Length ====" << endl;
-				for (auto it = lens.end() - 20; it != lens.end(); ++it)
-				{
-					cout << it->first << "\t" << it->second << endl;
-				}
-				cout << endl;
-
-				cout << "==== Shortest Angle ====" << endl;
-				lens.clear();
-				for (auto& w : tgm.getVocabs())
-				{
-					lens.emplace_back(w, tgm.angleOfWord(w));
-				}
-				sort(lens.begin(), lens.end(), [](auto a, auto b)
-				{
-					return a.second < b.second;
-				});
-				i = 0;
-				for (auto& p : lens)
-				{
-					cout << p.first << "\t" << p.second / EIGEN_PI * 180 << endl;
-					if (++i >= 20) break;
-				}
-				cout << "==== Longest Angle ====" << endl;
-				for (auto it = lens.end() - 20; it != lens.end(); ++it)
-				{
-					cout << it->first << "\t" << it->second / EIGEN_PI * 180 << endl;
-				}
-				cout << endl;
-			}
-			else
-			{
-				string w = line.substr(1);
-				cout << "Arc Length of " << w << " : " << tgm.arcLengthOfWord(w) << endl;
-				cout << "Angle of " << w << " : " << tgm.angleOfWord(w) / EIGEN_PI * 180 << endl;
-			}
-		}
-		else if (line[0] == '`') // estimate time of text
-		{
-			istringstream iss{ line.substr(1) };
-			istream_iterator<string> wBegin{ iss }, wEnd{};
-			vector<string> words{ wBegin, wEnd };
-			auto evaluator = tgm.evaluateSent(words, args.window, args.nsQ, priorFunc, args.timePrior);
-			for (size_t i = 0; i <= args.initStep; ++i)
-			{
-				float z = tgm.getMinPoint() + (i / (float)args.initStep) * (tgm.getMaxPoint() - tgm.getMinPoint());
-				cout << z << ": " << evaluator(tgm.normalizedTimePoint(z)) << endl;
-			}
-		}
-		else if (line[0] == '!') // estimate time of word
-		{
-			stringstream iss{ line.substr(1) };
-			istream_iterator<string> wBegin{ iss }, wEnd{};
-			vector<string> words{ wBegin, wEnd };
-			if (words.empty())
-			{
-				for (size_t i = 0; i <= args.initStep; ++i)
-				{
-					float z = tgm.getMinPoint() + (i / (float)args.initStep) * (tgm.getMaxPoint() - tgm.getMinPoint());
-					cout << z << ": " << tgm.getTimePrior(z) << endl;
-				}
-			}
-			else
-			{
-				cout << "Total count of " << words[0] << " : " << tgm.getWordCount(words[0]) << endl;
-				for (size_t i = 0; i <= args.initStep; ++i)
-				{
-					float z = tgm.getMinPoint() + (i / (float)args.initStep) * (tgm.getMaxPoint() - tgm.getMinPoint());
-					float w = tgm.getWordProbByTime(words[0], z);
-					float t = tgm.getTimePrior(z);
-					cout << z << ": " << w << "\t" << w / t << endl;
-				}
-			}
-		}
-		else if (line[0] == '#') // get embedding
-		{
-			vector<pair<string, float>> words;
-			pair<string, float>* lastInput = nullptr;
-			stringstream iss{ line.substr(1) };
-			istream_iterator<string> wBegin{ iss }, wEnd{};
-			for (; wBegin != wEnd; ++wBegin)
-			{
-				auto word = *wBegin;
-				if (word[0] == '@')
-				{
-					float t = stof(word.substr(1));
-					if (t < tgm.getMinPoint() || t > tgm.getMaxPoint())
-					{
-						cout << "Out of time range [" << tgm.getMinPoint() << ", " << tgm.getMaxPoint() << "]" << endl;
-					}
-
-					if (lastInput)
-					{
-						lastInput->second = t;
-						lastInput = nullptr;
-					}
-				}
-				else
-				{
-					words.emplace_back(word, -INFINITY);
-					lastInput = &words.back();
-				}
-			}
-			for(auto& w : words)
-			{
-				auto vec = isfinite(w.second) 
-					? tgm.getEmbedding(w.first, w.second)
-					: tgm.getEmbedding(w.first);
-				printf("[");
-				for (size_t i = 0; i < vec.size(); ++i)
-				{
-					printf("%.3f, ", vec(i));
-				}
-				printf("]\n");
-			}
-		}
-		else if (line[0] == '$') // similarity between two word
-		{
-			vector<pair<string, float>> words;
-			pair<string, float>* lastInput = nullptr;
-			istringstream iss{ line.substr(1) };
-			istream_iterator<string> wBegin{ iss }, wEnd{};
-			for (; wBegin != wEnd; ++wBegin)
-			{
-				auto word = *wBegin;
-				if (word[0] == '@')
-				{
-					float t = stof(word.substr(1));
-					if (t < tgm.getMinPoint() || t > tgm.getMaxPoint())
-					{
-						cout << "Out of time range [" << tgm.getMinPoint() << ", " << tgm.getMaxPoint() << "]" << endl;
-					}
-
-					if (lastInput)
-					{
-						lastInput->second = t;
-						lastInput = nullptr;
-					}
-				}
-				else
-				{
-					words.emplace_back(word, tgm.getMinPoint());
-					lastInput = &words.back();
-				}
-			}
-			if (words.size() < 2)
-			{
-				cout << "Input two words!!" << endl;
-			}
-			else
-			{
-				cout << "Similarity between '" << words[0].first << "' @" << words[0].second
-					<< " and '" << words[1].first << "' @" << words[1].second
-					<< " : " << tgm.similarity(words[0].first, words[0].second, words[1].first, words[1].second) << endl;
-				cout << "Overall similarity between '" << words[0].first << "' and '" << words[1].first
-					<< "' : " << tgm.similarityStatic(words[0].first,words[1].first) << endl;
-			}
-		}
-		else if (line[0] == '%') // find most similar word using mixed vector
-		{
-			istringstream iss{ line.substr(1) };
-			float mixed = 0;
-			iss >> mixed;
-			vector<pair<string, float>> positives, negatives;
-			pair<string, float>* lastInput = nullptr;
-			istream_iterator<string> wBegin{ iss }, wEnd{};
-			float searchingTimePoint = tgm.getMinPoint();
-			bool sign = false;
-			for (; wBegin != wEnd; ++wBegin)
-			{
-				auto word = *wBegin;
-				if (word == "-")
-				{
-					sign = true;
-				}
-				else if (word == "+")
-				{
-					sign = false;
-				}
-				else if (word[0] == '@')
-				{
-					float t = stof(word.substr(1));
-					if (t < tgm.getMinPoint() || t > tgm.getMaxPoint())
-					{
-						cout << "Out of time range [" << tgm.getMinPoint() << ", " << tgm.getMaxPoint() << "]" << endl;
-					}
-
-					if (lastInput)
-					{
-						lastInput->second = t;
-						lastInput = nullptr;
-					}
-					else
-					{
-						searchingTimePoint = t;
-					}
-				}
-				else
-				{
-					(sign ? negatives : positives).emplace_back(word, searchingTimePoint);
-					lastInput = &(sign ? negatives : positives).back();
-					sign = false;
-				}
-			}
-
-			for (auto& p : positives)
-			{
-				float wp = tgm.getWordProbByTime(p.first, p.second);
-				float tp = tgm.getTimePrior(p.second);
-				cout << "P(@" << p.second << " | " << p.first << ") = " << wp << ",\tP(@" << p.second << ") = " << tp << endl;
-			}
-
-			cout << "==== Most Similar at " << searchingTimePoint << " ====" << endl;
-			for (auto& p : tgm.mostSimilar(positives, negatives, searchingTimePoint, mixed, 20))
-			{
-				if (get<1>(p) <= 0) break;
-				cout << left << setw(12) << get<0>(p) << '\t' << get<1>(p) << '\t' << get<2>(p) << endl;
-			}
-			cout << endl;
-		}
-		else if (line[0] == '^') // calculate shift of words
-		{
-			istringstream iss{ line.substr(1) };
-			size_t minCnt = 100, show = 40;
-			float time1 = 0, time2 = 0, m = 0;
-			iss >> minCnt >> time1 >> time2 >> m >> show;
-			auto ret = tgm.calcShift(minCnt, time1, time2, m);
-			cout << "== Shift between " << time1 << " and " << time2 << " ==" << endl;
-			for (size_t i = 0; i < 10 && i < ret.size(); ++i)
-			{
-				cout << ret[i].first << "\t" << ret[i].second << endl;
-			}
-			cout << "  ...  " << endl;
-			for (size_t i = max(ret.size(), (size_t)show) - show; i < ret.size(); ++i)
-			{
-				cout << ret[i].first << "\t" << ret[i].second << endl;
-			}
-			cout << endl;
-		}
-		else if (line[0] == '&')
-		{
-			istringstream iss{ line.substr(1) };
-			float m = 0, time = 0;
-			string src, t;
-			vector<string> targets;
-			iss >> m >> time >> src;
-			while (iss >> t) targets.emplace_back(t);
-			cout << "== Sum of similarities from " << src << " : " << tgm.sumSimilarity(src, targets, time, m) << endl;
-		}
-		else // find most similar word
-		{
-			vector<pair<string, float>> positives, negatives;
-			vector<string> positivesO, negativesO;
-			pair<string, float>* lastInput = nullptr;
-			istringstream iss{ line };
-			istream_iterator<string> wBegin{ iss }, wEnd{};
-			float searchingTimePoint = tgm.getMinPoint();
-			bool sign = false;
-			for (; wBegin != wEnd; ++wBegin)
-			{
-				auto word = *wBegin;
-				if (word == "-")
-				{
-					sign = true;
-				}
-				else if (word == "+")
-				{
-					sign = false;
-				}
-				else if (word[0] == '@')
-				{
-					float t = stof(word.substr(1));
-					if (t < tgm.getMinPoint() || t > tgm.getMaxPoint())
-					{
-						cout << "Out of time range [" << tgm.getMinPoint() << ", " << tgm.getMaxPoint() << "]" << endl;
-					}
-
-					if (lastInput)
-					{
-						lastInput->second = t;
-						lastInput = nullptr;
-					}
-					else
-					{
-						searchingTimePoint = t;
-					}
-				}
-				else
-				{
-					(sign ? negatives : positives).emplace_back(word, searchingTimePoint);
-					(sign ? negativesO : positivesO).emplace_back(word);
-					lastInput = &(sign ? negatives : positives).back();
-					sign = false;
-				}
-			}
-
-			for (auto& p : positives)
-			{
-				float wp = tgm.getWordProbByTime(p.first, p.second);
-				float tp = tgm.getTimePrior(p.second);
-				cout << "P(@" << p.second << " | " << p.first << ") = " << wp << ",\tP(@" << p.second << ") = " << tp << endl;
-			}
-
-			cout << "==== Most Similar at " << searchingTimePoint << " ====" << endl;
-			for (auto& p : tgm.mostSimilar(positives, negatives, searchingTimePoint, 0, 20))
-			{
-				if (get<1>(p) <= 0) break;
-				cout << left << setw(12) << get<0>(p) << '\t' << get<1>(p) << '\t' << get<2>(p) << endl;
-			}
-			cout << endl;
-
-			cout << "==== Most Similar Overall ====" << endl;
-			for (auto& p : tgm.mostSimilarStatic(positivesO, negativesO, 20))
-			{
-				if (get<1>(p) <= 0) break;
-				cout << left << setw(12) << get<0>(p) << '\t' << get<1>(p) << endl;
-			}
-			cout << endl;
-		}
-	}
-    return 0;
-}
-
+#include <vector>
+#include <array>
+#include <map>
+#include <algorithm>
+#include <unordered_map>
+#include <numeric>
+#include <string>
+#include <iostream>
+#include <iomanip>
+#include <sstream>
+#include <iterator>
+#include <fstream>
+#include <random>
+#include <thread>
+
+#include "cxxopts.hpp"
+#include "ChronoGramModel.h"
+#include "DataReader.h"
+#include "MMap.h"
+#include "IOUtils.h"
+
+using namespace std;
+
+struct Args
+{
+	string load, save, eval, result, llSave, fixed, loadPrior;
+	string vocab, ngram;
+	size_t maxItem = -1;
+	float minT = INFINITY, maxT = -INFINITY;
+	vector<string> input;
+	int worker = 0, window = 4, dimension = 100;
+	int order = 5, negative = 5, temporalSample = 5;
+	int batch = 10000, minCnt = 10;
+	int report = 100000;
+	int nsQ = 8, initStep = 8, subword = 0, sdr = 5;
+	float eta = 1.f, zeta = .1f, lambda = .1f, padding = -1;
+	float initEpochs = 0, epoch = 1, threshold = 0.0025f;
+	float timePrior = 0;
+	float subsampling = 1e-4f, temporalSubsampling = 1;
+	float lr = 0.025f, weightDecay = 0, subwordWeightDecay = 0, orderDecay = 0;
+	float tnsWeight = 0, ugWeight = 0;
+	float dropout = 0;
+	int decayInterval = 0;
+	bool compressed = true;
+	bool recountVocabs = false;
+	bool semEval = false;
+
+	string evalShift, shiftMetric;
+	float mixed = 0, timeA = INFINITY, timeB = INFINITY;
+
+	string evalCTA;
+};
+
+
+int main(int argc, char* argv[])
+{
+#ifdef _WIN32
+	SetConsoleOutputCP(65001);
+#endif
+	Args args;
+	try
+	{
+		cxxopts::Options options("chronogram", "Diachronic Word Embeddings");
+
+		options.add_options()
+			("i,input", "Input File", cxxopts::value<string>(), "Input file path that contains documents per line")
+			("l,load", "Load Model File", cxxopts::value<string>(), "Model file path to be loaded")
+			("v,save", "Save Model File", cxxopts::value<string>(), "Model file path to be saved")
+			("f,fixed", "Fixed Word List File", cxxopts::value<string>())
+			("h,help", "Help")
+			("version", "Version")
+			("w,worker", "Number of Workes", cxxopts::value<int>(), "The number of workers(thread) for inferencing model, default value is 0 which means the number of cores in system")
+			("W,window", "Size of Window", cxxopts::value<int>())
+			("d,dimension", "Embedding Dimension", cxxopts::value<int>())
+			("r,order", "Order of Chebyshev Polynomial", cxxopts::value<int>())
+			("e,epoch", "Number of Epoch", cxxopts::value<float>())
+			("n,negative", "Negative Sampling Size", cxxopts::value<int>())
+			("T,ts", "Time Negative Weight", cxxopts::value<int>())
+			("F,initEpochs", "Weight-Initializing Epochs", cxxopts::value<float>())
+			("b,batch", "Batch Docs Size", cxxopts::value<int>())
+			("t,minCnt", "Min Count Threshold of Word", cxxopts::value<int>())
+			("report", "", cxxopts::value<int>())
+			("eta", "", cxxopts::value<float>())
+			("z,zeta", "", cxxopts::value<float>())
+			("tnsWeight", "", cxxopts::value<float>())
+			("ugWeight", "", cxxopts::value<float>())
+			("lambda", "", cxxopts::value<float>())
+			("p,padding", "", cxxopts::value<float>())
+			("ss", "Subsamping", cxxopts::value<float>())
+			("tss", "Temporal Subsamping", cxxopts::value<float>())
+			("wdi", "weight decay interval", cxxopts::value<int>())
+			("wd", "weight decay", cxxopts::value<float>())
+			("od", "order decay", cxxopts::value<float>())
+			("swd", "subword weight decay", cxxopts::value<float>())
+			("subword", "size of subword ngram", cxxopts::value<int>())
+			("sdr", "subword dropout remain", cxxopts::value<int>())
+			("rv", "recount vocabs", cxxopts::value<int>()->implicit_value("1"))
+			("lr", "", cxxopts::value<float>())
+			("dropout", "", cxxopts::value<float>())
+
+			("compressed", "Save as compressed", cxxopts::value<int>(), "default = 1")
+			("semEval", "Print SemEval2015 Task7 Result", cxxopts::value<int>()->implicit_value("1"))
+			;
+
+		options.add_options("Google Ngram")
+			("vocab", "Vocab file", cxxopts::value<string>())
+			("ngram", "Ngram file", cxxopts::value<string>())
+			("maxItem", "max item to be loaded", cxxopts::value<size_t>())
+			("minT", "Minimum time point", cxxopts::value<float>())
+			("maxT", "Maximum time point", cxxopts::value<float>())
+			;
+
+		options.add_options("Text Dating")
+			("eval", "Evaluation set File", cxxopts::value<string>(), "Evaluation set file path")
+			("result", "Evaluation Result File", cxxopts::value<string>(), "Evaluation result file path")
+			("llSave", "Save log likelihoods of evaluation", cxxopts::value<string>())
+			("nsQ", "", cxxopts::value<int>())
+			("initStep", "", cxxopts::value<int>())
+			("threshold", "", cxxopts::value<float>())
+			("timePrior", "", cxxopts::value<float>())
+			("loadPrior", "", cxxopts::value<string>())
+			;
+
+		options.add_options("Semantic Shift")
+			("evalShift", "File to be evaluate semantic shift", cxxopts::value<string>())
+			("mixed", "mixing factor of U and V", cxxopts::value<float>())
+			("timeA", "", cxxopts::value<float>())
+			("timeB", "", cxxopts::value<float>())
+			("shiftMetric", "", cxxopts::value<string>())
+			;
+
+		options.add_options("Cross Temporal Analogy")
+			("evalCTA", "File to be evaluate cross temporal analogy", cxxopts::value<string>())
+			;
+
+		try
+		{
+			auto result = options.parse(argc, argv);
+
+			if (result.count("version"))
+			{
+				cout << "v0.1" << endl;
+				return 0;
+			}
+			if (result.count("help"))
+			{
+				cout << options.help({ "", "Text Dating", "Semantic Shift", "Google Ngram", "Cross Temporal Analogy" }) << endl;
+				return 0;
+			}
+
+
+#define READ_OPT(P, TYPE) if (result.count(#P)) args.P = result[#P].as<TYPE>()
+#define READ_OPT2(P, Q, TYPE) if (result.count(#P)) args.Q = result[#P].as<TYPE>()
+
+
+			READ_OPT(load, string);
+			READ_OPT(save, string);
+			READ_OPT(eval, string);
+			READ_OPT(result, string);
+			READ_OPT(fixed, string);
+			READ_OPT(loadPrior, string);
+			READ_OPT(llSave, string);
+
+			READ_OPT(vocab, string);
+			READ_OPT(ngram, string);
+			READ_OPT(minT, float);
+			READ_OPT(maxT, float);
+			READ_OPT2(ss, subsampling, float);
+			READ_OPT2(tss, temporalSubsampling, float);
+			READ_OPT2(rv, recountVocabs, int);
+
+			READ_OPT(maxItem, size_t);
+
+			if (result.count("input")) args.input.emplace_back(result["input"].as<string>());
+			for (size_t i = 1; i < argc; ++i)
+			{
+				args.input.emplace_back(argv[i]);
+			}
+
+			READ_OPT(worker, int);
+			READ_OPT(window, int);
+			READ_OPT(dimension, int);
+			READ_OPT(order, int);
+			READ_OPT(epoch, float);
+			READ_OPT(negative, int);
+			READ_OPT(batch, int);
+			READ_OPT(minCnt, int);
+			READ_OPT(nsQ, int);
+			READ_OPT(initStep, int);
+			READ_OPT(report, int);
+			READ_OPT(subword, int);
+			READ_OPT(sdr, int);
+			
+			READ_OPT(compressed, int);
+			READ_OPT(semEval, int);
+
+			READ_OPT(eta, float);
+			READ_OPT(zeta, float);
+			READ_OPT(lambda, float);
+			READ_OPT(padding, float);
+			READ_OPT2(ts, temporalSample, int);
+			READ_OPT(initEpochs, float);
+			READ_OPT(threshold, float);
+			READ_OPT(timePrior, float);
+			READ_OPT(lr, float);
+			READ_OPT2(wd, weightDecay, float);
+			READ_OPT2(od, orderDecay, float);
+			READ_OPT2(swd, subwordWeightDecay, float);
+			READ_OPT2(wdi, decayInterval, int);
+			READ_OPT(tnsWeight, float);
+			READ_OPT(ugWeight, float);
+			READ_OPT(dropout, float);
+
+			READ_OPT(evalShift, string);
+			READ_OPT(timeA, float);
+			READ_OPT(timeB, float);
+			READ_OPT(mixed, float);
+			READ_OPT(shiftMetric, string);
+
+			READ_OPT(evalCTA, string);
+			
+			if (args.load.empty() && args.input.empty() && args.ngram.empty())
+			{
+				throw cxxopts::OptionException("'input', 'load' or 'ngram' should be specified.");
+			}
+		}
+		catch (const cxxopts::OptionException& e)
+		{
+			cout << "error parsing options: " << e.what() << endl;
+			cout << options.help({ "", "Text Dating", "Semantic Shift", "Google Ngram" }) << endl;
+			return -1;
+		}
+
+	}
+	catch (const cxxopts::OptionException& e)
+	{
+		cout << "error parsing options: " << e.what() << endl;
+		return -1;
+	}
+
+	ChronoGramModel::HyperParameter hp;
+	hp.dimension = args.dimension;
+	hp.order = args.order;
+	hp.negativeSamples = args.negative;
+	hp.temporalNegativeSamples = args.temporalSample;
+	hp.eta = args.eta;
+	hp.zeta = args.zeta;
+	hp.lambda = args.lambda;
+	hp.subsampling = args.subsampling;
+	hp.weightDecay = args.weightDecay;
+	hp.subwordWeightDecay = args.subwordWeightDecay;
+	hp.weightDecayInterval = args.decayInterval;
+	hp.temporalSubsampling = args.temporalSubsampling;
+	hp.subwordGrams = args.subword;
+	hp.subwordDropoutRemain = args.sdr;
+	hp.tnsWeight = args.tnsWeight;
+	hp.ugWeight = args.ugWeight;
+	hp.dropout = args.dropout;
+
+	ChronoGramModel tgm{ hp };
+	if (args.padding >= 0)
+	{
+		tgm.setPadding(args.padding);
+	}
+
+	if (!args.load.empty())
+	{
+		cout << "Loading Model: " << args.load << endl;
+		//ifstream ifs{ args.load, ios_base::binary };
+		MMap mm{ args.load };
+		imstream ifs{ mm.get(), mm.size() };
+		tgm = ChronoGramModel::loadModel(ifs);
+		cout << "Dimension: " << tgm.getHP().dimension << "\tOrder: " << tgm.getHP().order << endl;
+		cout << "Workers: " << (args.worker ? args.worker : thread::hardware_concurrency()) << endl;
+		cout << "Zeta: " << tgm.getHP().zeta << "\tLambda: " << tgm.getHP().lambda << endl;
+		cout << "Padding: " << tgm.getPadding() << endl;
+	}
+	else if (!args.input.empty() || !args.ngram.empty())
+	{
+		cout << "Dimension: " << args.dimension << "\tOrder: " << args.order << "\tNegative Sampling: " << args.negative << endl;
+		cout << "Workers: " << (args.worker ? args.worker : thread::hardware_concurrency()) << "\tBatch: " << args.batch << "\tEpochs: " << args.epoch << endl;
+		cout << "Eta: " << args.eta << "\tZeta: " << args.zeta << "\tLambda: " << args.lambda << endl;
+		cout << "SS: " << args.subsampling << "\tTSS: " << args.temporalSubsampling << endl;
+		cout << "Padding: " << tgm.getPadding() << "\tTemporal Negative Sampling: " << args.temporalSample << "\tWeight-Initializing Epochs: " << args.initEpochs << endl;
+
+		if (args.ngram.empty())
+		{
+			cout << "Training Input: ";
+			for (auto& s : args.input)
+			{
+				cout << s << "  ";
+			}
+			cout << endl;
+		}
+		else
+		{
+			cout << "Training Ngram Corpus Input: " << args.ngram << endl;
+		}
+
+		Timer timer;
+		if (!args.ngram.empty())
+		{
+			if (args.maxItem == (size_t)-1)
+			{
+				GNgramBinaryReader reader{ args.ngram };
+				args.maxItem = 0;
+				if (!isfinite(args.minT))
+				{
+					while (1)
+					{
+						auto p = reader().yearCnt;
+						args.maxItem++;
+						if (p.empty()) break;
+						args.minT = min(min_element(p.begin(), p.end())->first, args.minT);
+						args.maxT = max(max_element(p.begin(), p.end())->first, args.maxT);
+					}
+					cout << "Time point: [" << args.minT << ", " << args.maxT << "]" << endl;
+				}
+				else
+				{
+					while (args.maxItem++,!reader().yearCnt.empty());
+				}
+				cout << "Total items in training data: " << args.maxItem << endl;
+			}
+		}
+
+		if (args.vocab.empty())
+		{
+			tgm.buildVocab(MultipleReader::factory(args.input), args.minCnt, args.worker);
+			cout << "MinCnt: " << args.minCnt << "\tVocab Size: " << tgm.usedVocabSize()
+				<< "\tTotal Words: " << tgm.getTotalWords() << endl;
+		}
+		else
+		{
+			ifstream vocab{ args.vocab };
+			tgm.buildVocabFromDict([&vocab]()
+			{
+				string line;
+				getline(vocab, line);
+				istringstream iss{ line };
+				string w;
+				getline(iss, w, '\t');
+				uint64_t cnt = 0;
+				iss >> cnt;
+				return make_pair(w, cnt);
+			}, args.minT, args.maxT);
+
+			cout << "Vocab Size: " << tgm.usedVocabSize() << endl;
+			cout << "Subword Vocab Size: " << tgm.getSubwordVocabs().size() << endl;
+			cout << "Subword Dropout Remain: " << tgm.getHP().subwordDropoutRemain << endl;
+			if (args.recountVocabs)
+			{
+				cout << "Recounting vocabs in time range [" << args.minT << ", " << args.maxT << "]" << endl;
+				GNgramBinaryReader reader{ args.ngram };
+				cout << "Recounted Vocab Size: " <<
+					tgm.recountVocab(GNgramBinaryReader::factory(args.ngram), args.minT, args.maxT, 0) << endl;
+			}
+		}
+
+		if(!args.fixed.empty())
+		{
+			ifstream ifs{ args.fixed };
+			string line;
+			size_t numFixedWords = 0;
+			while (getline(ifs, line))
+			{
+				while (!line.empty() && isspace(line.back())) line.pop_back();
+				if (tgm.addFixedWord(line)) numFixedWords++;
+			}
+			cout << numFixedWords << " fixed words are loaded." << endl;
+		}
+
+		if (args.ngram.empty())
+		{
+			if (args.initEpochs)
+			{
+				cout << "Initializing weights ... " << endl;
+				tgm.template train<true>(MultipleReader::factory(args.input),
+					args.worker, args.window, args.lr, args.lr / 100, args.batch, args.initEpochs, args.report);
+			}
+			cout << "Training ... " << endl;
+			tgm.train(MultipleReader::factory(args.input),
+				args.worker, args.window, args.lr, args.lr / 100, args.batch, args.epoch, args.report);
+		}
+		else
+		{
+			if (args.initEpochs)
+			{
+				cout << "Initializing weights ... " << endl;
+				tgm.template trainFromGNgram<true>(GNgramBinaryReader::factory(args.ngram),
+					args.maxItem, args.worker, args.lr, args.lr / 100, args.batch, args.initEpochs, args.report);
+			}
+			cout << "Training ... " << endl;
+			tgm.trainFromGNgram(GNgramBinaryReader::factory(args.ngram),
+				args.maxItem, args.worker, args.lr, args.lr / 100, args.batch, args.epoch, args.report);
+		}
+
+		cout << "Finished in " << timer.getElapsed() << " sec" << endl;
+		if (!args.save.empty())
+		{
+			cout << "Saving Model: " << args.save << endl;
+			ofstream ofs{ args.save, ios_base::binary };
+			tgm.saveModel(ofs, args.compressed);
+		}
+	}
+
+	if (!args.evalShift.empty())
+	{
+		if (!isfinite(args.timeA)) args.timeA = tgm.getMinPoint();
+		if (!isfinite(args.timeB)) args.timeB = tgm.getMaxPoint();
+
+		ifstream ifs{ args.evalShift };
+		string line;
+		cout << "== Evaluating semantic shift : " << args.evalShift 
+			<< " between " << args.timeA << " and " << args.timeB << " ==" << endl;
+		vector<float> refScores, sysScores;
+		while (getline(ifs, line))
+		{
+			istringstream iss{ line };
+			string word;
+			float score = INFINITY, s;
+			getline(iss, word, '\t');
+			iss >> score;
+			if (word.empty()) continue;
+
+			auto v = tgm.getEmbedding(word);
+			auto u1 = tgm.getEmbedding(word, args.timeA), u2 = tgm.getEmbedding(word, args.timeB);
+			if (args.shiftMetric == "l2")
+			{
+				s = (u1 - u2).norm();
+			}
+			else
+			{
+				s = (v * args.mixed + u1 * (1 - args.mixed)).normalized().dot(
+					(v * args.mixed + u2 * (1 - args.mixed)).normalized());
+			}
+			cout << word << '\t' << s << endl;
+			if (isfinite(score))
+			{
+				refScores.emplace_back(score);
+				sysScores.emplace_back(s);
+			}
+		}
+		cout << endl;
+		if (!refScores.empty())
+		{
+			cout << "Pearson Correl: " << correlPearson<float>(refScores.begin(), refScores.end(), sysScores.begin()) << endl;
+			cout << "Spearman Correl: " << correlSpearman<float>(refScores.begin(), refScores.end(), sysScores.begin()) << endl;
+		}
+	}
+
+	if (!args.evalCTA.empty())
+	{
+		ifstream ifs{ args.evalCTA };
+		string line;
+		cout << "== Evaluating cross temporal analogy : " << args.evalCTA << endl;
+		array<size_t, 5> at = { 0, 1, 3, 5, 10 };
+		array<float, 5> scores = { 0, };
+		size_t totSet = 0;
+		
+		while (getline(ifs, line))
+		{
+			if (isspace(line.back())) line.pop_back();
+			istringstream iss{ line };
+			string left, right;
+			if (!getline(iss, left, ',')) continue;
+			if (!getline(iss, right, ',')) continue;
+			
+			if (left.find('-') == string::npos || right.find('-') == string::npos)
+			{
+				cerr << "wrong input: " << line << endl;
+				continue;
+			}
+
+			float lYear = stof(left.substr(left.find('-') + 1));
+			float rYear = stof(right.substr(right.find('-') + 1));
+
+			left = left.substr(0, left.find('-'));
+			right = right.substr(0, right.find('-'));
+			auto res = tgm.nearestNeighbors(left, lYear, rYear, args.mixed, 10);
+			size_t rank = 0;
+			for (; rank < res.size(); ++rank)
+			{
+				if (get<0>(res[rank]) == right) break;
+			}
+
+			if (rank < 10 && rank < res.size())
+			{
+				for (size_t i = 0; i < at.size(); ++i)
+				{
+					if (at[i] == 0) scores[i] += 1.f / (rank + 1);
+					else if (rank < at[i]) scores[i] += 1;
+				}
+			}
+			totSet++;
+		}
+
+		for (auto& s : scores) s /= totSet;
+		for (size_t i = 0; i < at.size(); ++i)
+		{
+			if (at[i]) cout << "MP@" << at[i];
+			else cout << "MPR";
+			cout << "\t" << scores[i] << endl;
+		}
+	}
+
+	map<float, float> priorMap;
+	function<float(float)> priorFunc = [&priorMap](float x)->float
+	{
+		auto it = priorMap.lower_bound(x);
+		if (it == priorMap.end()) return -INFINITY;
+		if (it->first == x) return it->second;
+		if (it == priorMap.begin()) return -INFINITY;
+		float nx = it->first, ny = it->second;
+		--it;
+		float px = it->first, py = it->second;
+		return py + (x - px) * (ny - py) / (nx - px);
+	};
+
+	if (!args.loadPrior.empty())
+	{
+		ifstream lpf{ args.loadPrior };
+		string line;
+		while (getline(lpf, line))
+		{
+			istringstream iss{ line };
+			float x = INFINITY, y = INFINITY;
+			iss >> x >> y;
+			if (!isfinite(x) || !isfinite(y)) continue;
+			priorMap.emplace(x, y);
+		}
+	}
+	if (priorMap.empty()) priorFunc = function<float(float)>{};
+
+	if (!args.eval.empty())
+	{
+		cout << "Evaluating Time Prediction: " << args.eval << endl;
+		cout << "TimePriorWeight: " << args.timePrior << endl;
+		Timer timer;
+		ifstream ifs{ args.eval };
+		if (args.result.empty()) args.result = args.eval + ".result";
+		ofstream ofs{ args.result };
+		ofstream ollfs;
+		if (!args.llSave.empty())
+		{
+			ollfs = ofstream{ args.llSave };
+			for (size_t i = 0; i <= args.initStep; ++i)
+			{
+				if (i) ollfs << '\t';
+				ollfs << tgm.getMinPoint() + (tgm.getMaxPoint() - tgm.getMinPoint()) * i / args.initStep;
+			}
+			ollfs << endl;
+		}
+
+		float avgErr = 0, meanErr = 0;
+		double score[3] = { 0, };
+		size_t correct[3] = { 0, };
+		size_t n = 0;
+		MultipleReader reader{ {args.eval} };
+		tgm.evaluate(bind(&MultipleReader::operator(), &reader), 
+			[&](ChronoGramModel::EvalResult r)
+		{
+			ofs << r.trueTime << "\t" << r.estimatedTime << "\t" << r.ll
+				<< "\t" << r.llPerWord << "\t" << r.normalizedErr << endl;
+			avgErr += pow(r.normalizedErr, 2);
+			meanErr += abs(r.normalizedErr);
+			if (abs(r.normalizedErr) >= 0.5)
+			{
+				cout << r.trueTime << "\t" << r.estimatedTime << "\t" << r.normalizedErr << "\t";
+				for (auto& w : r.words) cout << w << ' ';
+				cout << endl;
+			}
+
+			if (ollfs)
+			{
+				size_t n = 0;
+				for (auto ll : r.lls)
+				{
+					if (n++) ollfs << '\t';
+					ollfs << ll;
+				}
+				ollfs << endl;
+			}
+
+			if (args.semEval)
+			{
+				static size_t span[3] = { 6, 12, 20 };
+				static double offsetScore[] = { 1, 0.9, 0.85, 0.8, 0.6, 0.5, 0.4, 0.2, 0.1, 0.01 };
+				float err = r.trueTime - r.estimatedTime;
+				for (size_t i = 0; i < 3; ++i)
+				{
+					auto s = span[i];
+					size_t offset = 0;
+					if (abs(err) <= s / 2)
+					{
+						++correct[i];
+					}
+					else
+					{
+						offset = (abs(err) - s / 2 - 1) / (s + 1) + 1;
+					}
+					score[i] += offsetScore[min(offset, (size_t)9)];
+				}
+			}
+			n++;
+		}, args.worker, args.window, args.nsQ, priorFunc, args.timePrior, args.initStep, args.threshold);
+		
+		avgErr /= n;
+		meanErr /= n;
+
+		const auto printResult = [&](auto& os)
+		{
+			os << "Running Time: " << timer.getElapsed() << "s" << endl;
+			os << "Total Docs: " << n << endl;
+			os << "Avg Squared Error: " << avgErr << endl;
+			os << "Avg Error: " << sqrt(avgErr) << endl;
+			os << "MAE: " << meanErr << endl;
+
+			if (args.semEval)
+			{
+				os << "Correct (F, M, C): " << correct[0] << ", " << correct[1] << ", " << correct[2] << endl;
+				os << "Precision (F, M, C): " << correct[0] / (double)n << ", " << correct[1] / (double)n << ", " << correct[2] / (double)n << endl;
+				os << "Avg Score (F, M, C): " << score[0] / n << ", " << score[1] / n << ", " << score[2] / n << endl;
+			}
+		};
+
+		cout << "== Evaluating Result ==" << endl;
+		printResult(cout);
+		printResult(ofs);
+	}
+
+	string line;
+	while (cout << ">> ", getline(cin, line))
+	{
+		if (line[0] == '~') // calculate arc length
+		{
+			if (line.size() == 1) // find shortest arc length
+			{
+				cout << "==== Shortest Arc Length ====" << endl;
+				vector<pair<string, float>> lens;
+				for (auto& w : tgm.getVocabs())
+				{
+					lens.emplace_back(w, tgm.arcLengthOfWord(w));
+				}
+				sort(lens.begin(), lens.end(), [](auto a, auto b)
+				{
+					return a.second < b.second;
+				});
+				size_t i = 0;
+				for (auto& p : lens)
+				{
+					cout << p.first << "\t" << p.second << endl;
+					if (++i >= 20) break;
+				}
+				cout << "==== Longest Arc Length ====" << endl;
+				for (auto it = lens.end() - 20; it != lens.end(); ++it)
+				{
+					cout << it->first << "\t" << it->second << endl;
+				}
+				cout << endl;
+
+				cout << "==== Shortest Angle ====" << endl;
+				lens.clear();
+				for (auto& w : tgm.getVocabs())
+				{
+					lens.emplace_back(w, tgm.angleOfWord(w));
+				}
+				sort(lens.begin(), lens.end(), [](auto a, auto b)
+				{
+					return a.second < b.second;
+				});
+				i = 0;
+				for (auto& p : lens)
+				{
+					cout << p.first << "\t" << p.second / EIGEN_PI * 180 << endl;
+					if (++i >= 20) break;
+				}
+				cout << "==== Longest Angle ====" << endl;
+				for (auto it = lens.end() - 20; it != lens.end(); ++it)
+				{
+					cout << it->first << "\t" << it->second / EIGEN_PI * 180 << endl;
+				}
+				cout << endl;
+			}
+			else
+			{
+				string w = line.substr(1);
+				cout << "Arc Length of " << w << " : " << tgm.arcLengthOfWord(w) << endl;
+				cout << "Angle of " << w << " : " << tgm.angleOfWord(w) / EIGEN_PI * 180 << endl;
+			}
+		}
+		else if (line[0] == '`') // estimate time of text
+		{
+			istringstream iss{ line.substr(1) };
+			istream_iterator<string> wBegin{ iss }, wEnd{};
+			vector<string> words{ wBegin, wEnd };
+			auto evaluator = tgm.evaluateSent(words, args.window, args.nsQ, 0, priorFunc, args.timePrior);
+			for (size_t i = 0; i <= args.initStep; ++i)
+			{
+				float z = tgm.getMinPoint() + (i / (float)args.initStep) * (tgm.getMaxPoint() - tgm.getMinPoint());
+				cout << z << ": " << evaluator(tgm.normalizedTimePoint(z)) << endl;
+			}
+		}
+		else if (line[0] == '!') // estimate time of word
+		{
+			stringstream iss{ line.substr(1) };
+			istream_iterator<string> wBegin{ iss }, wEnd{};
+			vector<string> words{ wBegin, wEnd };
+			if (words.empty())
+			{
+				for (size_t i = 0; i <= args.initStep; ++i)
+				{
+					float z = tgm.getMinPoint() + (i / (float)args.initStep) * (tgm.getMaxPoint() - tgm.getMinPoint());
+					cout << z << ": " << tgm.getTimePrior(z) << endl;
+				}
+			}
+			else
+			{
+				cout << "Total count of " << words[0] << " : " << tgm.getWordCount(words[0]) << endl;
+				for (size_t i = 0; i <= args.initStep; ++i)
+				{
+					float z = tgm.getMinPoint() + (i / (float)args.initStep) * (tgm.getMaxPoint() - tgm.getMinPoint());
+					float w = tgm.getWordProbByTime(words[0], z);
+					float t = tgm.getTimePrior(z);
+					cout << z << ": " << w << "\t" << w / t << endl;
+				}
+			}
+		}
+		else if (line[0] == '#') // get embedding
+		{
+			vector<pair<string, float>> words;
+			pair<string, float>* lastInput = nullptr;
+			stringstream iss{ line.substr(1) };
+			istream_iterator<string> wBegin{ iss }, wEnd{};
+			for (; wBegin != wEnd; ++wBegin)
+			{
+				auto word = *wBegin;
+				if (word[0] == '@')
+				{
+					float t = stof(word.substr(1));
+					if (t < tgm.getMinPoint() || t > tgm.getMaxPoint())
+					{
+						cout << "Out of time range [" << tgm.getMinPoint() << ", " << tgm.getMaxPoint() << "]" << endl;
+					}
+
+					if (lastInput)
+					{
+						lastInput->second = t;
+						lastInput = nullptr;
+					}
+				}
+				else
+				{
+					words.emplace_back(word, -INFINITY);
+					lastInput = &words.back();
+				}
+			}
+			for(auto& w : words)
+			{
+				auto vec = isfinite(w.second) 
+					? tgm.getEmbedding(w.first, w.second)
+					: tgm.getEmbedding(w.first);
+				printf("[");
+				for (size_t i = 0; i < vec.size(); ++i)
+				{
+					printf("%.3f, ", vec(i));
+				}
+				printf("]\n");
+			}
+		}
+		else if (line[0] == '$') // similarity between two word
+		{
+			vector<pair<string, float>> words;
+			pair<string, float>* lastInput = nullptr;
+			istringstream iss{ line.substr(1) };
+			istream_iterator<string> wBegin{ iss }, wEnd{};
+			for (; wBegin != wEnd; ++wBegin)
+			{
+				auto word = *wBegin;
+				if (word[0] == '@')
+				{
+					float t = stof(word.substr(1));
+					if (t < tgm.getMinPoint() || t > tgm.getMaxPoint())
+					{
+						cout << "Out of time range [" << tgm.getMinPoint() << ", " << tgm.getMaxPoint() << "]" << endl;
+					}
+
+					if (lastInput)
+					{
+						lastInput->second = t;
+						lastInput = nullptr;
+					}
+				}
+				else
+				{
+					words.emplace_back(word, tgm.getMinPoint());
+					lastInput = &words.back();
+				}
+			}
+			if (words.size() < 2)
+			{
+				cout << "Input two words!!" << endl;
+			}
+			else
+			{
+				cout << "Similarity between '" << words[0].first << "' @" << words[0].second
+					<< " and '" << words[1].first << "' @" << words[1].second
+					<< " : " << tgm.similarity(words[0].first, words[0].second, words[1].first, words[1].second) << endl;
+				cout << "Overall similarity between '" << words[0].first << "' and '" << words[1].first
+					<< "' : " << tgm.similarityStatic(words[0].first,words[1].first) << endl;
+			}
+		}
+		else if (line[0] == '%') // find most similar word using mixed vector
+		{
+			istringstream iss{ line.substr(1) };
+			float mixed = 0;
+			iss >> mixed;
+			vector<pair<string, float>> positives, negatives;
+			pair<string, float>* lastInput = nullptr;
+			istream_iterator<string> wBegin{ iss }, wEnd{};
+			float searchingTimePoint = tgm.getMinPoint();
+			bool sign = false;
+			for (; wBegin != wEnd; ++wBegin)
+			{
+				auto word = *wBegin;
+				if (word == "-")
+				{
+					sign = true;
+				}
+				else if (word == "+")
+				{
+					sign = false;
+				}
+				else if (word[0] == '@')
+				{
+					float t = stof(word.substr(1));
+					if (t < tgm.getMinPoint() || t > tgm.getMaxPoint())
+					{
+						cout << "Out of time range [" << tgm.getMinPoint() << ", " << tgm.getMaxPoint() << "]" << endl;
+					}
+
+					if (lastInput)
+					{
+						lastInput->second = t;
+						lastInput = nullptr;
+					}
+					else
+					{
+						searchingTimePoint = t;
+					}
+				}
+				else
+				{
+					(sign ? negatives : positives).emplace_back(word, searchingTimePoint);
+					lastInput = &(sign ? negatives : positives).back();
+					sign = false;
+				}
+			}
+
+			for (auto& p : positives)
+			{
+				float wp = tgm.getWordProbByTime(p.first, p.second);
+				float tp = tgm.getTimePrior(p.second);
+				cout << "P(@" << p.second << " | " << p.first << ") = " << wp << ",\tP(@" << p.second << ") = " << tp << endl;
+			}
+
+			cout << "==== Most Similar at " << searchingTimePoint << " ====" << endl;
+			for (auto& p : tgm.mostSimilar(positives, negatives, searchingTimePoint, mixed, 20))
+			{
+				if (get<1>(p) <= 0) break;
+				cout << left << setw(12) << get<0>(p) << '\t' << get<1>(p) << '\t' << get<2>(p) << endl;
+			}
+			cout << endl;
+		}
+		else if (line[0] == '^') // calculate shift of words
+		{
+			istringstream iss{ line.substr(1) };
+			size_t minCnt = 100, show = 40;
+			float time1 = 0, time2 = 0, m = 0;
+			iss >> minCnt >> time1 >> time2 >> m >> show;
+			auto ret = tgm.calcShift(minCnt, time1, time2, m);
+			cout << "== Shift between " << time1 << " and " << time2 << " ==" << endl;
+			for (size_t i = 0; i < 10 && i < ret.size(); ++i)
+			{
+				cout << ret[i].first << "\t" << ret[i].second << endl;
+			}
+			cout << "  ...  " << endl;
+			for (size_t i = max(ret.size(), (size_t)show) - show; i < ret.size(); ++i)
+			{
+				cout << ret[i].first << "\t" << ret[i].second << endl;
+			}
+			cout << endl;
+		}
+		else if (line[0] == '&')
+		{
+			istringstream iss{ line.substr(1) };
+			float m = 0, time = 0;
+			string src, t;
+			vector<string> targets;
+			iss >> m >> time >> src;
+			while (iss >> t) targets.emplace_back(t);
+			cout << "== Sum of similarities from " << src << " : " << tgm.sumSimilarity(src, targets, time, m) << endl;
+		}
+		else // find most similar word
+		{
+			vector<pair<string, float>> positives, negatives;
+			vector<string> positivesO, negativesO;
+			pair<string, float>* lastInput = nullptr;
+			istringstream iss{ line };
+			istream_iterator<string> wBegin{ iss }, wEnd{};
+			float searchingTimePoint = tgm.getMinPoint();
+			bool sign = false;
+			for (; wBegin != wEnd; ++wBegin)
+			{
+				auto word = *wBegin;
+				if (word == "-")
+				{
+					sign = true;
+				}
+				else if (word == "+")
+				{
+					sign = false;
+				}
+				else if (word[0] == '@')
+				{
+					float t = stof(word.substr(1));
+					if (t < tgm.getMinPoint() || t > tgm.getMaxPoint())
+					{
+						cout << "Out of time range [" << tgm.getMinPoint() << ", " << tgm.getMaxPoint() << "]" << endl;
+					}
+
+					if (lastInput)
+					{
+						lastInput->second = t;
+						lastInput = nullptr;
+					}
+					else
+					{
+						searchingTimePoint = t;
+					}
+				}
+				else
+				{
+					(sign ? negatives : positives).emplace_back(word, searchingTimePoint);
+					(sign ? negativesO : positivesO).emplace_back(word);
+					lastInput = &(sign ? negatives : positives).back();
+					sign = false;
+				}
+			}
+
+			for (auto& p : positives)
+			{
+				float wp = tgm.getWordProbByTime(p.first, p.second);
+				float tp = tgm.getTimePrior(p.second);
+				cout << "P(@" << p.second << " | " << p.first << ") = " << wp << ",\tP(@" << p.second << ") = " << tp << endl;
+			}
+
+			cout << "==== Most Similar at " << searchingTimePoint << " ====" << endl;
+			for (auto& p : tgm.mostSimilar(positives, negatives, searchingTimePoint, 0, 20))
+			{
+				if (get<1>(p) <= 0) break;
+				cout << left << setw(12) << get<0>(p) << '\t' << get<1>(p) << '\t' << get<2>(p) << endl;
+			}
+			cout << endl;
+
+			cout << "==== Most Similar Overall ====" << endl;
+			for (auto& p : tgm.mostSimilarStatic(positivesO, negativesO, 20))
+			{
+				if (get<1>(p) <= 0) break;
+				cout << left << setw(12) << get<0>(p) << '\t' << get<1>(p) << endl;
+			}
+			cout << endl;
+		}
+	}
+    return 0;
+}
+
```

### Comparing `chronogram-0.1.7/src/mathUtils.h` & `chronogram-0.2.0/src/mathUtils.h`

 * *Files 17% similar despite different names*

```diff
@@ -1,125 +1,126 @@
-#pragma once
-#include <array>
-
-inline float sigmoid(float x)
-{
-	return 1 / (1 + expf(-x));
-}
-
-struct F_logsigmoid
-{
-	double operator()(double x) { return -log(1 + exp(-x)); }
-	double forLarge(double x) { return -0.f; }
-};
-
-template<class _Func, size_t N, size_t S>
-class SimpleLUT
-{
-protected:
-	std::array<float, N> points;
-	static constexpr float P = 1.f / S;
-	SimpleLUT()
-	{
-		_Func fun;
-		for (size_t i = 0; i < N; i++)
-		{
-			points[i] = fun(i * P);
-		}
-	}
-
-	float _get(float x) const
-	{
-		size_t idx = (size_t)(x * S);
-		if (idx >= N) return _Func{}.forLarge(x);
-		return points[idx];
-	}
-public:
-	static const SimpleLUT& getInst()
-	{
-		static SimpleLUT lg;
-		return lg;
-	}
-
-	static float get(float x)
-	{
-		return getInst()._get(x);
-	}
-};
-
-inline float logsigmoid(float x)
-{
-	if (x >= 0) return SimpleLUT<F_logsigmoid, 32 * 1024, 1024>::get(x);
-	return SimpleLUT<F_logsigmoid, 32 * 1024, 1024>::get(-x) + x;
-}
-
-inline float integratedChebyshevT(size_t n)
-{
-	if (n % 2) return 0;
-	return 2.f / (1.f - n * n);
-}
-
-inline float integratedSqChebyshevT(size_t n)
-{
-	return 1 - 1.f / (4 * n * n - 1.f);
-}
-
-inline float integratedChebyshevTT(size_t n, size_t m)
-{
-	return (integratedChebyshevT(n + m) + integratedChebyshevT(std::max(n, m) - std::min(n, m))) / 2;
-}
-
-template<typename _OutTy, typename _RandIter>
-_OutTy correlPearson(_RandIter xFirst, _RandIter xLast, _RandIter yFirst)
-{
-	_OutTy xMean = 0, yMean = 0, xSqMean = 0, ySqMean = 0, xyMean = 0;
-	size_t cnt = 0;
-	for (auto x = xFirst, y = yFirst; x != xLast; ++x, ++y, ++cnt)
-	{
-		xMean += *x;
-		yMean += *y;
-		xSqMean += *x * *x;
-		ySqMean += *y * *y;
-		xyMean += *x * *y;
-	}
-	xMean /= cnt;
-	yMean /= cnt;
-	xSqMean /= cnt;
-	ySqMean /= cnt;
-	xyMean /= cnt;
-	return (xyMean - xMean * yMean) / sqrt((xSqMean - xMean * xMean) * (ySqMean - yMean * yMean));
-}
-
-template<typename _InputIter, typename _OutputIter>
-void rankAvg(_InputIter srcFirst, _InputIter srcLast, _OutputIter destFirst)
-{
-	size_t len = std::distance(srcFirst, srcLast);
-	std::vector<size_t> idx(len);
-	std::iota(idx.begin(), idx.end(), 0);
-	std::sort(idx.begin(), idx.end(), [&](size_t l, size_t r)
-	{
-		return srcFirst[l] < srcFirst[r];
-	});
-	size_t rank = 1;
-	for (size_t i = 0; i < len; )
-	{
-		size_t n = 1;
-		while (i + n < len && srcFirst[idx[i + n - 1]] == srcFirst[idx[i + n]]) ++n;
-
-		for (size_t j = 0; j < n; ++j)
-		{
-			destFirst[idx[i + j]] = rank + (n - 1) * .5;
-		}
-		rank += n;
-		i += n;
-	}
-}
-
-template<typename _OutTy, typename _RandIter>
-_OutTy correlSpearman(_RandIter xFirst, _RandIter xLast, _RandIter yFirst)
-{
-	size_t len = std::distance(xFirst, xLast);
-	std::vector<_OutTy> xRank(len), yRank(len);
-	rankAvg(xFirst, xLast, xRank.begin());
-	rankAvg(yFirst, std::next(yFirst, len), yRank.begin());
-	return correlPearson<_OutTy>(xRank.begin(), xRank.end(), yRank.begin());
-}
+#pragma once
+#include <array>
+#include <numeric>
+
+inline float sigmoid(float x)
+{
+	return 1 / (1 + expf(-x));
+}
+
+struct F_logsigmoid
+{
+	double operator()(double x) { return -std::log(1 + std::exp(-x)); }
+	double forLarge(double x) { return -0.f; }
+};
+
+template<class _Func, size_t N, size_t S>
+class SimpleLUT
+{
+protected:
+	std::array<float, N> points;
+	static constexpr float P = 1.f / S;
+	SimpleLUT()
+	{
+		_Func fun;
+		for (size_t i = 0; i < N; i++)
+		{
+			points[i] = fun(i * P);
+		}
+	}
+
+	float _get(float x) const
+	{
+		size_t idx = (size_t)(x * S);
+		if (idx >= N) return _Func{}.forLarge(x);
+		return points[idx];
+	}
+public:
+	static const SimpleLUT& getInst()
+	{
+		static SimpleLUT lg;
+		return lg;
+	}
+
+	static float get(float x)
+	{
+		return getInst()._get(x);
+	}
+};
+
+inline float logsigmoid(float x)
+{
+	if (x >= 0) return SimpleLUT<F_logsigmoid, 32 * 1024, 1024>::get(x);
+	return SimpleLUT<F_logsigmoid, 32 * 1024, 1024>::get(-x) + x;
+}
+
+inline float integratedChebyshevT(size_t n)
+{
+	if (n % 2) return 0;
+	return 2.f / (1.f - n * n);
+}
+
+inline float integratedSqChebyshevT(size_t n)
+{
+	return 1 - 1.f / (4 * n * n - 1.f);
+}
+
+inline float integratedChebyshevTT(size_t n, size_t m)
+{
+	return (integratedChebyshevT(n + m) + integratedChebyshevT(std::max(n, m) - std::min(n, m))) / 2;
+}
+
+template<typename _OutTy, typename _RandIter>
+_OutTy correlPearson(_RandIter xFirst, _RandIter xLast, _RandIter yFirst)
+{
+	_OutTy xMean = 0, yMean = 0, xSqMean = 0, ySqMean = 0, xyMean = 0;
+	size_t cnt = 0;
+	for (auto x = xFirst, y = yFirst; x != xLast; ++x, ++y, ++cnt)
+	{
+		xMean += *x;
+		yMean += *y;
+		xSqMean += *x * *x;
+		ySqMean += *y * *y;
+		xyMean += *x * *y;
+	}
+	xMean /= cnt;
+	yMean /= cnt;
+	xSqMean /= cnt;
+	ySqMean /= cnt;
+	xyMean /= cnt;
+	return (xyMean - xMean * yMean) / sqrt((xSqMean - xMean * xMean) * (ySqMean - yMean * yMean));
+}
+
+template<typename _InputIter, typename _OutputIter>
+void rankAvg(_InputIter srcFirst, _InputIter srcLast, _OutputIter destFirst)
+{
+	size_t len = std::distance(srcFirst, srcLast);
+	std::vector<size_t> idx(len);
+	std::iota(idx.begin(), idx.end(), 0);
+	std::sort(idx.begin(), idx.end(), [&](size_t l, size_t r)
+	{
+		return srcFirst[l] < srcFirst[r];
+	});
+	size_t rank = 1;
+	for (size_t i = 0; i < len; )
+	{
+		size_t n = 1;
+		while (i + n < len && srcFirst[idx[i + n - 1]] == srcFirst[idx[i + n]]) ++n;
+
+		for (size_t j = 0; j < n; ++j)
+		{
+			destFirst[idx[i + j]] = rank + (n - 1) * .5;
+		}
+		rank += n;
+		i += n;
+	}
+}
+
+template<typename _OutTy, typename _RandIter>
+_OutTy correlSpearman(_RandIter xFirst, _RandIter xLast, _RandIter yFirst)
+{
+	size_t len = std::distance(xFirst, xLast);
+	std::vector<_OutTy> xRank(len), yRank(len);
+	rankAvg(xFirst, xLast, xRank.begin());
+	rankAvg(yFirst, std::next(yFirst, len), yRank.begin());
+	return correlPearson<_OutTy>(xRank.begin(), xRank.end(), yRank.begin());
+}
```

### Comparing `chronogram-0.1.7/src/polynomials.hpp` & `chronogram-0.2.0/src/polynomials.hpp`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,270 +1,270 @@
-#pragma once
-#include <type_traits>
-#include <cmath>
-
-namespace poly
-{
-	template<int n, int k>
-	struct combination
-	{
-		static constexpr int64_t value = combination<n - 1, k - 1>::value + combination<n - 1, k>::value;
-	};
-
-	template<int n>
-	struct combination<n, 0>
-	{
-		static constexpr int64_t value = 1;
-	};
-
-	template<int n>
-	struct combination<0, n>
-	{
-		static constexpr int64_t value = 1;
-	};
-
-	template<int n>
-	struct combination<n, n>
-	{
-		static constexpr int64_t value = 1;
-	};
-
-	template<>
-	struct combination<0, 0>
-	{
-		static constexpr int value = 1;
-	};
-
-	template<int n>
-	struct even_odd
-	{
-		static constexpr int value = -1;
-	};
-	template<>
-	struct even_odd<0>
-	{
-		static constexpr int value = 1;
-	};
-
-	template<int _Order, class _Type, int n = 0>
-	struct shiftedLegendre
-	{
-		inline static _Type at(_Type x)
-		{
-			return shiftedLegendre<_Order, _Type, n + 1>::at(x) * x + combination<_Order, n>::value * combination<_Order + n, n>::value * even_odd<(_Order + n) % 2>::value;
-		}
-	};
-
-	template<int _Order, class _Type>
-	struct shiftedLegendre<_Order, _Type, _Order>
-	{
-		inline static _Type at(_Type x)
-		{
-			return combination<_Order + _Order, _Order>::value;
-		}
-	};
-
-	template<class _Type>
-	struct shiftedLegendre<0, _Type, 0>
-	{
-		inline static _Type at(_Type x)
-		{
-			return 1;
-		}
-	};
-
-	template<int _Order, class _Type> inline _Type shiftedLegendreFunc(_Type x)
-	{
-		return shiftedLegendre<_Order, _Type, 0>::at(x);
-	}
-
-
-	template<class _Type> _Type slpGet(size_t order, _Type x)
-	{
-		switch (order)
-		{
-		case 0: return shiftedLegendreFunc<0>(x);
-		case 1: return shiftedLegendreFunc<1>(x);
-		case 2: return shiftedLegendreFunc<2>(x);
-		case 3: return shiftedLegendreFunc<3>(x);
-		case 4: return shiftedLegendreFunc<4>(x);
-		case 5: return shiftedLegendreFunc<5>(x);
-		case 6: return shiftedLegendreFunc<6>(x);
-		case 7: return shiftedLegendreFunc<7>(x);
-		case 8: return shiftedLegendreFunc<8>(x);
-		case 9: return shiftedLegendreFunc<9>(x);
-		case 10: return shiftedLegendreFunc<10>(x);
-		case 11: return shiftedLegendreFunc<11>(x);
-		case 12: return shiftedLegendreFunc<12>(x);
-		case 13: return shiftedLegendreFunc<13>(x);
-		case 14: return shiftedLegendreFunc<14>(x);
-		case 15: return shiftedLegendreFunc<15>(x);
-		}
-		return _Type{};
-	}
-
-	inline size_t partialProductDown(size_t n, size_t k)
-	{
-		size_t ret = 1;
-		for (size_t i = 0; i < k; ++i) ret *= n--;
-		return ret;
-	}
-
-	inline int slpGetCoef(size_t n, size_t k)
-	{
-		return ((n + k) & 1 ? -1 : 1) * (int)(partialProductDown(n, k) / partialProductDown(k, k) * partialProductDown(n + k, k) / partialProductDown(k, k));
-	}
-
-	template<class _Type, int _Order> struct chebyshevU;
-
-	template<class _Type, int _Order>
-	struct chebyshevT
-	{
-		inline static _Type get(_Type x)
-		{
-			if(_Order % 2) return 2 * chebyshevT<_Type, _Order / 2>::get(x) * chebyshevT<_Type, _Order / 2 + 1>::get(x) - x;
-			else return 2 * std::pow(chebyshevT<_Type, _Order / 2>::get(x), 2) - 1;
-		}
-
-		inline static _Type derived(_Type x)
-		{
-			return _Order * chebyshevU<_Type, _Order - 1>::get(x);
-		}
-	};
-
-	template<class _Type>
-	struct chebyshevT<_Type, 0>
-	{
-		inline static _Type get(_Type x)
-		{
-			return 1;
-		}
-
-		inline static _Type derived(_Type x)
-		{
-			return 0;
-		}
-	};
-
-	template<class _Type>
-	struct chebyshevT<_Type, 1>
-	{
-		inline static _Type get(_Type x)
-		{
-			return x;
-		}
-
-		inline static _Type derived(_Type x)
-		{
-			return 1;
-		}
-	};
-
-	template<int _Order, class _Type> inline _Type chebyshevTf(_Type x)
-	{
-		return chebyshevT<_Type, _Order>::get(x);
-	}
-
-	template<int _Order, class _Type> inline _Type chebyshevTg(_Type x)
-	{
-		return chebyshevT<_Type, _Order>::derived(x);
-	}
-
-	template<class _Type> _Type chebyshevTGet(size_t order, _Type x)
-	{
-		switch (order)
-		{
-		case 0: return chebyshevTf<0>(x);
-		case 1: return chebyshevTf<1>(x);
-		case 2: return chebyshevTf<2>(x);
-		case 3: return chebyshevTf<3>(x);
-		case 4: return chebyshevTf<4>(x);
-		case 5: return chebyshevTf<5>(x);
-		case 6: return chebyshevTf<6>(x);
-		case 7: return chebyshevTf<7>(x);
-		case 8: return chebyshevTf<8>(x);
-		case 9: return chebyshevTf<9>(x);
-		case 10: return chebyshevTf<10>(x);
-		case 11: return chebyshevTf<11>(x);
-		case 12: return chebyshevTf<12>(x);
-		case 13: return chebyshevTf<13>(x);
-		case 14: return chebyshevTf<14>(x);
-		case 15: return chebyshevTf<15>(x);
-		}
-		if(order % 2) return 2 * chebyshevTGet(order / 2, x) * chebyshevTGet(order / 2 + 1, x) - x;
-		return 2 * pow(chebyshevTGet(order / 2, x), 2) - 1;
-	}
-
-	template<class _Type> _Type chebyshevTDerived(size_t order, _Type x)
-	{
-		switch (order)
-		{
-		case 0: return chebyshevTg<0>(x);
-		case 1: return chebyshevTg<1>(x);
-		case 2: return chebyshevTg<2>(x);
-		case 3: return chebyshevTg<3>(x);
-		case 4: return chebyshevTg<4>(x);
-		case 5: return chebyshevTg<5>(x);
-		case 6: return chebyshevTg<6>(x);
-		case 7: return chebyshevTg<7>(x);
-		case 8: return chebyshevTg<8>(x);
-		case 9: return chebyshevTg<9>(x);
-		case 10: return chebyshevTg<10>(x);
-		case 11: return chebyshevTg<11>(x);
-		case 12: return chebyshevTg<12>(x);
-		case 13: return chebyshevTg<13>(x);
-		case 14: return chebyshevTg<14>(x);
-		case 15: return chebyshevTg<15>(x);
-		}
-		return _Type{};
-	}
-
-	template<class _Type, int _Order>
-	struct chebyshevU
-	{
-		inline static _Type get(_Type x)
-		{
-			return chebyshevU<_Type, _Order - 2>::get(x) * (4 * pow(x, 2) - 2) - chebyshevU<_Type, _Order - 4>::get(x);
-		}
-	};
-
-	template<class _Type>
-	struct chebyshevU<_Type, 0>
-	{
-		inline static _Type get(_Type x)
-		{
-			return 1;
-		}
-	};
-
-	template<class _Type>
-	struct chebyshevU<_Type, 1>
-	{
-		inline static _Type get(_Type x)
-		{
-			return 2 * x;
-		}
-	};
-
-	template<class _Type>
-	struct chebyshevU<_Type, 2>
-	{
-		inline static _Type get(_Type x)
-		{
-			return 4 * pow(x, 2) - 1;
-		}
-	};
-
-	template<class _Type>
-	struct chebyshevU<_Type, 3>
-	{
-		inline static _Type get(_Type x)
-		{
-			return 8 * pow(x, 3) - 4 * x;
-		}
-	};
-
-	template<int _Order, class _Type> inline _Type chebyshevUf(_Type x)
-	{
-		return chebyshevU<_Type, _Order>::get(x);
-	}
+#pragma once
+#include <type_traits>
+#include <cmath>
+
+namespace poly
+{
+	template<int n, int k>
+	struct combination
+	{
+		static constexpr int64_t value = combination<n - 1, k - 1>::value + combination<n - 1, k>::value;
+	};
+
+	template<int n>
+	struct combination<n, 0>
+	{
+		static constexpr int64_t value = 1;
+	};
+
+	template<int n>
+	struct combination<0, n>
+	{
+		static constexpr int64_t value = 1;
+	};
+
+	template<int n>
+	struct combination<n, n>
+	{
+		static constexpr int64_t value = 1;
+	};
+
+	template<>
+	struct combination<0, 0>
+	{
+		static constexpr int value = 1;
+	};
+
+	template<int n>
+	struct even_odd
+	{
+		static constexpr int value = -1;
+	};
+	template<>
+	struct even_odd<0>
+	{
+		static constexpr int value = 1;
+	};
+
+	template<int _Order, class _Type, int n = 0>
+	struct shiftedLegendre
+	{
+		inline static _Type at(_Type x)
+		{
+			return shiftedLegendre<_Order, _Type, n + 1>::at(x) * x + combination<_Order, n>::value * combination<_Order + n, n>::value * even_odd<(_Order + n) % 2>::value;
+		}
+	};
+
+	template<int _Order, class _Type>
+	struct shiftedLegendre<_Order, _Type, _Order>
+	{
+		inline static _Type at(_Type x)
+		{
+			return combination<_Order + _Order, _Order>::value;
+		}
+	};
+
+	template<class _Type>
+	struct shiftedLegendre<0, _Type, 0>
+	{
+		inline static _Type at(_Type x)
+		{
+			return 1;
+		}
+	};
+
+	template<int _Order, class _Type> inline _Type shiftedLegendreFunc(_Type x)
+	{
+		return shiftedLegendre<_Order, _Type, 0>::at(x);
+	}
+
+
+	template<class _Type> _Type slpGet(size_t order, _Type x)
+	{
+		switch (order)
+		{
+		case 0: return shiftedLegendreFunc<0>(x);
+		case 1: return shiftedLegendreFunc<1>(x);
+		case 2: return shiftedLegendreFunc<2>(x);
+		case 3: return shiftedLegendreFunc<3>(x);
+		case 4: return shiftedLegendreFunc<4>(x);
+		case 5: return shiftedLegendreFunc<5>(x);
+		case 6: return shiftedLegendreFunc<6>(x);
+		case 7: return shiftedLegendreFunc<7>(x);
+		case 8: return shiftedLegendreFunc<8>(x);
+		case 9: return shiftedLegendreFunc<9>(x);
+		case 10: return shiftedLegendreFunc<10>(x);
+		case 11: return shiftedLegendreFunc<11>(x);
+		case 12: return shiftedLegendreFunc<12>(x);
+		case 13: return shiftedLegendreFunc<13>(x);
+		case 14: return shiftedLegendreFunc<14>(x);
+		case 15: return shiftedLegendreFunc<15>(x);
+		}
+		return _Type{};
+	}
+
+	inline size_t partialProductDown(size_t n, size_t k)
+	{
+		size_t ret = 1;
+		for (size_t i = 0; i < k; ++i) ret *= n--;
+		return ret;
+	}
+
+	inline int slpGetCoef(size_t n, size_t k)
+	{
+		return ((n + k) & 1 ? -1 : 1) * (int)(partialProductDown(n, k) / partialProductDown(k, k) * partialProductDown(n + k, k) / partialProductDown(k, k));
+	}
+
+	template<class _Type, int _Order> struct chebyshevU;
+
+	template<class _Type, int _Order>
+	struct chebyshevT
+	{
+		inline static _Type get(_Type x)
+		{
+			if(_Order % 2) return 2 * chebyshevT<_Type, _Order / 2>::get(x) * chebyshevT<_Type, _Order / 2 + 1>::get(x) - x;
+			else return 2 * std::pow(chebyshevT<_Type, _Order / 2>::get(x), 2) - 1;
+		}
+
+		inline static _Type derived(_Type x)
+		{
+			return _Order * chebyshevU<_Type, _Order - 1>::get(x);
+		}
+	};
+
+	template<class _Type>
+	struct chebyshevT<_Type, 0>
+	{
+		inline static _Type get(_Type x)
+		{
+			return 1;
+		}
+
+		inline static _Type derived(_Type x)
+		{
+			return 0;
+		}
+	};
+
+	template<class _Type>
+	struct chebyshevT<_Type, 1>
+	{
+		inline static _Type get(_Type x)
+		{
+			return x;
+		}
+
+		inline static _Type derived(_Type x)
+		{
+			return 1;
+		}
+	};
+
+	template<int _Order, class _Type> inline _Type chebyshevTf(_Type x)
+	{
+		return chebyshevT<_Type, _Order>::get(x);
+	}
+
+	template<int _Order, class _Type> inline _Type chebyshevTg(_Type x)
+	{
+		return chebyshevT<_Type, _Order>::derived(x);
+	}
+
+	template<class _Type> _Type chebyshevTGet(size_t order, _Type x)
+	{
+		switch (order)
+		{
+		case 0: return chebyshevTf<0>(x);
+		case 1: return chebyshevTf<1>(x);
+		case 2: return chebyshevTf<2>(x);
+		case 3: return chebyshevTf<3>(x);
+		case 4: return chebyshevTf<4>(x);
+		case 5: return chebyshevTf<5>(x);
+		case 6: return chebyshevTf<6>(x);
+		case 7: return chebyshevTf<7>(x);
+		case 8: return chebyshevTf<8>(x);
+		case 9: return chebyshevTf<9>(x);
+		case 10: return chebyshevTf<10>(x);
+		case 11: return chebyshevTf<11>(x);
+		case 12: return chebyshevTf<12>(x);
+		case 13: return chebyshevTf<13>(x);
+		case 14: return chebyshevTf<14>(x);
+		case 15: return chebyshevTf<15>(x);
+		}
+		if(order % 2) return 2 * chebyshevTGet(order / 2, x) * chebyshevTGet(order / 2 + 1, x) - x;
+		return 2 * pow(chebyshevTGet(order / 2, x), 2) - 1;
+	}
+
+	template<class _Type> _Type chebyshevTDerived(size_t order, _Type x)
+	{
+		switch (order)
+		{
+		case 0: return chebyshevTg<0>(x);
+		case 1: return chebyshevTg<1>(x);
+		case 2: return chebyshevTg<2>(x);
+		case 3: return chebyshevTg<3>(x);
+		case 4: return chebyshevTg<4>(x);
+		case 5: return chebyshevTg<5>(x);
+		case 6: return chebyshevTg<6>(x);
+		case 7: return chebyshevTg<7>(x);
+		case 8: return chebyshevTg<8>(x);
+		case 9: return chebyshevTg<9>(x);
+		case 10: return chebyshevTg<10>(x);
+		case 11: return chebyshevTg<11>(x);
+		case 12: return chebyshevTg<12>(x);
+		case 13: return chebyshevTg<13>(x);
+		case 14: return chebyshevTg<14>(x);
+		case 15: return chebyshevTg<15>(x);
+		}
+		return _Type{};
+	}
+
+	template<class _Type, int _Order>
+	struct chebyshevU
+	{
+		inline static _Type get(_Type x)
+		{
+			return chebyshevU<_Type, _Order - 2>::get(x) * (4 * pow(x, 2) - 2) - chebyshevU<_Type, _Order - 4>::get(x);
+		}
+	};
+
+	template<class _Type>
+	struct chebyshevU<_Type, 0>
+	{
+		inline static _Type get(_Type x)
+		{
+			return 1;
+		}
+	};
+
+	template<class _Type>
+	struct chebyshevU<_Type, 1>
+	{
+		inline static _Type get(_Type x)
+		{
+			return 2 * x;
+		}
+	};
+
+	template<class _Type>
+	struct chebyshevU<_Type, 2>
+	{
+		inline static _Type get(_Type x)
+		{
+			return 4 * pow(x, 2) - 1;
+		}
+	};
+
+	template<class _Type>
+	struct chebyshevU<_Type, 3>
+	{
+		inline static _Type get(_Type x)
+		{
+			return 8 * pow(x, 3) - 4 * x;
+		}
+	};
+
+	template<int _Order, class _Type> inline _Type chebyshevUf(_Type x)
+	{
+		return chebyshevU<_Type, _Order>::get(x);
+	}
 }
```

