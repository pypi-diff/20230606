# Comparing `tmp/algokit_client_generator-0.1.0b8-py3-none-any.whl.zip` & `tmp/algokit_client_generator-0.1.1b1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,16 +1,16 @@
-Zip file size: 17693 bytes, number of entries: 14
+Zip file size: 18238 bytes, number of entries: 14
 -rw-r--r--  2.0 unx       91 b- defN 80-Jan-01 00:00 algokit_client_generator/__init__.py
 -rw-r--r--  2.0 unx       54 b- defN 80-Jan-01 00:00 algokit_client_generator/__main__.py
 -rw-r--r--  2.0 unx     2550 b- defN 80-Jan-01 00:00 algokit_client_generator/cli.py
 -rw-r--r--  2.0 unx     3199 b- defN 80-Jan-01 00:00 algokit_client_generator/document.py
--rw-r--r--  2.0 unx    31397 b- defN 80-Jan-01 00:00 algokit_client_generator/generator.py
+-rw-r--r--  2.0 unx    36317 b- defN 80-Jan-01 00:00 algokit_client_generator/generator.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 algokit_client_generator/py.typed
 -rw-r--r--  2.0 unx     7466 b- defN 80-Jan-01 00:00 algokit_client_generator/spec.py
 -rw-r--r--  2.0 unx     4303 b- defN 80-Jan-01 00:00 algokit_client_generator/utils.py
 -rw-r--r--  2.0 unx      995 b- defN 80-Jan-01 00:00 algokit_client_generator/writer.py
--rw-r--r--  2.0 unx     1076 b- defN 80-Jan-01 00:00 algokit_client_generator-0.1.0b8.dist-info/LICENSE
--rw-r--r--  2.0 unx     4585 b- defN 80-Jan-01 00:00 algokit_client_generator-0.1.0b8.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 algokit_client_generator-0.1.0b8.dist-info/WHEEL
--rw-r--r--  2.0 unx       67 b- defN 80-Jan-01 00:00 algokit_client_generator-0.1.0b8.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx     1298 b- defN 16-Jan-01 00:00 algokit_client_generator-0.1.0b8.dist-info/RECORD
-14 files, 57169 bytes uncompressed, 15477 bytes compressed:  72.9%
+-rw-r--r--  2.0 unx     1076 b- defN 80-Jan-01 00:00 algokit_client_generator-0.1.1b1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     4755 b- defN 80-Jan-01 00:00 algokit_client_generator-0.1.1b1.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 algokit_client_generator-0.1.1b1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       67 b- defN 80-Jan-01 00:00 algokit_client_generator-0.1.1b1.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx     1298 b- defN 16-Jan-01 00:00 algokit_client_generator-0.1.1b1.dist-info/RECORD
+14 files, 62259 bytes uncompressed, 16022 bytes compressed:  74.3%
```

## zipnote {}

```diff
@@ -21,23 +21,23 @@
 
 Filename: algokit_client_generator/utils.py
 Comment: 
 
 Filename: algokit_client_generator/writer.py
 Comment: 
 
-Filename: algokit_client_generator-0.1.0b8.dist-info/LICENSE
+Filename: algokit_client_generator-0.1.1b1.dist-info/LICENSE
 Comment: 
 
-Filename: algokit_client_generator-0.1.0b8.dist-info/METADATA
+Filename: algokit_client_generator-0.1.1b1.dist-info/METADATA
 Comment: 
 
-Filename: algokit_client_generator-0.1.0b8.dist-info/WHEEL
+Filename: algokit_client_generator-0.1.1b1.dist-info/WHEEL
 Comment: 
 
-Filename: algokit_client_generator-0.1.0b8.dist-info/entry_points.txt
+Filename: algokit_client_generator-0.1.1b1.dist-info/entry_points.txt
 Comment: 
 
-Filename: algokit_client_generator-0.1.0b8.dist-info/RECORD
+Filename: algokit_client_generator-0.1.1b1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## algokit_client_generator/generator.py

```diff
@@ -37,14 +37,15 @@
             "_filter_none",
             "_convert_on_complete",
             "_convert_deploy_args",
             "DeployCreate",
             "Deploy",
             "GlobalState",
             "LocalState",
+            "Composer",
         }
         self.used_client_symbols = {
             "__init__",
             "app_spec",
             "app_client",
             "algod_client",
             "app_id",
@@ -53,25 +54,27 @@
             "signer",
             "suggested_params",
             "no_op",
             "clear_state",
             "deploy",
             "get_global_state",
             "get_local_state",
+            "compose",
         }
         self.client_name = utils.get_unique_symbol_by_incrementing(
             self.used_module_symbols, utils.get_class_name(self.app_spec.contract.name, "client")
         )
         self.methods = get_contract_methods(app_spec, self.used_module_symbols, self.used_client_symbols)
         self.disable_linting = True
 
 
 def generated_comment(context: GenerateContext) -> DocumentParts:
     yield "# This file was automatically generated by algokit-client-generator."
     yield "# DO NOT MODIFY IT BY HAND."
+    yield "# requires: algokit-utils@^1.2.0"
 
 
 def disable_linting(context: GenerateContext) -> DocumentParts:
     yield "# flake8: noqa"  # this works for flake8 and ruff
     yield "# fmt: off"  # disable formatting
     yield '# mypy: disable-error-code="no-any-return, no-untyped-call"'  # disable common type warnings
 
@@ -82,15 +85,20 @@
 import dataclasses
 import decimal
 import typing
 from abc import ABC, abstractmethod
 
 import algokit_utils
 import algosdk
-from algosdk.atomic_transaction_composer import TransactionSigner, TransactionWithSigner"""
+from algosdk.atomic_transaction_composer import (
+    AtomicTransactionComposer,
+    AtomicTransactionResponse,
+    TransactionSigner,
+    TransactionWithSigner
+)"""
     )
 
 
 def typed_argument_class(abi: ABIContractMethod) -> DocumentParts:
     assert abi
     yield "@dataclasses.dataclass(kw_only=True)"
     yield f"class {abi.args_class_name}(_ArgsBase[{abi.python_type}]):"
@@ -324,14 +332,48 @@
         return self._data.hex()"""
         )
         yield Part.Gap2
     yield state_type(context, "GlobalState", global_schema)
     yield state_type(context, "LocalState", local_schema)
 
 
+def composer(context: GenerateContext) -> DocumentParts:
+    yield utils.indented(
+        """
+class Composer:
+
+    def __init__(self, app_client: algokit_utils.ApplicationClient, atc: AtomicTransactionComposer):
+        self.app_client = app_client
+        self.atc = atc
+
+    def build(self) -> AtomicTransactionComposer:
+        return self.atc
+
+    def execute(self) -> AtomicTransactionResponse:
+        return self.app_client.execute_atc(self.atc)
+"""
+    )
+    yield Part.IncIndent
+    yield Part.Gap1
+    yield methods_by_side_effect(context, "none", context.methods.no_op, is_compose_method=True)
+    yield Part.Gap1
+    yield methods_by_side_effect(context, "create", context.methods.create, is_compose_method=True)
+    yield Part.Gap1
+    yield methods_by_side_effect(context, "update", context.methods.update_application, is_compose_method=True)
+    yield Part.Gap1
+    yield methods_by_side_effect(context, "delete", context.methods.delete_application, is_compose_method=True)
+    yield Part.Gap1
+    yield methods_by_side_effect(context, "opt_in", context.methods.opt_in, is_compose_method=True)
+    yield Part.Gap1
+    yield methods_by_side_effect(context, "close_out", context.methods.close_out, is_compose_method=True)
+    yield Part.Gap1
+    yield compose_clear_method(context)
+    yield Part.DecIndent
+
+
 def typed_client(context: GenerateContext) -> DocumentParts:
     yield f"class {context.client_name}:"
     yield Part.IncIndent
     yield utils.docstring(
         (f"{context.app_spec.contract.desc}\n\n" if context.app_spec.contract.desc else "")
         + f"""A class for interacting with the {context.app_spec.contract.name} app providing high productivity and
 strongly typed methods to deploy and call the app"""
@@ -454,14 +496,16 @@
     yield methods_by_side_effect(context, "opt_in", context.methods.opt_in)
     yield Part.Gap1
     yield methods_by_side_effect(context, "close_out", context.methods.close_out)
     yield Part.Gap1
     yield clear_method(context)
     yield Part.Gap1
     yield deploy_method(context)
+    yield Part.Gap1
+    yield compose_method()
 
 
 def forwarded_client_properties(context: GenerateContext) -> DocumentParts:
     yield utils.indented(
         """
 @property
 def algod_client(self) -> algosdk.v2client.algod.AlgodClient:
@@ -537,67 +581,93 @@
     yield '_APP_SPEC_JSON = r"""'
     yield context.app_spec.to_json()
     yield '"""'
     yield Part.RestoreLineMode
     yield "APP_SPEC = algokit_utils.ApplicationSpecification.from_json(_APP_SPEC_JSON)"
 
 
-def create_method_doc_string(method: ContractMethod) -> Iterable[str]:
-    if method.abi:
-        if method.abi.method.desc:
-            yield method.abi.method.desc
-            yield ""
-        yield f"Calls `{method.abi.method.get_signature()}` ABI method"
+def abi_method_doc_string(method: ContractMethod, *, compose_signature: bool) -> Iterable[str]:
+    assert method.abi
+    if method.abi.method.desc:
+        yield method.abi.method.desc
         yield ""
-        for arg in method.abi.args:
-            desc = f":param {arg.python_type} {arg.name}: "
-            desc += "(optional) " if arg.has_default else ""
-            desc += arg.desc or f"The `{arg.name}` ABI parameter"
-            yield desc
-        if method.call_config == "create":
-            on_completes = method.on_complete
-            yield f":param typing.Literal[{', '.join(on_completes)}] on_complete: On completion type to use"
-            yield (
-                ":param algokit_utils.CreateTransactionParameters transaction_parameters: "
-                "(optional) Additional transaction parameters"
-            )
-        else:
-            yield (
-                ":param algokit_utils.TransactionParameters transaction_parameters: "
-                "(optional) Additional transaction parameters"
-            )
+    if compose_signature:
+        yield f"Adds a call to `{method.abi.method.get_signature()}` ABI method"
+    else:
+        yield f"Calls `{method.abi.method.get_signature()}` ABI method"
+    yield ""
+    for arg in method.abi.args:
+        desc = f":param {arg.python_type} {arg.name}: "
+        desc += "(optional) " if arg.has_default else ""
+        desc += arg.desc or f"The `{arg.name}` ABI parameter"
+        yield desc
+    if method.call_config == "create":
+        on_completes = method.on_complete
+        yield f":param typing.Literal[{', '.join(on_completes)}] on_complete: On completion type to use"
+        yield (
+            ":param algokit_utils.CreateTransactionParameters transaction_parameters: "
+            "(optional) Additional transaction parameters"
+        )
+    else:
+        yield (
+            ":param algokit_utils.TransactionParameters transaction_parameters: "
+            "(optional) Additional transaction parameters"
+        )
+    if compose_signature:
+        yield ":returns Composer: This Composer instance"
+    else:
         yield (
             f":returns algokit_utils.ABITransactionResponse[{method.abi.python_type}]: "
             f"{method.abi.method.returns.desc or 'The result of the transaction'}"
         )
+
+
+def bare_method_doc_string(method: ContractMethod, *, compose_signature: bool) -> Iterable[str]:
+    if method.call_config == "create":
+        if compose_signature and len(method.on_complete) > 1:
+            yield f"Adds a call to create an application using one of the {', '.join(method.on_complete)} bare methods"
+        elif compose_signature:
+            yield f"Adds a call to create an application using the {method.on_complete[0]} bare method"
+        elif len(method.on_complete) > 1:
+            yield f"Creates an application using one of the {', '.join(method.on_complete)} bare methods"
+        else:
+            yield f"Creates an application using the {method.on_complete[0]} bare method"
+        yield ""
+        on_completes = method.on_complete
+        yield f":param typing.Literal[{', '.join(on_completes)}] on_complete: On completion type to use"
+        yield (
+            ":param algokit_utils.CreateTransactionParameters transaction_parameters: "
+            "(optional) Additional transaction parameters"
+        )
     else:
-        if method.call_config == "create":
-            if len(method.on_complete) > 1:
-                yield f"Creates an application using one of the {', '.join(method.on_complete)} bare methods"
-            else:
-                yield f"Creates an application using the {method.on_complete[0]} bare method"
-            yield ""
-            on_completes = method.on_complete
-            yield f":param typing.Literal[{', '.join(on_completes)}] on_complete: On completion type to use"
-            yield (
-                ":param algokit_utils.CreateTransactionParameters transaction_parameters: "
-                "(optional) Additional transaction parameters"
-            )
+        if compose_signature:
+            yield f"Adds a calls to the {method.on_complete[0]} bare method"
         else:
             yield f"Calls the {method.on_complete[0]} bare method"
-            yield ""
-            yield (
-                ":param algokit_utils.TransactionParameters transaction_parameters: "
-                "(optional) Additional transaction parameters"
-            )
-
+        yield ""
+        yield (
+            ":param algokit_utils.TransactionParameters transaction_parameters: "
+            "(optional) Additional transaction parameters"
+        )
+    if compose_signature:
+        yield ":returns Composer: This Composer instance"
+    else:
         yield ":returns algokit_utils.TransactionResponse: The result of the transaction"
 
 
-def signature(context: GenerateContext, name: str, method: ContractMethod) -> DocumentParts:
+def create_method_doc_string(method: ContractMethod, *, compose_signature: bool) -> Iterable[str]:
+    if method.abi:
+        return abi_method_doc_string(method, compose_signature=compose_signature)
+    else:
+        return bare_method_doc_string(method, compose_signature=compose_signature)
+
+
+def signature(
+    context: GenerateContext, name: str, method: ContractMethod, *, compose_signature: bool = False
+) -> DocumentParts:
     yield f"def {name}("
     yield Part.IncIndent
     yield "self,"
     yield "*,"
     abi = method.abi
     if abi:
         for arg in abi.args:
@@ -607,20 +677,24 @@
                 yield f"{arg.name}: {arg.python_type},"
     if method.call_config == "create":
         yield on_complete_literals(method.on_complete)
         yield "transaction_parameters: algokit_utils.CreateTransactionParameters | None = None,"
     else:
         yield "transaction_parameters: algokit_utils.TransactionParameters | None = None,"
     yield Part.DecIndent
-    if abi:
-        yield f") -> algokit_utils.ABITransactionResponse[{abi.python_type}]:"
+
+    if compose_signature:
+        return_type = '"Composer"'
+    elif abi:
+        return_type = f"algokit_utils.ABITransactionResponse[{abi.python_type}]"
     else:
-        yield ") -> algokit_utils.TransactionResponse:"
+        return_type = "algokit_utils.TransactionResponse"
+    yield f") -> {return_type}:"
     yield Part.IncIndent
-    yield utils.docstring("\n".join(create_method_doc_string(method)))
+    yield utils.docstring("\n".join(create_method_doc_string(method, compose_signature=compose_signature)))
     yield Part.DecIndent
     yield Part.Gap1
 
 
 def instantiate_args(contract_method: ABIContractMethod | None) -> DocumentParts:
     if contract_method and not contract_method.args:
         yield f"args = {contract_method.args_class_name}()"
@@ -654,14 +728,38 @@
     if contract_method.abi and contract_method.abi.result_struct:
         yield 'elements = self.app_spec.hints[args.method()].structs["output"]["elements"]'
         yield "result_dict = {element[0]: value for element, value in zip(elements, result.return_value)}"
         yield f"result.return_value = {contract_method.abi.python_type}(**result_dict)"
     yield "return result"
 
 
+def app_client_compose_call(
+    app_client_method: Literal["call", "create", "update", "delete", "opt_in", "close_out"],
+    contract_method: ContractMethod,
+) -> DocumentParts:
+    yield f"self.app_client.compose_{app_client_method}("
+    yield Part.IncIndent
+    yield "self.atc,"
+    if contract_method.abi:
+        yield "call_abi_method=args.method(),"
+    else:
+        yield "call_abi_method=False,"
+    if contract_method.call_config == "create":
+        yield "transaction_parameters=_convert_create_transaction_parameters(transaction_parameters, on_complete),"
+    elif "no_op" in contract_method.on_complete:
+        yield "transaction_parameters=_convert_call_transaction_parameters(transaction_parameters),"
+    else:
+        yield "transaction_parameters=_convert_transaction_parameters(transaction_parameters),"
+    if contract_method.abi:
+        yield "**_as_dict(args, convert_all=True),"
+    yield Part.DecIndent
+    yield ")"
+    yield "return self"
+
+
 def on_complete_literals(on_completes: Iterable[algokit_utils.OnCompleteActionName]) -> DocumentParts:
     yield Part.InlineMode
     yield 'on_complete: typing.Literal["'
     yield utils.join('", "', on_completes)
     yield '"]'
     if "no_op" in on_completes:
         yield ' = "no_op"'
@@ -669,14 +767,16 @@
     yield Part.RestoreLineMode
 
 
 def methods_by_side_effect(
     context: GenerateContext,
     side_effect: Literal["none", "create", "update", "delete", "opt_in", "close_out"],
     methods: list[ContractMethod],
+    *,
+    is_compose_method: bool = False,
 ) -> DocumentParts:
     if not methods:
         return
 
     for method in methods:
         contract_method = method.abi
 
@@ -685,18 +785,21 @@
                 full_method_name = contract_method.client_method_name
             else:
                 full_method_name = "no_op"
         elif contract_method:  # an ABI method with a side effect
             full_method_name = f"{side_effect}_{contract_method.client_method_name}"
         else:  # a bare method
             full_method_name = f"{side_effect}_bare"
-        yield signature(context, full_method_name, method)
+        yield signature(context, full_method_name, method, compose_signature=is_compose_method)
         yield Part.IncIndent
         yield instantiate_args(contract_method)
-        yield app_client_call("call" if side_effect == "none" else side_effect, method)
+        if is_compose_method:
+            yield app_client_compose_call("call" if side_effect == "none" else side_effect, method)
+        else:
+            yield app_client_call("call" if side_effect == "none" else side_effect, method)
         yield Part.DecIndent
         yield Part.Gap1
 
 
 def clear_method(context: GenerateContext) -> DocumentParts:
     yield utils.indented(
         """
@@ -711,14 +814,33 @@
     :param list[bytes] | None app_args: (optional) Application args to pass
     :returns algokit_utils.TransactionResponse: The result of the transaction\"""
 
     return self.app_client.clear_state(_convert_transaction_parameters(transaction_parameters), app_args)"""
     )
 
 
+def compose_clear_method(context: GenerateContext) -> DocumentParts:
+    yield utils.indented(
+        """
+def clear_state(
+    self,
+    transaction_parameters: algokit_utils.TransactionParameters | None = None,
+    app_args: list[bytes] | None = None,
+) -> "Composer":
+    \"""Adds a call to the application with on completion set to ClearState
+
+    :param algokit_utils.TransactionParameters transaction_parameters: (optional) Additional transaction parameters
+    :param list[bytes] | None app_args: (optional) Application args to pass\"""
+
+    self.app_client.compose_clear_state(self.atc, _convert_transaction_parameters(transaction_parameters), app_args)
+    return self
+"""
+    )
+
+
 def deploy_method_args_type(arg_name: str, methods: list[ContractMethod]) -> str:
     has_bare = any(not m.abi for m in methods) or not methods
     typed_args = [m.abi.args_class_name for m in methods if m.abi]
     args = []
     if typed_args:
         deploy_type = "DeployCreate" if arg_name == "create_args" else "Deploy"
         args.append(f"{deploy_type}[{' | '.join(typed_args)}]")
@@ -819,14 +941,23 @@
     on_schema_break=on_schema_break,
     template_values=template_values,
     create_args=_convert_deploy_args(create_args),
     update_args=_convert_deploy_args(update_args),
     delete_args=_convert_deploy_args(delete_args),
 )"""
     )
+    yield Part.DecIndent
+
+
+def compose_method() -> DocumentParts:
+    yield utils.indented(
+        """
+def compose(self, atc: AtomicTransactionComposer | None = None) -> Composer:
+    return Composer(self.app_client, atc or AtomicTransactionComposer())"""
+    )
 
 
 def get_global_state_method(context: GenerateContext) -> DocumentParts:
     if not context.app_spec.schema.get("global", {}).get("declared", {}):
         return
     yield "def get_global_state(self) -> GlobalState:"
     yield Part.IncIndent
@@ -864,8 +995,10 @@
     yield embed_app_spec(context)
     yield helpers(context)
     yield Part.Gap2
     yield typed_arguments(context)
     yield Part.Gap2
     yield state_types(context)
     yield Part.Gap2
+    yield composer(context)
+    yield Part.Gap2
     yield typed_client(context)
```

## Comparing `algokit_client_generator-0.1.0b8.dist-info/LICENSE` & `algokit_client_generator-0.1.1b1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `algokit_client_generator-0.1.0b8.dist-info/METADATA` & `algokit_client_generator-0.1.1b1.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 Metadata-Version: 2.1
 Name: algokit-client-generator
-Version: 0.1.0b8
+Version: 0.1.1b1
 Summary: Algorand typed client Generator
 License: MIT
 Author: Algorand Foundation
 Author-email: contact@algorand.foundation
 Requires-Python: >=3.10,<4.0
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
-Requires-Dist: algokit-utils (>=1.2.0b3,<2.0.0)
+Requires-Dist: algokit-utils (>=1.2.0,<2.0.0)
 Description-Content-Type: text/markdown
 
-# AlgoKit Python client generator (algokit-client-generator-py)
+# AlgoKit Python client generator
 
 This project generates a type-safe smart contract client in Python for the Algorand Blockchain that wraps the 
 [application client](https://algorandfoundation.github.io/algokit-utils-py/html/apidocs/algokit_utils/algokit_utils.html#algokit_utils.ApplicationClient) in 
 [AlgoKit Utils](https://github.com/algorandfoundation/algokit-utils-py). It does this by reading an [ARC-0032](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0032.md) application spec file.
 
 
 > **Note**
@@ -27,15 +27,15 @@
 ## Usage
 
 ### Prerequisites
 
 To be able to consume the generated file you need to include it in a Python project that has (at least) the following package installed:
 
 ```
-poetry add algokit-utils@1.2.0b2
+poetry add algokit-utils@^1.2
 ```
 
 ### Use
 
 To install the generator as a CLI tool:
 
 ```
@@ -44,14 +44,20 @@
 
 Then to use it
 
 ```
 algokitgen-py path/to/application.json path/to/output/client_generated.py
 ```
 
+Or if you have [AlgoKit](https://github.com/algorandfoundation/algokit-cli) 1.1+ installed
+
+```commandline
+algokit generate client path/to/application.json --output path/to/output/client_generated.py
+```
+
 ## Examples
 
 There are a range of [examples](./examples) that you can look at to see a source smart contract (`{contract.py}`), 
 the generated client (`client_generated.py`) and some tests that demonstrate how you can use the client (`test_client.py`).
 
 ## Contributing
```

## Comparing `algokit_client_generator-0.1.0b8.dist-info/RECORD` & `algokit_client_generator-0.1.1b1.dist-info/RECORD`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 algokit_client_generator/__init__.py,sha256=ikLxrMdPVjpmrVYDdHbunvzUwiXqrCdvp8Qi5x0gC0c,91
 algokit_client_generator/__main__.py,sha256=MlkUdDAWa2XH1QDdjvayVR_WaZEGkA9voNutHzWEfFo,54
 algokit_client_generator/cli.py,sha256=XwuLZUhym9ntuHRIayPZsfv2-vTSbEykt3evF7EdVq4,2550
 algokit_client_generator/document.py,sha256=X4xMvu_LfDcaosEy3AtjRoXpiLZoXRVCIoPNo8b-h08,3199
-algokit_client_generator/generator.py,sha256=YJ1ul4f0TtEOzVEH3JL5dA-veVCge-Iu13Hbk0NihQA,31397
+algokit_client_generator/generator.py,sha256=kwWrqnxeEEzGbPs_4m_ZuPcpsB2kxe_CDA8UMjr78_o,36317
 algokit_client_generator/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 algokit_client_generator/spec.py,sha256=apgef1qcRbm2akT1ogF23d6HnSncPwnLdrqaVzJAKmo,7466
 algokit_client_generator/utils.py,sha256=LQ3wXw_1IlnkKKNzDetIbAIBqEgYrRRjI6Bu_42Yzpc,4303
 algokit_client_generator/writer.py,sha256=CynBYWnHlO1E4Ubcpjvzq8kRcgfYCpnO3nEAslBEr-s,995
-algokit_client_generator-0.1.0b8.dist-info/LICENSE,sha256=fkgfhUgPPyK1aS4tK9QOFRl5fWtuFEtkKx4zPQNT1bQ,1076
-algokit_client_generator-0.1.0b8.dist-info/METADATA,sha256=ymmsQJhkOT6oMNRfBnugK2NNZ_5pQn3B_nThMT-Fgoo,4585
-algokit_client_generator-0.1.0b8.dist-info/WHEEL,sha256=WGfLGfLX43Ei_YORXSnT54hxFygu34kMpcQdmgmEwCQ,88
-algokit_client_generator-0.1.0b8.dist-info/entry_points.txt,sha256=RnsJToDSJC_LyXvGqv7LNpgkqipw1C7eQsc0bke--A0,67
-algokit_client_generator-0.1.0b8.dist-info/RECORD,,
+algokit_client_generator-0.1.1b1.dist-info/LICENSE,sha256=fkgfhUgPPyK1aS4tK9QOFRl5fWtuFEtkKx4zPQNT1bQ,1076
+algokit_client_generator-0.1.1b1.dist-info/METADATA,sha256=79etaZLSpeA2wuUTX2zWBvNJGvWlM-jPZBnxdRoBxp0,4755
+algokit_client_generator-0.1.1b1.dist-info/WHEEL,sha256=Zb28QaM1gQi8f4VCBhsUklF61CTlNYfs9YAZn-TOGFk,88
+algokit_client_generator-0.1.1b1.dist-info/entry_points.txt,sha256=RnsJToDSJC_LyXvGqv7LNpgkqipw1C7eQsc0bke--A0,67
+algokit_client_generator-0.1.1b1.dist-info/RECORD,,
```

